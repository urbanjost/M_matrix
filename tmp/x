module M_matrix
use,intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
use M_strings, only : value_to_string, lower, v2s, s2v
use M_journal, only : journal
use M_help, only    : help_command
use M_history, only : redo
use M_list, only    : insert, locate, replace, remove
use M_io, only      : lookfor
use M_LA, only : mat_flop,   mat_inverse_hilbert,  mat_iwamax,  mat_magic,   mat_pythag,  mat_rat,    mat_round,  mat_rref
use M_LA, only : mat_rrot,   mat_rrotg,            mat_rset,    mat_rswap,   mat_urand,   mat_wasum,  mat_wcopy
use M_LA, only : mat_wdotci,           mat_wdotcr,  mat_wdotui,  mat_wdotur, mat_wmul,   mat_wnrm2
use M_LA, only : mat_wpofa,  mat_wrscal,           mat_wscal,   mat_wset,    mat_wsign,   mat_wsqrt,  mat_wswap
implicit none
public laff
public get_from_laff  ! get_a_laff   ! ??? maybe a function too with a second parameter and returned value is of same type(?)
public put_into_laff  ! give_a_laff
public :: ifin_laff   ! laffin
public :: printit
public mat_flop
public mat_wasum
public mat_wdotcr
public mat_wdotci
integer,parameter,private:: sp=kind(1.0),dp=kind(1.0d0)
integer,parameter        :: GG_LINELEN=1024
integer,parameter        :: GG_MAX_NUMBER_OF_NAMES=480
integer,parameter        :: GG_MAX_NAME_LENGTH=32       ! <WARNING> just began changing this to a constant
integer,parameter        :: GG_EOL=99999           ! make > 2256
character(len=GG_LINELEN),allocatable,save :: G_PSEUDO_FILE(:) ! allow for input to be passed from program instead of from file
logical                  :: G_PROMPT              ! companion for G_PSEUDO_FILE
logical,save             :: G_ECHO=.false.        ! echo input lines
integer                  :: G_LIN(GG_LINELEN)
integer                  :: G_LHS ! number of arguments on LHS
integer                  :: G_RHS ! number of arguments on RHS
integer                  :: G_FIN
integer                  :: G_FUN
integer                  :: G_FMT
integer                  :: G_RIO
integer                  :: G_INPUT_LUN
integer                  :: G_OUTPUT_LUN
integer                  :: G_PTZ
integer                  :: G_SYM
integer                  :: G_SYN(GG_MAX_NAME_LENGTH)
integer                  :: G_CURRENT_RANDOM_SEED
integer                  :: G_CURRENT_RANDOM_TYPE     ! [0] uniform distribution
integer                  :: G_FLOP_COUNTER(2)
integer                  :: G_DEBUG_LEVEL             ! select which debug messages to display. zero (0) is off
logical                  :: G_FILE_OPEN_ERROR         ! flag whether file open error occurred or not
integer                  :: G_ERR
integer                  :: G_LINECOUNT(4)            ! [1] lines displayed since count started
integer                  :: G_BUF(GG_LINELEN)
integer,parameter        :: G_PSIZE=32                        ! stack size for pseudo-recursion
integer                  :: G_IDS(GG_MAX_NAME_LENGTH,G_PSIZE)
integer                  :: G_PSTK(G_PSIZE)
integer                  :: G_RSTK(G_PSIZE)
integer                  :: G_PT
integer                  :: G_CHRA ! current character in line
integer                  :: G_LINE_POINTER(6) ! [1] first character to process in current line
integer,save                   :: GM_BIGMEM=-1                           ! allocated size of data storage
doubleprecision,allocatable    :: GM_REALS(:), GM_IMAGS(:)               ! set to size of GM_BIGMEM
integer                        :: G_STACK_IDS(GG_MAX_NAME_LENGTH, GG_MAX_NUMBER_OF_NAMES)
integer                        :: G_STACK_ID_LOC(GG_MAX_NUMBER_OF_NAMES)
integer                        :: G_STACK_ROWS(GG_MAX_NUMBER_OF_NAMES)
integer                        :: G_STACK_COLS(GG_MAX_NUMBER_OF_NAMES)
type vctr
   integer :: rows
   integer :: cols
   doubleprecision,allocatable :: re(:)
   doubleprecision,allocatable :: im(:)
endtype vctr
character(len=:),allocatable   :: keywords(:)
integer,allocatable            :: locs(:)
integer,allocatable            :: rows(:)
integer,allocatable            :: cols(:)
type(vctr),allocatable         :: vals(:)
character(len=:),allocatable   :: scr_keywords(:)
integer,allocatable            :: scr_locs(:)
integer,allocatable            :: scr_rows(:)
integer,allocatable            :: scr_cols(:)
integer                     :: G_TOP_OF_SAVED, G_BOTTOM_OF_SCRATCH_IN_USE
interface put_into_laff
   module procedure store_array_into_laff
   module procedure store_vector_into_laff
   module procedure store_scalar_into_laff
end interface put_into_laff
interface get_from_laff
   module procedure get_fixed_array_from_laff_dpcmplx
   module procedure get_fixed_array_from_laff_cmplx
   module procedure get_fixed_array_from_laff_real32
   module procedure get_fixed_array_from_laff_real64
   module procedure get_fixed_array_from_laff_real128
   module procedure get_fixed_array_from_laff_int8
   module procedure get_fixed_array_from_laff_int16
   module procedure get_fixed_array_from_laff_int32
   module procedure get_fixed_array_from_laff_int64
   module procedure get_fixed_array_from_laff_logical
   module procedure get_fixed_vector_from_laff_dpcmplx
   module procedure get_fixed_vector_from_laff_cmplx
   module procedure get_fixed_vector_from_laff_real32
   module procedure get_fixed_vector_from_laff_real64
   module procedure get_fixed_vector_from_laff_real128
   module procedure get_fixed_vector_from_laff_int8
   module procedure get_fixed_vector_from_laff_int16
   module procedure get_fixed_vector_from_laff_int32
   module procedure get_fixed_vector_from_laff_int64
   module procedure get_fixed_vector_from_laff_logical
   module procedure get_fixed_vector_from_laff_character
   module procedure get_fixed_scalar_from_laff_character
   module procedure get_array_from_laff_dpcmplx
   module procedure get_array_from_laff_cmplx
   module procedure get_array_from_laff_real32
   module procedure get_array_from_laff_real64
   module procedure get_array_from_laff_real128
   module procedure get_array_from_laff_int8
   module procedure get_array_from_laff_int16
   module procedure get_array_from_laff_int32
   module procedure get_array_from_laff_int64
   module procedure get_array_from_laff_logical
   module procedure get_vector_from_laff_dpcmplx
   module procedure get_vector_from_laff_cmplx
   module procedure get_vector_from_laff_real32
   module procedure get_vector_from_laff_real64
   module procedure get_vector_from_laff_real128
   module procedure get_vector_from_laff_int8
   module procedure get_vector_from_laff_int16
   module procedure get_vector_from_laff_int32
   module procedure get_vector_from_laff_int64
   module procedure get_vector_from_laff_logical
   module procedure get_vector_from_laff_character
   module procedure get_scalar_from_laff_dpcmplx
   module procedure get_scalar_from_laff_cmplx
   module procedure get_scalar_from_laff_real32
   module procedure get_scalar_from_laff_real64
   module procedure get_scalar_from_laff_real128
   module procedure get_scalar_from_laff_int8
   module procedure get_scalar_from_laff_int16
   module procedure get_scalar_from_laff_int32
   module procedure get_scalar_from_laff_int64
   module procedure get_scalar_from_laff_logical
   module procedure get_scalar_from_laff_character
end interface get_from_laff
interface laff
   module procedure laff_init
   module procedure laff_cmd
   module procedure laff_cmds
end interface laff
character(len=:),allocatable :: G_HELP_TEXT(:)
integer,parameter        :: G_CHARSET_SIZE=256      ! number of characters in character set
character(len=*),parameter :: digit='0123456789'
character(len=*),parameter :: little='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter :: big='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
integer,parameter :: dstar=3042
integer,parameter :: isname=0 ! -1000
integer,parameter :: isnum=1  ! -1001
integer,parameter :: blank=32 ! blank
integer,parameter ::  quote=39  ! '
integer,parameter ::  lparen=40 ! (
integer,parameter ::  rparen=41 ! )
integer,parameter ::  star=42   ! *
integer,parameter ::  plus=43   ! +
integer,parameter ::  comma=44  ! ,
integer,parameter ::  minus=45  ! -
integer,parameter ::  dot=46    ! .
integer,parameter ::  slash=47  ! /
integer,parameter ::  zero=48   ! 0
integer,parameter ::  colon=58  ! :
integer,parameter ::  semi=59   ! ;
integer,parameter ::  less=60   ! <
integer,parameter ::  equal=61  ! =
integer,parameter ::  great=62  ! >
integer,parameter ::  a_up=65   ! A
integer,parameter :: d_up=68   ! D
integer,parameter ::  e_up=69   ! E
integer,parameter ::  z_up=90   ! Z
integer,parameter ::  bslash=92 ! \
integer,parameter ::  score=95  ! _
integer,parameter ::  a_low=97  ! a
integer,parameter ::  d_low=100 ! d
integer,parameter ::  e_low=101 ! e
integer,parameter ::  z_low=122 ! z
integer,parameter        :: GG_PAD(32)=blank
private :: usersub_placeholder
abstract interface
   subroutine usersub_interface(a,m,n,s,t)
      import dp
      integer :: m,n
      doubleprecision :: a(m,n)
      doubleprecision :: s,t
   end subroutine usersub_interface
end interface
public usersub_interface
procedure(usersub_interface),pointer :: usersub => usersub_placeholder
contains
subroutine set_usersub(proc)
procedure(usersub_interface) :: proc
   usersub => proc
end subroutine set_usersub
subroutine usersub_placeholder(a,m,n,s,t)  ! sample usersub_placeholder routine
implicit none
integer                    :: m,n
doubleprecision            :: a(m,n)
doubleprecision            :: s,t
integer                    :: i, j
   write(*,*)'M=',m
   write(*,*)'N=',n
   write(*,*)'S=',s
   write(*,*)'T=',t
   do i = 1, m
      do j = 1, n
         write(*,*)i,j,a(i,j)
      enddo
   enddo
   do i = 1, m
      do j = 1, n
         a(i,j)=a(i,j)*s+t
      enddo
   enddo
end subroutine usersub_placeholder
subroutine LAFF_init(init,echo)
integer,intent(in)          :: init
logical,intent(in),optional :: echo
doubleprecision             :: s,t
integer,parameter           :: EPS(GG_MAX_NAME_LENGTH)=   [iachar(['e','p','s',' ',' ']),GG_PAD(6:)]
integer,parameter           :: FLOPS(GG_MAX_NAME_LENGTH)= [iachar(['f','l','o','p','s']),GG_PAD(6:)]
integer,parameter           :: EYE(GG_MAX_NAME_LENGTH)=   [iachar(['e','y','e',' ',' ']),GG_PAD(6:)]
integer,parameter           :: RAND(GG_MAX_NAME_LENGTH)=  [iachar(['r','a','n','d',' ']),GG_PAD(6:)]
integer                     :: i,j
   if(present(echo)) G_ECHO=echo
   G_PROMPT=.true.
   G_ERR=0
   if(allocated(G_PSEUDO_FILE))deallocate(G_PSEUDO_FILE)
   allocate(G_PSEUDO_FILE(0))
   G_LIN=blank
   do i=1,size(G_STACK_IDS,dim=1)
      do j=1,size(G_STACK_IDS,dim=2)
         G_STACK_IDS(i,j)=blank
      enddo
   enddo
   GM_BIGMEM=INIT
   if(GM_BIGMEM.lt.0)GM_BIGMEM=200000
   if(allocated(GM_REALS) )deallocate(GM_REALS)
   if(allocated(GM_IMAGS) )deallocate(GM_IMAGS)
   allocate(GM_REALS(GM_BIGMEM),GM_IMAGS(GM_BIGMEM))          ! set to size of GM_BIGMEM
   G_INPUT_LUN = STDIN                                                    ! unit number for terminal input
   call mat_files(G_INPUT_LUN,G_BUF)
   G_RIO = G_INPUT_LUN                                                    ! current file to read commands from
   G_OUTPUT_LUN = STDOUT                                                  ! unit number for terminal output
   call mat_files(G_OUTPUT_LUN,G_BUF)
   call mat_help_text()                                                   ! initialize help text
   G_CURRENT_RANDOM_SEED = 0                                              ! random number seed
   G_CURRENT_RANDOM_TYPE = 0                                              ! set the type of random numbers to compute
   G_LINECOUNT(2) = 23                                                    ! initial line limit for paging output
   G_TOP_OF_SAVED = GG_MAX_NUMBER_OF_NAMES-3  ! move up to allow room for the built-in values eps, flops, eye, rand
   call mat_wset(5,0.0D0,0.0d0,GM_REALS(GM_BIGMEM-4),GM_IMAGS(GM_BIGMEM-4),1)
   call update('eps',1,1,GM_BIGMEM-4)
      call mat_copyid(G_STACK_IDS(1,GG_MAX_NUMBER_OF_NAMES-3),EPS)
      G_STACK_ID_LOC(GG_MAX_NUMBER_OF_NAMES-3) = GM_BIGMEM-4
      G_STACK_ROWS(GG_MAX_NUMBER_OF_NAMES-3) = 1
      G_STACK_COLS(GG_MAX_NUMBER_OF_NAMES-3) = 1
   s = 1.0d0
   SET_ST: do
      s = s/2.0D0
      t = 1.0d0 + s
      if (t .LE. 1.0d0) exit
   enddo SET_ST
   GM_REALS(GM_BIGMEM-4) = 2.0d0*s
   call update('flops',1,2,GM_BIGMEM-3)
      call mat_copyid(G_STACK_IDS(1,GG_MAX_NUMBER_OF_NAMES-2),flops)
      G_STACK_ID_LOC(GG_MAX_NUMBER_OF_NAMES-2) = GM_BIGMEM-3
      G_STACK_ROWS(GG_MAX_NUMBER_OF_NAMES-2) = 1
      G_STACK_COLS(GG_MAX_NUMBER_OF_NAMES-2) = 2
   call update('eye',-1,-1,GM_BIGMEM-1)
      call mat_copyid(G_STACK_IDS(1,GG_MAX_NUMBER_OF_NAMES-1), eye)
      G_STACK_ID_LOC(GG_MAX_NUMBER_OF_NAMES-1) = GM_BIGMEM-1
      G_STACK_ROWS(GG_MAX_NUMBER_OF_NAMES-1) = -1
      G_STACK_COLS(GG_MAX_NUMBER_OF_NAMES-1) = -1
   GM_REALS(GM_BIGMEM-1) = 1.0D0
   call update('rand',1,1,GM_BIGMEM)
      call mat_copyid(G_STACK_IDS(1,GG_MAX_NUMBER_OF_NAMES), rand)
      G_STACK_ID_LOC(GG_MAX_NUMBER_OF_NAMES) = GM_BIGMEM
      G_STACK_ROWS(GG_MAX_NUMBER_OF_NAMES) = 1
      G_STACK_COLS(GG_MAX_NUMBER_OF_NAMES) = 1
   G_FMT = 1
   G_FLOP_COUNTER(1) = 0
   G_FLOP_COUNTER(2) = 0
   G_DEBUG_LEVEL = 0
   G_PTZ = 0
   G_PT = G_PTZ
end subroutine LAFF_init
subroutine LAFF_cmd(input_string,echo)
character(len=*),intent(in) :: input_string
logical,intent(in),optional :: echo
   call laff_cmds( [input_string],echo=echo)
end subroutine LAFF_cmd
subroutine LAFF_cmds(pseudo_file,echo)
character(len=*),intent(in),optional :: pseudo_file(:)
logical,intent(in),optional          :: echo
   if(present(echo)) G_ECHO=echo
   if(GM_BIGMEM.LT.0)then
      call laff_init(200000)
   else
      G_INPUT_LUN = STDIN                                                    ! unit number for terminal input
      G_RIO = G_INPUT_LUN                                                    ! current file to read commands from
      G_OUTPUT_LUN = STDOUT                                                  ! unit number for terminal output
      G_PROMPT=.true.
   endif
   if(present(pseudo_file))then
      G_PSEUDO_FILE=[character(len=GG_LINELEN) :: pseudo_file,'quit;']
      G_PROMPT=.false.
   else
      if(allocated(G_PSEUDO_FILE))deallocate(G_PSEUDO_FILE)
      allocate(G_PSEUDO_FILE(0))
   endif
   PARSE_LINE : do
      call mat_parse()
      select case(G_FUN)
      case(1) ; call mat_matfn1()
      case(2) ; call mat_matfn2()
      case(3) ; call mat_matfn3()
      case(4) ; call mat_matfn4()
      case(5) ; call mat_matfn5()
      case(6) ; call mat_matfn6()
      case(21); call mat_matfn1()
      case(99); exit PARSE_LINE
      case default
      end select
   enddo PARSE_LINE
end subroutine LAFF_cmds
subroutine mat_err(n)
integer,intent(in)   :: n
integer              :: i
integer              :: k
integer              :: lb
integer              :: lt
character(len=255)   :: msg
   G_ERR = n
   select case(n)
    case(1);  msg='Improper multiple assignment'
    case(2);  msg='Improper factor'
    case(3);  msg='Expected right parenthesis'
    case(4);  msg='Undefined variable: '//ade2str(G_IDS(:,G_PT+1)) ! extract variable name into buffer
    case(5);  msg='Column lengths do not match'
    case(6);  msg='Row lengths do not match'
    case(7);  msg='Text too long'
    case(8);  msg='Incompatible for ADDITION'
    case(9);  msg='Incompatible for SUBTRACTION'
    case(10); msg='Incompatible for MULTIPLICATION'
    case(11); msg='Incompatible for RIGHT DIVISION'
    case(12); msg='Incompatible for LEFT DIVISION'
    case(13); msg='Improper assignment to PERMANENT VARIABLE'
    case(14); msg='EYE-dentity undefined by CONTEXT'
    case(15); msg='Improper assignment to submatrix'
    case(16); msg='Improper command'
    case(17)
      lb = GM_BIGMEM - G_STACK_ID_LOC(G_TOP_OF_SAVED) + 1
      lt = g_err + G_STACK_ID_LOC(G_TOP_OF_SAVED)
      call journal(' Too much memory required')
      write(msg,'(1X,I7,'' Variables,'',I7,'' Temporaries,'',I7,'' Available.'')') lb,lt,GM_BIGMEM
    case(18); msg='Too many names'
    case(19); msg='Matrix is singular to working precision'
    case(20); msg='Matrix must be square'
    case(21); msg='Subscript out of range'
    case(22); write(msg, "(1x,'Recursion difficulties',*(i4))") (G_RSTK(i),i=1,G_PT)
    case(23); msg='Only 1, 2 or INF norm of matrix'
    case(24); msg='No convergence'
    case(25); msg='Can not use function name as variable'
    case(26); msg='Too complicated (STACK OVERFLOW)'
    case(27); msg='Division by zero is a NO-NO'
    case(28); msg='Empty macro'
    case(29); msg='Not positive definite'
    case(30); msg='Improper exponent'
    case(31); msg='Improper string'
    case(32); msg='Singularity of LOG or ATAN'
    case(33); msg='Too many colons'
    case(34); msg='Improper FOR clause'
    case(35); msg='Improper WHILE or IF clause'
    case(36); msg='Argument out of range'
    case(37); msg='Improper MACROS'
    case(38); msg='Improper file name'
    case(39); msg='Incorrect number of arguments'
    case(40); msg='Expecting statement terminator'
    case default
       call journal('sc','*mat_err* internal error: unknown error code=',n)
       return
   end select
   k = max(1,G_LINE_POINTER(2) - G_LINE_POINTER(1)) ! number of spaces to shift arrow by
   call journal(' '//repeat(' ',k)//'/\--ERROR:'//msg)
end subroutine mat_err
subroutine mat_files(lunit,iname,status)
integer                      :: lunit             ! logical unit number
integer                      :: iname(GG_LINELEN) ! INAME = FILE NAME, 1 character per word
character(len=1024)          :: name
character(len=1024)          :: temp1
character(len=*),optional    :: status
character(len=20)            :: status_local
integer                      :: ios
   if(present(status))then
      status_local=status
   else
      status_local='UNKNOWN'
   endif
   G_FILE_OPEN_ERROR=.false.
   select case(lunit)
    case(0)      ! error catcher
    case(stdin)  ! if unit is standard input return
    case(stdout) ! if unit is standard output return
    case(8)      ! diary file
       call mat_buf2str(name,iname,GG_LINELEN)
       call journal('O',trim(name)) ! open up trail file
    case(:-1)
      if(lunit.eq.-8)then
         call journal('O','')                                        ! close trail file
      else                                                           ! if LUNIT is negative, close the unit
         ios=0
         flush(unit=-lunit,iostat=ios)
         if(-lunit.ne.STDIN)then
            close(unit=-lunit,iostat=ios)
         endif
      endif
    case default                                                     !  ALL OTHER FILES
      call mat_buf2str(name,iname,GG_LINELEN)
      if(lunit.ne.STDIN)then
         open(unit=lunit,file=name,status=status_local,iostat=ios)      ! open a file
         if(ios.ne.0)then                                               ! general file open failure
            call journal('OPEN failed on file '//name)
            G_FILE_OPEN_ERROR=.true.                                    ! set the flag a file error occurred
            G_RIO=G_INPUT_LUN                                           ! set current file to read input lines from/to G_INPUT_LUN
         else
            G_FILE_OPEN_ERROR=.false.                                   ! set the flag a file error did not occur
         endif
      endif
   end select
end subroutine mat_files
subroutine mat_getsym()
doubleprecision   :: syv
doubleprecision   :: s
integer      :: sign
integer      :: chcnt
integer      :: ss
integer      :: i
   INFINITE : do
      if (G_CHRA .ne. blank) exit INFINITE
      call mat_getch() ! get next character
   enddo INFINITE
   G_LINE_POINTER(2) = G_LINE_POINTER(3)
   G_LINE_POINTER(3) = G_LINE_POINTER(4)
   if ( verify(achar(G_CHRA),digit) == 0) then
      call mat_getval(syv)
      if (G_CHRA .ne. dot) goto 60
      call mat_getch() ! get next character
   elseif (verify(achar(G_CHRA),digit//big//little//achar(score))== 0) then ! alphameric (0-9a-zA-Z_)
      G_SYM = isname
      G_SYN=blank
      G_SYN(1) = G_CHRA
      do i=2,GG_MAX_NAME_LENGTH
         call mat_getch() ! get next character
         if (verify(achar(G_CHRA),digit//big//little//achar(score))== 0 ) then
            G_SYN(i) = G_CHRA
         else
            exit
         endif
      enddo
      goto 90
   else ! special character
      ss = G_SYM
      G_SYM = G_CHRA
      call mat_getch() ! get next character
      if (G_SYM .ne. dot) goto 90
      syv = 0.0d0
      if (.not.(verify(achar(G_CHRA),digit)== 0) ) then ! not a number character
         if (G_CHRA.eq.star.or.G_CHRA.eq.slash.or.G_CHRA.eq.bslash) goto 90
         if (ss.eq.star .or. ss.eq.slash .or. ss.eq.bslash) goto 90
      endif
   endif
   chcnt = G_LINE_POINTER(4)
   call mat_getval(s)
   chcnt = G_LINE_POINTER(4) - chcnt
   if (G_CHRA .eq. GG_EOL) chcnt = chcnt+1
   syv = syv + s/10.0d0**chcnt
   goto 60
60 continue
   if (.not.(G_CHRA.ne.d_low .and. G_CHRA.ne.e_low .and. G_CHRA.ne.d_up .and. G_CHRA.ne.e_up) )then
      call mat_getch() ! get next character
      sign = G_CHRA
      if (sign.eq.minus .or. sign.eq.plus) call mat_getch() ! get next character
      call mat_getval(s)
      if (sign .ne. minus) syv = syv*10.0d0**s
      if (sign .eq. minus) syv = syv/10.0d0**s
   endif
   GM_IMAGS(GM_BIGMEM) = mat_flop(syv)
   G_SYM = isnum
   goto 90
90 continue
   if (G_CHRA .eq. blank) then
      call mat_getch() ! get next character till a non-blank is found
      goto 90
   endif
end subroutine mat_getsym
subroutine mat_str2buf(string,buf,lrecl)
character(len=*),intent(in) :: string
integer,intent(in)          :: lrecl
integer,intent(out)         :: buf(:)
integer                     :: i
   buf=iachar(' ')
   do i=1,min(lrecl,len_trim(string),size(buf))
      buf(i)=iachar(string(i:i))
   enddo
end subroutine mat_str2buf
function str2ade(string) result(vec)
character(len=*),intent(in)  :: string
integer,allocatable          :: vec(:)
integer                      :: i
   allocate(vec(len(string)))
   do i=1,len(string)
      vec(i)=iachar(string(i:i))
   enddo
end function str2ade
function ade2str(buf) result(string)
character(len=:),allocatable :: string
integer,intent(in)           :: buf(:)
integer                      :: i
   string=repeat(' ',size(buf))
   do i=1,size(buf)
      if(buf(i).ge.0 .or. buf(i).lt.255)then
         string(i:i)=achar(buf(i))
      else
         call journal('sc','ADE2STR:string contains unacceptable characters, position=',i,'ADE=',buf(i))
      endif
   enddo
end function ade2str
subroutine mat_buf2str(string,buf,lrecl)
integer,intent(in)     :: lrecl
integer,intent(in)     :: buf(:)
character(len=*)       :: string
integer                :: i
integer                :: ilen
   string(:)=' '
   ilen=len(string)
   do i=1,min(lrecl,ilen,size(buf))
      string(i:i)=achar(buf(i))
   enddo
end subroutine mat_buf2str
subroutine ints2str(ints,string,ierr)
integer,intent(in)                       :: ints(:)
character(len=:),allocatable,intent(out) :: string
integer,intent(out)                      :: ierr
integer                                  :: i
   ierr=0
   if(allocated(string))deallocate(string)
   allocate(character(len=size(ints)) :: string)
   string(:)=' '
   do i=1,size(ints)
      if( ints(i).lt.G_CHARSET_SIZE .and. ints(i).ge.0 )then
         string(i:i)=achar(ints(i))
      else
         call journal('sc',' function name contains unacceptable characters:',ints(i))
         ierr=ierr+1
      endif
   enddo
end subroutine ints2str
subroutine mat_matfn6()
integer :: i, j, k
integer :: ia
integer :: ib
integer :: ja
integer :: jb
integer :: location
integer :: la
integer :: lb
integer :: ld
integer :: lj
integer :: ll
integer :: ls
integer :: m
integer :: ma
integer :: mn
integer :: n
integer :: na
integer :: nn
integer,parameter :: unifor(GG_MAX_NAME_LENGTH) =  [iachar(['u','n','i','f','o','r','m']),GG_PAD(8:)]
integer,parameter :: normal(GG_MAX_NAME_LENGTH) =  [iachar(['n','o','r','m','a','l',' ']),GG_PAD(8:)]
integer,parameter :: seed(GG_MAX_NAME_LENGTH)   =  [iachar(['s','e','e','d',' ',' ',' ']),GG_PAD(8:)]
integer           :: id(GG_MAX_NAME_LENGTH)
doubleprecision   :: eps0,eps,s,sr,si,t
character(len=80) :: message
character(len=GG_LINELEN) :: string_buf
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   FUN6: select case(G_FIN)
   case(1) ! COMMAND::MAGIC
      N = MAX(int(GM_REALS(location)),0)
      IF (N .EQ. 2) N = 0
      IF (N .GT. 0) call mat_magic(GM_REALS(location),N,N)
      call mat_rset(N*N,0.0D0,GM_IMAGS(location),1)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
   case(11,12,13) !  COMMAND::KRONECKER PRODUCT
      if (G_RHS .ne. 2) then
         call mat_err(39) ! Incorrect number of arguments
         return
      endif
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      MA = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
      NA = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      LA = location + MAX(M*N*MA*NA,M*N+MA*NA)
      LB = LA + MA*NA
      if(too_much_memory(LB + M*N - G_STACK_ID_LOC(G_TOP_OF_SAVED)) )return
      call mat_wcopy(MA*NA+M*N,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(LA),GM_IMAGS(LA),1)
      DO JA = 1, NA
        DO J = 1, N
          LJ = LB + (J-1)*M
          DO IA = 1, MA
            call mat_wcopy(M,GM_REALS(LJ),GM_IMAGS(LJ),1,GM_REALS(location),GM_IMAGS(location),1)
            LS = LA + IA-1 + (JA-1)*MA
            DO I = 1, M
              IF (G_FIN .EQ. 11) &
              call mat_wmul( GM_REALS(LS), GM_IMAGS(LS), &
                             GM_REALS(location),  GM_IMAGS(location),  &
                             GM_REALS(location),  GM_IMAGS(location))
              IF (G_FIN .EQ. 12) &
              call mat_wdiv( GM_REALS(LS), GM_IMAGS(LS), &
                             GM_REALS(location),  GM_IMAGS(location),  &
                             GM_REALS(location),  GM_IMAGS(location))
              IF (G_FIN .EQ. 13)  &
              call mat_wdiv( GM_REALS(location),  GM_IMAGS(location),  &
                             GM_REALS(LS), GM_IMAGS(LS), &
                             GM_REALS(location),  GM_IMAGS(location))
              IF (G_ERR .GT. 0) return
              location = location + 1
            ENDDO
          enddo
        enddo
      enddo
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = M*MA
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N*NA
   case(9) ! COMMAND::CHOP
      eps0 = 1.0d0
      do                                                                  ! recalculate epsilon
         eps0 = eps0/2.0d0
         t = mat_flop(1.0d0 + eps0)
         if (t .le. 1.0d0) exit
      enddo
      eps0 = 2.0d0*eps0
      G_FLOP_COUNTER(2) = int(GM_REALS(location))
      if (G_SYM .ne. SEMI) then
         write(message,'(''CHOP '',I2,'' PLACES.'')') G_FLOP_COUNTER(2)
         call journal(message)
      endif
      eps = 1.0d0
      do                                                                  ! recalculate epsilon
         eps = eps/2.0d0
         t = mat_flop(1.0d0 + eps)
         if (t .le. 1.0d0) exit
      enddo
      eps = 2.0d0*eps
      t = GM_REALS(GM_BIGMEM-4)
      if (t.lt.eps .or. t.eq.eps0) GM_REALS(GM_BIGMEM-4) = eps
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   case(3) ! COMMAND::SUM
      sr = 0.0d0
      si = 0.0d0
      mn = m*n
      do i = 1, mn
         ls = location+i-1
         sr = mat_flop(SR+GM_REALS(LS))
         si = mat_flop(SI+GM_IMAGS(LS))
      enddo
      GM_REALS(location) = sr
      GM_IMAGS(location) = si
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
   case(4) ! COMMAND::PROD
      SR = 1.0D0
      SI = 0.0D0
      MN = M*N
      DO I = 1, MN
         LS = location+I-1
         call mat_wmul(GM_REALS(LS),GM_IMAGS(LS),SR,SI,SR,SI)
      enddo
      GM_REALS(location) = SR
      GM_IMAGS(location) = SI
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
   case(5) ! COMMAND::USER
      s = 0.0d0
      t = 0.0d0
      write(*,*)'GOT HERE A:G_RHS:',G_RHS
      if (G_RHS .eq. 2) then
         write(*,*)'GOT HERE B:G_RHS:',G_RHS
         write(*,*)'GOT HERE B.2:',location
         call printit()
         s = G_STACK_ROWS(location)
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
         n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      elseif(G_RHS.gt.2)then
         write(*,*)'GOT HERE C:G_RHS:',G_RHS
         write(*,*)'GOT HERE D:',location
         call printit()
         t = G_STACK_ROWS(location)
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         s = G_STACK_ROWS(location)
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
         n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      else  ! if not 1,2,3 should it be an error???
      endif
      write(*,*)'GOT HERE D:G_RHS:',G_RHS,':S:',S,':T:',T
      call usersub(GM_REALS(location),m,n,s,t)
      call mat_rset(m*n,0.0d0,GM_IMAGS(location),1)
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
   case(10) ! COMMAND::SIZE
      GM_REALS(location) = M
      GM_IMAGS(location) = 0.0D0
      GM_REALS(location+1) = N
      GM_IMAGS(location+1) = 0.0D0
      if(G_LHS.eq.1)then
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 2
      else
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
         G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location+1
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      endif
   case(2,14,15) ! COMMAND::DIAG=2
      k = 0
      if (G_RHS .eq. 2) then
         k = int(GM_REALS(location))
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
         n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      endif
      if (G_FIN .ge. 14) then ! COMMAND::TRIL, COMMAND::TRIU
            do j = 1, n
               ld = location + j - k - 1 + (j-1)*m
               select case(G_FIN)
               case(14)
                        ll = j - k - 1
                        ls = ld - ll
               case(15)
                        ll = m - j + k
                        ls = ld + 1
               end select
               if (ll .gt. 0) call mat_wset(ll, 0.0d0, 0.0d0, GM_REALS(ls), GM_IMAGS(ls), 1)
            enddo
      elseif (m .eq. 1 .or. n .eq. 1) then
         n = max(m,n)+iabs(k)
         if(too_much_memory( location+n*n - G_STACK_ID_LOC(G_TOP_OF_SAVED)) )return
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         do jb = 1, n
            do ib = 1, n
               j = n+1-jb
               i = n+1-ib
               sr = 0.0d0
               si = 0.0d0
               if (k.ge.0) ls = location+i-1
               if (k.lt.0) ls = location+j-1
               ll = location+i-1+(j-1)*n
               if (j-i .eq. k) sr = GM_REALS(ls)
               if (j-i .eq. k) si = GM_IMAGS(ls)
               GM_REALS(LL) = sr
               GM_IMAGS(LL) = si
            enddo
         enddo
      else
         if (k.ge.0) mn=min(m,n-k)
         if (k.lt.0) mn=min(m+k,n)
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = max(mn,0)
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         if (mn .le. 0) exit FUN6
         do i = 1, mn
            if (k.ge.0) ls = location+(i-1)+(i+k-1)*m
            if (k.lt.0) ls = location+(i-k-1)+(i-1)*m
            ll = location+i-1
            GM_REALS(ll) = GM_REALS(ls)
            GM_IMAGS(ll) = GM_IMAGS(ls)
         enddo
      endif
      exit FUN6
   case(6,7,8,16) ! COMMAND::EYE,
      if (.not.(m.gt.1 .or. G_RHS.eq.0)) then
         if (G_RHS .eq. 2) then
            nn = int(GM_REALS(location))
            G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
            location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
            n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
         endif
         if (G_FIN.eq.7.and.n.lt.GG_MAX_NAME_LENGTH)then        ! a call to RAND might be RAND('UNIFORM'|'SEED'|'NORMAL')
            id=blank
            do i = 1, min(GG_MAX_NAME_LENGTH,n)  ! in case it is one of these words store it in the ID array to test if it matches
               ls = location+i-1
               id(i) = int(GM_REALS(ls))
            enddo
            if(mat_eqid(id,unifor).or.mat_eqid(id,normal))then ! SWITCH UNIFORM AND NORMAL(if a matrix just happens to match, a bug)
               G_CURRENT_RANDOM_TYPE = id(1) - unifor(1)        ! set random type to generate by seeing if first letter is a "u"
               G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
               exit FUN6
            elseif (mat_eqid(id,seed)) then                     ! if a matrix just happens to match "seed" , a bug)
               if (G_RHS .eq. 2) G_CURRENT_RANDOM_SEED = nn
               GM_REALS(location) = G_CURRENT_RANDOM_SEED
               G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
               if (G_RHS .eq. 2) G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
               G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
               exit FUN6
            endif
         endif
         if (n .le. 1) then
            m = max(int(GM_REALS(location)),0)
            if (G_RHS .eq. 2) n = max(nn,0)
            if (G_RHS .ne. 2) n = m
            if(too_much_memory( location+m*n - G_STACK_ID_LOC(G_TOP_OF_SAVED))) return
            G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
            G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
            if (m*n .eq. 0) exit FUN6
         endif
      endif
      do j = 1, n
         do i = 1, m
           ll = location+i-1+(j-1)*m             ! location to place value
           GM_IMAGS(ll) = 0.0d0      ! all of these functions set imaginary values to zero
           select case(G_FIN)
           case( 6 ) !::EYE
              if(i.eq.j)then               ! on the diagonal
                 GM_REALS(ll) = 1.0d0
              else
                 GM_REALS(ll) = 0.0d0
              endif
           case( 7 ) !::RAND
              IF(G_CURRENT_RANDOM_TYPE.EQ.0) then
                 GM_REALS(ll)=mat_flop(mat_urand(G_CURRENT_RANDOM_SEED))
              else
                 do
                    sr = 2.0d0*mat_urand(G_CURRENT_RANDOM_SEED)-1.0d0
                    si = 2.0d0*mat_urand(G_CURRENT_RANDOM_SEED)-1.0d0
                    t = sr*sr + si*si
                    if (t .le. 1.0d0) exit
                 enddo
                 GM_REALS(ll) = mat_flop(sr*dsqrt((-(2.0d0*dlog(t)))/t))
              endif
           case( 8 ) !::ONES
              GM_REALS(ll) = 1.0d0
           case( 16) !::ZEROS
              GM_REALS(ll) = 0.0d0
           case default
              call journal('should not get here: internal error')
           end select
         enddo
      enddo
      exit FUN6
   case(17) ! COMMAND::GETENV JSU
      GETENV : block
      character(len=:),allocatable :: answers(:)
      character(len=GG_LINELEN)    :: varname
      character(len=:),allocatable :: env_value
      allocate(character(len=0)    :: answers(0) )
      if (m.lt.1 .or. G_RHS.eq.0)then
         call journal('sc','<ERROR>getenv:needs an argument:rows=',m,' arg_count=',G_RHS)
         G_ERR=999
         return
      endif
      if (G_RHS.gt.1)then
         call journal('sc','<ERROR>getenv:too many arguments:arg_count=',G_RHS)
         G_ERR=999
         return
      endif
      ll=location
      do j=1,m
         id=blank
         id(1:n)=int(GM_REALS(ll:ll+n-1))
         varname=''
         do i=1,n
            if(id(i).le.0)exit   ! ??? why exit. What is the special meaning?
            if(id(i).lt.G_CHARSET_SIZE.and.id(i).ge.0)then
               varname(i:i)=achar(id(i))
            else
               call journal('sc',' function name contains unacceptable characters:',id(i))
               return
            endif
         enddo
         ll=ll+n
         env_value=system_getenv(varname)
         answers=[character(len=max(len(answers),len_trim(env_value),1)) :: answers,env_value]
      enddo
      m=size(answers,dim=1)
      n=len(answers)
      if(too_much_memory( location+m*n - G_STACK_ID_LOC(G_TOP_OF_SAVED)) )return
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      if (m*n .eq. 0) exit FUN6
      do j = 1, n
         do i = 1, m
           ll = location+i-1+(j-1)*m             ! location to place value
           GM_IMAGS(ll) = 0.0d0             ! all of these functions set imaginary values to zero
           nn=iachar(answers(m)(j:j))
           if(nn.gt.0)then
              GM_REALS(ll) = real(nn)
           else
              call journal('sc','bad character')
              GM_REALS(ll) = 0.0d0
           endif
         enddo
      enddo
      endblock GETENV
      exit FUN6
   case(18) ! COMMAND::DAT
      DATETIME: block
      integer :: time_values(8)
      call date_and_time(values=time_values)
      GM_REALS(location:location+8-1) = dble(time_values)
      GM_IMAGS(location:location+8-1) = 0.0D0
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 8
      endblock DATETIME
   end select FUN6
end subroutine mat_matfn6
subroutine mat_funs(id)
integer,intent(in)                :: id(GG_MAX_NAME_LENGTH)
integer                           :: selector
character(len=GG_MAX_NAME_LENGTH) :: name
integer                           :: i
   name=' '
   do i=1,size(id)
      if(id(i).le.0)exit
      if(id(i).le.G_CHARSET_SIZE)then
         name(i:i)=achar(id(i))
      else
         call journal('sc',' function name contains unacceptable characters:',name,'... ADE=',id(i),'position=',i)
         G_FIN = 0
         return
      endif
   enddo
   select case(name)
   case('eps');             selector=000
   case('flop');            selector=000
   case('inv');             selector=101
   case('det');             selector=102
   case('rcond');           selector=103
   case('lu');              selector=104
   case('invh','inverse_hilbert','invhilb');  selector=105
   case('chol');            selector=106
   case('rref');            selector=107
   case('sin');             selector=201
   case('cos');             selector=202
   case('atan');            selector=203
   case('exp');             selector=204
   case('sqrt');            selector=205
   case('log');             selector=206
   case('eig');             selector=211
   case('schur');           selector=212
   case('hess');            selector=213
   case('poly');            selector=214
   case('roots');           selector=215
   case('abs');             selector=221  !  calling  codes  corresponding  to  the  function  names
   case('round');           selector=222
   case('real');            selector=223
   case('imag');            selector=224
   case('conjg');           selector=225
   case('svd');             selector=301
   case('pinv');            selector=302
   case('cond');            selector=303
   case('norm');            selector=304
   case('rank');            selector=305
   case('qr');              selector=401
   case('orth');            selector=402
   case('exec','include','source','script');  selector=501
   case('save');            selector=502
   case('load');            selector=503
   case('print');           selector=504
   case('diary');           selector=505
   case('disp','display','echo');  selector=506
   case('base');            selector=507
   case('lines');           selector=508
   case('char');            selector=509
   case('plot');            selector=510
   case('rat');             selector=511
   case('debug');           selector=512
   case('show');            selector=513
   case('delete');          selector=514
   case('magic');           selector=601
   case('diag');            selector=602
   case('sum');             selector=603
   case('prod');            selector=604
   case('user');            selector=605
   case('eye');             selector=606
   case('rand','random');   selector=607
   case('ones');            selector=608
   case('chop');            selector=609
   case('size');            selector=610
   case('kron');            selector=611
   case('tril');            selector=614
   case('triu');            selector=615
   case('zeros');           selector=616
   case('getenv');          selector=617
   case('dat','date_and_time');   selector=618
   case default !  function name was not found
      G_FIN = 0
      return
   end select
   G_FIN = mod(selector,100) ! which case to select in called procedure
   G_FUN = selector/100      ! which routine to call (SUBROUTINE MAT_MATFN[1-6])
   if (G_RHS.eq.0 .and. selector.eq.606) G_FIN = 0
   if (G_RHS.eq.0 .and. selector.eq.607) G_FIN = 0
end subroutine mat_funs
subroutine mat_copyid(x,y)
integer,intent(out) :: x(GG_MAX_NAME_LENGTH)
integer,intent(in)  :: y(GG_MAX_NAME_LENGTH)
integer             :: i
      do i = 1, GG_MAX_NAME_LENGTH
         x(i) = y(i)
      enddo
end subroutine mat_copyid
subroutine mat_getval(s)
doubleprecision,intent(out) :: s
      s = 0.0d0
      INFINITE: do
         select case(G_CHRA)
         case(iachar('0')); s = 10.0d0*s + 0.0d0
         case(iachar('1')); s = 10.0d0*s + 1.0d0
         case(iachar('2')); s = 10.0d0*s + 2.0d0
         case(iachar('3')); s = 10.0d0*s + 3.0d0
         case(iachar('4')); s = 10.0d0*s + 4.0d0
         case(iachar('5')); s = 10.0d0*s + 5.0d0
         case(iachar('6')); s = 10.0d0*s + 6.0d0
         case(iachar('7')); s = 10.0d0*s + 7.0d0
         case(iachar('8')); s = 10.0d0*s + 8.0d0
         case(iachar('9')); s = 10.0d0*s + 9.0d0
         case default
            exit INFINITE
         end select
         call mat_getch() ! get next character
      enddo INFINITE
end subroutine mat_getval
subroutine mat_getch()
   G_CHRA = G_LIN(G_LINE_POINTER(4))
   if (G_CHRA .ne. GG_EOL) G_LINE_POINTER(4) = G_LINE_POINTER(4) + 1
end subroutine mat_getch
subroutine mat_base(x,b,eps,s,n)
doubleprecision :: x
doubleprecision :: b
doubleprecision :: eps
doubleprecision :: s(*)
integer         :: n
doubleprecision :: t
integer      :: l
integer      :: j
integer      :: k
integer      :: m
   l = 1
   if (x .ge. 0.0d0)then
      s(l) = plus
   else
      s(l) = minus
   endif
   s(l+1) = zero
   s(l+2) = dot
   x = dabs(x)
   if (x .ne. 0.0d0) then
      k = dlog(x)/dlog(b)
   else
      k = 0
   endif
   if (x .gt. 1.0d0) k = k + 1
   x = x/b**k
   if (b*x .ge. b) k = k + 1
   if (b*x .ge. b) x = x/b
   if (eps .ne. 0.0d0)then
      m = (-1)*dlog(eps)/dlog(b) + 4
   else
      m = 54
   endif
   do l = 4, m
      x = b*x
      j = int(x)
      s(l) = dble(j)
      x = x - s(l)
   enddo
   s(m+1) = comma
   if (k .ge. 0) s(m+2) = plus
   if (k .lt. 0) s(m+2) = minus
   t = dabs(dble(k))
   n = m + 3
   if (t .ge. b) n = n + int(dlog(t)/dlog(b))
   l = n
   INFINITE: do
      j = int(dmod(t,b))
      s(l) = dble(j)
      l = l - 1
      t = t/b
      if (l .lt. m+3) exit
   enddo INFINITE
end subroutine mat_base
subroutine mat_print(ID,K)
integer           :: id(GG_MAX_NAME_LENGTH)
integer           :: k
character(len=81) :: message
character(len=80) :: form
character(len=1)  :: ls_char
doubleprecision   :: s
doubleprecision   :: tr
doubleprecision   :: ti
doubleprecision   :: pr(12)
doubleprecision   :: pi(12)
integer           :: sig(12)
integer           :: typ
integer           :: f
integer           :: location,m,n,mn
integer           :: ks
integer           :: i
integer           :: ios
integer           :: istep
integer           :: j
integer           :: j1
integer           :: j2
integer           :: j3
integer           :: jinc
integer           :: jm
integer           :: ls
integer,save      :: fno(11)= [11,12,21,22,23,24,31,32,33,34,-1]
integer,save      :: fnl(11)= [12, 6, 8, 4, 6, 3, 4, 2, 3, 1, 1]
integer           :: itype
   if (G_LINECOUNT(1) .lt. 0) goto 99
   location = G_STACK_ID_LOC(k)
   m = G_STACK_ROWS(k)
   n = G_STACK_COLS(k)
   mn = m*n
   typ = 1
   s = 0.0d0
   itype=-9999
   do i = 1, mn
      ls = location+i-1
      tr = GM_REALS(ls)
      ti = GM_IMAGS(ls)
      s = dmax1(s,dabs(tr),dabs(ti))
      if (mat_round(tr) .ne. tr) typ = max(2,typ)
      if (ti .ne. 0.0d0) typ = 3
   enddo
   if (s .ne. 0.0d0) s = dlog10(s)
   ks = int(s)
   if (-2 .le. ks .and. ks .le. 1) ks = 0
   if (ks .eq. 2 .and. G_FMT .eq. 1 .and. typ .eq. 2) ks = 0
   f=0                          ! initialize to bad value
   if (typ .eq. 1 )then         ! if output type is integer
      if( ks .le. 2 )then
         f = 1
      else
         f = 2
      endif
   endif
   if (typ .eq. 1 .and. ks .gt. 9) typ = 2  !change type from integer to real
   if (typ .eq. 2) f = G_FMT + 2   ! if type is real
   if (typ .eq. 3) f = G_FMT + 6   ! if type is complex
   if(f.eq.0)then
      call journal('*mat_print* internal error - bad type')
      goto 99
   endif
   if (mn.eq.1 .and. ks.ne.0 .and. G_FMT.lt.3 .and. typ.ne.1) f = f+2
   if (G_FMT .eq. 5) f = 11
   jinc = fnl(f)
   f = fno(f)
   s = 1.0d0
   if (f.eq.21 .or. f.eq.22 .or. f.eq.31 .or. f.eq.32) s = 10.0D0**ks
   ls = ((n-1)/jinc+1)*m + 2
   IF (G_LINECOUNT(1) + LS .gt. G_LINECOUNT(2)) then
      G_LINECOUNT(1) = 0
      if(G_PROMPT)then
         WRITE(message, "(' AT LEAST ',I5,' MORE LINES.','  ENTER BLANK LINE TO CONTINUE OUTPUT.')") LS
         call journal(message)
         READ(G_INPUT_LUN,'(a1)',END=19) LS_CHAR  ! read response to pause from standard input
         IF (LS_CHAR .EQ. ' ') goto 20      ! if blank or a return display the values
         G_LINECOUNT(1) = -1
         goto 99
      else
         LS_CHAR = ' '
         goto 20
      endif
   19 continue
      call mat_files(-G_INPUT_LUN,G_BUF)
   endif
   20 continue
   call journal(' ')
   call mat_print_id(ID,-1)
   G_LINECOUNT(1) = G_LINECOUNT(1)+2
   if (s .ne. 1.0d0)then
      write(message,'(''  '',1PD9.1," *")') s
      if(G_OUTPUT_LUN.eq.STDOUT)then
         call journal(message)
      else
         write(G_OUTPUT_LUN,'(a)')message(1:80)
      endif
   endif
   do j1 = 1, n, jinc
      j2 = min(n, j1+jinc-1)
      if (n .gt. jinc)then
         write(message,'(''     COLUMNS'',I6,'' THRU'',I6)') j1,j2
         if(G_OUTPUT_LUN.eq.STDOUT)then
            call journal(message)
         else
            write(G_OUTPUT_LUN,'(a)')message(1:80)
         endif
      endif
      do i = 1, m
         jm = j2-j1+1
         do j = 1, jm
            ls = location+i-1+(j+j1-2)*m
            pr(j) = GM_REALS(ls)/s
            pi(j) = dabs(GM_IMAGS(ls)/s)
            sig(j) = plus
            if (GM_IMAGS(ls) .lt. 0.0d0) sig(j) = minus
         enddo
         select case(F)
         case(11)
            form='(1X,12F6.0)'          ! integer
            istep=12
            itype= 777
         case(12)
            form='(1X,6F12.0)'          ! integer
            istep=6
            itype= 777
         case(21)
            form='(1X,F9.4,7F10.4)'     ! 8 numbers
            istep=8
            itype= 999
         case(22)
            form='(1X,F19.15,3F20.15)'  ! 4 numbers
            istep=4
            itype= 999
         case(23)
            form='(1X,1P6D13.4)'        ! 6 numbers
            istep=6
            itype= 999
         case(24)
            form='(1X,1P3D24.15)'       ! 3 numbers
            istep=3
            itype= 999
         case(31)
            form='(1X,4(F9.4,1X,A1,F7.4,''i''))'                       ! 4x3
            istep=12
            itype= 888
         case(32)
            form='(1X,F19.15,A1,F18.15,''i'',F20.15,A1,F18.15,''i'')'  ! 6
            istep=6
            itype= 888
         case(33)
            form='(1X,3(1PD13.4,1X,A1,1PD10.4,''i''))'                 ! 9
            istep=9
            itype= 888
         case(34)
            form='(1X,1PD24.15,1X,A1,1PD21.15,''i'')'                  ! 3
            istep=3
            itype= 888
         case(-1)
            call mat_formz(G_OUTPUT_LUN,GM_REALS(ls),GM_IMAGS(ls))
            istep=-1
            itype=-1
         case default
            call journal('*internal error*')
            goto 99
         end select
         if(itype.gt.0)then
            do j3=1,jm,istep
               select case(itype)
               case(777); write(message,form)(pr(j),j=j3,min(j3+istep-1,jm))
               case(999); write(message,form)(pr(j),j=j3,min(j3+istep,jm))
               case(888); write(message,form)(pr(j),sig(j),pi(j),j=j3,min(j3+istep-1,jm))
               end select
               if(G_OUTPUT_LUN.eq.STDOUT)then
                  call journal(message)
               else
                  write(G_OUTPUT_LUN,'(a)')message(1:80)
               endif
            enddo
         endif
         G_LINECOUNT(1) = G_LINECOUNT(1)+1
      enddo
   enddo
99 continue
   if(G_OUTPUT_LUN.ne.STDOUT)flush(unit=G_OUTPUT_LUN,iostat=ios)
end subroutine mat_print
subroutine mat_formz(lunit,x,y)
integer                    :: lunit
doubleprecision,intent(in) :: x,y
character(len=36)          :: mline
   if (y .ne. 0.0d0) then
      write(mline,'(2z18)') x,y
   else
      write(mline,'(z18)') x
   endif
   call journal(mline)
end subroutine mat_formz
subroutine mat_prompt(pause)
integer,intent(in) :: pause
character(len=1)   :: dummy
   if(.not.G_PROMPT)return ! in batch mode
   if(G_OUTPUT_LUN.le.0)then
      call journal('*mat_prompt* internal error: G_OUTPUT_LUN <= 0')
   elseif(G_INPUT_LUN.lt.0)then
      call journal('*mat_prompt* internal error: G_INPUT_LUN <= 0')
   else
      if(G_OUTPUT_LUN.eq.STDOUT)then
         WRITE(G_OUTPUT_LUN,'(''<>'')',advance='no')   ! write prompt to interactive input
      endif
      if (pause .eq. 1) read(G_INPUT_LUN,'(a1)') dummy
   endif
end subroutine mat_prompt
subroutine mat_stack1(op)
integer           :: op
integer           :: i
integer           :: j
integer           :: location
integer           :: ll
integer           :: ls
integer           :: m
integer           :: mn
integer           :: n
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   mn = m*n
   if (mn .eq. 0) then
   elseif (op .ne. quote) then                                 ! unary minus
      call mat_wrscal(MN,-1.0D0,GM_REALS(location),GM_IMAGS(location),1)
   else                                                        ! transpose
      ll = location + mn
      if(too_much_memory( ll+mn - G_STACK_ID_LOC(G_TOP_OF_SAVED)) )return
      call mat_wcopy(MN,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(ll),GM_IMAGS(ll),1)
      M = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      N = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      do i = 1, m
         do j = 1, n
            ls = location+mn+(j-1)+(i-1)*n
            ll = location+(i-1)+(j-1)*m
            GM_REALS(ll) = GM_REALS(ls)
            GM_IMAGS(ll) = -GM_IMAGS(ls)
         enddo
      enddo
   endif
end subroutine mat_stack1
subroutine mat_print_id(id,argcnt)
integer            :: id(GG_MAX_NAME_LENGTH,*)
integer            :: argcnt
integer            :: id_counter                               !
integer            :: i, j, k
integer            :: line_position                            ! pointer into output line being built
integer            :: linebuf(8*GG_MAX_NAME_LENGTH+2*8+1)      ! scratch buffer for building up line
character(len=(8*GG_MAX_NAME_LENGTH+2*8+1)) :: mline           ! scratch space for building line to print
   id_counter = 1                                         ! which ID to start the line with
   INFINITE : do
      linebuf(1)=blank                                    ! put a space at beginning of line
      line_position = 2
      do j = id_counter,min(id_counter+7,iabs(argcnt))    ! copy up to eight names into buffer
         do i = 1, GG_MAX_NAME_LENGTH                     ! copy one name into buffer
            k = id(i,j)                                   ! this is the kth letter of the set
            linebuf(line_position) = k
            if(linebuf(line_position).ne.blank)line_position = line_position+1   ! increment pointer into output
         enddo
         linebuf(line_position+0)=blank         ! put two spaces between names
         linebuf(line_position+1)=blank
         line_position=line_position+2
      enddo
      if (argcnt .eq. -1) then                            ! special flag to print one word and  =
         linebuf(line_position) = equal                   ! put value for equal sign into buffer
      else
         line_position=line_position-3                    ! was prepared for another ID with two blanks
      endif
      call mat_buf2str(mline,linebuf,line_position)       ! write LINEBUF(1:line_position) line to a character variable
      if(G_OUTPUT_LUN.eq.STDOUT)then
         call journal(mline)                              ! print the line to stdout
      else
         write(G_OUTPUT_LUN,'(a)')trim(mline)             ! print the line to a file
      endif
      id_counter = id_counter+8                           ! prepare to get up to eight more IDs
      if (id_counter .gt. iabs(argcnt)) exit INFINITE     ! if not done do another line
   enddo INFINITE
end subroutine mat_print_id
subroutine mat_stack_put(id)
integer  :: id(GG_MAX_NAME_LENGTH)
integer  :: i, j, k
integer  :: ib
integer  :: km1
integer  :: location
integer  :: l1,l2, li,lj,lk, ll,ls,lt
integer  :: m, m1,m2, mk
integer  :: mn, mn1, mn2, mnk
integer  :: mt
integer  :: n, nk, nt
   if (G_BOTTOM_OF_SCRATCH_IN_USE .le. 0) then
      call mat_err(1)  ! Improper multiple assignment
      return
   endif
   call mat_funs(id)
   if (G_FIN .ne. 0) then
      call mat_err(25) ! Can not use function name as variable
      return
   endif
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   if (m .gt. 0) then
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   elseif(m.lt.0) then
      call mat_err(14) ! EYE-dentity undefined by CONTEXT
      return
   elseif (m .eq. 0 .and. n .ne. 0) then
      goto 99
   else  ! what about m zero and n not zero???
   endif
   mn = m*n
   lk = 0
   mk = 1
   nk = 0
   lt = 0
   mt = 0
   nt = 0
   call mat_copyid(G_STACK_IDS(1,G_TOP_OF_SAVED-1),id)
   do k=GG_MAX_NUMBER_OF_NAMES,1,-1
      if (mat_eqid(G_STACK_IDS(1:,k),id)) exit
   enddo
   if (k .ne. G_TOP_OF_SAVED-1) then        ! variable exists
      lk = G_STACK_ID_LOC(k)
      mk = G_STACK_ROWS(k)
      nk = G_STACK_COLS(k)
      mnk = mk*nk
      if (G_RHS .gt. 2) then
         call mat_err(15)                   ! Improper assignment to submatrix
         return
      elseif (G_RHS .ne. 0) then
         mt = mk
         nt = nk
         lt = location + mn
         if(too_much_memory( lt + mnk - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )then
            return
         endif
         call mat_wcopy(mnk,GM_REALS(lk),GM_IMAGS(lk),1,GM_REALS(lt),GM_IMAGS(lt),1)
      endif
      if (G_RHS.eq.0 .and. mn.eq.mnk) then    ! size of existing array did not change
         goto 40
      endif
      if (k .ge. GG_MAX_NUMBER_OF_NAMES-3) then
         call mat_err(13) ! Improper assignment to PERMANENT VARIABLE
         return
      endif
      if (k .ne. G_TOP_OF_SAVED) then
         ls = G_STACK_ID_LOC(G_TOP_OF_SAVED)
         ll = ls + mnk
         call mat_wcopy(lk-ls,GM_REALS(ls),GM_IMAGS(ls),-1,GM_REALS(ll),GM_IMAGS(ll),-1)
         km1 = k-1
         do ib = G_TOP_OF_SAVED, km1
            i = G_TOP_OF_SAVED+km1-ib
            call mat_copyid(G_STACK_IDS(1,i+1),G_STACK_IDS(1,i))
            G_STACK_ROWS(i+1) = G_STACK_ROWS(i)
            G_STACK_COLS(i+1) = G_STACK_COLS(i)
            G_STACK_ID_LOC(i+1) = G_STACK_ID_LOC(i)+mnk
         enddo
      endif
      G_TOP_OF_SAVED = G_TOP_OF_SAVED+1
   endif
   if (mn .eq. 0) then
      goto 99
   endif
   if (G_TOP_OF_SAVED-2 .le. G_BOTTOM_OF_SCRATCH_IN_USE) then
      call mat_err(18) ! Too many names
      return
   endif
   k = G_TOP_OF_SAVED-1
   call mat_copyid(G_STACK_IDS(1,k), id)
   if (G_RHS .eq. 1) then
      if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-1) .lt. 0) then
         goto 59
      endif
      mn1 = 1
      mn2 = 1
      l1 = 0
      l2 = 0
      if (n.ne.1 .or. nk.ne.1) then
         if (m.ne.1 .or. mk.ne.1) then
            call mat_err(15) ! Improper assignment to submatrix
            return
         endif
         l2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE-1)
         m2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
         mn2 = m2*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
         m1 = -1
         goto 60
      endif
      l1 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE-1)
      m1 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
      mn1 = m1*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
      m2 = -1
      goto 60
   elseif (G_RHS .eq. 2)then
      if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-1).lt.0 .and. G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-2).lt.0) then
         goto 59
      endif
      l2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE-1)
      m2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
      mn2 = m2*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
      if (m2 .lt. 0) mn2 = n
      l1 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE-2)
      m1 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-2)
      mn1 = m1*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE-2)
      if (m1 .lt. 0) mn1 = m
      goto 60
   endif
40 continue
   if (k .lt. GG_MAX_NUMBER_OF_NAMES) G_STACK_ID_LOC(k) = G_STACK_ID_LOC(k+1) - mn
   G_STACK_ROWS(k) = m
   G_STACK_COLS(k) = n
   lk = G_STACK_ID_LOC(k)
   call mat_wcopy(mn,GM_REALS(location),GM_IMAGS(location),-1,GM_REALS(lk),GM_IMAGS(lk),-1)
   goto 90
59 continue
   if (mn .ne. mnk) then
      call mat_err(15) ! Improper assignment to submatrix
      return
   endif
   lk = G_STACK_ID_LOC(k)
   call mat_wcopy(mn,GM_REALS(location),GM_IMAGS(location),-1,GM_REALS(lk),GM_IMAGS(lk),-1)
   goto 90
60 continue
   if (mn1.ne.m .or. mn2.ne.n) then
      call mat_err(15) ! Improper assignment to submatrix
      return
   endif
   ll = 1
   if (m1 .ge. 0) then
      do i = 1, mn1
         ls = l1+i-1
         mk = max(mk,int(GM_REALS(ls)))
         ll = min(ll,int(GM_REALS(ls)))
      enddo
   endif
   mk = max(mk,m)
   if (m2 .ge. 0) then
      do i = 1, mn2
         ls = l2+i-1
         nk = max(nk,int(GM_REALS(ls)))
         ll = min(ll,int(GM_REALS(ls)))
      enddo
   endif
   nk = max(nk,n)
   if (ll .lt. 1) then
      call mat_err(21) ! Subscript out of range
      return
   endif
   mnk = mk*nk
   lk = G_STACK_ID_LOC(k+1) - mnk
   if(too_much_memory( lt + mt*nt - lk) )return
   G_STACK_ID_LOC(k) = lk
   G_STACK_ROWS(k) = mk
   G_STACK_COLS(k) = nk
   call mat_wset(mnk,0.0d0,0.0d0,GM_REALS(lk),GM_IMAGS(lk),1)
   if (nt .ge. 1) then
      do j = 1, nt
         ls = lt+(j-1)*mt
         ll = lk+(j-1)*mk
         call mat_wcopy(mt,GM_REALS(ls),GM_IMAGS(ls),-1,GM_REALS(ll),GM_IMAGS(ll),-1)
      enddo
   endif
   do j = 1, n
      do i = 1, m
         li = l1+i-1
         if (m1 .gt. 0) li = l1 + int(GM_REALS(li)) - 1
         lj = l2+j-1
         if (m2 .gt. 0) lj = l2 + int(GM_REALS(lj)) - 1
         ll = lk+li-l1+(lj-l2)*mk
         ls = location+i-1+(j-1)*m
         GM_REALS(ll) = GM_REALS(ls)
         GM_IMAGS(ll) = GM_IMAGS(ls)
      enddo
   enddo
   goto 90
90 continue
   if (G_SYM.ne.semi .and. G_LINECOUNT(3).eq.0) call mat_print(id,k) ! if not a semi-colon and "semi" mode print
   if (G_SYM.eq.semi .and. G_LINECOUNT(3).eq.1) call mat_print(id,k) ! if a semi-colon and "semi" mode off print
   if (k .eq. G_TOP_OF_SAVED-1) G_TOP_OF_SAVED = G_TOP_OF_SAVED-1
99 continue
   if (m .eq. 0) then
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1
   else
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1 - G_RHS
   endif
end subroutine MAT_STACK_PUT
SUBROUTINE mat_parse()
integer            :: id(GG_MAX_NAME_LENGTH)
integer            :: excnt
integer            :: pts
integer,parameter  :: ans(GG_MAX_NAME_LENGTH)  = [iachar(['a','n','s',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: ennd(GG_MAX_NAME_LENGTH) = [iachar(['e','n','d',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: else(GG_MAX_NAME_LENGTH) = [iachar(['e','l','s','e',' ',' ',' ']),GG_PAD(8:)]
integer            :: p
integer            :: r
integer            :: i5
integer            :: ierr
integer            :: ilen
integer            :: j
integer            :: k
integer            :: location
integer            :: ls
integer            :: n
character(len=:),allocatable :: symbol
   01 continue
      r = 0
      if (G_ERR .gt. 0) G_PTZ = 0
      if (G_ERR.le.0 .and. G_PT.gt.G_PTZ) r = G_RSTK(G_PT)
      if (r.eq.15) goto 93
      if (r.eq.16 .or. r.eq.17) goto 94
      G_SYM = GG_EOL
      G_BOTTOM_OF_SCRATCH_IN_USE = 0
      if (G_RIO .ne. G_INPUT_LUN) call mat_files(-G_RIO,G_BUF)
      G_RIO = G_INPUT_LUN
      G_LINECOUNT(3) = 0
      G_LINECOUNT(4) = 2
      G_LINE_POINTER(1) = 1
   10 continue  ! get a new line if the current line has ended
      if (G_SYM.eq.GG_EOL.and.mod(G_LINECOUNT(4)/2,2).eq.1) call mat_prompt(G_LINECOUNT(4)/4)
      if (G_SYM .eq. GG_EOL) call mat_getlin()
      G_ERR = 0
      G_PT = G_PTZ
   15 continue   ! (continue) processing current line
      excnt = 0
      G_LHS = 1
      call mat_copyid(id,ans) ! copy ans to id
      call mat_getsym()
      if (G_SYM .eq. colon) then
         call mat_getsym()
      endif
      if (G_SYM.eq.SEMI .or. G_SYM.eq.COMMA .or. G_SYM.eq.GG_EOL) goto 80
      if (G_SYM .eq. isname) then
         call ints2str(G_SYN,symbol,ierr)              ! convert ID to a character variable
         call mat_comand(symbol)
         IF (G_ERR .GT. 0) goto 01
         IF (G_FUN .EQ. 99) goto 95
         IF (G_FIN .EQ. -15) goto 80
         IF (G_FIN .LT. 0) goto 91
         IF (G_FIN .GT. 0) goto 70
         G_RHS = 0
         call mat_funs(G_SYN)
         IF (G_FIN .NE. 0)then
            goto 50
         endif
         IF (G_CHRA.EQ.SEMI .OR. G_CHRA.EQ.COMMA .OR. G_CHRA.EQ.GG_EOL) call mat_copyid(ID,G_SYN)
         IF (G_CHRA .EQ. EQUAL) then
            call mat_copyid(ID,G_SYN)
            call mat_getsym()
            call mat_getsym()
            goto 50
         endif
         IF (G_CHRA .EQ. LPAREN) then
            G_LINE_POINTER(5) = G_LINE_POINTER(4)
            call mat_copyid(ID,G_SYN)
            call mat_getsym()
            goto 32
         endif
         goto 50
      endif
      if (G_SYM .eq. less) goto 40
      if (G_SYM .eq. great) goto 45
      goto 50
   32 continue
      call mat_getsym()
      excnt = excnt+1
      G_PT = G_PT+1
      call mat_copyid(G_IDS(1,G_PT), id)
      G_PSTK(G_PT) = excnt
      G_RSTK(G_PT) = 1
      goto 92
   35 continue
      call mat_copyid(id,G_IDS(1,G_PT))
      excnt = G_PSTK(G_PT)
      G_PT = G_PT-1
      if (G_SYM .eq. comma) goto 32
      if (G_SYM .ne. rparen) then
         call mat_err(3)
         goto 01
         return  ! ???? cannot unconditionally goto and return
      endif
      if (G_SYM .eq. rparen) call mat_getsym()
      if (G_SYM .eq. equal) goto 50
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - excnt
      G_LINE_POINTER(4) = G_LINE_POINTER(5)
      G_CHRA = lparen
      G_SYM = isname
      call mat_copyid(G_SYN,id)
      call mat_copyid(id,ans)
      excnt = 0
      goto 50
   40 continue
      G_LINE_POINTER(5) = G_LINE_POINTER(4)
      pts = G_PT
      call mat_getsym()
   41 continue
      if (G_SYM .ne. isname)then
         goto 43
      endif
      call mat_copyid(id,G_SYN)
      call mat_getsym()
      if (G_SYM .eq. great)then
         call mat_getsym()
         if (G_SYM .eq. equal) goto 50
         goto 43
      endif
      if (G_SYM .eq. comma) call mat_getsym()
      G_PT = G_PT+1
      G_LHS = G_LHS+1
      G_PSTK(G_PT) = 0
      call mat_copyid(G_IDS(1,G_PT),id)
      goto 41
   43 continue
      G_LINE_POINTER(4) = G_LINE_POINTER(5)
      G_PT = pts
      G_LHS = 1
      G_SYM = less
      G_CHRA = G_LIN(G_LINE_POINTER(4)-1)
      call mat_copyid(id,ans)
      goto 50
   45 continue
      call mat_getsym()
      if (G_SYM.eq.less .and. G_CHRA.eq.GG_EOL) then
         call mat_err(28) ! Empty macro
         goto 01
      endif
      G_PT = G_PT+1
      G_RSTK(G_PT) = 20
      goto 92
   46 continue
      G_PT = G_PT-1
      if (G_SYM.ne.less .and. G_SYM.ne.GG_EOL) then
         call mat_err(37) ! Improper MACROS
         goto 01
      endif
      if (G_SYM .eq. less) call mat_getsym()
      k = G_LINE_POINTER(6)
      G_LIN(k+1) = G_LINE_POINTER(1)
      G_LIN(k+2) = G_LINE_POINTER(2)
      G_LIN(k+3) = G_LINE_POINTER(6)
      G_LINE_POINTER(1) = k + 4
      k = G_LINE_POINTER(1)
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      n = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      do j = 1, n
         ls = location + j-1
         G_LIN(k) = int(GM_REALS(ls))
         if (G_LIN(k).lt.0 .or. G_LIN(k).ge.G_CHARSET_SIZE) then
            call mat_err(37) ! improper MACROS
            return
         endif
         if (k.lt.1024) k = k+1
         if (k.eq.1024) then
            call journal('sc',' input buffer limit is',k,'characters')
          endif
      enddo
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
      G_LIN(K) = GG_EOL; G_LIN(K+1:)=blank
      G_LINE_POINTER(6) = k
      G_LINE_POINTER(4) = G_LINE_POINTER(1)
      G_LINE_POINTER(3) = 0
      G_LINE_POINTER(2) = 0
      G_LINECOUNT(1) = 0
      G_CHRA = blank
      G_PT = G_PT+1
      G_PSTK(G_PT) = G_LINE_POINTER(1)
      G_RSTK(G_PT) = 21
      goto 15
   49 continue
      G_PT = G_PT-1
      k = G_LINE_POINTER(1) - 4
      G_LINE_POINTER(1) = G_LIN(K+1)
      G_LINE_POINTER(4) = G_LIN(K+2)
      G_LINE_POINTER(6) = G_LIN(K+3)
      G_CHRA = BLANK
      call mat_getsym()
      goto 80
   50 continue
      if (G_SYM .eq. equal) call mat_getsym()
      G_PT = G_PT+1
      call mat_copyid(G_IDS(1,G_PT),id)
      G_PSTK(G_PT) = excnt
      G_RSTK(G_PT) = 2
      goto 92
   60 continue
      G_RHS = G_PSTK(G_PT)
      call MAT_STACK_PUT(G_IDS(1,G_PT))
      if (G_ERR .gt. 0) goto 01
      G_PT = G_PT-1
      G_LHS = G_LHS-1
      if (G_LHS .gt. 0) goto 60
      goto 70
   70 continue
      k = G_FLOP_COUNTER(1)
      if (K .ne. 0) GM_REALS(GM_BIGMEM-3) = dble(k)
      GM_REALS(GM_BIGMEM-2) = GM_REALS(GM_BIGMEM-2) + dble(K)
      G_FLOP_COUNTER(1) = 0
      if (.not.(G_CHRA.eq.comma .or. (G_SYM.eq.comma .and. G_CHRA.eq.GG_EOL)))goto 80
      call mat_getsym()
      i5 = 10**5
      if (k .eq. 0) then
         call journal('   no flops')
      elseif (k .EQ. 1) then
         call journal('    1 flop')
      else
         call journal('sc','',k,' flops')
      endif
      goto 80
   80 continue
      G_FIN = 0
      p = 0
      r = 0
      if (G_PT .gt. 0) p = G_PSTK(G_PT)
      if (G_PT .gt. 0) r = G_RSTK(G_PT)
      if (G_SYM.eq.comma .or. G_SYM.eq.semi) goto 15
      if (r.eq.21 .and. p.eq.G_LINE_POINTER(1)) goto 49
      if (G_PT .gt. G_PTZ) goto 91
      goto 10
   91 continue
      call mat_clause()
      if (G_ERR .gt. 0) goto 01
      if (G_PT .le. G_PTZ) goto 15
      r = G_RSTK(G_PT)
      select case(R)
      case(3:5);   goto 92
      case(13:14); goto 15
      case(21);    goto 49
      case default
         write(*,*)'INTERNAL ERROR 91'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
   92 CONTINUE
      call mat_expr()
      if (G_ERR .gt. 0) goto 01
      r = G_RSTK(G_PT)
      select case(r)
      case(1);     goto 35
      case(2)
         if (G_SYM.eq.semi .or. G_SYM.eq.comma .or. G_SYM.eq.GG_EOL) goto 60
         if (G_SYM.eq.isname .and. mat_eqid(G_SYN,else)) goto 60
         if (G_SYM.eq.isname .and. mat_eqid(G_SYN,ennd)) goto 60
         call mat_err(40)
         if (G_ERR .gt. 0) goto 01
         goto 60
      case(3:5);   goto 91
      case(6:7);   goto 93
      case(10:11); goto 94
      case(18:19); goto 94
      case(20);    goto 46
      case default
         write(*,*)'Internal error 92'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
   93 continue
      call mat_term()
      if (G_ERR .gt. 0) goto 01
      r = G_RSTK(G_PT)
      select case(R)
      case(6:7);   goto 92
      case(8:9);   goto 94
      case(15);    goto 95
      case default
         write(*,*)'INTERNAL ERROR 93'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
   94 continue
      call mat_factor()
      if (G_ERR .gt. 0) goto 01
      r = G_RSTK(G_PT)
      select case(R)
      case(8:9);   goto 93
      case(10:11); goto 92
      case(12);    goto 94
      case(16:17); goto 95
      case(18:19); goto 92
      case default
         write(*,*)'INTERNAL ERROR 94'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
   95 continue
      if(G_BOTTOM_OF_SCRATCH_IN_USE.lt.1)then
      else
         if (G_FIN.gt.0 .and. G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE).lt.0) call mat_err(14)
      endif
      if (G_ERR .gt. 0) goto 01
      return
end subroutine mat_parse
subroutine mat_comand(id)
character(len=*),intent(in)  :: id
integer                      :: chr
integer                      :: i, j, k, ii, jj
integer                      :: l
integer                      :: ierr
character(len=10),parameter :: cmd(*)=[ character(len=10) :: &
 & 'clear', 'else',  'end',      'exit',  'for',  &
 & 'help',  'if',    'long',     'quit',  'semi', &
 & 'short', 'what',  'while',    'who',   'sh',   &
 & 'laff',  'shell', 'continue', 'return'         &
 & ]
FINISHED: block
   G_FUN = 0
   do k = size(cmd),0,-1
     if(k.eq.0)then                          ! did not match anything
        G_FIN = 0
        return
     elseif (id.eq.cmd(k))then               ! found match to command
        select case(G_CHRA)                  ! check next character
        case(comma,semi,GG_EOL)               ! next character is end of a command so good to go
           exit
        case(iachar('0'):iachar('9'),iachar('a'):iachar('z'),iachar('A'):iachar('Z'),score) ! alphanumeric or a HELP command so good to go
           exit
        end select
        if (id.eq.'help')then                ! special case where anything after the help could be a topic
           exit
        else
           call mat_err(16)                  ! improper command
           return
        endif
     endif
   enddo
   G_FIN = 1                                 ! found a match and next character passed tests
   COMAND : select case(id)
   case('clear')
      if(verify(achar(G_CHRA),big//little//digit)==0)then ! is alphanumeric so good to go by name
         call mat_getsym()
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
         G_RHS = 0
         call mat_stack_put(G_SYN)
         if (G_ERR .gt. 0) return
         G_FIN = 1
      else
         G_TOP_OF_SAVED = GG_MAX_NUMBER_OF_NAMES-3
      endif
   case('for')
      G_FIN = -11
      exit FINISHED
   case('while')
      G_FIN = -12
      exit FINISHED
   case('if')
      G_FIN = -13
      exit FINISHED
   case('else')
      G_FIN = -14
      exit FINISHED
   case('end')
      G_FIN = -15
      exit FINISHED
   case('exit')
      IF (G_PT .GT. G_PTZ)then
         G_FIN = -16
         exit COMAND
      endif
      K = int(GM_REALS(GM_BIGMEM-2))
      call journal('sc',' total flops ',k)
      select case( int(mat_urand(G_CURRENT_RANDOM_SEED)*9) )    ! for serendipity's sake randomly pick a sign-off
      case(1); call journal(' adios')
      case(2); call journal(' adieu')
      case(3); call journal(' arrivederci')
      case(4); call journal(' au revior')
      case(5); call journal(' so long')
      case(6); call journal(' sayonara')
      case(7); call journal(' auf wiedersehen')
      case default
         call journal(' cheerio')
      end select
      G_FUN = 99
   case('quit','return')
      K = G_LINE_POINTER(1) - 7
      IF (K .LE. 0)then
         G_FUN = 99
         exit COMAND
      endif
      call mat_files(-G_RIO,G_BUF)
      G_LINE_POINTER(1) = G_LIN(K+1)
      G_LINE_POINTER(4) = G_LIN(K+2)
      G_LINE_POINTER(6) = G_LIN(K+3)
      G_PTZ = G_LIN(K+4)
      G_RIO = G_LIN(K+5)
      G_LINECOUNT(4) = G_LIN(K+6)
      G_CHRA = BLANK
      G_SYM = COMMA
      exit FINISHED
   case('continue')
      G_FUN = 99
      exit FINISHED
   case('laff')
      call journal('QUIT SINGING AND GET BACK TO WORK.')
   case('shell')
      call journal(' Your place or mine?')
   case('short','long')
      if(k.eq.11)then
         G_FMT = 1
      else
         G_FMT = 2
      endif
      if (G_CHRA.eq.e_low .or. G_CHRA.eq.d_low .or. G_CHRA.eq.e_up .or. chr.eq.d_up ) G_FMT = G_FMT+2
      if (G_CHRA .eq. z_low) G_FMT = 5
      if (G_CHRA.eq.e_low .or. G_CHRA.eq.d_low .or. G_CHRA.eq.z_low) call mat_getsym()
      if (G_CHRA.eq.e_UP .or. G_CHRA.eq.d_up .or. G_CHRA.eq.z_up ) call mat_getsym()
   case('semi')
      G_LINECOUNT(3) = 1 - G_LINECOUNT(3)  ! toggle "semi" mode
   case('who')
      call journal(' Your current variables are...')
      call mat_print_id(G_STACK_IDS(1,G_TOP_OF_SAVED),GG_MAX_NUMBER_OF_NAMES-G_TOP_OF_SAVED+1)
      l = GM_BIGMEM-G_STACK_ID_LOC(G_TOP_OF_SAVED)+1
      call journal('sc','using',l,'out of',GM_BIGMEM,'elements')
   case('what')
   case('sh')
      call sh_command()
   case('help')
      HELP_ : block
      character(len=GG_LINELEN) :: topic_name
         G_BUF=blank
         if (G_CHRA .eq. GG_EOL) then                                ! if no topic
            topic_name= ' '
         else
            call mat_getsym()                                       ! get next symbol or name
            if (G_SYM .eq. isname)then                              ! use next word on line as topic
                 G_BUF(:GG_MAX_NAME_LENGTH) = G_SYN
            else                                                    ! use next non-blank character as topic
               if (G_SYM .eq. 0) G_SYM = dot
               G_BUF(1)  = G_SYM
               G_BUF(2:) = blank
            endif
            call mat_buf2str(topic_name,G_BUF,len(topic_name))      ! convert ADE array to string
         endif
         call help_command(G_HELP_TEXT,topic_name,merge(G_LINECOUNT(:2),[0,huge(0)],G_PROMPT))
      endblock HELP_
   case default ! did not find a match
      G_FIN = 0
      return
   end select COMAND
   call mat_getsym()
endblock FINISHED
end subroutine mat_comand
subroutine sh_command()
character(len=GG_LINELEN) :: line
integer                   :: istat
   call get_environment_variable('SHELL',line)               ! get command to execute
   IF (G_CHRA .eq. GG_EOL )then                               ! if next character on stack is end-of-line call interactive shell
      call execute_command_line(line,cmdstat=istat)          ! call shell interactively
   else                                                      ! there were characters after SH on the line
      call execute_command_line(line,cmdstat=istat)          ! call shell interactively
   endif
end subroutine sh_command
subroutine mat_plot(lplot,x,y,n,p,k)
integer           :: lplot
integer           :: n
doubleprecision   :: x(n)
doubleprecision   :: y(n)
doubleprecision   :: p(*)
integer           :: k
integer           :: lets(k)
character(len=k)  :: string
doubleprecision   :: xmin,ymin,xmax,ymax,dy,dx,y1,y0
character(len=79) :: pbuf                             ! work space for ascii plot
integer,parameter :: h=20,w=79                        ! h = height, w = width
integer           :: tlun
integer           :: ios
integer           :: ch
integer           :: i
integer           :: j
integer           :: jmax
integer           :: l
   xmin = x(1)
   xmax = x(1)
   ymin = y(1)
   ymax = y(1)
   do i = 1, n
      xmin = dmin1(xmin,x(i))
      xmax = dmax1(xmax,x(i))
      ymin = dmin1(ymin,y(i))
      ymax = dmax1(ymax,y(i))
   enddo
   dx = xmax - xmin
   if (dx .eq. 0.0d0) dx = 1.0d0
   dy = ymax - ymin
   write(lplot,'(80x)')
   do l = 1, h
      pbuf(:)=' '  ! blank out the line
      y1 = ymin + (h-l+1)*dy/h
      y0 = ymin + (h-l)*dy/h
      jmax = 1
      do i = 1, n
         if (y(i) .gt. y1) cycle
         if (l.ne.h .and. y(i).le.y0) cycle
         j = 1 + (w-1)*(x(i) - xmin)/dx
         pbuf(j:j) = '*'
         jmax = max(jmax,j)
      enddo
      write(lplot,'(1x,a)') pbuf(1:jmax)
   enddo
   open(newunit=tlun,file='xy.dat')
   do i=1,n
      write(tlun,*)x(i),y(i)
   enddo
   flush(tlun)
   string=' '
   lets=0
   do i=1,k
      ch=p(i)
      if ((ch.ge.0) .and. (ch.lt.G_CHARSET_SIZE)) then
         lets(i) = ch
      endif
   enddo
   call mat_buf2str(string,lets,k)
   call journal('sc','xy xy.dat ',trim(string))
   call execute_command_line('xy xy.dat '//trim(string))
   close(unit=tlun,status='delete',iostat=ios)
end subroutine mat_plot
subroutine mat_matfn1()
doubleprecision   :: dtr(2)
doubleprecision   :: dti(2)
doubleprecision   :: sr(1)
doubleprecision   :: si(1)
doubleprecision   :: rcond
doubleprecision   :: t
doubleprecision   :: t0
doubleprecision   :: t1
doubleprecision   :: eps
character(len=80) ::  mline
integer           :: i
integer           :: info
integer           :: j
integer           :: k
integer           :: ka
integer           :: kb
integer           :: location
integer           :: l2
integer           :: l3
integer           :: li
integer           :: lj
integer           :: lk
integer           :: ll
integer           :: ls
integer           :: lu
integer           :: m
integer           :: m2
integer           :: n
integer           :: n2
integer           :: nn
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   M = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   N = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   select case(G_FIN)
    case(-1) ! MATRIX RIGHT DIVISION, A/A2
      l2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      m2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      n2 = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      if (m2 .ne. n2) then
         call mat_err(20)
         return
      endif
      if (m*n .ne. 1) then
         if (n .ne. n2) then
            call mat_err(11)
            return
         endif
         l3 = l2 + m2*n2
         if(too_much_memory( l3+n2 - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
         call ml_wgeco(GM_REALS(l2),GM_IMAGS(l2),m2,n2,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
         if (rcond .eq. 0.0d0) then
            call mat_err(19)
            return
         endif
         t = mat_flop(1.0d0 + rcond)
         if (t.eq.1.0d0 .and. G_FUN.ne.21)then
            call journal('WARNING:')
            call journal('MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.')
            WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
            call journal(mline)
         endif
         if (t.eq.1.0d0 .and. G_FUN.eq.21)then
            call journal('WARNING')
            call journal('EIGENVECTORS ARE BADLY CONDITIONED.')
            WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
            call journal(mline)
         endif
         do i = 1, m
            do j = 1, n
               ls = location+i-1+(j-1)*m
               ll = l3+j-1
               GM_REALS(ll) = GM_REALS(ls)
               GM_IMAGS(ll) = -GM_IMAGS(ls)
            enddo
            call ml_wgesl(GM_REALS(l2),GM_IMAGS(l2),m2,n2,G_BUF,GM_REALS(l3),GM_IMAGS(l3),1)
            do j = 1, n
               ll = location+i-1+(j-1)*m
               ls = l3+j-1
               GM_REALS(ll) = GM_REALS(ls)
               GM_IMAGS(ll) = -GM_IMAGS(ls)
            enddo
         enddo
         if (G_FUN .ne. 21) goto 99
         sr(1) = mat_wasum(n*n,GM_REALS(location),GM_REALS(location),1)
         si(1) = mat_wasum(n*n,GM_IMAGS(location),GM_IMAGS(location),1)
         eps = GM_REALS(GM_BIGMEM-4)
         t = eps*sr(1)
         if (si(1) .le. eps*sr(1)) call mat_rset(n*n,0.0d0,GM_IMAGS(location),1)
         goto 99
      endif
      sr(1) = GM_REALS(location)
      si(1) = GM_IMAGS(location)
      n = n2
      m = n
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      call mat_wcopy(n*n,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
    case(-2) ! MATRIX LEFT DIVISION A BACKSLASH A2
      l2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      m2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      n2 = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      if (m2*n2 .ne. 1) then
         l3 = l2 + m2*n2
         if(too_much_memory( l3+n - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
         call ml_wgeco(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
         if (rcond .eq. 0.0d0) then
            call mat_err(19)
            return
         endif
         t = mat_flop(1.0d0 + rcond)
         if (t .eq. 1.0d0) then
            call journal('WARNING:')
            call journal('MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.')
            WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
            call journal(mline)
         endif
         if (m2 .ne. n) then
            call mat_err(12)
            return
         endif
         do j = 1, n2
            lj = l2+(j-1)*m2
            call ml_wgesl(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,GM_REALS(lj),GM_IMAGS(lj),0)
         enddo
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n2
         call mat_wcopy(m2*n2,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
         goto 99
      endif
      sr(1) = GM_REALS(l2)
      si(1) = GM_IMAGS(l2)
   end select
   select case(G_FIN)
    case(1) ! COMMAND::INV
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      do j = 1, n
         do i = 1, n
            ls = location+i-1+(j-1)*n
            t0 = GM_REALS(ls)
            t1 = mat_flop(1.0d0/(dble(i+j-1)))
            if (t0 .ne. t1) goto 32
         enddo
      enddo
      call mat_inverse_hilbert(GM_REALS(location),n,n)
      call mat_rset(n*n,0.0d0,GM_IMAGS(location),1)
      if (G_FIN .lt. 0) call mat_wscal(n*n,sr(1),si(1),GM_REALS(location),GM_IMAGS(location),1)
      goto 99
32    continue
      l3 = location + n*n
      if(too_much_memory( l3+n - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      call ml_wgeco(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
      if (rcond .eq. 0.0d0) then
         call mat_err(19)
         return
      endif
      t = mat_flop(1.0d0 + rcond)
      if (t .eq. 1.0d0) then
         call journal('warning:')
         call journal('matrix is close to singular or badly scaled.')
         write(mline,'(''results may be inaccurate. rcond='',1pd13.4)') rcond
         call journal(mline)
      endif
      call ml_wgedi(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,dtr,dti,GM_REALS(l3),GM_IMAGS(l3),1)
      if (G_FIN .lt. 0) call mat_wscal(n*n,sr(1),si(1),GM_REALS(location),GM_IMAGS(location),1)
    case (2) ! COMMAND::DET
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      call ml_wgefa(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,info)
      call ml_wgedi(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,dtr,dti,sr(1),si(1),10)
      k = int(dtr(2))
      ka = iabs(k)+2
      t = 1.0d0
      do i = 1, ka
         t = t/10.0d0
         if (t .ne. 0.0d0) goto 42
      enddo
      GM_REALS(location) = dtr(1)*10.d0**k
      GM_IMAGS(location) = dti(1)*10.d0**k
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      goto 99
42    continue
      if (dti(1) .eq. 0.0d0)then
         write(mline,43) dtr(1),k
         call journal(mline)
      else
         write(mline,44) dtr(1),dti(1),k
         call journal(mline)
      endif
      GM_REALS(location) = dtr(1)
      GM_IMAGS(location) = dti(1)
      GM_REALS(location+1) = dtr(2)
      GM_IMAGS(location+1) = 0.0d0
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 2
43    format(' det =  ',f7.4,7h * 10**,i4)
44    format(' det =  ',f7.4,' + ',f7.4,' i ',7h * 10**,i4)
    case(3) ! COMMAND::RCOND
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      l3 = location + n*n
      if(too_much_memory( l3+n - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      call ml_wgeco(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
      GM_REALS(location) = rcond
      GM_IMAGS(location) = 0.0d0
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      if (G_lhs .ne. 1)then
         location = location + 1
         call mat_wcopy(n,GM_REALS(l3),GM_IMAGS(l3),1,GM_REALS(location),GM_IMAGS(location),1)
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
         G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      endif
    case(4) ! COMMAND::LU
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      call ml_wgefa(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,info)
      if (G_lhs .ne. 2) goto 99
      nn = n*n
      if (G_BOTTOM_OF_SCRATCH_IN_USE+1 .ge. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
      G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location + nn
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      if(too_much_memory( location+nn+nn - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      do kb = 1, n
         k = n+1-kb
         do i = 1, n
            ll = location+i-1+(k-1)*n
            lu = ll + nn
            if (i .le. k) GM_REALS(lu) = GM_REALS(ll)
            if (i .le. k) GM_IMAGS(lu) = GM_IMAGS(ll)
            if (i .gt. k) GM_REALS(lu) = 0.0d0
            if (i .gt. k) GM_IMAGS(lu) = 0.0d0
            if (i .lt. k) GM_REALS(ll) = 0.0d0
            if (i .lt. k) GM_IMAGS(ll) = 0.0d0
            if (i .eq. k) GM_REALS(ll) = 1.0d0
            if (i .eq. k) GM_IMAGS(ll) = 0.0d0
            if (i .gt. k) GM_REALS(ll) = -GM_REALS(ll)
            if (i .gt. k) GM_IMAGS(ll) = -GM_IMAGS(ll)
         enddo
         i = G_BUF(k)
         if (i .eq. k) cycle
         li = location+i-1+(k-1)*n
         lk = location+k-1+(k-1)*n
         call mat_wswap(n-k+1,GM_REALS(li),GM_IMAGS(li),n,GM_REALS(lk),GM_IMAGS(lk),n)
      enddo
    case(5) ! COMMAND::inverse_hilbert
      n = int(GM_REALS(location))
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      call mat_inverse_hilbert(GM_REALS(location),n,n)
      call mat_rset(n*n,0.0d0,GM_IMAGS(location),1)
      if (G_FIN .lt. 0) call mat_wscal(n*n,sr(1),si(1),GM_REALS(location),GM_IMAGS(location),1)
    case(6) ! COMMAND::CHOLESKY
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      call mat_wpofa(GM_REALS(location),GM_IMAGS(location),m,n,G_err)
      if (G_err .ne. 0) then
         call mat_err(29)
         return
      endif
      do j = 1, n
         ll = location+j+(j-1)*m
         call mat_wset(m-j,0.0d0,0.0d0,GM_REALS(ll),GM_IMAGS(ll),1)
      enddo
    case(7) ! COMMAND::RREF
      if (G_RHS .ge. 2)then
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .ne. m) then
            call mat_err(5)
            return
         endif
         n = n + G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      endif
      call mat_rref(GM_REALS(location),GM_IMAGS(location),m,m,n,GM_REALS(GM_BIGMEM-4))
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
   end select
99 continue
end subroutine mat_matfn1
subroutine mat_matfn2()
integer          :: i
integer          :: inc
integer          :: j
integer          :: job
integer          :: k
integer          :: location
integer          :: l1
integer          :: l2
integer          :: ld
integer          :: le
integer          :: lj
integer          :: ll
integer          :: ls
integer          :: lw
integer          :: m
integer          :: n
integer          :: nn
      doubleprecision tr(1),ti(1),sr,si,powr,powi
      logical herm,schur,vect,hess
      if (G_FIN .ne. 0) goto 05
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
         powr = GM_REALS(location)
         powi = GM_IMAGS(location)
   05 continue
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
      n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      if (G_FIN .ge. 11 .and. G_FIN .le. 13) goto 10
      if (G_FIN .eq. 14 .and. (m.eq.1 .or. n.eq.1))then
         goto 50
      endif
      if (G_FIN .eq. 14) goto 10
      if (G_FIN .eq. 15) goto 60
      if (G_FIN .gt. 20) goto 40
      if (m .eq. 1 .or. n .eq. 1) goto 40
   10 continue
      IF (M .NE. N) then
         call mat_err(20)
         return
      endif
      SCHUR = G_FIN .EQ. 12
      HESS = G_FIN .EQ. 13
      VECT = G_LHS.EQ.2 .OR. G_FIN.LT.10
      NN = N*N
      L2 = location + NN
      LD = L2 + NN
      LE = LD + N
      LW = LE + N
      if(too_much_memory( LW+N - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      call mat_wcopy(NN,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(L2),GM_IMAGS(L2),1)
      HERM=.FALSE.
      DO J = 1, N
         DO I = 1, J
            LS = location+I-1+(J-1)*N
            LL = location+(I-1)*N+J-1
            HERM = GM_REALS(LL).EQ.GM_REALS(LS) .AND. GM_IMAGS(LL).EQ.-GM_IMAGS(LS)
            IF (.NOT. HERM) goto 30
         enddo
      enddo
      call mat_wset(NN,0.0D0,0.0D0,GM_REALS(location),GM_IMAGS(location),1)
      call mat_wset(N,1.0D0,0.0D0,GM_REALS(location),GM_IMAGS(location),N+1)
      call mat_wset(N,0.0D0,0.0D0,GM_IMAGS(LD),GM_IMAGS(LE),1)
      job = 0
      IF (VECT) JOB = 1
      call ML_HTRIDI(N,N, &
      GM_REALS(L2),GM_IMAGS(L2), &
      GM_REALS(LD),GM_REALS(LE), &
      GM_REALS(LE),GM_REALS(LW))
      IF(.NOT.HESS)call ML_IMTQL2(N,N,GM_REALS(LD),GM_REALS(LE),GM_REALS(location),G_ERR,JOB)
      IF (G_ERR .GT. 0) then
         call mat_err(24)
         return
      endif
      IF (JOB .NE. 0) call ML_HTRIBK(N,N,GM_REALS(L2),GM_IMAGS(L2), &
                                         GM_REALS(LW),N,GM_REALS(location), &
                                         GM_IMAGS(location))
      goto 31
   30 continue
      call ML_CORTH(N,N,1,N,GM_REALS(L2),GM_IMAGS(L2), &
                            GM_REALS(LW),GM_IMAGS(LW))
      IF (.NOT.VECT .AND. HESS) goto 31
      JOB = 0
      IF (VECT) JOB = 2
      IF (VECT .AND. SCHUR) JOB = 1
      IF (HESS) JOB = 3
      call ML_COMQR3(N,N,1,N,GM_REALS(LW),GM_IMAGS(LW), &
                             GM_REALS(L2),GM_IMAGS(L2),  &
                             GM_REALS(LD),GM_IMAGS(LD), &
                             GM_REALS(location),GM_IMAGS(location), &
                             G_ERR,JOB)
      IF (G_ERR .GT. 0) then
         call mat_err(24)
         return
      endif
   31 continue
      IF (.NOT.VECT) goto 34
      IF (G_BOTTOM_OF_SCRATCH_IN_USE+1 .GE. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
      G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = L2
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
   34 continue
      IF (.NOT.VECT .AND. .NOT.SCHUR .AND. .NOT.HESS) goto 37
      DO J = 1, N
         LJ = L2+(J-1)*N
         IF (SCHUR .AND. (.NOT.HERM)) LJ = LJ+J
         IF (HESS .AND. (.NOT.HERM)) LJ = LJ+J+1
         LL = L2+J*N-LJ
         call mat_wset(LL,0.0D0,0.0D0,GM_REALS(LJ),GM_IMAGS(LJ),1)
      enddo
      IF (.NOT.HESS .OR. HERM) call mat_wcopy(N,GM_REALS(LD),GM_IMAGS(LD),1,GM_REALS(L2),GM_IMAGS(L2),N+1)
      LL = L2+1
      IF (HESS .AND. HERM)call mat_wcopy(N-1,GM_REALS(LE+1),GM_IMAGS(LE+1),1,GM_REALS(LL),GM_IMAGS(LL),N+1)
      LL = L2+N
      IF (HESS .AND. HERM)call mat_wcopy(N-1,GM_REALS(LE+1),GM_IMAGS(LE+1),1,GM_REALS(LL),GM_IMAGS(LL),N+1)
      IF (G_FIN .LT. 10) goto 42
      IF (VECT .OR. .NOT.(SCHUR.OR.HESS)) goto 99
      call mat_wcopy(NN,GM_REALS(L2),GM_IMAGS(L2),1,GM_REALS(location),GM_IMAGS(location),1)
      goto 99
   37 continue
      IF (G_FIN .EQ. 14) goto 52
      call mat_wcopy(N,GM_REALS(LD),GM_IMAGS(LD),1,GM_REALS(location),GM_IMAGS(location),1)
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      goto 99
   40 continue
      INC = 1
      N = M*N
      L2 = location
      goto 44
   42 continue
      INC = N+1
   44 continue
      DO J = 1, N
        LS = L2+(J-1)*INC
        SR = GM_REALS(LS)
        SI = GM_IMAGS(LS)
        TI = 0.0D0
        IF (G_FIN .eq. 0) then
          call mat_wlog(SR,SI,SR,SI)
          call mat_wmul(SR,SI,POWR,POWI,SR,SI)
          TR(1) = DEXP(SR)*DCOS(SI)
          TI(1) = DEXP(SR)*DSIN(SI)
        endif
        select case(G_FIN)
        CASE( 1)
                 TR(1) = DSIN(SR)*DCOSH(SI)
                 TI(1) = DCOS(SR)*DSINH(SI)
        CASE( 2)
                 TR(1) = DCOS(SR)*DCOSH(SI)
                 TI(1) = (-DSIN(SR))*DSINH(SI)
        CASE( 3)
                 call mat_watan(SR,SI,TR(1),TI(1))
        CASE( 4)
                 TR(1) = DEXP(SR)*DCOS(SI)
                 TI(1) = DEXP(SR)*DSIN(SI)
        CASE( 5)
                 call mat_wsqrt(SR,SI,TR(1),TI(1))
        CASE( 6)
                 call mat_wlog(SR,SI,TR(1),TI(1))
        CASE( 21)
                 TR(1) = mat_pythag(SR,SI)
        CASE( 22)
                 TR(1) = mat_round(SR)
        CASE( 23)
                 TR(1) = SR
        CASE( 24)
                 TR(1) = SI
        CASE( 25)
                 TR(1) = SR
                 TI(1) = -SI
        end select
        IF (G_ERR .GT. 0) return
        GM_REALS(LS) = mat_flop(TR(1))
        GM_IMAGS(LS) = 0.0D0
        IF (TI(1) .NE. 0.0D0) GM_IMAGS(LS) = mat_flop(TI(1))
      enddo
      IF (INC .EQ. 1) goto 99
      DO J = 1, N
        LS = L2+(J-1)*INC
        SR = GM_REALS(LS)
        SI = GM_IMAGS(LS)
        LS = location+(J-1)*N
        LL = L2+(J-1)*N
        call mat_wcopy(N,GM_REALS(LS),GM_IMAGS(LS),1,GM_REALS(LL),GM_IMAGS(LL),1)
        call mat_wscal(N,SR,SI,GM_REALS(LS),GM_IMAGS(LS),1)
      enddo
      G_FUN = 21
      G_FIN = -1
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
      goto 99
   50 continue
      N = MAX(M,N)
      LD = location+N+1
      call mat_wcopy(N,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(LD),GM_IMAGS(LD),1)
      goto 52
   52 continue
      call mat_wset(N+1,0.0D0,0.0D0,GM_REALS(location),GM_IMAGS(location),1)
      GM_REALS(location) = 1.0D0
      DO J = 1, N
         call matX_waxpy(J,-GM_REALS(LD),-GM_IMAGS(LD), &
                            GM_REALS(location),GM_IMAGS(location), &
                            -1,  &
                            GM_REALS(location+1),GM_IMAGS(location+1), &
                            -1)
         LD = LD+1
      enddo
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = N+1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      goto 99
   60 continue
      LL = location+M*N
      GM_REALS(LL) = -1.0D0
      GM_IMAGS(LL) = 0.0D0
      K = -1
   61 continue
      K = K+1
      L1 = location+K
      IF (DABS(GM_REALS(L1))+DABS(GM_IMAGS(L1)) .EQ. 0.0D0) goto 61
      N = MAX(M*N - K-1, 0)
      IF (N .LE. 0) goto 65
      L2 = L1+N+1
      LW = L2+N*N
      if(too_much_memory( LW+N - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      call mat_wset(N*N+N,0.0D0,0.0D0,GM_REALS(L2),GM_IMAGS(L2),1)
      DO J = 1, N
         LL = L2+J+(J-1)*N
         GM_REALS(LL) = 1.0D0
         LS = L1+J
         LL = L2+(J-1)*N
         call mat_wdiv(-GM_REALS(LS),-GM_IMAGS(LS), &
                        GM_REALS(L1),GM_IMAGS(L1),  &
                        GM_REALS(LL),GM_IMAGS(LL))
         IF (G_ERR .GT. 0) return
      enddo
      call ML_COMQR3(N,N,1,N,GM_REALS(LW),GM_IMAGS(LW), &
                             GM_REALS(L2),GM_IMAGS(L2), &
                             GM_REALS(location),GM_IMAGS(location), &
                             TR,TI,G_ERR,0)
      IF (G_ERR .GT. 0) then
         call mat_err(24)
         return
      endif
   65 continue
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      goto 99
   99 continue
end subroutine mat_matfn2
subroutine mat_matfn3()
integer         :: i
integer         :: j
integer         :: jb
integer         :: job
integer         :: k
integer         :: location
integer         :: l1
integer         :: l2
integer         :: ld
integer         :: li
integer         :: lj
integer         :: ll
integer         :: ls
integer         :: lu
integer         :: lv
integer         :: m
integer         :: mn
integer         :: n
logical         :: fro,inf
doubleprecision :: p,s,t(1,1),tol,eps
   if (G_FIN.eq.1 .and. G_RHS.eq.2) G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   mn = m*n
   FUN3: select case(G_FIN)
    case(3) ! COMMAND::COND
      ld = location + m*n
      l1 = ld + min(m+1,n)
      l2 = l1 + n
      if(too_much_memory( l2+min(m,n) - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      call ml_wsvdc(GM_REALS(location),GM_IMAGS(location),   &
                  & m,m,n,                               &
                  & GM_REALS(ld),GM_IMAGS(ld), &
                  & GM_REALS(l1),GM_IMAGS(l1), &
                  & t,t,1,t,t,1,                         &
                  & GM_REALS(l2),GM_IMAGS(l2), &
                  & 0,G_err)
      if (G_err .ne. 0) then
         call mat_err(24)
         return
      endif
      s = GM_REALS(ld)
      ld = ld + min(m,n) - 1
      t(1,1) = GM_REALS(ld)
      if (t(1,1) .ne. 0.0d0) then
         GM_REALS(location) = mat_flop(s/t(1,1))
         GM_IMAGS(location) = 0.0d0
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      else
         call journal(' CONDITION IS INFINITE')
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      endif
    case(4) ! command::norm
      p = 2.0d0
      inf = .false.
      if (G_RHS .eq. 2)then
         fro = int(GM_REALS(location)).eq.iachar('f') .and. mn.gt.1
         inf = int(GM_REALS(location)).eq.iachar('i') .and. mn.gt.1
         if (.not. fro) then
            p = GM_REALS(location)
         endif
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
         n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
         mn = m*n
         if (fro) then
            m = mn
            n = 1
         endif
      endif
      if (m .gt. 1 .and. n .gt. 1) then
         if (inf)then
            s = 0.0d0
            do i = 1, m
               li = location+i-1
               t(1,1) = mat_wasum(n,GM_REALS(LI),GM_IMAGS(li),m)
               s = dmax1(s,t(1,1))
            enddo
         elseif (p .eq. 1.0d0) then
            s = 0.0d0
            do j = 1, n
               lj = location+(j-1)*m
               t(1,1) = mat_wasum(m,GM_REALS(LJ),GM_IMAGS(lj),1)
               s = dmax1(s,t(1,1))
            enddo
         elseif (p .ne. 2.0d0) then
            call mat_err(23) ! Only 1, 2 or INF norm of matrix
            return
         else
            ld = location + m*n
            l1 = ld + min(m+1,n)
            l2 = l1 + n
            if(too_much_memory( l2+min(m,n) - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )then
               return
            endif
            call ml_wsvdc(GM_REALS(location),GM_IMAGS(location), &
                        & m,m,n, &
                        & GM_REALS(ld),GM_IMAGS(ld), &
                        & GM_REALS(l1),GM_IMAGS(l1), &
                        & t,t,1,t,t,1, &
                        & GM_REALS(l2),GM_IMAGS(l2), &
                        & 0,G_err)
            if (G_ERR .ne. 0)then
               call mat_err(24)
               return
            endif
            s = GM_REALS(LD)
         endif
      elseif (p .eq. 1.0d0)then
         s = mat_wasum(MN,GM_REALS(location),GM_IMAGS(location),1)
      elseif (p .eq. 2.0d0) then
         s = mat_wnrm2(MN,GM_REALS(location),GM_IMAGS(location),1)
      else
         i = mat_iwamax(mn,GM_REALS(location),GM_IMAGS(location),1) + location - 1
         s = dabs(GM_REALS(i)) + dabs(GM_IMAGS(i))
         if (.not.(inf .or. s .eq. 0.0d0))then
            t(1,1) = 0.0d0
            do i = 1, mn
               ls = location+i-1
               t(1,1) = mat_flop(t(1,1) + (mat_pythag(GM_REALS(ls),GM_IMAGS(ls))/s)**p)
            enddo
            if (p .ne. 0.0d0) then
               p = 1.0d0/p
            endif
            s = mat_flop(s*t(1,1)**p)
         endif
      endif
      GM_REALS(location) = s
      GM_IMAGS(location) = 0.0d0
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
    case(1) !     COMMAND::SVD
      IF (G_LHS .EQ. 3)then
         K = M
         IF (G_RHS .EQ. 2) K = MIN(M,N)
         LU = location + M*N
         LD = LU + M*K
         LV = LD + K*N
         L1 = LV + N*N
         L2 = L1 + N
         if(too_much_memory( L2+MIN(M,N) - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
         JOB = 11
         IF (G_RHS .EQ. 2) JOB = 21
         call ml_wsvdc(GM_REALS(location),GM_IMAGS(location), &
         & m,m,n, &
         & GM_REALS(ld),GM_IMAGS(ld), &
         & GM_REALS(l1),GM_IMAGS(l1), &
         & GM_REALS(lu),GM_IMAGS(lu), &
         & m, &
         & GM_REALS(lv),GM_IMAGS(lv), &
         & n, &
         & GM_REALS(l2),GM_IMAGS(l2), &
         & job,G_err)
         DO JB = 1, N
            DO I = 1, K
               J = N+1-JB
               LL = LD+I-1+(J-1)*K
               IF (I.NE.J) GM_REALS(LL) = 0.0D0
               GM_IMAGS(LL) = 0.0D0
               LS = LD+I-1
               IF (I.EQ.J) GM_REALS(LL) = GM_REALS(LS)
               LS = L1+I-1
               IF (G_ERR.NE.0 .AND. I.EQ.J-1) GM_REALS(LL) = GM_REALS(LS)
            enddo
         enddo
         IF (G_ERR .NE. 0) call mat_err(24)
         G_ERR = 0
         call mat_wcopy(M*K+K*N+N*N, &
                      & GM_REALS(LU),GM_IMAGS(LU), &
                      & 1, &
                      & GM_REALS(location),GM_IMAGS(location), &
                      & 1)
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = M
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = K
         IF (G_BOTTOM_OF_SCRATCH_IN_USE+1 .GE. G_TOP_OF_SAVED) then
            call mat_err(18)
            return
         endif
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
         G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location + M*K
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = K
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
         IF (G_BOTTOM_OF_SCRATCH_IN_USE+1 .GE. G_TOP_OF_SAVED) then
            call mat_err(18)
            return
         endif
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
         G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location + M*K + K*N
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      else
         LD = location + M*N
         L1 = LD + MIN(M+1,N)
         L2 = L1 + N
         if(too_much_memory( L2+MIN(M,N) - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
         call ml_wsvdc(GM_REALS(location),GM_IMAGS(location),m,m,n, &
         & GM_REALS(ld),GM_IMAGS(ld),GM_REALS(l1),GM_IMAGS(l1), &
         & t,t,1,t,t,1,GM_REALS(l2),GM_IMAGS(l2),0,G_err)
         IF (G_ERR .NE. 0) then
            call mat_err(24)
            return
         endif
         K = MIN(M,N)
         call mat_wcopy(K,GM_REALS(LD),GM_IMAGS(LD),1,GM_REALS(location),GM_IMAGS(location),1)
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = K
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      endif
    case(2,5) ! COMMAND::PINV AND RANK
      TOL = -1.0D0
      IF (G_RHS .EQ. 2) then
         TOL = GM_REALS(location)
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         M = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
         N = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      endif
      LU = location + M*N
      LD = LU + M*M
      IF (G_FIN .EQ. 5) LD = location + M*N
      LV = LD + M*N
      L1 = LV + N*N
      IF (G_FIN .EQ. 5) L1 = LD + N
      L2 = L1 + N
      if(too_much_memory( L2+MIN(M,N) - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      IF (G_FIN .EQ. 2) JOB = 11
      IF (G_FIN .EQ. 5) JOB = 0
      call ML_WSVDC(GM_REALS(location),GM_IMAGS(location),M,M,N, &
                  & GM_REALS(LD),GM_IMAGS(LD), &
                  & GM_REALS(L1),GM_IMAGS(L1), &
                  & GM_REALS(LU),GM_IMAGS(LU), &
                  & M, &
                  & GM_REALS(LV),GM_IMAGS(LV), &
                  & N, &
                  & GM_REALS(L2),GM_IMAGS(L2), &
                  & JOB,G_ERR)
      IF (G_ERR .NE. 0) then
         call mat_err(24)
         return
      endif
      EPS = GM_REALS(GM_BIGMEM-4)
      IF (TOL .LT. 0.0D0) TOL = mat_flop(dble(MAX(M,N))*EPS*GM_REALS(LD))
      MN = MIN(M,N)
      K = 0
      DO J = 1, MN
         LS = LD+J-1
         S = GM_REALS(LS)
         IF (S .LE. TOL) exit
         K = J
         LL = LV+(J-1)*N
         IF (G_FIN .EQ. 2) call mat_wrscal(N,1.0D0/S,GM_REALS(LL),GM_IMAGS(LL),1)
      enddo
      if (G_FIN .ne. 5) then
         do j = 1, m
            do i = 1, n
               ll = location+i-1+(j-1)*n
               l1 = lv+i-1
               l2 = lu+j-1
               GM_REALS(ll) = mat_wdotcr(k,GM_REALS(l2),GM_IMAGS(l2),m,GM_REALS(l1),GM_IMAGS(l1),n)
               GM_IMAGS(ll) = mat_wdotci(k,GM_REALS(l2),GM_IMAGS(l2),m,GM_REALS(l1),GM_IMAGS(l1),n)
            enddo
         enddo
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
      else
         GM_REALS(location) = dble(k)
         GM_IMAGS(location) = 0.0d0
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      endif
   end select FUN3
end subroutine mat_matfn3
SUBROUTINE mat_matfn4()
integer           :: info
integer           :: j
integer           :: jb
integer           :: job
integer           :: k
integer           :: location
integer           :: l2
integer           :: l3
integer           :: l4
integer           :: le
integer           :: ll
integer           :: ls
integer           :: m
integer           :: m2
integer           :: mm
integer           :: mn
integer           :: n
integer           :: n2
character(len=81) :: message
DOUBLEPRECISION   :: T(1),TOL,EPS
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      M = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
      N = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      IF (G_FIN .EQ. -1) then
         goto 10
      elseIF (G_FIN .EQ. -2) then
         goto 20
      else
         goto 40
      endif
   10 continue
      L2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      M2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      N2 = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
      IF (N.GT.1 .AND. N.NE.N2) then
         call mat_err(11)
         return
      endif
      call mat_stack1(QUOTE)
      IF (G_ERR .GT. 0) return
      LL = L2+M2*N2
      call mat_wcopy(M*N,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(LL),GM_IMAGS(LL),1)
      call mat_wcopy(M*N+M2*N2,GM_REALS(L2),GM_IMAGS(L2),1,GM_REALS(location),GM_IMAGS(location),1)
      G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location+M2*N2
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = M
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      call mat_stack1(QUOTE)
      IF (G_ERR .GT. 0) return
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1
      M = N2
      N = M2
      goto 20
   20 continue
      L2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      M2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      N2 = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      IF (M2*N2 .GT. 1) goto 21
        M2 = M
        N2 = M
        if(too_much_memory( L2+M*M - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
        call mat_wset(M*M-1,0.0D0,0.0D0,GM_REALS(L2+1),GM_IMAGS(L2+1),1)
        call mat_wcopy(M,GM_REALS(L2),GM_IMAGS(L2),0,GM_REALS(L2),GM_IMAGS(L2),M+1)
   21 continue
      IF (M2 .NE. M) then
         call mat_err(12)
         return
      endif
      L3 = L2 + MAX(M,N)*N2
      L4 = L3 + N
      if(too_much_memory( L4 + N - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      IF (M .GT. N) goto 23
      DO JB = 1, N2
        J = N+1-JB
        LS = L2 + (J-1)*M
        LL = L2 + (J-1)*N
        call mat_wcopy(M,GM_REALS(LS),GM_IMAGS(LS),-1,GM_REALS(LL),GM_IMAGS(LL),-1)
      enddo
   23 continue
      DO J = 1, N
        G_BUF(J) = 0
      enddo
      call ML_WQRDC(GM_REALS(location),GM_IMAGS(location), &
                  & M,M,N, &
                  & GM_REALS(L4),GM_IMAGS(L4), &
                  & G_BUF, &
                  & GM_REALS(L3),GM_IMAGS(L3), &
                  & 1)
      K = 0
      EPS = GM_REALS(GM_BIGMEM-4)
      T(1) = DABS(GM_REALS(location))+DABS(GM_IMAGS(location))
      TOL = mat_flop(dble(MAX(M,N))*EPS*T(1))
      MN = MIN(M,N)
      DO J = 1, MN
        LS = location+J-1+(J-1)*M
        T(1) = DABS(GM_REALS(LS)) + DABS(GM_IMAGS(LS))
        IF (T(1) .GT. TOL) K = J
      enddo
      IF (K .LT. MN) then
         WRITE(message,'(" RANK DEFICIENT,  RANK =",I4,",  TOL =",1PD13.4)') K,TOL
         call journal(message)
      endif
      MN = MAX(M,N)
      DO J = 1, N2
        LS = L2+(J-1)*MN
        call ML_WQRSL(GM_REALS(location),GM_IMAGS(location), &
                        & M,M,K, &
                        & GM_REALS(L4),GM_IMAGS(L4), &
                        & GM_REALS(LS),GM_IMAGS(LS), &
                        & T,T, &
                        & GM_REALS(LS),GM_IMAGS(LS), &
                        & GM_REALS(LS),GM_IMAGS(LS), &
                        & T,T,T,T,100,INFO)
        LL = LS+K
        call mat_wset(N-K,0.0D0,0.0D0,GM_REALS(LL),GM_IMAGS(LL),1)
      enddo
      DO J = 1, N
        G_BUF(J) = -G_BUF(J)
      enddo
      DO J = 1, N
        IF (G_BUF(J) .GT. 0) cycle
        K = -G_BUF(J)
        G_BUF(J) = K
   33   CONTINUE
          IF (K .EQ. J) cycle
          LS = L2+J-1
          LL = L2+K-1
          call mat_wswap(N2,GM_REALS(LS),GM_IMAGS(LS),MN,GM_REALS(LL),GM_IMAGS(LL),MN)
          G_BUF(K) = -G_BUF(K)
          K = G_BUF(K)
          goto 33
      enddo
      DO J = 1, N2
        LS = L2+(J-1)*MN
        LL = location+(J-1)*N
        call mat_wcopy(N,GM_REALS(LS),GM_IMAGS(LS),1,GM_REALS(LL),GM_IMAGS(LL),1)
      enddo
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N2
      IF (G_FIN .EQ. -1) call mat_stack1(QUOTE)
      IF (G_ERR .GT. 0) return
      goto 99
   40 continue
      mm = max(m,n)
      ls = location + mm*mm
      if (G_LHS.eq.1 .and. G_FIN.eq.1) ls = location
      le = ls + m*n
      l4 = le + mm
      if(too_much_memory( l4+mm - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      if (ls.ne.location) then
         call mat_wcopy(m*n,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(ls),GM_IMAGS(ls),1)
      endif
      job = 1
      if (G_LHS.lt.3) job = 0
      do j = 1, n
        G_BUF(j) = 0
      enddo
      call ml_wqrdc(GM_REALS(ls),GM_IMAGS(ls), &
       & m,m,n, &
       & GM_REALS(l4),GM_IMAGS(l4), &
       & G_BUF, &
       & GM_REALS(le),GM_IMAGS(le), &
       & job)
      if (G_LHS.eq.1 .and. G_FIN.eq.1) goto 99
      call mat_wset(m*m,0.0d0,0.0d0,GM_REALS(location),GM_IMAGS(location),1)
      call mat_wset(m,1.0d0,0.0d0,GM_REALS(location),GM_IMAGS(location),m+1)
      do j = 1, m
        ll = location+(j-1)*m
        call ml_wqrsl(GM_REALS(ls),GM_IMAGS(ls),m,m,n,GM_REALS(l4),GM_IMAGS(l4),   &
     &             GM_REALS(ll),GM_IMAGS(ll),GM_REALS(ll),GM_IMAGS(ll),t,t,        &
     &             t,t,t,t,t,t,10000,info)
      enddo
      if (G_FIN .eq. 2) goto 99
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = M
      do j = 1, n
        ll = ls+j+(j-1)*m
        call mat_wset(m-j,0.0d0,0.0d0,GM_REALS(ll),GM_IMAGS(ll),1)
      enddo
      if (G_BOTTOM_OF_SCRATCH_IN_USE+1 .ge. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
      G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = ls
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      if (G_LHS .eq. 2) goto 99
      call mat_wset(N*N,0.0D0,0.0D0,GM_REALS(le),GM_IMAGS(le),1)
      do j = 1, n
        ll = le+G_BUF(j)-1+(j-1)*n
        GM_REALS(ll) = 1.0d0
      enddo
      if (G_BOTTOM_OF_SCRATCH_IN_USE+1 .ge. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
      G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = le
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      goto 99
   99 continue
END SUBROUTINE mat_matfn4
subroutine mat_matfn5()
character(len=GG_LINELEN)  :: mline
character(len=256)         :: errmsg
character(len=1024)        :: name
character(len=1)           :: ch_char
integer                    :: temp_lun
integer                    :: ios
integer,save               :: flag=0  ! should be saved or set at each call?
integer,save               :: lrat=5
integer,save               :: mrat=100
integer                    :: ch,top2,ch1(1)
integer                    :: id(GG_MAX_NAME_LENGTH)
doubleprecision            :: eps,b,s,t,tdum(2)
logical                    :: text
integer                    :: i, j, k, location, m, n
integer                    :: img
integer                    :: job, space_left
integer                    :: l2
integer                    :: ll
integer                    :: ls
integer                    :: lun
integer                    :: lunit
integer                    :: lw
integer                    :: lx
integer                    :: ly
integer                    :: mn
logical                    :: isfound
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   select case(G_FIN)
      case(:5,13,14) ! setup for filename parameter
         mn = m*n
         if (G_SYM .eq. semi)then
            flag = 0
         else
            flag = 3
         endif
         if (G_RHS .ge. 2) then            ! if more than one parameter on exec('filename',flag) get value of FLAG
            flag = int(GM_REALS(location))
            top2 = G_BOTTOM_OF_SCRATCH_IN_USE
            G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
            location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
            mn = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
         endif
         if (mn.eq.1 .and. GM_REALS(location).LT.10.0d0)then
            lun = int(GM_REALS(location))
         else
            lun = -1
            do j = 1, GG_LINELEN
               ls = location+j-1
               if (j .le. mn) ch = int(GM_REALS(ls))
               if (j .gt. mn) ch = blank
               if (ch.lt.0 .or. ch.ge.g_charset_size) then
                  call mat_err(38)
                  return
               endif
               G_BUF(j) = ch
            enddo
         endif
      end select
      FUN5 : select case(G_FIN)
      case(1)                                               ! command::exec
      EXEC_CMD : block
      character(len=:),allocatable :: filename
      if (lun .eq. 0) then                                  ! exec(0)
         G_RIO = G_INPUT_LUN
         G_ERR = 99
      else
         k = G_LINE_POINTER(6)
         G_LIN(k+1) = G_LINE_POINTER(1)
         G_LIN(k+2) = G_LINE_POINTER(3)
         G_LIN(k+3) = G_LINE_POINTER(6)
         G_LIN(k+4) = G_PTZ
         G_LIN(k+5) = G_RIO
         G_LIN(k+6) = G_LINECOUNT(4)
         G_LINE_POINTER(1) = k + 7
         G_LINECOUNT(4) = flag
         G_PTZ = G_PT - 4
         if (G_RIO .eq. G_INPUT_LUN)then
            G_RIO = 12
         endif
         G_RIO = G_RIO + 1
         filename=find_exec_file(ade2str(G_BUF))
         call mat_str2buf(filename,G_BUF,GG_LINELEN)    ! convert input line to ADE buffer
         call mat_files(G_RIO,G_BUF,status='old')
         if(G_FILE_OPEN_ERROR)then
            G_RIO = G_INPUT_LUN
            G_ERR = 99
         endif
         if (flag .ge. 4)then
            call journal(' PAUSE MODE. Enter blank lines.')
         endif
         G_SYM = GG_EOL
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      endif
      endblock EXEC_CMD
      case(2) ! COMMAND::SAVE
      lunit = 1
      call mat_files(lunit,G_BUF)
      k = GG_MAX_NUMBER_OF_NAMES-4
      if (k .lt. G_TOP_OF_SAVED) k = GG_MAX_NUMBER_OF_NAMES
      if (G_RHS .eq. 2) k = top2
      if (G_RHS .eq. 2) call mat_copyid(G_STACK_IDS(1,k),G_SYN)
      do
         location = G_STACK_ID_LOC(k)
         m = G_STACK_ROWS(k)
         n = G_STACK_COLS(k)
         do i = 1, GG_MAX_NAME_LENGTH
            j = G_STACK_IDS(i,k)
            G_BUF(i) = j
         enddo
         img = 0
         if (mat_wasum(m*n,GM_IMAGS(location),GM_IMAGS(location),1) .ne. 0.0d0) img = 1
         if(.not.G_FILE_OPEN_ERROR)call mat_savlod(lunit,G_BUF,m,n,img,0,GM_REALS(location),GM_IMAGS(location))
         k = k-1
         if (k .lt. G_TOP_OF_SAVED) exit
      enddo
      call mat_files(-lunit,G_BUF) ! close unit
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0  ! do not set "ans" to filename
      case(14) ! COMMAND::DELETE
         DELETE_IT: block
         integer :: templun
         integer :: ios
         call mat_buf2str(mline,G_BUF,GG_LINELEN)
         open(file=mline,newunit=templun,iostat=ios,iomsg=errmsg,status='old')
         if(ios.ne.0)then
            call journal('sc','ERROR:',errmsg)
            G_ERR=999
            exit FUN5
         endif
         close(unit=templun,iostat=ios,iomsg=errmsg,status='delete')
         if(ios.ne.0)then
            call journal('sc','ERROR:',errmsg)
            G_ERR=999
            exit FUN5
         endif
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0  ! do not set "ans" to filename
         endblock DELETE_IT
      case(3) ! command::load
      call mat_buf2str(mline,G_BUF,GG_LINELEN)
      lunit = 2
      call mat_files(LUNIT,G_BUF) ! open the unit
      call mat_buf2str(mline,G_BUF,GG_LINELEN)
      do
         space_left = G_STACK_ID_LOC(G_TOP_OF_SAVED) - location
         IF(.not.G_FILE_OPEN_ERROR)then
            call mat_savlod(lunit, &
                & id, &
                & G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE), &
                & G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE), &
                & img, &
                & space_left, &
                & GM_REALS(location), &
                & GM_IMAGS(location))
         endif
         mn = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
         if (mn .ne. 0)then
            if (img .eq. 0) call mat_rset(mn,0.0d0,GM_IMAGS(location),1)
            G_SYM = semi
            G_RHS = 0
            call MAT_STACK_PUT(ID)
            G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
         else
            exit
         endif
      enddo
      call mat_files(-lunit,G_BUF) ! close unit
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(4) ! command::print
      k = G_OUTPUT_LUN                                ! hold
      G_OUTPUT_LUN = 7
      call mat_files(G_OUTPUT_LUN,G_BUF)
      location = G_LINECOUNT(2)                       ! hold
      G_LINECOUNT(2) = 999999                         ! turn off paging of output
      if (G_RHS .gt. 1) call mat_print(G_SYN,top2)
      G_LINECOUNT(2) = location                       ! restore
      G_OUTPUT_LUN = k                                ! restore
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(5) ! command::diary
      call mat_files(8,G_BUF)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(6,7) !     COMMAND::DISPLAY
60    continue
      if (G_FIN.eq.7)goto 65
      if (G_RHS .ge. 2)then
         if (G_RHS .ne. 2) call mat_err(39) ! Incorrect number of arguments
         if (GM_REALS(location) .lt. 1.0d0)then ! test if base is 0
            call mat_err(36) ! Argument out of range
            exit FUN5
         endif
         b = GM_REALS(location)
         if(b.gt.1)then
            goto 65
         endif
      else
         b=10
      endif
      mn = m*n
      text = .true.
      do i = 1, mn
        ls = location+i-1
        ch = int(GM_REALS(LS))
        text = text .and. (ch.ge.0) .and. (ch.lt.G_CHARSET_SIZE)
        text = text .and. (dble(ch).eq.GM_REALS(ls) )
      enddo
      if(b.le.1)text=.false. ! for forcing non-text display when values are in range of text
      do i = 1, m
         do j = 1, n
           ls = location+i-1+(j-1)*m
           if (GM_REALS(ls) .eq. 0.0d0) ch = blank
           if (GM_REALS(ls) .gt. 0.0d0) ch = plus
           if (GM_REALS(ls) .lt. 0.0d0) ch = minus
           if (text) ch = int(GM_REALS(ls))
           G_BUF(j) = ch
         enddo
         call mat_buf2str(mline,G_BUF,n)
         call journal(mline)
      enddo
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      exit FUN5
   65 CONTINUE
      if (G_RHS .ne. 2) call mat_err(39) ! Incorrect number of arguments
      if (GM_REALS(location) .le. 1.0d0)then ! test if base is 0
         call mat_err(36) ! Argument out of range
         exit FUN5
      endif
      b = GM_REALS(location)
      l2 = location
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
      G_RHS = 1
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      eps = GM_REALS(GM_BIGMEM-4)
      do i = 1, m
         ls = l2+(i-1)*n
         ll = location+i-1
         call mat_base(GM_REALS(ll),b,eps,GM_REALS(ls),n)
      enddo
      call mat_rset(m*n,0.0d0,GM_IMAGS(l2),1)
      call mat_wcopy(m*n,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
      call mat_stack1(quote)
      if (G_FIN .eq. 6) goto 60
      case(8)
      G_LINECOUNT(2) = int(GM_REALS(location))
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(9) !     COMMAND::CHAR                   ! does currently not do anything
      K = IABS(int(GM_REALS(location)))
      IF (M*N.NE.1 .OR. K.GT.G_CHARSET_SIZE-1) then
         call mat_err(36) ! Argument out of range
         exit FUN5
      endif
      CH = K
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(10) !     COMMAND::PLOT
      IF (G_RHS .GE. 2) goto 82
      N = M*N
      DO I = 1, N
         LL = location+I-1
         GM_IMAGS(LL) = dble(I)
      enddo
      call mat_plot(G_OUTPUT_LUN,GM_IMAGS(location),GM_REALS(location),N,TDUM,0)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      exit FUN5
   82 continue
      IF (G_RHS .EQ. 2) K = 0
      IF (G_RHS .EQ. 3) K = M*N
      IF (G_RHS .GT. 3) K = G_RHS - 2
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - (G_RHS - 1)
      N = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1) .NE. N) then
         call mat_err(5)
         exit FUN5
      endif
      LX = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      LY = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      IF (G_RHS .GT. 3) location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+2)
      call mat_plot(G_OUTPUT_LUN,GM_REALS(LX),GM_REALS(LY),N,GM_REALS(location),K)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(11) ! COMMAND::RAT
      if (G_RHS .ne. 2) then
         mn = m*n
         l2 = location
         if (G_lhs .eq. 2) l2 = location + mn
         lw = l2 + mn
         if(too_much_memory( lw + lrat - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
         if (G_lhs .eq. 2) G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
         G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = l2
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         call mat_rset(G_lhs*mn,0.0d0,GM_IMAGS(location),1)
         do i = 1, mn
            call mat_rat(GM_REALS(location),lrat,mrat,s,t,GM_REALS(lw))
            GM_REALS(location) = s
            GM_REALS(l2) = t
            if (G_lhs .eq. 1) GM_REALS(location) = mat_flop(s/t)
            location = location + 1
            l2 = l2 + 1
         enddo
      else
         mrat = int(GM_REALS(location))
         lrat = int(GM_REALS(location-1))
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      endif
      case(12) !     COMMAND::DEBUG
      G_DEBUG_LEVEL = int(GM_REALS(location))
      call journal('sc',' DEBUG ',G_DEBUG_LEVEL)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      case(13) !     COMMAND::SHOW
      call printit()
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      end select FUN5
end subroutine mat_matfn5
subroutine mat_stack_get(id)
integer,intent(in)  :: id(GG_MAX_NAME_LENGTH)
integer             :: i
integer             :: j
integer             :: k
integer             :: location
integer             :: l2
integer             :: l3
integer             :: li
integer             :: lj
integer             :: current_location
integer             :: ll
integer             :: ls
integer             :: m
integer             :: mk
integer             :: mn
integer             :: mnk
integer             :: n
character(len=GG_MAX_NAME_LENGTH)    :: id_name
   call mat_copyid(G_STACK_IDS(1,G_TOP_OF_SAVED-1), ID)    ! copy ID to next blank entry in G_STACK_IDS in case it is not there(?)
   do k=GG_MAX_NUMBER_OF_NAMES,1,-1                       ! start at bottom and search up through names till find the name
      if (mat_eqid(G_STACK_IDS(1:,k), id))exit             ! if found name exit loop
   enddo
   if ( (k .ge. GG_MAX_NUMBER_OF_NAMES-1 .and. G_RHS .gt. 0) .or. (k .eq. G_TOP_OF_SAVED-1) ) then
      G_FIN = 0
      return
   endif
   current_location = G_STACK_ID_LOC(K)                               ! found it, so this is the location where the data begins
   IF (G_RHS .EQ. 1) then                                             ! VECT(ARG)
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .EQ. 0) goto 99
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      MN = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      MNK = G_STACK_ROWS(K)*G_STACK_COLS(K)                            ! number of values in this variable
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .LT. 0) MN = MNK
      DO I = 1, MN
        LL = location+I-1
        LS = current_location+I-1
        IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .GT. 0) LS = current_location + int(GM_REALS(LL)) - 1
        IF (LS .LT. current_location .OR. LS .GE. current_location+MNK) then
           call mat_err(21)          ! Subscript out of range
           return
        endif
        GM_REALS(LL) = GM_REALS(LS)
        GM_IMAGS(LL) = GM_IMAGS(LS)
      enddo
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      IF (G_STACK_ROWS(K) .GT. 1) G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = MN
      IF (G_STACK_ROWS(K) .EQ. 1) G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = MN
      goto 99
   elseif (G_RHS .EQ. 2) then                                              ! MATRIX(ARG,ARG)
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1) .EQ. 0) G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .EQ. 0) goto 99
      L2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      M = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .LT. 0) M = G_STACK_ROWS(K)
      N = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1) .LT. 0) N = G_STACK_COLS(K)
      L3 = L2 + N
      MK = G_STACK_ROWS(K)
      MNK = G_STACK_ROWS(K)*G_STACK_COLS(K)
      DO J = 1, N
         DO I = 1, M
           LI = location+I-1
           IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .GT. 0) LI = location + int(GM_REALS(LI)) - 1
           LJ = L2+J-1
           IF (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1) .GT. 0) LJ = L2 + int(GM_REALS(LJ)) - 1
           LS = current_location + LI-location + (LJ-L2)*MK
           IF (LS.LT.current_location .OR. LS.GE.current_location+MNK) then
              call mat_err(21)
              return
           endif
           LL = L3 + I-1 + (J-1)*M
           GM_REALS(LL) = GM_REALS(LS)
           GM_IMAGS(LL) = GM_IMAGS(LS)
         enddo
      enddo
      MN = M*N
      call mat_wcopy(MN,GM_REALS(L3),GM_IMAGS(L3),1,GM_REALS(location),GM_IMAGS(location),1)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = M
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      goto 99
   elseif (G_RHS .GT. 2) then
      call mat_err(21)                                                     ! Subscript out of range
      return
   else                                                                    ! SCALAR
      location = 1
      IF (G_BOTTOM_OF_SCRATCH_IN_USE .GT. 0) &
        & location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) + &
        & G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      IF (G_BOTTOM_OF_SCRATCH_IN_USE+1 .GE. G_TOP_OF_SAVED) then
         call mat_err(18)  ! Too many names
         return
      endif
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
      G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = G_STACK_ROWS(K)
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = G_STACK_COLS(K)
      MN = G_STACK_ROWS(K)*G_STACK_COLS(K)
      if(too_much_memory( location+MN - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
      IF (K .EQ. GG_MAX_NUMBER_OF_NAMES) then
         G_FIN = 7
         G_FUN = 6
         return
      endif
      call mat_wcopy(MN,GM_REALS(current_location),   &
                        & GM_IMAGS(current_location), &
                        & 1,                               &
                        & GM_REALS(location),         &
                        & GM_IMAGS(location),         &
                        & 1)
   endif
99 continue
   G_FIN = -1
   G_FUN = 0
END SUBROUTINE MAT_STACK_GET
subroutine mat_stack2(op)
integer           :: op
doubleprecision   :: sr,si,e1,st,e2
integer           ::  i
integer           ::  j
integer           ::  k
integer           ::  k1
integer           ::  k2
integer           ::  kexp
integer           ::  location
integer           ::  l1
integer           ::  l2
integer           ::  l3
integer           ::  ll
integer           ::  ls
integer           ::  m
integer           ::  m2
integer           ::  mn
integer           ::  n
integer           ::  n2
integer           ::  nexp
integer           :: op_select
   l2 = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m2 = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n2 = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   G_FUN = 0
   if(op.eq.DSTAR)then
      op_select=-op
   else
      op_select=op
   endif
   DO_OP: select case(op_select)
   case (PLUS) ! ADDITION
      if (m .lt. 0) then
         if (m2 .ne. n2) then
            call mat_err(8)
            exit DO_OP
         endif
         m = m2
         n = n2
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         sr = GM_REALS(location)
         si = GM_IMAGS(location)
         call mat_wcopy(m*n,GM_REALS(location+1),GM_IMAGS(location+1),1,GM_REALS(location),GM_IMAGS(location),1)
         call finish()
         exit DO_OP
      endif
      if (m2 .lt. 0)then
         if (m .ne. n) then
            call mat_err(8)
            exit DO_OP
         endif
         sr = GM_REALS(l2)
         si = GM_IMAGS(l2)
         call finish()
         exit DO_OP
      endif
      if (m .ne. m2) then
         call mat_err(8)
         exit DO_OP
      endif
      if (n .ne. n2) then
         call mat_err(8)
         exit DO_OP
      endif
      call matX_waxpy(m*n,1.0d0,0.0d0,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
   case (MINUS) ! SUBTRACTION
      if (m .lt. 0) then
         if (m2 .ne. n2)then
            call mat_err(9)
            exit do_op
         endif
         m = m2
         n = n2
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
         sr = GM_REALS(location)
         si = GM_IMAGS(location)
         call mat_wcopy(m*n,GM_REALS(location+1),GM_IMAGS(location+1),1,GM_REALS(location),GM_IMAGS(location),1)
         call mat_wrscal(m*n,-1.0d0,GM_REALS(location),GM_IMAGS(location),1)
         call finish()
         exit DO_OP
      endif
      if (m2 .lt. 0) then
         if (m .ne. n) then
            call mat_err(9)
            exit DO_OP
         endif
         sr = -GM_REALS(l2)
         si = -GM_IMAGS(l2)
         call finish()
         exit DO_OP
      endif
      if (m .ne. m2)then
         call mat_err(9)
         exit DO_OP
      endif
      if (n .ne. n2) then
         call mat_err(9)
         exit DO_OP
      endif
      call matX_waxpy(M*N,-1.0D0,0.0D0,GM_REALS(L2),GM_IMAGS(L2),1,GM_REALS(location),GM_IMAGS(location),1)
   case (STAR) ! MULTIPLICATION
      if (m2*m2*n2 .eq. 1) goto 10
      if (m*n .eq. 1) goto 11
      if (m2*n2 .eq. 1) goto 10
      if (n .ne. m2) then
         call mat_err(10)
         exit do_op
      endif
      mn = m*n2
      ll = location + mn
      if(too_much_memory( ll+m*n+m2*n2 - G_STACK_ID_LOC(G_TOP_OF_SAVED)) ) exit do_op
      call mat_wcopy(m*n+m2*n2,GM_REALS(location),GM_IMAGS(location),-1,GM_REALS(ll),GM_IMAGS(ll),-1)
      do j = 1, n2
         do i = 1, m
            k1 = location + mn + (i-1)
            k2 = l2 + mn + (j-1)*m2
            k = location + (i-1) + (j-1)*m
            GM_REALS(k) = mat_wdotur(N,GM_REALS(k1),GM_IMAGS(k1),m,GM_REALS(k2),GM_IMAGS(k2),1)
            GM_IMAGS(k) = mat_wdotui(N,GM_REALS(k1),GM_IMAGS(k1),m,GM_REALS(k2),GM_IMAGS(k2),1)
         enddo
      enddo
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n2
      exit do_op
   10 continue
      sr = GM_REALS(l2)
      si = GM_IMAGS(l2)
      l1 = location
      goto 13
   11 continue
      sr = GM_REALS(location)
      si = GM_IMAGS(location)
      l1 = location+1
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m2
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n2
   13 continue
      mn = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
      call mat_wscal(mn,sr,si,GM_REALS(l1),GM_IMAGS(l1),1)
      if (l1.ne.location) call mat_wcopy(mn,GM_REALS(l1),GM_IMAGS(l1),1,GM_REALS(location),GM_IMAGS(location),1)
   case (-DSTAR) ! POWER
      IF (M2*N2 .NE. 1) then
         call mat_err(30)
         exit do_op
      endif
      IF (M .NE. N) then
         call mat_err(20)
         exit do_op
      endif
      NEXP = int(GM_REALS(L2))
      IF ( (GM_REALS(L2) .NE. dble(NEXP)) .or. (GM_IMAGS(L2) .NE. 0.0D0) .or. (NEXP .LT. 2) )then
         G_FUN = 2
         G_FIN = 0
         exit DO_OP
      endif
      MN = M*N
      if(too_much_memory( L2+MN+N - G_STACK_ID_LOC(G_TOP_OF_SAVED)) ) exit do_op
      call mat_wcopy(MN,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(L2),GM_IMAGS(L2),1)
      L3 = L2+MN
      DO KEXP = 2, NEXP
         DO J = 1, N
            LS = location+(J-1)*N
            call mat_wcopy(N,GM_REALS(LS),GM_IMAGS(LS),1,GM_REALS(L3),GM_IMAGS(L3),1)
            DO I = 1, N
               LS = L2+I-1
               LL = location+I-1+(J-1)*N
               GM_REALS(LL)=mat_wdotur(N,GM_REALS(LS),GM_IMAGS(LS),N,GM_REALS(L3),GM_IMAGS(L3),1)
               GM_IMAGS(LL)=mat_wdotui(N,GM_REALS(LS),GM_IMAGS(LS),N,GM_REALS(L3),GM_IMAGS(L3),1)
            enddo
         enddo
      enddo
   case (SLASH) ! right division
      if (m2*n2 .ne. 1) then
         if (m2 .eq. n2) G_FUN = 1
         if (m2 .ne. n2) G_FUN = 4
         G_FIN = -1
         G_RHS = 2
         exit DO_OP
      endif
      sr = GM_REALS(l2)
      si = GM_IMAGS(l2)
      mn = m*n
      do i = 1, mn
         ll = location+i-1
         call mat_wdiv(GM_REALS(ll),GM_IMAGS(ll),sr,si,GM_REALS(ll),GM_IMAGS(ll))
         if (G_ERR .gt. 0) exit
      enddo
   case (BSLASH) ! LEFT DIVISION
      if (m*n .ne. 1) then
         if (m .eq. n) G_FUN = 1
         if (m .ne. n) G_FUN = 4
         G_FIN = -2
         G_RHS = 2
         exit DO_OP
      endif
      SR = GM_REALS(location)
      SI = GM_IMAGS(location)
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = M2
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N2
      MN = M2*N2
      DO I = 1, MN
         LL = location+I-1
         call mat_wdiv(GM_REALS(LL+1),GM_IMAGS(LL+1),SR,SI,GM_REALS(LL),GM_IMAGS(LL))
         IF (G_ERR .GT. 0) exit
      enddo
   case (COLON) ! COLON
      E2 = GM_REALS(L2)
      ST = 1.0D0
      N = 0
      IF (G_RHS .GE. 3) then
         ST = GM_REALS(location)
         G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
         location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
         IF (ST .EQ. 0.0D0) goto 63
      endif
      E1 = GM_REALS(location)
      IF (G_RSTK(G_PT) .EQ. 3) then
         GM_REALS(location) = E1
         GM_REALS(location+1) = ST
         GM_REALS(location+2) = E2
         G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = -3
         G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = -1
         exit DO_OP
      endif
      if(too_much_memory( location + MAX(3,int((E2-E1)/ST)) - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) ) exit do_op
      do
         IF (ST .GT. 0.0D0 .AND. GM_REALS(location) .GT. E2) exit
         IF (ST .LT. 0.0D0 .AND. GM_REALS(location) .LT. E2) exit
         N = N+1
         location = location+1
         GM_REALS(location) = E1 + dble(N)*ST
         GM_IMAGS(location) = 0.0D0
      enddo
   63 continue
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = N
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      IF (N .EQ. 0) G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   case (1000:2000-1) ! element-wise operations
      op = op -1000
      if (m.ne.m2 .or. n.ne.n2) then
         call mat_err(10)
         exit do_op
      endif
      mn = m*n
      do i = 1, mn
         j = location+i-1
         k = l2+i-1
         select case(op)
         case(STAR)
         call mat_wmul(GM_REALS(J),GM_IMAGS(J), &
                                        GM_REALS(K),GM_IMAGS(K), &
                                        GM_REALS(J),GM_IMAGS(J))
         case(SLASH)
         call mat_wdiv(GM_REALS(J),GM_IMAGS(J), &
                                        GM_REALS(K),GM_IMAGS(K), &
                                        GM_REALS(J),GM_IMAGS(J))
         case(BSLASH)
         call mat_wdiv(GM_REALS(K),GM_IMAGS(K), &
                                        GM_REALS(J),GM_IMAGS(J), &
                                        GM_REALS(J),GM_IMAGS(J))
         end select
         IF (G_ERR .GT. 0) exit
      enddo
   case (2000:) ! kronecker
      G_FIN = op - 2000 - star + 11
      G_FUN = 6
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
      G_RHS = 2
   case default
      write(*,*)'<ERROR> unknown operator ',op
      stop
   end select DO_OP
contains
subroutine finish()
   do i = 1, n
      ll = location + (i-1)*(n+1)
      GM_REALS(ll) = mat_flop(GM_REALS(LL)+sr)
      GM_IMAGS(ll) = mat_flop(GM_IMAGS(LL)+si)
   enddo
end subroutine finish
end subroutine mat_stack2
subroutine mat_getlin() ! get a new input line
character(len=GG_LINELEN) :: mline
character(len=GG_LINELEN) :: shift_mline
integer                   :: istat
integer,parameter         :: retu(GG_MAX_NAME_LENGTH) =  [iachar(['q','u','i','t',' ',' ',' ']),GG_PAD(8:)]
integer                   :: i, j, k
integer                   :: l
integer                   :: n
integer                   :: ios
   l = G_LINE_POINTER(1)
   11 continue
      G_BUF(:GG_LINELEN)= blank      ! blank out buffer before reading into it
      n = GG_LINELEN+1
      if(size(G_PSEUDO_FILE).eq.1.and.G_RIO.eq.STDIN)then
         mline=get_pseudo_line()
         G_RIO = G_INPUT_LUN
      elseif(size(G_PSEUDO_FILE).ne.0.and.G_RIO.eq.STDIN)then
         mline=get_pseudo_line()
      else
         mline(:)=' '
         read(G_RIO,'(a)',iostat=ios) mline       ! read input line from file
         if( (ios.ne.0) ) then
             if(is_iostat_end(ios))then           ! hit end of file
                call mat_copyid(G_LIN(l),retu) ! store QUIT onto G_LIN(L) to simulate RETURN command
                l = l + 4
                goto 45
             else
                goto 15
             endif
         endif
      endif
      if(G_ECHO)write(*,'(*(g0))')'',trim(mline)
      call fold(mline)
      shift_mline=adjustl(mline)
      if(shift_mline(1:2).eq.'??')then            ! edit command line history
         mline='. '//mline(3:)
      endif
      if(G_RIO.eq.stdin)then
         call journal('t',mline)   ! reading from standard input, so copy to trail file
      else
         call journal('c',mline)   ! reading from an exec() command, so write as a comment
      endif
      call redo(mline,'.')         ! pass line to REDO(3f). This is a no-op except for storing the line into the input history
      shift_mline=adjustl(mline)
      if(shift_mline(1:1).eq.'#')then
         mline=''                                                      ! ignore lines with a # as first non-blank character
      elseif(shift_mline(1:1).eq.'!')then
         if(shift_mline.eq.'!')then
            call get_environment_variable('SHELL',shift_mline)         ! get command to execute
            call execute_command_line(shift_mline,cmdstat=istat)       ! call system shell
         else
            call execute_command_line(shift_mline(2:),cmdstat=istat)   ! call system shell
         endif
         mline=''
      endif
      call mat_str2buf(mline,G_BUF,GG_LINELEN)    ! convert input line to "Hollerith" buffer
   15 continue
      n = n-1
      if(n.lt.1)then
         n=1
      elseif (G_BUF(n) .eq. blank)then
         goto 15 ! trim off trailing spaces
      endif
      if (mod(G_LINECOUNT(4),2) .eq. 1) then
              call mat_buf2str(mline,G_BUF,n) ! convert ADE buffer to character
              call journal('s',mline) ! just to standard output
      endif
      do j = 1, n
         do k = 1, G_CHARSET_SIZE  ! make sure this letter is in set of LAFF characters and get its LAFF number
           if (G_BUF(j).eq.k ) goto 30
         enddo
         call journal('sc','Unknown character at column ',j) ! this is not a known character
         k = GG_EOL+1
         if (k .gt. GG_EOL) then
            l = G_LINE_POINTER(1)
            goto 11   ! Unknown character , K not changed. get new line
         endif
         if (k .eq. GG_EOL) exit
         if (k .eq. -1) l = l-1
         if (k .le. 0) cycle
   30    continue
         if (k.eq.slash .and. G_BUF(j+1).eq.G_BUF(j)) exit     ! if // rest is comment
         if (k.eq.dot .and. G_BUF(j+1).eq.G_BUF(j)) goto 11    ! if .. line continuation
         if (k.eq.bslash .and. n.eq.1) then                    ! if \ in column 1
            n = G_LINE_POINTER(6) - G_LINE_POINTER(1)
            do i = 1, n
               k = G_LIN(l+i-1)
               G_BUF(i) = k
            enddo
            goto 15
         endif
         G_LIN(l) = k
         if (l.lt.1024) l = l+1
         if (l.eq.1024) call journal('sc','input buffer limit exceeded=',l)
      enddo
   45 CONTINUE      ! line is ready, reset line pointers
      G_LIN(l) = GG_EOL;G_LIN(l+1:)=blank
      G_LINE_POINTER(6) = l
      G_LINE_POINTER(4) = G_LINE_POINTER(1)
      G_LINE_POINTER(3) = 0
      G_LINE_POINTER(2) = 0
      G_LINECOUNT(1) = 0
      call mat_getch() ! load first character onto G_CHRA
contains
function get_pseudo_line() result(line)
character(len=GG_LINELEN) :: line
   line=G_PSEUDO_FILE(1)
   if(size(G_PSEUDO_FILE).gt.1)then
      G_PSEUDO_FILE=G_PSEUDO_FILE(2:)
   else
      G_PSEUDO_FILE=[character(len=GG_LINELEN) :: ]
   endif
end function get_pseudo_line
subroutine fold(line)
character(len=*) :: line
   do i=1,len(line)
      select case(line(i:i))
      case('{');line(i:i)='('
      case('}');line(i:i)=')'
      case('|');line(i:i)=':'
      case('$');line(i:i)='\'
      case('@');line(i:i)='.'
      case('"');line(i:i)="'"
      case('[');line(i:i)='<'
      case(']');line(i:i)='>'
      case default
      endselect
   enddo
end subroutine fold
end subroutine mat_getlin
subroutine mat_clause()
character(len=GG_LINELEN) :: mline
doubleprecision    :: e1,e2
integer            :: op
integer            :: r
integer,parameter :: for(GG_MAX_NAME_LENGTH)   =  [iachar(['f','o','r',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter :: while(GG_MAX_NAME_LENGTH) =  [iachar(['w','h','i','l','e',' ',' ']),GG_PAD(8:)]
integer,parameter :: iff(GG_MAX_NAME_LENGTH)   =  [iachar(['i','f',' ',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter :: else(GG_MAX_NAME_LENGTH)  =  [iachar(['e','l','s','e',' ',' ',' ']),GG_PAD(8:)]
integer,parameter :: ennd(GG_MAX_NAME_LENGTH)  =  [iachar(['e','n','d',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter :: do(GG_MAX_NAME_LENGTH)    =  [iachar(['d','o',' ',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter :: thenn(GG_MAX_NAME_LENGTH) =  [iachar(['t','h','e','n',' ',' ',' ']),GG_PAD(8:)]
integer            :: i
integer            :: j
integer            :: kount
integer            :: location
integer            :: l2
integer            :: lj
integer            :: m
integer            :: n
   r = -G_FIN-10
   G_FIN = 0
   if (r.lt.1 .or. r.gt.6) goto 01
   goto (02,30,30,80,99,90),R
01 continue
   r = G_RSTK(G_PT)
   goto (99,99,05,40,45,99,99,99,99,99,99,99,15,55,99,99,99),R
   call journal('*mat_clause* -- internal error')
   goto 99
02 continue
   call mat_getsym()
   if (G_SYM .ne. isname) then
      call mat_err(34) ! improper for clause
      return
   endif
   G_PT = G_PT+2
   call mat_copyid(G_IDS(1,G_PT),G_SYN)
   call mat_getsym()
   if (G_SYM .ne. equal) then
      call mat_err(34) ! improper for clause
      return
   endif
   call mat_getsym()
   G_RSTK(G_PT) = 3
   return
05 continue
   G_PSTK(G_PT-1) = 0
   G_PSTK(G_PT) = G_LINE_POINTER(4) - 1
   if (mat_eqid(G_SYN,DO)) G_SYM = semi
   if (G_SYM .eq. comma) G_SYM = semi
   if (G_SYM .ne. semi) then
      call mat_err(34) ! improper for clause
      return
   endif
10 continue
   j = G_PSTK(G_PT-1)
   G_LINE_POINTER(4) = G_PSTK(G_PT)
   G_SYM = semi
   G_CHRA = blank
   j = j+1
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   m = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   lj = location+(j-1)*m
   l2 = location + m*n
   if (m .ne. -3) goto 12
   lj = location+3
   l2 = lj
   GM_REALS(lj) = GM_REALS(location) + dble(j-1)*GM_REALS(location+1)
   GM_IMAGS(lj) = 0.0d0
   if (GM_REALS(location+1).gt.0.0d0 .and. GM_REALS(lj).gt.GM_REALS(location+2)) goto 20
   if (GM_REALS(location+1).lt.0.0d0 .and. GM_REALS(lj).lt.GM_REALS(location+2)) goto 20
   m = 1
   n = j
12 continue
   if (j .gt. n) goto 20
   if (G_BOTTOM_OF_SCRATCH_IN_USE+1 .ge. G_TOP_OF_SAVED) then
      call mat_err(18) ! too many names
      return
   endif
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
   G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = l2
   G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = m
   G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
   if(too_much_memory( l2+m - G_STACK_ID_LOC(G_TOP_OF_SAVED) ) )return
   call mat_wcopy(m,GM_REALS(lj),GM_IMAGS(lj),1,GM_REALS(l2),GM_IMAGS(l2),1)
   G_RHS = 0
   call mat_stack_put(G_IDS(1,G_PT))
   if (G_ERR .gt. 0) return
   G_PSTK(G_PT-1) = j
   G_PSTK(G_PT) = G_LINE_POINTER(4)
   G_RSTK(G_PT) = 13
   return
15 continue
   goto 10
20 continue
   G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   G_RHS = 0
   call mat_stack_put(G_IDS(1,G_PT))
   if (G_ERR .gt. 0) return
   G_PT = G_PT-2
   goto 80
30 continue
   G_PT = G_PT+1
   call mat_copyid(G_IDS(1,G_PT),G_SYN)
   G_PSTK(G_PT) = G_LINE_POINTER(4)-1
35 continue
   G_LINE_POINTER(4) = G_PSTK(G_PT)
   G_CHRA = blank
   call mat_getsym()
   G_RSTK(G_PT) = 4
   return
40 continue
   if (G_SYM.ne.equal .and. G_SYM.NE.LESS .and. G_SYM.NE.GREAT)then
      call mat_err(35)    ! improper WHILE or IF clause
      return
   endif
   op = G_SYM
   call mat_getsym()
   if (G_SYM.EQ.equal .or. G_SYM.EQ.great) op = op + G_SYM
   if (op .gt. great) call mat_getsym()
   G_PSTK(G_PT) = 256*G_PSTK(G_PT) + op
   G_RSTK(G_PT) = 5
   return
45 continue
   op = mod(G_PSTK(G_PT),256)
   G_PSTK(G_PT) = G_PSTK(G_PT)/256
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE-1)
   e1 = GM_REALS(location)
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   e2 = GM_REALS(location)
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 2
   if (mat_eqid(G_SYN,do) .or. mat_eqid(G_SYN,thenn)) G_SYM = semi
   if (G_SYM .EQ. COMMA) G_SYM = SEMI
   if (G_SYM .NE. SEMI) then
      call mat_err(35) ! improper WHILE or IF clause
      return
   endif
   if (op.eq.equal         .and. e1.eq.e2) goto 50
   if (op.eq.less          .and. e1.lt.e2) goto 50
   if (op.eq.great         .and. e1.gt.e2) goto 50
   if (op.eq.(less+equal)  .and. e1.le.e2) goto 50
   if (op.eq.(great+equal) .and. e1.ge.e2) goto 50
   if (op.eq.(less+great)  .and. e1.ne.e2) goto 50
   G_PT = G_PT-1
   goto 80
50 continue
   G_RSTK(G_PT) = 14
   return
55 continue
   IF (mat_eqid(G_IDS(1:,G_PT),while)) goto 35
   G_PT = G_PT-1
   if (mat_eqid(G_SYN,else)) goto 80
   return
80 continue
   kount = 0
   call mat_getsym()
82 continue
   if (G_SYM .eq. GG_EOL) return
   if (G_SYM .ne. isname) goto 83
   if (mat_eqid(G_SYN,ennd) .and. kount.eq.0) return
   if (mat_eqid(G_SYN,else) .and. kount.eq.0) return
   if (mat_eqid(G_SYN,ennd) .or. mat_eqid(G_SYN,else))kount = kount-1
   if (mat_eqid(G_SYN,for) .or. mat_eqid(G_SYN,while).or.mat_eqid(G_SYN,iff)) kount = kount+1
83 continue
   call mat_getsym()
   goto 82
90 continue
   if (G_RSTK(G_PT) .eq. 14) G_PT = G_PT-1
   if (G_PT .le. G_PTZ) return
   if (G_RSTK(G_PT) .eq. 14) G_PT = G_PT-1
   if (G_PT-1 .le. G_PTZ) return
   if (G_RSTK(G_PT) .eq. 13) G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
   if (G_RSTK(G_PT) .eq. 13) G_PT = G_PT-2
   goto 80
99 continue
   call mat_err(22)    ! recursion difficulties
end subroutine mat_clause
subroutine mat_expr()
integer           :: r
integer           :: sign
integer,parameter :: eye(GG_MAX_NAME_LENGTH) =  [iachar(['e','y','e',' ',' ',' ',' ']),GG_PAD(8:)]
integer           :: kount
integer           :: ls
integer           :: op
   r = G_RSTK(G_pt)
   goto (01,01,01,01,01,05,25,99,99,01,01,99,99,99,99,99,99,01,01,01),R
01 continue
   if (G_SYM .eq. colon) call mat_copyid(G_SYN,eye)
   if (G_SYM .eq. colon) G_SYM = isname
   kount = 1
02 continue
   sign = plus
   if (G_SYM .eq. minus) sign = minus
   if (G_SYM.eq.plus .or. G_SYM.eq.minus) call mat_getsym()
   G_pt = G_pt+1
   if (G_pt .gt. G_PSIZE-1) then
      call mat_err(26) ! too complicated (stack overflow)
      return
   endif
   G_PSTK(G_pt) = sign + 256*kount
   G_RSTK(G_pt) = 6
   return
05 continue
   sign = mod(G_PSTK(G_pt),256)
   kount = G_PSTK(G_pt)/256
   G_pt = G_pt-1
   if (sign .eq. minus) call mat_stack1(minus)
   if (G_err .gt. 0) return
10 continue
   if (G_SYM.eq.plus .or. G_SYM.eq.minus) goto 20
   goto 50
20 continue
   if (G_RSTK(G_pt) .eq. 10) then
      ls = G_LINE_POINTER(3) - 2
      if (G_LIN(ls) .eq. blank) goto 50
   endif
   op = G_SYM
   call mat_getsym()
   G_PT = G_PT+1
   G_PSTK(G_PT) = op + 256*kount
   G_RSTK(G_PT) = 7
   return
25 continue
   op = mod(G_PSTK(G_pt),256)
   kount = G_PSTK(G_pt)/256
   G_PT = G_PT-1
   call mat_stack2(op)
   if (G_ERR .gt. 0) return
   goto 10
50 continue
   if (G_SYM .ne. colon) goto 60
   call mat_getsym()
   kount = kount+1
   goto 02
60 continue
   if (kount .gt. 3) then
      call mat_err(33)  ! too many colons
      return
   endif
   G_RHS = kount
   if (kount .gt. 1) call mat_stack2(colon)
   if (G_err .gt. 0) return
   return
99 continue
   call mat_err(22)     ! recursion difficulties
   return
end subroutine mat_expr
subroutine mat_factor()
integer           :: r
integer           :: id(gg_max_name_length)
integer           :: excnt
integer           :: i, j, k
integer           :: location
integer           :: ln
integer           :: ls
integer           :: n
   r = G_RSTK(G_PT)
   goto (99,99,99,99,99,99,99,01,01,25,45,65,99,99,99,55,75,32,37),r
01 continue
   if (.not.(G_SYM.eq.isnum .or. G_SYM.eq.quote .or.  G_SYM.EQ.less)) then
      if (G_SYM .eq. great)then
            call mat_getsym()
            if (G_SYM .eq. less .and. G_CHRA.EQ.GG_EOL) then
            call mat_err(28) ! Empty macro
            return
         endif
            G_PT = G_PT+1
            G_RSTK(G_PT) = 18
            return
      endif
      excnt = 0
      if (G_SYM .eq. isname)then
         call mat_copyid(id,G_SYN)
         call mat_getsym()
         if (G_SYM .eq. lparen) goto 42
         G_RHS = 0
         call mat_funs(ID)
         if (G_FIN .ne. 0) then
            call mat_err(25) ! Can not use function name as variable
            return
         endif
         call mat_stack_get(id)
         if (G_ERR .gt. 0) return
         if (G_FIN .eq. 7) goto 50
         if (G_FIN .eq. 0) call mat_copyid(G_IDS(1,G_PT+1),id)
         if (G_FIN .eq. 0) then
            call mat_err(4) ! undefined variable
            return
         endif
         goto 60
      endif
      id(1) = BLANK
      if (G_SYM .eq. lparen) goto 42
      call mat_err(2)
      return
   endif
   location = 1
   if (G_BOTTOM_OF_SCRATCH_IN_USE .gt. 0) then
      location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) &
       & + G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) &
       & * G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   endif
   if (G_BOTTOM_OF_SCRATCH_IN_USE+1 .ge. G_TOP_OF_SAVED) then
      call mat_err(18)
      return
   endif
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE+1
   G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = location
   if (G_SYM .ne. quote) then
      if (G_SYM .eq. less) goto 20
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
      GM_REALS(location) = GM_IMAGS(GM_BIGMEM)
      GM_IMAGS(location) = 0.0D0
      call mat_getsym()
      goto 60
   endif
   n = 0
   G_LINE_POINTER(4) = G_LINE_POINTER(3)
   call mat_getch()  ! get next character
16 continue
   if (G_CHRA .eq. QUOTE) goto 18
17 continue
   ln = location+n
   if (G_CHRA .eq. GG_EOL) then
      call mat_err(31) ! Improper string
      return
   endif
   GM_REALS(LN) = dble(G_CHRA)
   GM_IMAGS(LN) = 0.0d0
   n = n+1
   call mat_getch()  ! get next character
   goto 16
18 continue
   call mat_getch()  ! get next character
   if (G_CHRA .eq. QUOTE) goto 17
   if (n .le. 0) then
      call mat_err(31) ! Improper string
      return
   endif
   G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 1
   G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = n
   call mat_getsym()
   goto 60
20 continue
   G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
21 continue
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE + 1
   G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE) = &
      &   G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE-1) &
      & + G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE-1)&
      & * G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE-1)
   G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = 0
   call mat_getsym()
22 continue
   if (G_SYM.eq.semi .or. G_SYM.eq.great .or. G_SYM.eq.GG_EOL) then
      if (G_SYM.eq.semi .and. G_CHRA.eq.GG_EOL) call mat_getsym()
      call mat_stack1(quote)
      if (G_ERR .gt. 0) return
      G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1
      if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .eq. 0)  &
         & G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .ne. G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1) &
         & .and. G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1) .gt. 0) then
         call mat_err(6)
         return
      endif
      G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) = G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) &
         & + G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
      if (G_SYM .eq. GG_EOL) call mat_getlin()
      if (G_SYM .ne. great) goto 21
      call mat_stack1(quote)
      if (G_ERR .gt. 0) return
      call mat_getsym()
      goto 60
   endif
   if (G_SYM .eq. comma) call mat_getsym()
   G_PT = G_PT+1
   G_RSTK(G_PT) = 10
   return
25 continue
   G_PT = G_PT-1
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE - 1
   if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .eq. 0) then
      G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
   endif
   if (G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE) .ne. G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE+1))then
      call mat_err(5)
      return
   endif
   G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) =  &
      & G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE) + G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE+1)
   goto 22
32 continue
   G_PT = G_PT-1
   if (G_SYM.ne.less .and. G_SYM.NE.GG_EOL) then
      call mat_err(37) ! Improper MACROS
      return
   endif
   if (G_SYM .EQ. LESS) call mat_getsym()
   k = G_LINE_POINTER(6)
   G_LIN(k+1) = G_LINE_POINTER(1)
   G_LIN(k+2) = G_LINE_POINTER(2)
   G_LIN(k+3) = G_LINE_POINTER(6)
   G_LINE_POINTER(1) = k + 4
   k = G_LINE_POINTER(1)
   location = G_STACK_ID_LOC(G_BOTTOM_OF_SCRATCH_IN_USE)
   n = G_STACK_ROWS(G_BOTTOM_OF_SCRATCH_IN_USE)*G_STACK_COLS(G_BOTTOM_OF_SCRATCH_IN_USE)
   do j = 1, n
      ls = location + j-1
      G_LIN(k) = int(GM_REALS(ls))
      if (G_LIN(k).lt.0 .or. G_LIN(k).ge.G_CHARSET_SIZE) then
         call mat_err(37) ! Improper MACROS
         return
      endif
      if (k.lt.1024) k = k+1
      if (k.eq.1024)call journal('sc','Input buffer char limit exceeded=',K)
   enddo
   G_BOTTOM_OF_SCRATCH_IN_USE = G_BOTTOM_OF_SCRATCH_IN_USE-1
   G_LIN(k) = GG_EOL;G_LIN(k+1:)=blank
   G_LINE_POINTER(6) = k
   G_LINE_POINTER(4) = G_LINE_POINTER(1)
   G_LINE_POINTER(3) = 0
   G_LINE_POINTER(2) = 0
   G_LINECOUNT(1) = 0
   G_CHRA = blank
   call mat_getsym()
   G_PT = G_PT+1
   G_RSTK(G_PT) = 19
   return
37 continue
   G_PT = G_PT-1
   k = G_LINE_POINTER(1) - 4
   G_LINE_POINTER(1) = G_LIN(K+1)
   G_LINE_POINTER(4) = G_LIN(K+2)
   G_LINE_POINTER(6) = G_LIN(K+3)
   G_CHRA = BLANK
   call mat_getsym()
   goto 60
42 continue
   call mat_getsym()
   excnt = excnt+1
   G_PT = G_PT+1
   G_PSTK(G_PT) = excnt
   call mat_copyid(G_IDS(1,G_PT),id)
   G_RSTK(G_PT) = 11
   return
45 continue
   call mat_copyid(id,G_IDS(1,G_PT))
   excnt = G_PSTK(G_PT)
   G_PT = G_PT-1
   if (G_SYM .eq. comma) goto 42
   if (G_SYM .ne. rparen) then
      call mat_err(3)
      return
   endif
   if (G_SYM .eq. rparen) call mat_getsym()
   if (id(1) .eq. blank) goto 60
   G_RHS = excnt
   call MAT_STACK_GET(id)
   if (G_ERR .gt. 0) return
   if (G_FIN .eq. 0) call mat_funs(ID)
   if (G_FIN .eq. 0) then
      call mat_err(4) ! undefined variable
      return
   endif
50 continue
   G_PT = G_PT+1
   G_RSTK(G_PT) = 16
   return
55 continue
   G_PT = G_PT-1
   goto 60
60 continue
   if (G_SYM .eq. quote) then
      i = G_LINE_POINTER(3) - 2
      if (G_LIN(i) .eq. blank) goto 90
      call mat_stack1(quote)
      if (G_ERR .gt. 0) return
      call mat_getsym()
   endif
   if (G_SYM.ne.star .or. G_CHRA.ne.star) goto 90
   call mat_getsym()
   call mat_getsym()
   G_PT = G_PT+1
   G_RSTK(G_PT) = 12
   goto 01
65 continue
   G_PT = G_PT-1
   call mat_stack2(DSTAR)
   if (G_ERR .gt. 0) return
   if (G_FUN .ne. 2) goto 90
   G_PT = G_PT+1
   G_RSTK(G_PT) = 17
   return
75 continue
   G_PT = G_PT-1
90 continue
   return
99 continue
   call mat_err(22) ! recursion difficulties
   return
end subroutine mat_factor
subroutine mat_term()
character(len=GG_LINELEN) :: mline
integer            :: op
integer            :: ierr
integer            :: ilen
   select case( G_RSTK(G_PT) )
   case(6,7)
      G_PT = G_PT+1
      G_RSTK(G_PT) = 8
      return
   case(8)
      G_PT = G_PT-1
   case(9)
      op = G_PSTK(G_PT)
      G_PT = G_PT-1
      call mat_stack2(op)
      if (G_ERR .gt. 0)then
         return
      endif
      if (G_FUN .ne. 0) then
         G_PT = G_PT+1
         G_RSTK(G_PT) = 15
         return
      endif
   case(15)
      G_PT = G_PT-1
   case default
      call mat_err(22)
      return
   end select
   op = 0
   if (G_SYM .eq. dot) then
      op = dot
      call mat_getsym()
   endif
   if (.not.(G_SYM.eq.star .or. G_SYM.eq.slash .or. G_SYM.eq.bslash)) then
      return
   endif
   if(op.eq.0)then ! make a special code out of two characters ie. "./" or just set to last symbol found if op=0
      op = G_SYM
   else
      op = G_SYM + 1000
   endif
   call mat_getsym()
   if (G_SYM .eq. dot)then
      op = op + 1000  ! now holds three characters
      call mat_getsym()
   endif
   G_PT = G_PT+1
   G_PSTK(G_PT) = op
   G_RSTK(G_PT) = 9
end subroutine mat_term
subroutine mat_savlod(lun,id,m,n,img,space_left,xreal,ximag)
integer,intent(in)                :: lun                                       ! logical unit number
integer                           :: id(GG_MAX_NAME_LENGTH)                    ! name, format 32a1
integer                           :: m, n                                      ! dimensions
integer                           :: img                                       ! nonzero if ximag is nonzero.  returned on a load
integer                           :: space_left                                ! 0 for save, = space available for load
doubleprecision                   :: xreal(*), ximag(*)                        ! real and optional imaginary parts
character(len=GG_MAX_NAME_LENGTH) :: cid
integer                           :: j,k,l
integer                           :: ios
character(len=256)                :: message
character(len=*),parameter        :: f101 ='(A,3I9)'                           ! ID, MxN dimensions of ID, imaginary or real flag
character(len=*),parameter        :: f102 ='(4Z18)'                            ! format for data
      if (space_left .le. 0) then                                              ! save
         call mat_buf2str(cid,id,GG_MAX_NAME_LENGTH)                           ! convert ID to a character string
         write(lun,f101) cid,m,n,img
         do j = 1, n
            k = (j-1)*m+1
            l = j*m
            write(lun,f102) xreal(k:l)                                         ! real
            if (img .ne. 0) write(lun,f102) ximag(k:l)                         ! imaginary
         enddo
      else                                                                     ! load
         read(lun,f101,iostat=ios,iomsg=message) cid,m,n,img
         if(ios.ne.0)then
            call journal(message)
            m=0
            n=0
         else
            call mat_str2buf(cid,id,GG_MAX_NAME_LENGTH)                        ! convert character string to an ID
            if (m*n .gt. space_left) then
               m=0
               n=0
            else
               do j = 1, n
                  k = (j-1)*m+1
                  l = j*m
                  read(lun,f102,iostat=ios,iomsg=message) xreal(k:l)           ! real
                  if(ios.ne.0)then
                     call journal(message)
                     m=0
                     n=0
                     exit
                  elseif (img .ne. 0) then
                     read(lun,f102,iostat=ios,iomsg=message) ximag(k:l)        ! imaginary
                     if(ios.ne.0)then
                        m=0
                        n=0
                        exit
                     endif
                  endif
               enddo
            endif
         endif
      endif
end subroutine mat_savlod
logical function mat_eqid(x,y)
integer,intent(in) :: x(GG_MAX_NAME_LENGTH)
integer,intent(in) :: y(GG_MAX_NAME_LENGTH)
integer            :: i
   mat_eqid = .true.
   do i = 1, GG_MAX_NAME_LENGTH
      mat_eqid = mat_eqid .and. (x(i).eq.y(i))
   enddo
end function mat_eqid

subroutine printit()
integer :: i
integer :: m,n
integer :: l
if(allocated(G_PSEUDO_FILE)) write(*,*)'G_PSEUDO_FILE:SIZE:',size(G_PSEUDO_FILE)
write(*,*)'G_PROMPT:',G_PROMPT,':G_ECHO:',G_ECHO
write(*,*)'G_LIN:',trim(ade2str(G_LIN))
write(*,*)'G_LHS:',G_LHS,':G_RHS:',G_RHS
write(*,*)'G_FIN:',G_FIN,':G_FUN:',G_FUN,':G_FMT:',G_FMT
write(*,*)'G_RIO:',G_RIO,':G_INPUT_LUN:',G_INPUT_LUN,':G_OUTPUT_LUN:',G_OUTPUT_LUN
write(*,*)'G_PTZ:',G_PTZ,':G_SYM:',G_SYM,':G_SYN:',trim(ade2str(G_SYN))
write(*,*)'G_CURRENT_RANDOM_SEED:',G_CURRENT_RANDOM_SEED,':G_CURRENT_RANDOM_TYPE:',G_CURRENT_RANDOM_TYPE
write(*,*)'G_FLOP_COUNTER:',G_FLOP_COUNTER
write(*,*)'G_DEBUG_LEVEL:',G_DEBUG_LEVEL
write(*,*)'G_FILE_OPEN_ERROR:',G_FILE_OPEN_ERROR,':G_ERR:',G_ERR
write(*,*)'G_LINECOUNT:',G_LINECOUNT
write(*,*)'G_BUF:',trim(ade2str(G_BUF))
write(*,*)'GM_BIGMEM:',GM_BIGMEM
write(*,*)'G_TOP_OF_SAVED:',G_TOP_OF_SAVED,':G_BOTTOM_OF_SCRATCH_IN_USE:',G_BOTTOM_OF_SCRATCH_IN_USE
do i=1,GG_MAX_NUMBER_OF_NAMES
   m=G_STACK_ROWS(i)
   n=G_STACK_COLS(i)
   l=G_STACK_ID_LOC(i)
   if(.not.(ade2str(G_STACK_IDS(:,i)).eq.''.and.l.eq.0.and.m.eq.0.and.n.eq.0))then
      write(*,*)i,ade2str(G_STACK_IDS(:,i)),l,m,n,'VALS=',real(GM_REALS(l:l+m*n-1))
   endif
enddo
end subroutine printit
end module M_matrix

      PROGRAM BIGMAT
      CALL MATLAB(0)
      STOP
      END PROGRAM BIGMAT

      SUBROUTINE CLAUSE
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER FOR(4),WHILE(4),IFF(4),ELSE(4),ENND(4),DO(4),THENN(4)
      INTEGER SEMI,EQUAL,EOL,BLANK,R
      INTEGER OP,COMMA,LESS,GREAT,NAME
      LOGICAL EQID
      DOUBLE PRECISION E1,E2
      DATA SEMI/39/,EQUAL/46/,EOL/99/,BLANK/36/
      DATA COMMA/48/,LESS/50/,GREAT/51/,NAME/1/
      DATA FOR/15,24,27,36/,WHILE/32,17,18,21/,IFF/18,15,36,36/
      DATA ELSE/14,21,28,14/,ENND/14,23,13,36/
      DATA DO/13,24,36,36/,THENN/29,17,14,23/
      SAVE SEMI,EQUAL,EOL,BLANK
      SAVE COMMA,LESS,GREAT,NAME
      SAVE FOR,WHILE,IFF
      SAVE ELSE,ENND
      SAVE DO,THENN
      R = -FIN-10
      FIN = 0
      IF (DDT == 1) WRITE(WTE,100) PT,RSTK(PT),R
  100 FORMAT(1X,'CLAUSE',3I4)
      IF (R<1 .OR. R>6) GOTO 01
      GOTO (02,30,30,80,99,90),R
   01 R = RSTK(PT)
      GOTO (99,99,05,40,45,99,99,99,99,99,99,99,15,55,99,99,99),R
   02 CALL GETSYM
      IF (SYM /= NAME) CALL ERROR(34)
      IF (ERR > 0) RETURN
      PT = PT+2
      CALL PUTID(IDS(1,PT),SYN)
      CALL GETSYM
      IF (SYM /= EQUAL) CALL ERROR(34)
      IF (ERR > 0) RETURN
      CALL GETSYM
      RSTK(PT) = 3
      RETURN
   05 PSTK(PT-1) = 0
      PSTK(PT) = LPT(4) - 1
      IF (EQID(SYN,DO)) SYM = SEMI
      IF (SYM == COMMA) SYM = SEMI
      IF (SYM /= SEMI) CALL ERROR(34)
      IF (ERR > 0) RETURN
   10 J = PSTK(PT-1)
      LPT(4) = PSTK(PT)
      SYM = SEMI
      CHRA = BLANK
      J = J+1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      LJ = L+(J-1)*M
      L2 = L + M*N
      IF (M /= -3) GOTO 12
      LJ = L+3
      L2 = LJ
      STKR(LJ) = STKR(L) + DFLOAT(J-1)*STKR(L+1)
      STKI(LJ) = 0.0
      IF (STKR(L+1)>0.0D0 .AND. STKR(LJ)>STKR(L+2)) GOTO 20
      IF (STKR(L+1)<0.0D0 .AND. STKR(LJ)<STKR(L+2)) GOTO 20
      M = 1
      N = J
   12 IF (J > N) GOTO 20
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L2
      MSTK(TOP) = M
      NSTK(TOP) = 1
      ERR = L2+M - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(M,STKR(LJ),STKI(LJ),1,STKR(L2),STKI(L2),1)
      RHS = 0
      CALL STACKP(IDS(1,PT))
      IF (ERR > 0) RETURN
      PSTK(PT-1) = J
      PSTK(PT) = LPT(4)
      RSTK(PT) = 13
      RETURN
   15 GOTO 10
   20 MSTK(TOP) = 0
      NSTK(TOP) = 0
      RHS = 0
      CALL STACKP(IDS(1,PT))
      IF (ERR > 0) RETURN
      PT = PT-2
      GOTO 80
   30 PT = PT+1
      CALL PUTID(IDS(1,PT),SYN)
      PSTK(PT) = LPT(4)-1
   35 LPT(4) = PSTK(PT)
      CHRA = BLANK
      CALL GETSYM
      RSTK(PT) = 4
      RETURN
   40 IF (SYM/=EQUAL .AND. SYM/=LESS .AND. SYM/=GREAT)&
          CALL ERROR(35)
      IF (ERR > 0) RETURN
      OP = SYM
      CALL GETSYM
      IF (SYM==EQUAL .OR. SYM==GREAT) OP = OP + SYM
      IF (OP > GREAT) CALL GETSYM
      PSTK(PT) = 256*PSTK(PT) + OP
      RSTK(PT) = 5
      RETURN
   45 OP = MOD(PSTK(PT),256)
      PSTK(PT) = PSTK(PT)/256
      L = LSTK(TOP-1)
      E1 = STKR(L)
      L = LSTK(TOP)
      E2 = STKR(L)
      TOP = TOP - 2
      IF (EQID(SYN,DO) .OR. EQID(SYN,THENN)) SYM = SEMI
      IF (SYM == COMMA) SYM = SEMI
      IF (SYM /= SEMI) CALL ERROR(35)
      IF (ERR > 0) RETURN
      IF (OP==EQUAL         .AND. E1==E2) GOTO 50
      IF (OP==LESS          .AND. E1<E2) GOTO 50
      IF (OP==GREAT         .AND. E1>E2) GOTO 50
      IF (OP==(LESS+EQUAL)  .AND. E1<=E2) GOTO 50
      IF (OP==(GREAT+EQUAL) .AND. E1>=E2) GOTO 50
      IF (OP==(LESS+GREAT)  .AND. E1/=E2) GOTO 50
      PT = PT-1
      GOTO 80
   50 RSTK(PT) = 14
      RETURN
   55 IF (EQID(IDS(1,PT),WHILE)) GOTO 35
      PT = PT-1
      IF (EQID(SYN,ELSE)) GOTO 80
      RETURN
   80 KOUNT = 0
      CALL GETSYM
   82 IF (SYM == EOL) RETURN
      IF (SYM /= NAME) GOTO 83
      IF (EQID(SYN,ENND) .AND. KOUNT==0) RETURN
      IF (EQID(SYN,ELSE) .AND. KOUNT==0) RETURN
      IF (EQID(SYN,ENND) .OR. EQID(SYN,ELSE))&
             KOUNT = KOUNT-1
      IF (EQID(SYN,FOR) .OR. EQID(SYN,WHILE)&
             .OR. EQID(SYN,IFF)) KOUNT = KOUNT+1
   83 CALL GETSYM
      GOTO 82
   90 IF (DDT == 1) WRITE(WTE,190) (RSTK(I),I=1,PT)
  190 FORMAT(1X,'EXIT  ',10I4)
      IF (RSTK(PT) == 14) PT = PT-1
      IF (PT <= PTZ) RETURN
      IF (RSTK(PT) == 14) PT = PT-1
      IF (PT-1 <= PTZ) RETURN
      IF (RSTK(PT) == 13) TOP = TOP-1
      IF (RSTK(PT) == 13) PT = PT-2
      GOTO 80
   99 CALL ERROR(22)
      IF (ERR > 0) RETURN
      RETURN
      END SUBROUTINE CLAUSE

      SUBROUTINE COMAND(ID)
      INTEGER ID(4)
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER CMD(4,17),CMDL,A,D,E,Z,LRECL,CH,BLANK,NAME,DOT,H(4)
      INTEGER SEMI,COMMA,EOL
      DOUBLE PRECISION URAND
      LOGICAL EQID
      DATA CMDL/17/,A/10/,D/13/,E/14/,Z/35/,EOL/99/,SEMI/39/,COMMA/48/
      DATA BLANK/36/,NAME/1/,DOT/47/
      SAVE CMDL,A,D,E,Z,EOL,SEMI,COMMA,BLANK,NAME,DOT
      DATA CMD/&
        12,21,14,10, 14,21,28,14, 14,23,13,36, 14,33,18,29,&
        15,24,27,36, 17,14,21,25, 18,15,36,36, 21,24,23,16,&
        27,14,29,30, 28,14,22,18,&
        28,17,24,27, 32,17,10,29, 32,17,18,21,&
        32,17,24,36, 32,17,34,36, 21,10,21,10, 15,30,12,20/
      DATA LRECL/80/
      save LRECL
  101 FORMAT(80A1)
  102 FORMAT(1X,80A1)
      IF (DDT == 1) WRITE(WTE,100)
  100 FORMAT(1X,'COMAND')
      FUN = 0
      DO 10 K = 1, CMDL
        IF (EQID(ID,CMD(1,K))) GOTO 20
   10 CONTINUE
      FIN = 0
      RETURN
   20 IF (CHRA==COMMA .OR. CHRA==SEMI .OR. CHRA==EOL) GOTO 22
      IF (CHRA<=Z .OR. K==6) GOTO 22
      CALL ERROR(16)
      RETURN
   22 FIN = 1
      GOTO (25,36,38,40,30,80,34,52,44,55,50,65,32,60,70,46,48),K
   25 IF (CHRA>=A .AND. CHRA<=Z) GOTO 26
      BOT = LSIZE-3
      GOTO 98
   26 CALL GETSYM
      TOP = TOP+1
      MSTK(TOP) = 0
      NSTK(TOP) = 0
      RHS = 0
      CALL STACKP(SYN)
      IF (ERR > 0) RETURN
      FIN = 1
      GOTO 98
   30 FIN = -11
      GOTO 99
   32 FIN = -12
      GOTO 99
   34 FIN = -13
      GOTO 99
   36 FIN = -14
      GOTO 99
   38 FIN = -15
      GOTO 99
   40 IF (PT > PTZ) FIN = -16
      IF (PT > PTZ) GOTO 98
      K = IDINT(STKR(VSIZE-2))
      WRITE(WTE,140) K
      IF (WIO /= 0) WRITE(WIO,140) K
  140 FORMAT(/1X,'total flops ',I9//1X,'ADIOS'/)
      FUN = 99
      GOTO 98
   44 K = LPT(1) - 7
      IF (K <= 0) FUN = 99
      IF (K <= 0) GOTO 98
      CALL FILES(-RIO,BUF)
      LPT(1) = LIN(K+1)
      LPT(4) = LIN(K+2)
      LPT(6) = LIN(K+3)
      PTZ = LIN(K+4)
      RIO = LIN(K+5)
      LCT(4) = LIN(K+6)
      CHRA = BLANK
      SYM = COMMA
      GOTO 99
   46 WRITE(WTE,146)
  146 FORMAT(1X,'QUIT SINGING AND GET BACK TO WORK.')
      GOTO 98
   48 WRITE(WTE,148)
  148 FORMAT(1X,'YOUR PLACE OR MINE')
      GOTO 98
   50 FMT = 1
      GOTO 54
   52 FMT = 2
   54 IF (CHRA==E .OR. CHRA==D) FMT = FMT+2
      IF (CHRA == Z) FMT = 5
      IF (CHRA==E .OR. CHRA==D .OR. CHRA==Z) CALL GETSYM
      GOTO 98
   55 LCT(3) = 1 - LCT(3)
      GOTO 98
   60 WRITE(WTE,160)
      IF (WIO /= 0) WRITE(WIO,160)
  160 FORMAT(1X,'Your current variables are...')
      CALL PRNTID(IDSTK(1,BOT),LSIZE-BOT+1)
      L = VSIZE-LSTK(BOT)+1
      WRITE(WTE,161) L,VSIZE
      IF (WIO /= 0) WRITE(WIO,161) L,VSIZE
  161 FORMAT(1X,'using ',I7,' out of ',I7,' elements.')
      GOTO 98
   65 WRITE(WTE,165)
  165 FORMAT(1X,'The functions and commands are...')
      H(1) = 0
      CALL FUNS(H)
      CALL PRNTID(CMD,CMDL-2)
      GOTO 98
   70 K = IDINT(9.0D0*URAND(RAN(1))+1.0D0)
      GOTO (71,72,73,74,75,76,77,78,79),K
   71 WRITE(WTE,171)
  171 FORMAT(1X,'WHAT?')
      GOTO 98
   72 WRITE(WTE,172)
  172 FORMAT(1X,'R.T.F.M.')
      GOTO 98
   73 WRITE(WTE,173)
  173 FORMAT(1X,'HOW THE HELL SHOULD I KNOW?')
      GOTO 98
   74 WRITE(WTE,174)
  174 FORMAT(1X,'PETE MADE ME DO IT.')
      GOTO 98
   75 WRITE(WTE,175)
  175 FORMAT(1X,'INSUFFICIENT DATA TO ANSWER.')
      GOTO 98
   76 WRITE(WTE,176)
  176 FORMAT(1X,'IT FEELS GOOD.')
      GOTO 98
   77 WRITE(WTE,177)
  177 FORMAT(1X,'WHY NOT?')
      GOTO 98
   78 WRITE(WTE,178)
  178 FORMAT(1X,'/--ERROR'/1X,'STUPID QUESTION.')
      GOTO 98
   79 WRITE(WTE,179)
  179 FORMAT(1X,'SYSTEM ERROR, RETRY')
      GOTO 98
   80 IF (CHRA /= EOL) GOTO 81
      WRITE(WTE,180)
      IF (WIO /= 0) WRITE(WIO,180)
  180 FORMAT(1X,'Type HELP followed by ...'&
        /1X,'INTRO   (To get started)'&
        /1X,'NEWS    (recent revisions)')
      H(1) = 0
      CALL FUNS(H)
      CALL PRNTID(CMD,CMDL-2)
      J = BLANK+2
      WRITE(WTE,181)
      IF (WIO /= 0) WRITE(WIO,181)
  181 FORMAT(1X,'ANS   EDIT  FILE  FUN   MACRO')
      WRITE(WTE,182) (ALFA(I),I=J,ALFL)
      IF (WIO /= 0) WRITE(WIO,182) (ALFA(I),I=J,ALFL)
  182 FORMAT(1X,17(A1,1X)/)
      GOTO 98
   81 CALL GETSYM
      IF (SYM == NAME) GOTO 82
      IF (SYM == 0) SYM = DOT
      H(1) = ALFA(SYM+1)
      H(2) = ALFA(BLANK+1)
      H(3) = ALFA(BLANK+1)
      H(4) = ALFA(BLANK+1)
      GOTO 84
   82 DO 83 I = 1, 4
        CH = SYN(I)
        H(I) = ALFA(CH+1)
   83 CONTINUE
   84 IF(HIO /= 0) THEN
      READ(HIO,101,END=89) (BUF(I),I=1,LRECL)
      DO 85 I = 1, 4
        IF (H(I) /= BUF(I)) GOTO 84
   85 CONTINUE
      WRITE(WTE,102)
      IF (WIO /= 0) WRITE(WIO,102)
   86 K = LRECL + 1
   87 K = K - 1
      IF (BUF(K) == ALFA(BLANK+1)) GOTO 87
      WRITE(WTE,102) (BUF(I),I=1,K)
      IF (WIO /= 0) WRITE(WIO,102) (BUF(I),I=1,K)
      READ(HIO,101) (BUF(I),I=1,LRECL)
      IF (BUF(1) == ALFA(BLANK+1)) GOTO 86
      CALL FILES(-HIO,BUF)
      GOTO 98
      ENDIF
   89 WRITE(WTE,189) (H(I),I=1,4)
  189 FORMAT(1X,'SORRY, NO HELP ON ',4A1)
      CALL FILES(-HIO,BUF)
      GOTO 98
   98 CALL GETSYM
   99 RETURN
      END SUBROUTINE COMAND

      SUBROUTINE EDIT(BUF,N)
      INTEGER BUF(N)
      RETURN
      END SUBROUTINE EDIT

      SUBROUTINE ERROR(N)
      INTEGER N
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      CHARACTER*80 BLH
      BLH(1:80)='        '
      K = LPT(2) - LPT(1)
      IF (K < 1) K = 1
      LUNIT = WTE
   98 CONTINUE
      WRITE(LUNIT,'(1X,A,''/--ERROR'',A1)') BLH(1:K),ERRMSG,CHAR(7)
      GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,&
            23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40),N
    1 WRITE(LUNIT,101)
  101 FORMAT(1X,'IMPROPER MULTIPLE ASSIGNMENT')
      GOTO 99
    2 WRITE(LUNIT,102)
  102 FORMAT(1X,'IMPROPER FACTOR')
      GOTO 99
    3 WRITE(LUNIT,103)
  103 FORMAT(1X,'EXPECT RIGHT PARENTHESIS')
      GOTO 99
    4 DO 94 I = 1, 4
         K = IDS(I,PT+1)
         BUF(I) = ALFA(K+1)
   94 CONTINUE
      WRITE(LUNIT,104) (BUF(I),I=1,4)
  104 FORMAT(1X,'UNDEFINED VARIABLE: ',4A1)
      GOTO 99
    5 WRITE(LUNIT,105)
  105 FORMAT(1X,'COLUMN LENGTHS DO NOT MATCH')
      GOTO 99
    6 WRITE(LUNIT,106)
  106 FORMAT(1X,'ROW LENGTHS DO NOT MATCH')
      GOTO 99
    7 WRITE(LUNIT,107)
  107 FORMAT(1X,'TEXT TOO LONG')
      GOTO 99
    8 WRITE(LUNIT,108)
  108 FORMAT(1X,'INCOMPATIBLE FOR ADDITION')
      GOTO 99
    9 WRITE(LUNIT,109)
  109 FORMAT(1X,'INCOMPATIBLE FOR SUBTRACTION')
      GOTO 99
   10 WRITE(LUNIT,110)
  110 FORMAT(1X,'INCOMPATIBLE FOR MULTIPLICATION')
       GOTO 99
   11 WRITE(LUNIT,111)
  111 FORMAT(1X,'INCOMPATIBLE FOR RIGHT DIVISION')
      GOTO 99
   12 WRITE(LUNIT,112)
  112 FORMAT(1X,'INCOMPATIBLE FOR LEFT DIVISION')
      GOTO 99
   13 WRITE(LUNIT,113)
  113 FORMAT(1X,'IMPROPER ASSIGNMENT TO PERMANENT VARIABLE')
      GOTO 99
   14 WRITE(LUNIT,114)
  114 FORMAT(1X,'EYE-DENTITY UNDEFINED BY CONTEXT')
      GOTO 99
   15 WRITE(LUNIT,115)
  115 FORMAT(1X,'IMPROPER ASSIGNMENT TO SUBMATRIX')
      GOTO 99
   16 WRITE(LUNIT,116)
  116 FORMAT(1X,'IMPROPER COMMAND')
      GOTO 99
   17 LB = VSIZE - LSTK(BOT) + 1
      LT = ERR + LSTK(BOT)
      WRITE(LUNIT,117) LB,LT,VSIZE
  117 FORMAT(1X,'TOO MUCH MEMORY REQUIRED'&
        /1X,' ',I7,' VARIABLES,',I7,' TEMPORARIES,',I7,' AVAILABLE.')
      GOTO 99
   18 WRITE(LUNIT,118)
  118 FORMAT(1X,'TOO MANY NAMES')
      GOTO 99
   19 WRITE(LUNIT,119)
  119 FORMAT(1X,'MATRIX IS SINGULAR TO WORKING PRECISION')
      GOTO 99
   20 WRITE(LUNIT,120)
  120 FORMAT(1X,'MATRIX MUST BE SQUARE')
      GOTO 99
   21 WRITE(LUNIT,121)
  121 FORMAT(1X,'SUBSCRIPT OUT OF RANGE')
      GOTO 99
   22 WRITE(LUNIT,122) (RSTK(I),I=1,PT)
  122 FORMAT(1X,'RECURSION DIFFICULTIES',10I4)
      GOTO 99
   23 WRITE(LUNIT,123)
  123 FORMAT(1X,'ONLY 1, 2 OR INF NORM OF MATRIX')
      GOTO 99
   24 WRITE(LUNIT,124)
  124 FORMAT(1X,'NO CONVERGENCE')
      GOTO 99
   25 WRITE(LUNIT,125)
  125 FORMAT(1X,'CAN NOT USE FUNCTION NAME AS VARIABLE')
      GOTO 99
   26 WRITE(LUNIT,126)
  126 FORMAT(1X,'TOO COMPLICATED (STACK OVERFLOW)')
      GOTO 99
   27 WRITE(LUNIT,127)
  127 FORMAT(1X,'DIVISION BY ZERO IS A NO-NO')
      GOTO 99
   28 WRITE(LUNIT,128)
  128 FORMAT(1X,'EMPTY MACRO')
      GOTO 99
   29 WRITE(LUNIT,129)
  129 FORMAT(1X,'NOT POSITIVE DEFINITE')
      GOTO 99
   30 WRITE(LUNIT,130)
  130 FORMAT(1X,'IMPROPER EXPONENT')
      GOTO 99
   31 WRITE(LUNIT,131)
  131 FORMAT(1X,'IMPROPER STRING')
      GOTO 99
   32 WRITE(LUNIT,132)
  132 FORMAT(1X,'SINGULARITY OF LOG OR ATAN')
      GOTO 99
   33 WRITE(LUNIT,133)
  133 FORMAT(1X,'TOO MANY COLONS')
      GOTO 99
   34 WRITE(LUNIT,134)
  134 FORMAT(1X,'IMPROPER FOR CLAUSE')
      GOTO 99
   35 WRITE(LUNIT,135)
  135 FORMAT(1X,'IMPROPER WHILE OR IF CLAUSE')
      GOTO 99
   36 WRITE(LUNIT,136)
  136 FORMAT(1X,'ARGUMENT OUT OF RANGE')
      GOTO 99
   37 WRITE(LUNIT,137)
  137 FORMAT(1X,'IMPROPER MACRO')
      GOTO 99
   38 WRITE(LUNIT,138)
  138 FORMAT(1X,'IMPROPER FILE NAME')
      GOTO 99
   39 WRITE(LUNIT,139)
  139 FORMAT(1X,'INCORRECT NUMBER OF ARGUMENTS')
      GOTO 99
   40 WRITE(LUNIT,140)
  140 FORMAT(1X,'EXPECT STATEMENT TERMINATOR')
      GOTO 99
   99 ERR = N
      IF (LUNIT==WIO .OR. WIO==0) RETURN
      LUNIT = WIO
      GOTO 98
      END SUBROUTINE ERROR

      SUBROUTINE EXPR
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER OP,R,BLANK,SIGN,PLUS,MINUS,NAME,COLON,EYE(4)
      DATA COLON/40/,BLANK/36/,PLUS/41/,MINUS/42/,NAME/1/
      DATA EYE/14,34,14,36/
      SAVE COLON,BLANK,PLUS,MINUS,NAME,EYE
      IF (DDT == 1) WRITE(WTE,100) PT,RSTK(PT)
  100 FORMAT(1X,'EXPR  ',2I4)
      R = RSTK(PT)
      GOTO (01,01,01,01,01,05,25,99,99,01,01,99,99,99,99,99,99,01,01,&
             01),R
   01 IF (SYM == COLON) CALL PUTID(SYN,EYE)
      IF (SYM == COLON) SYM = NAME
      KOUNT = 1
   02 SIGN = PLUS
      IF (SYM == MINUS) SIGN = MINUS
      IF (SYM==PLUS .OR. SYM==MINUS) CALL GETSYM
      PT = PT+1
      IF (PT > PSIZE-1) CALL ERROR(26)
      IF (ERR > 0) RETURN
      PSTK(PT) = SIGN + 256*KOUNT
      RSTK(PT) = 6
      RETURN
   05 SIGN = MOD(PSTK(PT),256)
      KOUNT = PSTK(PT)/256
      PT = PT-1
      IF (SIGN == MINUS) CALL STACK1(MINUS)
      IF (ERR > 0) RETURN
   10 IF (SYM==PLUS .OR. SYM==MINUS) GOTO 20
      GOTO 50
   20 IF (RSTK(PT) /= 10) GOTO 21
      LS = LPT(3) - 2
      IF (LIN(LS) == BLANK) GOTO 50
   21 OP = SYM
      CALL GETSYM
      PT = PT+1
      PSTK(PT) = OP + 256*KOUNT
      RSTK(PT) = 7
      RETURN
   25 OP = MOD(PSTK(PT),256)
      KOUNT = PSTK(PT)/256
      PT = PT-1
      CALL STACK2(OP)
      IF (ERR > 0) RETURN
      GOTO 10
   50 IF (SYM /= COLON) GOTO 60
      CALL GETSYM
      KOUNT = KOUNT+1
      GOTO 02
   60 IF (KOUNT > 3) CALL ERROR(33)
      IF (ERR > 0) RETURN
      RHS = KOUNT
      IF (KOUNT > 1) CALL STACK2(COLON)
      IF (ERR > 0) RETURN
      RETURN
   99 CALL ERROR(22)
      IF (ERR > 0) RETURN
      RETURN
      END SUBROUTINE EXPR

      SUBROUTINE FACTOR
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER SEMI,EOL,BLANK,R,ID(4),EXCNT,LPAREN,RPAREN
      INTEGER STAR,DSTAR,COMMA,LESS,GREAT,QUOTE,NUM,NAME,ALFL
      DATA DSTAR/54/,SEMI/39/,EOL/99/,BLANK/36/
      DATA STAR/43/,COMMA/48/,LPAREN/37/,RPAREN/38/
      DATA LESS/50/,GREAT/51/,QUOTE/49/,NUM/0/,NAME/1/,ALFL/52/
      SAVE DSTAR,SEMI,EOL,BLANK
      SAVE STAR,COMMA,LPAREN,RPAREN
      SAVE LESS,GREAT,QUOTE,NUM,NAME,ALFL
      IF (DDT == 1) WRITE(WTE,100) PT,RSTK(PT),SYM
  100 FORMAT(1X,'FACTOR',3I4)
      R = RSTK(PT)
      GOTO (99,99,99,99,99,99,99,01,01,25,45,65,99,99,99,55,75,32,37),R
   01 IF (SYM==NUM .OR. SYM==QUOTE .OR.  SYM==LESS) GOTO 10
      IF (SYM == GREAT) GOTO 30
      EXCNT = 0
      IF (SYM == NAME) GOTO 40
      ID(1) = BLANK
      IF (SYM == LPAREN) GOTO 42
      CALL ERROR(2)
      IF (ERR > 0) RETURN
   10 L = 1
      IF (TOP > 0) L = LSTK(TOP) + MSTK(TOP)*NSTK(TOP)
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L
      IF (SYM == QUOTE) GOTO 15
      IF (SYM == LESS) GOTO 20
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      STKR(L) = STKI(VSIZE)
      STKI(L) = 0.0D0
      CALL GETSYM
      GOTO 60
   15 N = 0
      LPT(4) = LPT(3)
      CALL GETCH
   16 IF (CHRA == QUOTE) GOTO 18
   17 LN = L+N
      IF (CHRA == EOL) CALL ERROR(31)
      IF (ERR > 0) RETURN
      STKR(LN) = DFLOAT(CHRA)
      STKI(LN) = 0.0D0
      N = N+1
      CALL GETCH
      GOTO 16
   18 CALL GETCH
      IF (CHRA == QUOTE) GOTO 17
      IF (N <= 0) CALL ERROR(31)
      IF (ERR > 0) RETURN
      MSTK(TOP) = 1
      NSTK(TOP) = N
      CALL GETSYM
      GOTO 60
   20 MSTK(TOP) = 0
      NSTK(TOP) = 0
   21 TOP = TOP + 1
      LSTK(TOP) = LSTK(TOP-1) + MSTK(TOP-1)*NSTK(TOP-1)
      MSTK(TOP) = 0
      NSTK(TOP) = 0
      CALL GETSYM
   22 IF (SYM==SEMI .OR. SYM==GREAT .OR. SYM==EOL) GOTO 27
      IF (SYM == COMMA) CALL GETSYM
      PT = PT+1
      RSTK(PT) = 10
      RETURN
   25 PT = PT-1
      TOP = TOP - 1
      IF (MSTK(TOP) == 0) MSTK(TOP) = MSTK(TOP+1)
      IF (MSTK(TOP) /= MSTK(TOP+1)) CALL ERROR(5)
      IF (ERR > 0) RETURN
      NSTK(TOP) = NSTK(TOP) + NSTK(TOP+1)
      GOTO 22
   27 IF (SYM==SEMI .AND. CHRA==EOL) CALL GETSYM
      CALL STACK1(QUOTE)
      IF (ERR > 0) RETURN
      TOP = TOP - 1
      IF (MSTK(TOP) == 0) MSTK(TOP) = MSTK(TOP+1)
      IF (MSTK(TOP)/=MSTK(TOP+1) .AND. MSTK(TOP+1)>0) CALL ERROR(6)
      IF (ERR > 0) RETURN
      NSTK(TOP) = NSTK(TOP) + NSTK(TOP+1)
      IF (SYM == EOL) CALL GETLIN
      IF (SYM /= GREAT) GOTO 21
      CALL STACK1(QUOTE)
      IF (ERR > 0) RETURN
      CALL GETSYM
      GOTO 60
   30 CALL GETSYM
      IF (SYM==LESS .AND. CHRA==EOL) CALL ERROR(28)
      IF (ERR > 0) RETURN
      PT = PT+1
      RSTK(PT) = 18
      RETURN
   32 PT = PT-1
      IF (SYM/=LESS .AND. SYM/=EOL) CALL ERROR(37)
      IF (ERR > 0) RETURN
      IF (SYM == LESS) CALL GETSYM
      K = LPT(6)
      LIN(K+1) = LPT(1)
      LIN(K+2) = LPT(2)
      LIN(K+3) = LPT(6)
      LPT(1) = K + 4
      K = LPT(1)
      L = LSTK(TOP)
      N = MSTK(TOP)*NSTK(TOP)
      DO 34 J = 1, N
         LS = L + J-1
         LIN(K) = IDINT(STKR(LS))
         IF (LIN(K)<0 .OR. LIN(K)>=ALFL) CALL ERROR(37)
         IF (ERR > 0) RETURN
         IF (K<1024) K = K+1
         IF (K==1024) WRITE(WTE,33) K
   33    FORMAT(1X,'INPUT BUFFER LIMIT IS ',I4,' CHARACTERS.')
   34 CONTINUE
      TOP = TOP-1
      LIN(K) = EOL
      LPT(6) = K
      LPT(4) = LPT(1)
      LPT(3) = 0
      LPT(2) = 0
      LCT(1) = 0
      CHRA = BLANK
      CALL GETSYM
      PT = PT+1
      RSTK(PT) = 19
      RETURN
   37 PT = PT-1
      K = LPT(1) - 4
      LPT(1) = LIN(K+1)
      LPT(4) = LIN(K+2)
      LPT(6) = LIN(K+3)
      CHRA = BLANK
      CALL GETSYM
      GOTO 60
   40 CALL PUTID(ID,SYN)
      CALL GETSYM
      IF (SYM == LPAREN) GOTO 42
      RHS = 0
      CALL FUNS(ID)
      IF (FIN /= 0) CALL ERROR(25)
      IF (ERR > 0) RETURN
      CALL STACKG(ID)
      IF (ERR > 0) RETURN
      IF (FIN == 7) GOTO 50
      IF (FIN == 0) CALL PUTID(IDS(1,PT+1),ID)
      IF (FIN == 0) CALL ERROR(4)
      IF (ERR > 0) RETURN
      GOTO 60
   42 CALL GETSYM
      EXCNT = EXCNT+1
      PT = PT+1
      PSTK(PT) = EXCNT
      CALL PUTID(IDS(1,PT),ID)
      RSTK(PT) = 11
      RETURN
   45 CALL PUTID(ID,IDS(1,PT))
      EXCNT = PSTK(PT)
      PT = PT-1
      IF (SYM == COMMA) GOTO 42
      IF (SYM /= RPAREN) CALL ERROR(3)
      IF (ERR > 0) RETURN
      IF (SYM == RPAREN) CALL GETSYM
      IF (ID(1) == BLANK) GOTO 60
      RHS = EXCNT
      CALL STACKG(ID)
      IF (ERR > 0) RETURN
      IF (FIN == 0) CALL FUNS(ID)
      IF (FIN == 0) CALL ERROR(4)
      IF (ERR > 0) RETURN
   50 PT = PT+1
      RSTK(PT) = 16
      RETURN
   55 PT = PT-1
      GOTO 60
   60 IF (SYM /= QUOTE) GOTO 62
         I = LPT(3) - 2
         IF (LIN(I) == BLANK) GOTO 90
         CALL STACK1(QUOTE)
         IF (ERR > 0) RETURN
         CALL GETSYM
   62 IF (SYM/=STAR .OR. CHRA/=STAR) GOTO 90
      CALL GETSYM
      CALL GETSYM
      PT = PT+1
      RSTK(PT) = 12
      GOTO 01
   65 PT = PT-1
      CALL STACK2(DSTAR)
      IF (ERR > 0) RETURN
      IF (FUN /= 2) GOTO 90
      PT = PT+1
      RSTK(PT) = 17
      RETURN
   75 PT = PT-1
   90 RETURN
   99 CALL ERROR(22)
      IF (ERR > 0) RETURN
      RETURN
      END SUBROUTINE FACTOR

      SUBROUTINE FILES(LUNIT,INAME)
      INTEGER LUNIT
      INTEGER INAME(256)
      character*1024 NAME
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      character*1024 NAME2
      integer*1 strip(4,256),strip2(32)
      character*32 NAME3
      equivalence (NAME2,strip),(NAME3,strip2)
      WRITE(NAME,'(256A4)')(INAME(I),I=1,256)
      FE=0
      IF (LUNIT == 0) RETURN
      !if (LUNIT == RTE) return
      !if (LUNIT == WTE) return
      if (LUNIT == 5) return
      if (LUNIT == 6) return
      if (LUNIT == 11) then
         OPEN(11,FILE='matlab88_help.txt',STATUS='OLD',ERR=14)
         write(WTE,'(/,1X,''HELP is available'')')
         return
      elseif (LUNIT == -11 .AND. HIO /= 0) then
         rewind (11,ERR=99)
         return
      elseif (LUNIT < 0) then
         close(unit=-LUNIT,ERR=99)
         return
      end if
   10 continue
      NAME2=NAME
      do 37 j=1,32
   37 strip2(j)=strip(1,j)
      OPEN(UNIT=LUNIT,FILE=NAME3,STATUS='UNKNOWN',ERR=98)
      RETURN
   14 CONTINUE
      WRITE(WTE,'(1x,''HELP IS NOT AVAILABLE'')')
      HIO = 0
      RETURN
   98 WRITE(WTE,'(1X,''OPEN FILE FAILED'')')
      FE=1
      IF(LUNIT == 8) THEN
        WIO=0
      ELSE
        RIO=RTE
      ENDIF
      RETURN
   99 CONTINUE
      RETURN
      END SUBROUTINE FILES

      DOUBLE PRECISION FUNCTION FLOP(X)
      DOUBLE PRECISION X
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION MASK(14),XX,MM
      real mas(2,14)
      LOGICAL LX(2),LM(2)
      EQUIVALENCE (LX(1),XX),(LM(1),MM)
      equivalence (MASK(1),mas(1,1))
      data mas/&
       Z'ffffffff',Z'fff0ffff',&
       Z'ffffffff',Z'ff00ffff',&
       Z'ffffffff',Z'f000ffff',&
       Z'ffffffff',Z'0000ffff',&
       Z'ffffffff',Z'0000fff0',&
       Z'ffffffff',Z'0000ff00',&
       Z'ffffffff',Z'0000f000',&
       Z'ffffffff',Z'00000000',&
       Z'fff0ffff',Z'00000000',&
       Z'ff00ffff',Z'00000000',&
       Z'f000ffff',Z'00000000',&
       Z'0000ffff',Z'00000000',&
       Z'0000fff0',Z'00000000',&
       Z'0000ff80',Z'00000000'/
      save mas
      FLP(1) = FLP(1) + 1
      K = FLP(2)
      FLOP = X
      IF (K <= 0) RETURN
      FLOP = 0.0D0
      IF (K >= 15) RETURN
      XX = X
      MM = MASK(K)
      LX(1) = LX(1) .AND. LM(1)
      LX(2) = LX(2) .AND. LM(2)
      FLOP = XX
      RETURN
      END FUNCTION FLOP

      SUBROUTINE FORMZ(LUNIT,X,Y)
      DOUBLE PRECISION X,Y
      IF (Y /= 0.0D0) WRITE(LUNIT,10) X,Y
      IF (Y == 0.0D0) WRITE(LUNIT,10) X
   10 FORMAT(2Z18)
      RETURN
      END SUBROUTINE FORMZ

      SUBROUTINE FUNS(ID)
      INTEGER ID(4)
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      LOGICAL EQID
      INTEGER FUNL,FUNN(4,57),FUNP(57)
      DATA FUNL/57/
      DATA FUNN/&
        10,11,28,36, 10,29,10,23, 11,10,28,14, 12,17,10,27,&
        12,17,24,21, 12,17,24,25, 12,24,23,13, 12,24,23,19,&
        12,24,28,36, 13,14,29,36, 13,18,10,16, 13,18,10,27,&
        13,18,28,25, 14,18,16,36, 14,25,28,36, 14,33,14,12,&
        14,33,25,36, 14,34,14,36, 15,21,24,25, 17,14,28,28,&
        17,18,21,11, 18,22,10,16, 18,23,31,36, 20,27,24,23,&
        21,18,23,14, 21,24,10,13, 21,24,16,36, 21,30,36,36,&
        22,10,16,18, 23,24,27,22, 24,23,14,28, 24,27,29,17,&
        25,18,23,31, 25,21,24,29, 25,24,21,34, 25,27,18,23,&
        25,27,24,13, 26,27,36,36, 27,10,23,13, 27,10,23,20,&
        27,10,29,36, 27,12,24,23, 27,14,10,21, 27,24,24,29,&
        27,24,30,23, 27,27,14,15, 28,10,31,14, 28,12,17,30,&
        28,18,23,36, 28,18,35,14, 28,26,27,29, 28,30,22,36,&
        28,31,13,36, 29,27,18,21, 29,27,18,30, 30,28,14,27,&
        13,14,11,30/
      DATA FUNP/&
        221,203,507,509, 106,609,303,225, 202,102,602,505,&
        506,211,000,501, 204,606,000,213, 105,224,101,611,&
        508,503,206,104, 601,304,608,402, 302,510,214,504,&
        604,401,607,305, 511,103,223,215, 222,107,502,212,&
        201,610,205,603, 301,614,615,605, 512/
      save funl, funn, funp
      IF (ID(1)==0) CALL PRNTID(FUNN,FUNL-1)
      IF (ID(1)==0) RETURN
      DO 10 K = 1, FUNL
         IF (EQID(ID,FUNN(1,K))) GOTO 20
   10 CONTINUE
      FIN = 0
      RETURN
   20 FIN = MOD(FUNP(K),100)
      FUN = FUNP(K)/100
      IF (RHS==0 .AND. FUNP(K)==606) FIN = 0
      IF (RHS==0 .AND. FUNP(K)==607) FIN = 0
      RETURN
      END SUBROUTINE FUNS
      SUBROUTINE GETCH
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER EOL
      DATA EOL/99/
      save EOL
      L = LPT(4)
      CHRA = LIN(L)
      IF (CHRA /= EOL) LPT(4) = L + 1
      RETURN
      END SUBROUTINE GETCH

      SUBROUTINE GETLIN
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER LRECL,EOL,SLASH,BSLASH,DOT,BLANK,RETU(4)
      DATA EOL/99/,DOT/47/,BLANK/36/,RETU/27,14,29,30/
      DATA SLASH/44/,BSLASH/45/,LRECL/80/
      SAVE  EOL, DOT, BLANK, RETU, SLASH, BSLASH, LRECL
   10 L = LPT(1)
   11 DO 12 J = 1, LRECL
         BUF(J) = ALFA(BLANK+1)
   12 CONTINUE
      READ(RIO,101,END=50,ERR=15) (BUF(J),J=1,LRECL)
  101 FORMAT(80A1)
      N = LRECL+1
   15 N = N-1
      IF (BUF(N) == ALFA(BLANK+1)) GOTO 15
      IF (MOD(LCT(4),2) == 1) WRITE(WTE,102) (BUF(J),J=1,N)
      IF (WIO /= 0) WRITE(WIO,102) (BUF(J),J=1,N)
  102 FORMAT(1X,80A1)
      DO 40 J = 1, N
         DO 20 K = 1, ALFL
           IF (BUF(J)==ALFA(K) .OR. BUF(J)==ALFB(K)) GOTO 30
   20    CONTINUE
         K = EOL+1
         IF (K > EOL) GOTO 10
         IF (K == EOL) GOTO 45
         IF (K == -1) L = L-1
         IF (K <= 0) GOTO 40
   30    K = K-1
         IF (K==SLASH .AND. BUF(J+1)==BUF(J)) GOTO 45
         IF (K==DOT .AND. BUF(J+1)==BUF(J)) GOTO 11
         IF (K==BSLASH .AND. N==1) GOTO 60
         LIN(L) = K
         IF (L<1024) L = L+1
         IF (L==1024) WRITE(WTE,33) L
   33    FORMAT(1X,'INPUT BUFFER LIMIT IS ',I4,' CHARACTERS.')
   40 CONTINUE
   45 LIN(L) = EOL
      LPT(6) = L
      LPT(4) = LPT(1)
      LPT(3) = 0
      LPT(2) = 0
      LCT(1) = 0
      CALL GETCH
      RETURN
   50 IF (RIO == RTE) GOTO 52
      CALL PUTID(LIN(L),RETU)
      L = L + 4
      GOTO 45
   52 CALL FILES(-RTE,BUF)
      LIN(L) = EOL
      RETURN
   60 N = LPT(6) - LPT(1)
      DO 61 I = 1, N
         J = L+I-1
         K = LIN(J)
         BUF(I) = ALFA(K+1)
         IF (CASE==1 .AND. K<36) BUF(I) = ALFB(K+1)
   61 CONTINUE
      CALL EDIT(BUF,N)
      N = N + 1
      GOTO 15
      END SUBROUTINE GETLIN

      SUBROUTINE GETSYM
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION SYV,S,FLOP
      INTEGER BLANK,Z,DOT,D,E,PLUS,MINUS,NAME,NUM,SIGN,CHCNT,EOL
      INTEGER STAR,SLASH,BSLASH,SS
      DATA BLANK/36/,Z/35/,DOT/47/,D/13/,E/14/,EOL/99/,PLUS/41/
      DATA MINUS/42/,NAME/1/,NUM/0/,STAR/43/,SLASH/44/,BSLASH/45/
      SAVE BLANK,Z,DOT,D,E,EOL,PLUS,MINUS,NAME,NUM,STAR,SLASH,BSLASH
   10 IF (CHRA /= BLANK) GOTO 20
      CALL GETCH
      GOTO 10
   20 LPT(2) = LPT(3)
      LPT(3) = LPT(4)
      IF (CHRA <= 9) GOTO 50
      IF (CHRA <= Z) GOTO 30
      SS = SYM
      SYM = CHRA
      CALL GETCH
      IF (SYM /= DOT) GOTO 90
      SYV = 0.0D0
      IF (CHRA <= 9) GOTO 55
      IF (CHRA==STAR.OR.CHRA==SLASH.OR.CHRA==BSLASH) GOTO 90
      IF (SS==STAR .OR. SS==SLASH .OR. SS==BSLASH) GOTO 90
      GOTO 55
   30 SYM = NAME
      SYN(1) = CHRA
      CHCNT = 1
   40 CALL GETCH
      CHCNT = CHCNT+1
      IF (CHRA > Z) GOTO 45
      IF (CHCNT <= 4) SYN(CHCNT) = CHRA
      GOTO 40
   45 IF (CHCNT > 4) GOTO 47
      DO 46 I = CHCNT, 4
   46 SYN(I) = BLANK
   47 CONTINUE
      GOTO 90
   50 CALL GETVAL(SYV)
      IF (CHRA /= DOT) GOTO 60
      CALL GETCH
   55 CHCNT = LPT(4)
      CALL GETVAL(S)
      CHCNT = LPT(4) - CHCNT
      IF (CHRA == EOL) CHCNT = CHCNT+1
      SYV = SYV + S/10.0D0**CHCNT
   60 IF (CHRA/=D .AND. CHRA/=E) GOTO 70
      CALL GETCH
      SIGN = CHRA
      IF (SIGN==MINUS .OR. SIGN==PLUS) CALL GETCH
      CALL GETVAL(S)
      IF (SIGN /= MINUS) SYV = SYV*10.0D0**S
      IF (SIGN == MINUS) SYV = SYV/10.0D0**S
   70 STKI(VSIZE) = FLOP(SYV)
      SYM = NUM
   90 IF (CHRA /= BLANK) GOTO 99
      CALL GETCH
      GOTO 90
   99 IF (DDT /= 1) RETURN
      IF (SYM>NAME .AND. SYM<ALFL) WRITE(WTE,197) ALFA(SYM+1)
      IF (SYM >= ALFL) WRITE(WTE,198)
      IF (SYM == NAME) CALL PRNTID(SYN,1)
      IF (SYM == NUM) WRITE(WTE,199) SYV
  197 FORMAT(1X,A1)
  198 FORMAT(1X,'EOL')
  199 FORMAT(1X,G8.2)
      RETURN
      END SUBROUTINE GETSYM

      SUBROUTINE GETVAL(S)
      DOUBLE PRECISION S
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      S = 0.0D0
   10 IF (CHRA > 9) RETURN
      S = 10.0D0*S + CHRA
      CALL GETCH
      GOTO 10
      END SUBROUTINE GETVAL

      SUBROUTINE MATFN1
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION DTR(2),DTI(2),SR,SI,RCOND,T,T0,T1,FLOP,EPS,WASUM
      IF (DDT == 1) WRITE(WTE,100) FIN
  100 FORMAT(1X,'MATFN1',I4)
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (FIN == -1) GOTO 10
      IF (FIN == -2) GOTO 20
      GOTO (30,40,50,60,70,80,85),FIN
   10 L2 = LSTK(TOP+1)
      M2 = MSTK(TOP+1)
      N2 = NSTK(TOP+1)
      IF (M2 /= N2) CALL ERROR(20)
      IF (ERR > 0) RETURN
      IF (M*N == 1) GOTO 16
      IF (N /= N2) CALL ERROR(11)
      IF (ERR > 0) RETURN
      L3 = L2 + M2*N2
      ERR = L3+N2 - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WGECO(STKR(L2),STKI(L2),M2,N2,BUF,RCOND,STKR(L3),STKI(L3))
      IF (RCOND == 0.0D0) CALL ERROR(19)
      IF (ERR > 0) RETURN
      T = FLOP(1.0D0 + RCOND)
      IF (T==1.0D0 .AND. FUN/=21) WRITE(WTE,11) RCOND
      IF (T==1.0D0 .AND. FUN/=21 .AND. WIO/=0) WRITE(WIO,11) RCOND
   11 FORMAT(1X,'WARNING.'&
        /1X,'MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.'&
        /1X,'RESULTS MAY BE INACCURATE.  RCOND =', 1PD13.4/)
      IF (T==1.0D0 .AND. FUN==21) WRITE(WTE,12) RCOND
      IF (T==1.0D0 .AND. FUN==21 .AND. WIO/=0) WRITE(WIO,12) RCOND
   12 FORMAT(1X,'WARNING.'&
        /1X,'EIGENVECTORS ARE BADLY CONDITIONED.'&
        /1X,'RESULTS MAY BE INACCURATE.  RCOND =', 1PD13.4/)
      DO 15 I = 1, M
         DO 13 J = 1, N
            LS = L+I-1+(J-1)*M
            LL = L3+J-1
            STKR(LL) = STKR(LS)
            STKI(LL) = -STKI(LS)
   13    CONTINUE
         CALL WGESL(STKR(L2),STKI(L2),M2,N2,BUF,STKR(L3),STKI(L3),1)
         DO 14 J = 1, N
            LL = L+I-1+(J-1)*M
            LS = L3+J-1
            STKR(LL) = STKR(LS)
            STKI(LL) = -STKI(LS)
   14    CONTINUE
   15 CONTINUE
      IF (FUN /= 21) GOTO 99
      SR = WASUM(N*N,STKR(L),STKR(L),1)
      SI = WASUM(N*N,STKI(L),STKI(L),1)
      EPS = STKR(VSIZE-4)
      T = EPS*SR
      IF (DDT == 18) WRITE(WTE,115) SR,SI,EPS,T
  115 FORMAT(1X,'SR,SI,EPS,T',1P4D13.4)
      IF (SI <= EPS*SR) CALL RSET(N*N,0.0D0,STKI(L),1)
      GOTO 99
   16 SR = STKR(L)
      SI = STKI(L)
      N = N2
      M = N
      MSTK(TOP) = N
      NSTK(TOP) = N
      CALL WCOPY(N*N,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      GOTO 30
   20 L2 = LSTK(TOP+1)
      M2 = MSTK(TOP+1)
      N2 = NSTK(TOP+1)
      IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      IF (M2*N2 == 1) GOTO 26
      L3 = L2 + M2*N2
      ERR = L3+N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WGECO(STKR(L),STKI(L),M,N,BUF,RCOND,STKR(L3),STKI(L3))
      IF (RCOND == 0.0D0) CALL ERROR(19)
      IF (ERR > 0) RETURN
      T = FLOP(1.0D0 + RCOND)
      IF (T == 1.0D0) WRITE(WTE,11) RCOND
      IF (T==1.0D0 .AND. WIO/=0) WRITE(WIO,11) RCOND
      IF (M2 /= N) CALL ERROR(12)
      IF (ERR > 0) RETURN
      DO 23 J = 1, N2
         LJ = L2+(J-1)*M2
         CALL WGESL(STKR(L),STKI(L),M,N,BUF,STKR(LJ),STKI(LJ),0)
   23 CONTINUE
      NSTK(TOP) = N2
      CALL WCOPY(M2*N2,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      GOTO 99
   26 SR = STKR(L2)
      SI = STKI(L2)
      GOTO 30
   30 IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      IF (DDT == 17) GOTO 32
      DO 31 J = 1, N
      DO 31 I = 1, N
        LS = L+I-1+(J-1)*N
        T0 = STKR(LS)
        T1 = FLOP(1.0D0/(DFLOAT(I+J-1)))
        IF (T0 /= T1) GOTO 32
   31 CONTINUE
      GOTO 72
   32 L3 = L + N*N
      ERR = L3+N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WGECO(STKR(L),STKI(L),M,N,BUF,RCOND,STKR(L3),STKI(L3))
      IF (RCOND == 0.0D0) CALL ERROR(19)
      IF (ERR > 0) RETURN
      T = FLOP(1.0D0 + RCOND)
      IF (T == 1.0D0) WRITE(WTE,11) RCOND
      IF (T==1.0D0 .AND. WIO/=0) WRITE(WIO,11) RCOND
      CALL WGEDI(STKR(L),STKI(L),M,N,BUF,DTR,DTI,STKR(L3),STKI(L3),1)
      IF (FIN < 0) CALL WSCAL(N*N,SR,SI,STKR(L),STKI(L),1)
      GOTO 99
   40 IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      CALL WGEFA(STKR(L),STKI(L),M,N,BUF,INFO)
      CALL WGEDI(STKR(L),STKI(L),M,N,BUF,DTR,DTI,SR,SI,10)
      K = IDINT(DTR(2))
      KA = IABS(K)+2
      T = 1.0D0
      DO 41 I = 1, KA
         T = T/10.0D0
         IF (T == 0.0D0) GOTO 42
   41 CONTINUE
      STKR(L) = DTR(1)*10.D0**K
      STKI(L) = DTI(1)*10.D0**K
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      GOTO 99
   42 IF (DTI(1) == 0.0D0) WRITE(WTE,43) DTR(1),K
      IF (DTI(1) /= 0.0D0) WRITE(WTE,44) DTR(1),DTI(1),K
   43 FORMAT(1X,'DET =  ',F7.4,7H * 10**,I4)
   44 FORMAT(1X,'DET =  ',F7.4,' + ',F7.4,' i ',7H * 10**,I4)
      STKR(L) = DTR(1)
      STKI(L) = DTI(1)
      STKR(L+1) = DTR(2)
      STKI(L+1) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 2
      GOTO 99
   50 IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      L3 = L + N*N
      ERR = L3+N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WGECO(STKR(L),STKI(L),M,N,BUF,RCOND,STKR(L3),STKI(L3))
      STKR(L) = RCOND
      STKI(L) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      IF (LHS == 1) GOTO 99
      L = L + 1
      CALL WCOPY(N,STKR(L3),STKI(L3),1,STKR(L),STKI(L),1)
      TOP = TOP + 1
      LSTK(TOP) = L
      MSTK(TOP) = N
      NSTK(TOP) = 1
      GOTO 99
   60 IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      CALL WGEFA(STKR(L),STKI(L),M,N,BUF,INFO)
      IF (LHS /= 2) GOTO 99
      NN = N*N
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L + NN
      MSTK(TOP) = N
      NSTK(TOP) = N
      ERR = L+NN+NN - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      DO 64 KB = 1, N
        K = N+1-KB
        DO 61 I = 1, N
          LL = L+I-1+(K-1)*N
          LU = LL + NN
          IF (I <= K) STKR(LU) = STKR(LL)
          IF (I <= K) STKI(LU) = STKI(LL)
          IF (I > K) STKR(LU) = 0.0D0
          IF (I > K) STKI(LU) = 0.0D0
          IF (I < K) STKR(LL) = 0.0D0
          IF (I < K) STKI(LL) = 0.0D0
          IF (I == K) STKR(LL) = 1.0D0
          IF (I == K) STKI(LL) = 0.0D0
          IF (I > K) STKR(LL) = -STKR(LL)
          IF (I > K) STKI(LL) = -STKI(LL)
   61   CONTINUE
        I = BUF(K)
        IF (I == K) GOTO 64
        LI = L+I-1+(K-1)*N
        LK = L+K-1+(K-1)*N
        CALL WSWAP(N-K+1,STKR(LI),STKI(LI),N,STKR(LK),STKI(LK),N)
   64 CONTINUE
      GOTO 99
   70 N = IDINT(STKR(L))
      MSTK(TOP) = N
      NSTK(TOP) = N
   72 CALL HILBER(STKR(L),N,N)
      CALL RSET(N*N,0.0D0,STKI(L),1)
      IF (FIN < 0) CALL WSCAL(N*N,SR,SI,STKR(L),STKI(L),1)
      GOTO 99
   80 IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      CALL WPOFA(STKR(L),STKI(L),M,N,ERR)
      IF (ERR /= 0) CALL ERROR(29)
      IF (ERR > 0) RETURN
      DO 81 J = 1, N
        LL = L+J+(J-1)*M
        CALL WSET(M-J,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
   81 CONTINUE
      GOTO 99
   85 IF (RHS < 2) GOTO 86
        TOP = TOP-1
        L = LSTK(TOP)
        IF (MSTK(TOP) /= M) CALL ERROR(5)
        IF (ERR > 0) RETURN
        N = N + NSTK(TOP)
   86 CALL RREF(STKR(L),STKI(L),M,M,N,STKR(VSIZE-4))
      NSTK(TOP) = N
      GOTO 99
   99 RETURN
      END SUBROUTINE MATFN1

         SUBROUTINE MATFN2
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION PYTHAG,ROUND,TR,TI,SR,SI,POWR,POWI,FLOP
      LOGICAL HERM,SCHUR,VECT,HESS
      IF (DDT == 1) WRITE(WTE,100) FIN
  100 FORMAT(1X,'MATFN2',I4)
      IF (FIN /= 0) GOTO 05
         L = LSTK(TOP+1)
         POWR = STKR(L)
         POWI = STKI(L)
   05 L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (FIN >= 11 .AND. FIN <= 13) GOTO 10
      IF (FIN == 14 .AND. (M==1 .OR. N==1)) GOTO 50
      IF (FIN == 14) GOTO 10
      IF (FIN == 15) GOTO 60
      IF (FIN > 20) GOTO 40
      IF (M == 1 .OR. N == 1) GOTO 40
   10 IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      SCHUR = FIN == 12
      HESS = FIN == 13
      VECT = LHS==2 .OR. FIN<10
      NN = N*N
      L2 = L + NN
      LD = L2 + NN
      LE = LD + N
      LW = LE + N
      ERR = LW+N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(NN,STKR(L),STKI(L),1,STKR(L2),STKI(L2),1)
      DO 15 J = 1, N
      DO 15 I = 1, J
         LS = L+I-1+(J-1)*N
         LL = L+(I-1)*N+J-1
         HERM = STKR(LL)==STKR(LS) .AND. STKI(LL)==-STKI(LS)
         IF (.NOT. HERM) GOTO 30
   15 CONTINUE
      CALL WSET(NN,0.0D0,0.0D0,STKR(L),STKI(L),1)
      CALL WSET(N,1.0D0,0.0D0,STKR(L),STKI(L),N+1)
      CALL WSET(N,0.0D0,0.0D0,STKI(LD),STKI(LE),1)
      JOB = 0
      IF (VECT) JOB = 1
      CALL HTRIDI(N,N,STKR(L2),STKI(L2),STKR(LD),STKR(LE),&
                  STKR(LE),STKR(LW))
      IF (.NOT.HESS) CALL IMTQL2(N,N,STKR(LD),STKR(LE),STKR(L),ERR,JOB)
      IF (ERR > 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
      IF (JOB /= 0)&
        CALL HTRIBK(N,N,STKR(L2),STKI(L2),STKR(LW),N,STKR(L),STKI(L))
      GOTO 31
   30 CALL CORTH(N,N,1,N,STKR(L2),STKI(L2),STKR(LW),STKI(LW))
      IF (.NOT.VECT .AND. HESS) GOTO 31
      JOB = 0
      IF (VECT) JOB = 2
      IF (VECT .AND. SCHUR) JOB = 1
      IF (HESS) JOB = 3
      CALL COMQR3(N,N,1,N,STKR(LW),STKI(LW),STKR(L2),STKI(L2),&
                  STKR(LD),STKI(LD),STKR(L),STKI(L),ERR,JOB)
      IF (ERR > 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
   31 IF (.NOT.VECT) GOTO 34
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L2
      MSTK(TOP) = N
      NSTK(TOP) = N
   34 IF (.NOT.VECT .AND. .NOT.SCHUR .AND. .NOT.HESS) GOTO 37
      DO 36 J = 1, N
         LJ = L2+(J-1)*N
         IF (SCHUR .AND. (.NOT.HERM)) LJ = LJ+J
         IF (HESS .AND. (.NOT.HERM)) LJ = LJ+J+1
         LL = L2+J*N-LJ
         CALL WSET(LL,0.0D0,0.0D0,STKR(LJ),STKI(LJ),1)
   36 CONTINUE
      IF (.NOT.HESS .OR. HERM)&
         CALL WCOPY(N,STKR(LD),STKI(LD),1,STKR(L2),STKI(L2),N+1)
      LL = L2+1
      IF (HESS .AND. HERM)&
         CALL WCOPY(N-1,STKR(LE+1),STKI(LE+1),1,STKR(LL),STKI(LL),N+1)
      LL = L2+N
      IF (HESS .AND. HERM)&
         CALL WCOPY(N-1,STKR(LE+1),STKI(LE+1),1,STKR(LL),STKI(LL),N+1)
      IF (FIN < 10) GOTO 42
      IF (VECT .OR. .NOT.(SCHUR.OR.HESS)) GOTO 99
      CALL WCOPY(NN,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      GOTO 99
   37 IF (FIN == 14) GOTO 52
      CALL WCOPY(N,STKR(LD),STKI(LD),1,STKR(L),STKI(L),1)
      NSTK(TOP) = 1
      GOTO 99
   40 INC = 1
      N = M*N
      L2 = L
      GOTO 44
   42 INC = N+1
   44 DO 46 J = 1, N
        LS = L2+(J-1)*INC
        SR = STKR(LS)
        SI = STKI(LS)
        TI = 0.0D0
        IF (FIN /= 0) GOTO 45
          CALL WLOG(SR,SI,SR,SI)
          CALL WMUL(SR,SI,POWR,POWI,SR,SI)
          TR = DEXP(SR)*DCOS(SI)
          TI = DEXP(SR)*DSIN(SI)
   45   IF (FIN == 1) TR = DSIN(SR)*DCOSH(SI)
        IF (FIN == 1) TI = DCOS(SR)*DSINH(SI)
        IF (FIN == 2) TR = DCOS(SR)*DCOSH(SI)
        IF (FIN == 2) TI = (-DSIN(SR))*DSINH(SI)
        IF (FIN == 3) CALL WATAN(SR,SI,TR,TI)
        IF (FIN == 4) TR = DEXP(SR)*DCOS(SI)
        IF (FIN == 4) TI = DEXP(SR)*DSIN(SI)
        IF (FIN == 5) CALL WSQRT(SR,SI,TR,TI)
        IF (FIN == 6) CALL WLOG(SR,SI,TR,TI)
        IF (FIN == 21) TR = PYTHAG(SR,SI)
        IF (FIN == 22) TR = ROUND(SR)
        IF (FIN == 23) TR = SR
        IF (FIN == 24) TR = SI
        IF (FIN == 25) TR = SR
        IF (FIN == 25) TI = -SI
        IF (ERR > 0) RETURN
        STKR(LS) = FLOP(TR)
        STKI(LS) = 0.0D0
        IF (TI /= 0.0D0) STKI(LS) = FLOP(TI)
   46 CONTINUE
      IF (INC == 1) GOTO 99
      DO 48 J = 1, N
        LS = L2+(J-1)*INC
        SR = STKR(LS)
        SI = STKI(LS)
        LS = L+(J-1)*N
        LL = L2+(J-1)*N
        CALL WCOPY(N,STKR(LS),STKI(LS),1,STKR(LL),STKI(LL),1)
        CALL WSCAL(N,SR,SI,STKR(LS),STKI(LS),1)
   48 CONTINUE
      FUN = 21
      FIN = -1
      TOP = TOP-1
      GOTO 99
   50 N = MAX0(M,N)
      LD = L+N+1
      CALL WCOPY(N,STKR(L),STKI(L),1,STKR(LD),STKI(LD),1)
   52 CALL WSET(N+1,0.0D0,0.0D0,STKR(L),STKI(L),1)
      STKR(L) = 1.0D0
      DO 56 J = 1, N
         CALL WAXPY(J,-STKR(LD),-STKI(LD),STKR(L),STKI(L),-1,&
                    STKR(L+1),STKI(L+1),-1)
         LD = LD+1
   56 CONTINUE
      MSTK(TOP) = N+1
      NSTK(TOP) = 1
      GOTO 99
   60 LL = L+M*N
      STKR(LL) = -1.0D0
      STKI(LL) = 0.0D0
      K = -1
   61 K = K+1
      L1 = L+K
      IF (DABS(STKR(L1))+DABS(STKI(L1)) == 0.0D0) GOTO 61
      N = MAX0(M*N - K-1, 0)
      IF (N <= 0) GOTO 65
      L2 = L1+N+1
      LW = L2+N*N
      ERR = LW+N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WSET(N*N+N,0.0D0,0.0D0,STKR(L2),STKI(L2),1)
      DO 64 J = 1, N
         LL = L2+J+(J-1)*N
         STKR(LL) = 1.0D0
         LS = L1+J
         LL = L2+(J-1)*N
         CALL WDIV(-STKR(LS),-STKI(LS),STKR(L1),STKI(L1),&
                   STKR(LL),STKI(LL))
         IF (ERR > 0) RETURN
   64 CONTINUE
      CALL COMQR3(N,N,1,N,STKR(LW),STKI(LW),STKR(L2),STKI(L2),&
                  STKR(L),STKI(L),TR,TI,ERR,0)
      IF (ERR > 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
   65 MSTK(TOP) = N
      NSTK(TOP) = 1
      GOTO 99
   99 RETURN
      END SUBROUTINE MATFN2

      SUBROUTINE MATFN3
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      LOGICAL FRO,INF
      DOUBLE PRECISION P,S,T,TOL,EPS
      DOUBLE PRECISION WDOTCR,WDOTCI,PYTHAG,WNRM2,WASUM,FLOP
      IF (DDT == 1) WRITE(WTE,100) FIN
  100 FORMAT(1X,'MATFN3',I4)
      IF (FIN==1 .AND. RHS==2) TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      MN = M*N
      GOTO (50,70,10,30,70), FIN
   10 LD = L + M*N
      L1 = LD + MIN0(M+1,N)
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),&
                 STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),&
                 0,ERR)
      IF (ERR /= 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
      S = STKR(LD)
      LD = LD + MIN0(M,N) - 1
      T = STKR(LD)
      IF (T == 0.0D0) GOTO 13
      STKR(L) = FLOP(S/T)
      STKI(L) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      GOTO 99
   13 WRITE(WTE,14)
      IF (WIO /= 0) WRITE(WIO,14)
   14 FORMAT(1X,'CONDITION IS INFINITE')
      MSTK(TOP) = 0
      GOTO 99
   30 P = 2.0D0
      INF = .FALSE.
      IF (RHS /= 2) GOTO 31
      FRO = IDINT(STKR(L))==15 .AND. MN>1
      INF = IDINT(STKR(L))==18 .AND. MN>1
      IF (.NOT. FRO) P = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      MN = M*N
      IF (FRO) M = MN
      IF (FRO) N = 1
   31 IF (M > 1 .AND. N > 1) GOTO 40
      IF (P == 1.0D0) GOTO 36
      IF (P == 2.0D0) GOTO 38
      I = IWAMAX(MN,STKR(L),STKI(L),1) + L - 1
      S = DABS(STKR(I)) + DABS(STKI(I))
      IF (INF .OR. S == 0.0D0) GOTO 49
      T = 0.0D0
      DO 33 I = 1, MN
         LS = L+I-1
         T = FLOP(T + (PYTHAG(STKR(LS),STKI(LS))/S)**P)
   33 CONTINUE
      IF (P /= 0.0D0) P = 1.0D0/P
      S = FLOP(S*T**P)
      GOTO 49
   36 S = WASUM(MN,STKR(L),STKI(L),1)
      GOTO 49
   38 S = WNRM2(MN,STKR(L),STKI(L),1)
      GOTO 49
   40 IF (INF) GOTO 43
      IF (P == 1.0D0) GOTO 46
      IF (P /= 2.0D0) CALL ERROR(23)
      IF (ERR > 0) RETURN
      LD = L + M*N
      L1 = LD + MIN0(M+1,N)
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),&
                 STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),&
                 0,ERR)
      IF (ERR /= 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
      S = STKR(LD)
      GOTO 49
   43 S = 0.0D0
      DO 45 I = 1, M
         LI = L+I-1
         T = WASUM(N,STKR(LI),STKI(LI),M)
         S = DMAX1(S,T)
   45 CONTINUE
      GOTO 49
   46 S = 0.0D0
      DO 48 J = 1, N
         LJ = L+(J-1)*M
         T = WASUM(M,STKR(LJ),STKI(LJ),1)
         S = DMAX1(S,T)
   48 CONTINUE
      GOTO 49
   49 STKR(L) = S
      STKI(L) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      GOTO 99
   50 IF (LHS /= 3) GOTO 52
      K = M
      IF (RHS == 2) K = MIN0(M,N)
      LU = L + M*N
      LD = LU + M*K
      LV = LD + K*N
      L1 = LV + N*N
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      JOB = 11
      IF (RHS == 2) JOB = 21
      CALL WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),&
              STKR(L1),STKI(L1),STKR(LU),STKI(LU),M,STKR(LV),STKI(LV),&
              N,STKR(L2),STKI(L2),JOB,ERR)
      DO 51 JB = 1, N
      DO 51 I = 1, K
        J = N+1-JB
        LL = LD+I-1+(J-1)*K
        IF (I/=J) STKR(LL) = 0.0D0
        STKI(LL) = 0.0D0
        LS = LD+I-1
        IF (I==J) STKR(LL) = STKR(LS)
        LS = L1+I-1
        IF (ERR/=0 .AND. I==J-1) STKR(LL) = STKR(LS)
   51 CONTINUE
      IF (ERR /= 0) CALL ERROR(24)
      ERR = 0
      CALL WCOPY(M*K+K*N+N*N,STKR(LU),STKI(LU),1,STKR(L),STKI(L),1)
      MSTK(TOP) = M
      NSTK(TOP) = K
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L + M*K
      MSTK(TOP) = K
      NSTK(TOP) = N
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L + M*K + K*N
      MSTK(TOP) = N
      NSTK(TOP) = N
      GOTO 99
   52 LD = L + M*N
      L1 = LD + MIN0(M+1,N)
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),&
                 STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),&
                 0,ERR)
      IF (ERR /= 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
      K = MIN0(M,N)
      CALL WCOPY(K,STKR(LD),STKI(LD),1,STKR(L),STKI(L),1)
      MSTK(TOP) = K
      NSTK(TOP) = 1
      GOTO 99
   70 TOL = -1.0D0
      IF (RHS /= 2) GOTO 71
      TOL = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
   71 LU = L + M*N
      LD = LU + M*M
      IF (FIN == 5) LD = L + M*N
      LV = LD + M*N
      L1 = LV + N*N
      IF (FIN == 5) L1 = LD + N
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      IF (FIN == 2) JOB = 11
      IF (FIN == 5) JOB = 0
      CALL WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),&
              STKR(L1),STKI(L1),STKR(LU),STKI(LU),M,STKR(LV),STKI(LV),&
              N,STKR(L2),STKI(L2),JOB,ERR)
      IF (ERR /= 0) CALL ERROR(24)
      IF (ERR > 0) RETURN
      EPS = STKR(VSIZE-4)
      IF (TOL < 0.0D0) TOL = FLOP(DFLOAT(MAX0(M,N))*EPS*STKR(LD))
      MN = MIN0(M,N)
      K = 0
      DO 72 J = 1, MN
        LS = LD+J-1
        S = STKR(LS)
        IF (S <= TOL) GOTO 73
        K = J
        LL = LV+(J-1)*N
        IF (FIN == 2) CALL WRSCAL(N,1.0D0/S,STKR(LL),STKI(LL),1)
   72 CONTINUE
   73 IF (FIN == 5) GOTO 78
      DO 76 J = 1, M
      DO 76 I = 1, N
        LL = L+I-1+(J-1)*N
        L1 = LV+I-1
        L2 = LU+J-1
        STKR(LL) = WDOTCR(K,STKR(L2),STKI(L2),M,STKR(L1),STKI(L1),N)
        STKI(LL) = WDOTCI(K,STKR(L2),STKI(L2),M,STKR(L1),STKI(L1),N)
   76 CONTINUE
      MSTK(TOP) = N
      NSTK(TOP) = M
      GOTO 99
   78 STKR(L) = DFLOAT(K)
      STKI(L) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      GOTO 99
   99 RETURN
      END SUBROUTINE MATFN3

      SUBROUTINE MATFN4
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION T,TOL,EPS,FLOP
      INTEGER QUOTE
      DATA QUOTE/49/
      save quote
      IF (DDT == 1) WRITE(WTE,100) FIN
  100 FORMAT(1X,'MATFN4',I4)
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (FIN == -1) GOTO 10
      IF (FIN == -2) GOTO 20
      GOTO 40
   10 L2 = LSTK(TOP+1)
      M2 = MSTK(TOP+1)
      N2 = NSTK(TOP+1)
      TOP = TOP + 1
      IF (N>1 .AND. N/=N2) CALL ERROR(11)
      IF (ERR > 0) RETURN
      CALL STACK1(QUOTE)
      IF (ERR > 0) RETURN
      LL = L2+M2*N2
      CALL WCOPY(M*N,STKR(L),STKI(L),1,STKR(LL),STKI(LL),1)
      CALL WCOPY(M*N+M2*N2,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      LSTK(TOP) = L+M2*N2
      MSTK(TOP) = M
      NSTK(TOP) = N
      CALL STACK1(QUOTE)
      IF (ERR > 0) RETURN
      TOP = TOP - 1
      M = N2
      N = M2
      GOTO 20
   20 L2 = LSTK(TOP+1)
      M2 = MSTK(TOP+1)
      N2 = NSTK(TOP+1)
      IF (M2*N2 > 1) GOTO 21
        M2 = M
        N2 = M
        ERR = L2+M*M - LSTK(BOT)
        IF (ERR > 0) CALL ERROR(17)
        IF (ERR > 0) RETURN
        CALL WSET(M*M-1,0.0D0,0.0D0,STKR(L2+1),STKI(L2+1),1)
        CALL WCOPY(M,STKR(L2),STKI(L2),0,STKR(L2),STKI(L2),M+1)
   21 IF (M2 /= M) CALL ERROR(12)
      IF (ERR > 0) RETURN
      L3 = L2 + MAX0(M,N)*N2
      L4 = L3 + N
      ERR = L4 + N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      IF (M > N) GOTO 23
      DO 22 JB = 1, N2
        J = N+1-JB
        LS = L2 + (J-1)*M
        LL = L2 + (J-1)*N
        CALL WCOPY(M,STKR(LS),STKI(LS),-1,STKR(LL),STKI(LL),-1)
   22 CONTINUE
   23 DO 24 J = 1, N
        BUF(J) = 0
   24 CONTINUE
      CALL WQRDC(STKR(L),STKI(L),M,M,N,STKR(L4),STKI(L4),&
                 BUF,STKR(L3),STKI(L3),1)
      K = 0
      EPS = STKR(VSIZE-4)
      T = DABS(STKR(L))+DABS(STKI(L))
      TOL = FLOP(DFLOAT(MAX0(M,N))*EPS*T)
      MN = MIN0(M,N)
      DO 27 J = 1, MN
        LS = L+J-1+(J-1)*M
        T = DABS(STKR(LS)) + DABS(STKI(LS))
        IF (T > TOL) K = J
   27 CONTINUE
      IF (K < MN) WRITE(WTE,28) K,TOL
      IF (K<MN .AND. WIO/=0) WRITE(WIO,28) K,TOL
   28 FORMAT(1X,'RANK DEFICIENT,  RANK =',I4,',  TOL =',1PD13.4)
      MN = MAX0(M,N)
      DO 29 J = 1, N2
        LS = L2+(J-1)*MN
        CALL WQRSL(STKR(L),STKI(L),M,M,K,STKR(L4),STKI(L4),&
                   STKR(LS),STKI(LS),T,T,STKR(LS),STKI(LS),&
                   STKR(LS),STKI(LS),T,T,T,T,100,INFO)
        LL = LS+K
        CALL WSET(N-K,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
   29 CONTINUE
      DO 31 J = 1, N
        BUF(J) = -BUF(J)
   31 CONTINUE
      DO 35 J = 1, N
        IF (BUF(J) > 0) GOTO 35
        K = -BUF(J)
        BUF(J) = K
   33   CONTINUE
          IF (K == J) GOTO 34
          LS = L2+J-1
          LL = L2+K-1
          CALL WSWAP(N2,STKR(LS),STKI(LS),MN,STKR(LL),STKI(LL),MN)
          BUF(K) = -BUF(K)
          K = BUF(K)
          GOTO 33
   34   CONTINUE
   35 CONTINUE
      DO 36 J = 1, N2
        LS = L2+(J-1)*MN
        LL = L+(J-1)*N
        CALL WCOPY(N,STKR(LS),STKI(LS),1,STKR(LL),STKI(LL),1)
   36 CONTINUE
      MSTK(TOP) = N
      NSTK(TOP) = N2
      IF (FIN == -1) CALL STACK1(QUOTE)
      IF (ERR > 0) RETURN
      GOTO 99
   40 MM = MAX0(M,N)
      LS = L + MM*MM
      IF (LHS==1 .AND. FIN==1) LS = L
      LE = LS + M*N
      L4 = LE + MM
      ERR = L4+MM - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      IF (LS/=L) CALL WCOPY(M*N,STKR(L),STKI(L),1,STKR(LS),STKI(LS),1)
      JOB = 1
      IF (LHS<3) JOB = 0
      DO 42 J = 1, N
        BUF(J) = 0
   42 CONTINUE
      CALL WQRDC(STKR(LS),STKI(LS),M,M,N,STKR(L4),STKI(L4),&
                  BUF,STKR(LE),STKI(LE),JOB)
      IF (LHS==1 .AND. FIN==1) GOTO 99
      CALL WSET(M*M,0.0D0,0.0D0,STKR(L),STKI(L),1)
      CALL WSET(M,1.0D0,0.0D0,STKR(L),STKI(L),M+1)
      DO 43 J = 1, M
        LL = L+(J-1)*M
        CALL WQRSL(STKR(LS),STKI(LS),M,M,N,STKR(L4),STKI(L4),&
                   STKR(LL),STKI(LL),STKR(LL),STKI(LL),T,T,&
                   T,T,T,T,T,T,10000,INFO)
   43 CONTINUE
      IF (FIN == 2) GOTO 99
      NSTK(TOP) = M
      DO 45 J = 1, N
        LL = LS+J+(J-1)*M
        CALL WSET(M-J,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
   45 CONTINUE
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = LS
      MSTK(TOP) = M
      NSTK(TOP) = N
      IF (LHS == 2) GOTO 99
      CALL WSET(N*N,0.0D0,0.0D0,STKR(LE),STKI(LE),1)
      DO 47 J = 1, N
        LL = LE+BUF(J)-1+(J-1)*N
        STKR(LL) = 1.0D0
   47 CONTINUE
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = LE
      MSTK(TOP) = N
      NSTK(TOP) = N
      GOTO 99
   99 RETURN
      END SUBROUTINE MATFN4

      SUBROUTINE MATFN5
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER EOL,CH,BLANK,FLAG,TOP2,PLUS,MINUS,QUOTE,SEMI,LRAT,MRAT
      INTEGER ID(4)
      DOUBLE PRECISION EPS,B,S,T,FLOP,WASUM
      LOGICAL TEXT
      DATA EOL/99/,BLANK/36/,PLUS/41/,MINUS/42/,QUOTE/49/,SEMI/39/
      DATA LRAT/5/,MRAT/100/
      SAVE EOL,BLANK,PLUS,MINUS,QUOTE,SEMI,LRAT,MRAT
      IF (DDT == 1) WRITE(WTE,100) FIN
  100 FORMAT(1X,'MATFN5',I4)
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (FIN > 5) GOTO 15
      MN = M*N
      FLAG = 3
      IF (SYM == SEMI) FLAG = 0
      IF (RHS < 2) GOTO 12
         FLAG = IDINT(STKR(L))
         TOP2 = TOP
         TOP = TOP-1
         L = LSTK(TOP)
         MN = MSTK(TOP)*NSTK(TOP)
   12 LUN = -1
      IF (MN==1 .AND. STKR(L)<10.0D0) LUN = IDINT(STKR(L))
      IF (LUN >= 0) GOTO 15
      DO 14 J = 1, 32
         LS = L+J-1
         IF (J <= MN) CH = IDINT(STKR(LS))
         IF (J > MN) CH = BLANK
         IF (CH<0 .OR. CH>=ALFL) CALL ERROR(38)
         IF (ERR > 0) RETURN
         IF (CASE == 0) BUF(J) = ALFA(CH+1)
         IF (CASE == 1) BUF(J) = ALFB(CH+1)
   14 CONTINUE
   15 GOTO (20,30,35,25,27,60,65,70,50,80,40,95),FIN
   20 IF (LUN == 0) GOTO 23
      K = LPT(6)
      LIN(K+1) = LPT(1)
      LIN(K+2) = LPT(3)
      LIN(K+3) = LPT(6)
      LIN(K+4) = PTZ
      LIN(K+5) = RIO
      LIN(K+6) = LCT(4)
      LPT(1) = K + 7
      LCT(4) = FLAG
      PTZ = PT - 4
      IF (RIO == RTE) RIO = 12
      RIO = RIO + 1
      IF (LUN > 0) RIO = LUN
      IF (LUN < 0) CALL FILES(RIO,BUF)
      IF (FLAG >= 4) WRITE(WTE,22)
   22 FORMAT(1X,'PAUSE MODE. ENTER BLANK LINES.')
      SYM = EOL
      MSTK(TOP) = 0
      GOTO 99
   23 RIO = RTE
      ERR = 99
      GOTO 99
   25 K = WTE
      WTE = LUN
      IF (LUN < 0) WTE = 7
      IF (LUN < 0) CALL FILES(WTE,BUF)
      L = LCT(2)
      LCT(2) = 9999
      IF (RHS > 1) CALL PRINT(SYN,TOP2)
      LCT(2) = L
      WTE = K
      MSTK(TOP) = 0
      GOTO 99
   27 WIO = LUN
      IF (LUN < 0) WIO = 8
      IF (LUN < 0) CALL FILES(WIO,BUF)
      MSTK(TOP) = 0
      GOTO 99
   30 IF (LUN < 0) LUNIT = 1
      IF (LUN < 0) CALL FILES(LUNIT,BUF)
      IF (LUN > 0) LUNIT = LUN
      K = LSIZE-4
      IF (K < BOT) K = LSIZE
      IF (RHS == 2) K = TOP2
      IF (RHS == 2) CALL PUTID(IDSTK(1,K),SYN)
   32 L = LSTK(K)
      M = MSTK(K)
      N = NSTK(K)
      DO 34 I = 1, 4
         J = IDSTK(I,K)+1
         BUF(I) = ALFA(J)
   34 CONTINUE
      IMG = 0
      IF (WASUM(M*N,STKI(L),STKI(L),1) /= 0.0D0) IMG = 1
      IF(FE == 0)CALL SAVLOD(LUNIT,BUF,M,N,IMG,0,STKR(L),STKI(L))
      K = K-1
      IF (K >= BOT) GOTO 32
      CALL FILES(-LUNIT,BUF)
      MSTK(TOP) = 0
      GOTO 99
   35 IF (LUN < 0) LUNIT = 2
      IF (LUN < 0) CALL FILES(LUNIT,BUF)
      IF (LUN > 0) LUNIT = LUN
   36 JOB = LSTK(BOT) - L
      IF(FE == 0)&
      CALL SAVLOD(LUNIT,ID,MSTK(TOP),NSTK(TOP),IMG,JOB,STKR(L),STKI(L))
      MN = MSTK(TOP)*NSTK(TOP)
      IF (MN == 0) GOTO 39
      IF (IMG == 0) CALL RSET(MN,0.0D0,STKI(L),1)
      DO 38 I = 1, 4
         J = 0
   37    J = J+1
         IF (ID(I)/=ALFA(J) .AND. J<=BLANK) GOTO 37
         ID(I) = J-1
   38 CONTINUE
      SYM = SEMI
      RHS = 0
      CALL STACKP(ID)
      TOP = TOP + 1
      GOTO 36
   39 CALL FILES(-LUNIT,BUF)
      MSTK(TOP) = 0
      GOTO 99
   40 IF (RHS == 2) GOTO 44
      MN = M*N
      L2 = L
      IF (LHS == 2) L2 = L + MN
      LW = L2 + MN
      ERR = LW + LRAT - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      IF (LHS == 2) TOP = TOP + 1
      LSTK(TOP) = L2
      MSTK(TOP) = M
      NSTK(TOP) = N
      CALL RSET(LHS*MN,0.0D0,STKI(L),1)
      DO 42 I = 1, MN
         CALL RAT(STKR(L),LRAT,MRAT,S,T,STKR(LW))
         STKR(L) = S
         STKR(L2) = T
         IF (LHS == 1) STKR(L) = FLOP(S/T)
         L = L + 1
         L2 = L2 + 1
   42 CONTINUE
      GOTO 99
   44 MRAT = IDINT(STKR(L))
      LRAT = IDINT(STKR(L-1))
      TOP = TOP - 1
      MSTK(TOP) = 0
      GOTO 99
   50 K = IABS(IDINT(STKR(L)))
      IF (M*N/=1 .OR. K>=ALFL) CALL ERROR(36)
      IF (ERR > 0) RETURN
      CH = ALFA(K+1)
      IF (STKR(L) < 0.0D0) CH = ALFB(K+1)
      WRITE(WTE,51) CH
   51 FORMAT(1X,'REPLACE CHARACTER ',A1)
      READ(RTE,52) CH
   52 FORMAT(A1)
      IF (STKR(L) >= 0.0D0) ALFA(K+1) = CH
      IF (STKR(L) < 0.0D0) ALFB(K+1) = CH
      MSTK(TOP) = 0
      GOTO 99
   60 WRITE(WTE,61)
      IF (WIO /= 0) WRITE(WIO,61)
   61 FORMAT(1X,80A1)
      IF (RHS == 2) GOTO 65
      MN = M*N
      TEXT = .TRUE.
      DO 62 I = 1, MN
        LS = L+I-1
        CH = IDINT(STKR(LS))
        TEXT = TEXT .AND. (CH>=0) .AND. (CH<ALFL)
        TEXT = TEXT .AND. (DFLOAT(CH)==STKR(LS))
   62 CONTINUE
      DO 64 I = 1, M
      DO 63 J = 1, N
        LS = L+I-1+(J-1)*M
        IF (STKR(LS) == 0.0D0) CH = BLANK
        IF (STKR(LS) > 0.0D0) CH = PLUS
        IF (STKR(LS) < 0.0D0) CH = MINUS
        IF (TEXT) CH = IDINT(STKR(LS))
        BUF(J) = ALFA(CH+1)
   63 CONTINUE
      WRITE(WTE,61) (BUF(J),J=1,N)
      IF (WIO /= 0) WRITE(WIO,61) (BUF(J),J=1,N)
   64 CONTINUE
      MSTK(TOP) = 0
      GOTO 99
   65 IF (RHS /= 2) CALL ERROR(39)
      IF (STKR(L) <= 1.0D0) CALL ERROR(36)
      IF (ERR > 0) RETURN
      B = STKR(L)
      L2 = L
      TOP = TOP-1
      RHS = 1
      L = LSTK(TOP)
      M = MSTK(TOP)*NSTK(TOP)
      EPS = STKR(VSIZE-4)
      DO 66 I = 1, M
         LS = L2+(I-1)*N
         LL = L+I-1
         CALL BASE(STKR(LL),B,EPS,STKR(LS),N)
   66 CONTINUE
      CALL RSET(M*N,0.0D0,STKI(L2),1)
      CALL WCOPY(M*N,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      MSTK(TOP) = N
      NSTK(TOP) = M
      CALL STACK1(QUOTE)
      IF (FIN == 6) GOTO 60
      GOTO 99
   70 LCT(2) = IDINT(STKR(L))
      MSTK(TOP) = 0
      GOTO 99
   80 IF (RHS >= 2) GOTO 82
      N = M*N
      DO 81 I = 1, N
         LL = L+I-1
         STKI(LL) = DFLOAT(I)
   81 CONTINUE
      CALL PLOT(WTE,STKI(L),STKR(L),N,T,0)
      IF (WIO /= 0) CALL PLOT(WIO,STKI(L),STKR(L),N,T,0)
      MSTK(TOP) = 0
      GOTO 99
   82 IF (RHS == 2) K = 0
      IF (RHS == 3) K = M*N
      IF (RHS > 3) K = RHS - 2
      TOP = TOP - (RHS - 1)
      N = MSTK(TOP)*NSTK(TOP)
      IF (MSTK(TOP+1)*NSTK(TOP+1) /= N) CALL ERROR(5)
      IF (ERR > 0) RETURN
      LX = LSTK(TOP)
      LY = LSTK(TOP+1)
      IF (RHS > 3) L = LSTK(TOP+2)
      CALL PLOT(WTE,STKR(LX),STKR(LY),N,STKR(L),K)
      IF (WIO /= 0) CALL PLOT(WIO,STKR(LX),STKR(LY),N,STKR(L),K)
      MSTK(TOP) = 0
      GOTO 99
   95 DDT = IDINT(STKR(L))
      WRITE(WTE,96) DDT
   96 FORMAT(1X,'DEBUG ',I4)
      MSTK(TOP) = 0
      GOTO 99
   99 RETURN
      END SUBROUTINE MATFN5

      SUBROUTINE MATFN6
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER SEMI,ID(4),UNIFOR(4),NORMAL(4),SEED(4)
      DOUBLE PRECISION EPS0,EPS,S,SR,SI,T
      DOUBLE PRECISION FLOP,URAND
      LOGICAL EQID
      DATA SEMI/39/
      DATA UNIFOR/30,23,18,15/,NORMAL/23,24,27,22/,SEED/28,14,14,13/
      save semi,unifor,normal,seed
      IF (DDT == 1) WRITE(WTE,100) FIN
  100 FORMAT(1X,'MATFN6',I4)
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      GOTO (75,80,65,67,70,90,90,90,60,77,50,50,50,80,80),FIN
   50 IF (RHS /= 2) CALL ERROR(39)
      IF (ERR > 0) RETURN
      TOP = TOP - 1
      L = LSTK(TOP)
      MA = MSTK(TOP)
      NA = NSTK(TOP)
      LA = L + MAX0(M*N*MA*NA,M*N+MA*NA)
      LB = LA + MA*NA
      ERR = LB + M*N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(MA*NA+M*N,STKR(L),STKI(L),1,STKR(LA),STKI(LA),1)
      DO 54 JA = 1, NA
        DO 53 J = 1, N
          LJ = LB + (J-1)*M
          DO 52 IA = 1, MA
            CALL WCOPY(M,STKR(LJ),STKI(LJ),1,STKR(L),STKI(L),1)
            LS = LA + IA-1 + (JA-1)*MA
            DO 51 I = 1, M
              IF (FIN == 11) CALL WMUL(STKR(LS),STKI(LS),&
                 STKR(L),STKI(L),STKR(L),STKI(L))
              IF (FIN == 12) CALL WDIV(STKR(LS),STKI(LS),&
                 STKR(L),STKI(L),STKR(L),STKI(L))
              IF (FIN == 13) CALL WDIV(STKR(L),STKI(L),&
                 STKR(LS),STKI(LS),STKR(L),STKI(L))
              IF (ERR > 0) RETURN
              L = L + 1
   51       CONTINUE
   52     CONTINUE
   53   CONTINUE
   54 CONTINUE
      MSTK(TOP) = M*MA
      NSTK(TOP) = N*NA
      GOTO 99
   60 EPS0 = 1.0D0
   61 EPS0 = EPS0/2.0D0
      T = FLOP(1.0D0 + EPS0)
      IF (T > 1.0D0) GOTO 61
      EPS0 = 2.0D0*EPS0
      FLP(2) = IDINT(STKR(L))
      IF (SYM /= SEMI) WRITE(WTE,62) FLP(2)
   62 FORMAT(/1X,'CHOP ',I2,' PLACES.')
      EPS = 1.0D0
   63 EPS = EPS/2.0D0
      T = FLOP(1.0D0 + EPS)
      IF (T > 1.0D0) GOTO 63
      EPS = 2.0D0*EPS
      T = STKR(VSIZE-4)
      IF (T<EPS .OR. T==EPS0) STKR(VSIZE-4) = EPS
      MSTK(TOP) = 0
      GOTO 99
   65 SR = 0.0D0
      SI = 0.0D0
      MN = M*N
      DO 66 I = 1, MN
         LS = L+I-1
         SR = FLOP(SR+STKR(LS))
         SI = FLOP(SI+STKI(LS))
   66 CONTINUE
      GOTO 69
   67 SR = 1.0D0
      SI = 0.0D0
      MN = M*N
      DO 68 I = 1, MN
         LS = L+I-1
         CALL WMUL(STKR(LS),STKI(LS),SR,SI,SR,SI)
   68 CONTINUE
   69 STKR(L) = SR
      STKI(L) = SI
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      GOTO 99
   70 S = 0.0D0
      T = 0.0D0
      IF (RHS < 2) GOTO 72
      IF (RHS < 3) GOTO 71
      T = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
   71 S = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
   72 CALL USER(STKR(L),M,N,S,T)
      CALL RSET(M*N,0.0D0,STKI(L),1)
      MSTK(TOP) = M
      NSTK(TOP) = N
      GOTO 99
   75 N = MAX0(IDINT(STKR(L)),0)
      IF (N == 2) N = 0
      IF (N > 0) CALL MAGIC(STKR(L),N,N)
      CALL RSET(N*N,0.0D0,STKI(L),1)
      MSTK(TOP) = N
      NSTK(TOP) = N
      GOTO 99
   77 STKR(L) = M
      STKR(L+1) = N
      STKI(L) = 0.0D0
      STKI(L+1) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 2
      IF (LHS == 1) GOTO 99
      NSTK(TOP) = 1
      TOP = TOP + 1
      LSTK(TOP) = L+1
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      GOTO 99
   80 K = 0
      IF (RHS /= 2) GOTO 81
         K = IDINT(STKR(L))
         TOP = TOP-1
         L = LSTK(TOP)
         M = MSTK(TOP)
         N = NSTK(TOP)
   81 IF (FIN >= 14) GOTO 85
      IF (M == 1 .OR. N == 1) GOTO 83
      IF (K>=0) MN=MIN0(M,N-K)
      IF (K<0) MN=MIN0(M+K,N)
      MSTK(TOP) = MAX0(MN,0)
      NSTK(TOP) = 1
      IF (MN <= 0) GOTO 99
      DO 82 I = 1, MN
         IF (K>=0) LS = L+(I-1)+(I+K-1)*M
         IF (K<0) LS = L+(I-K-1)+(I-1)*M
         LL = L+I-1
         STKR(LL) = STKR(LS)
         STKI(LL) = STKI(LS)
   82 CONTINUE
      GOTO 99
   83 N = MAX0(M,N)+IABS(K)
      ERR = L+N*N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      MSTK(TOP) = N
      NSTK(TOP) = N
      DO 84 JB = 1, N
      DO 84 IB = 1, N
         J = N+1-JB
         I = N+1-IB
         SR = 0.0D0
         SI = 0.0D0
         IF (K>=0) LS = L+I-1
         IF (K<0) LS = L+J-1
         LL = L+I-1+(J-1)*N
         IF (J-I == K) SR = STKR(LS)
         IF (J-I == K) SI = STKI(LS)
         STKR(LL) = SR
         STKI(LL) = SI
   84 CONTINUE
      GOTO 99
   85 DO 87 J = 1, N
         LD = L + J - K - 1 + (J-1)*M
         IF (FIN == 14) LL = J - K - 1
         IF (FIN == 14) LS = LD - LL
         IF (FIN == 15) LL = M - J + K
         IF (FIN == 15) LS = LD + 1
         IF (LL > 0) CALL WSET(LL,0.0D0,0.0D0,STKR(LS),STKI(LS),1)
   87 CONTINUE
      GOTO 99
   90 IF (M>1 .OR. RHS==0) GOTO 94
      IF (RHS /= 2) GOTO 91
        NN = IDINT(STKR(L))
        TOP = TOP-1
        L = LSTK(TOP)
        N = NSTK(TOP)
   91 IF (FIN/=7 .OR. N<4) GOTO 93
      DO 92 I = 1, 4
        LS = L+I-1
        ID(I) = IDINT(STKR(LS))
   92 CONTINUE
      IF (EQID(ID,UNIFOR).OR.EQID(ID,NORMAL)) GOTO 97
      IF (EQID(ID,SEED)) GOTO 98
   93 IF (N > 1) GOTO 94
      M = MAX0(IDINT(STKR(L)),0)
      IF (RHS == 2) N = MAX0(NN,0)
      IF (RHS /= 2) N = M
      ERR = L+M*N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      MSTK(TOP) = M
      NSTK(TOP) = N
      IF (M*N == 0) GOTO 99
   94 DO 96 J = 1, N
      DO 96 I = 1, M
        LL = L+I-1+(J-1)*M
        STKR(LL) = 0.0D0
        STKI(LL) = 0.0D0
        IF (I==J .OR. FIN==8) STKR(LL) = 1.0D0
        IF (FIN==7 .AND. RAN(2)==0) STKR(LL) = FLOP(URAND(RAN(1)))
        IF (FIN/=7 .OR. RAN(2)==0) GOTO 96
   95      SR = 2.0D0*URAND(RAN(1))-1.0D0
           SI = 2.0D0*URAND(RAN(1))-1.0D0
           T = SR*SR + SI*SI
           IF (T > 1.0D0) GOTO 95
        STKR(LL) = FLOP(SR*DSQRT((-(2.0D0*DLOG(T)))/T))
   96 CONTINUE
      GOTO 99
   97 RAN(2) = ID(1) - UNIFOR(1)
      MSTK(TOP) = 0
      GOTO 99
   98 IF (RHS == 2) RAN(1) = NN
      STKR(L) = RAN(1)
      MSTK(TOP) = 1
      IF (RHS == 2) MSTK(TOP) = 0
      NSTK(TOP) = 1
      GOTO 99
   99 RETURN
      END SUBROUTINE MATFN6

      SUBROUTINE MATLAB(INIT)
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION S,T
      INTEGER EPS(4),FLOPS(4),EYE(4),RAND(4)
      CHARACTER SETA*52,SETB*52
      DATA SETA/'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ ();:+-*/\=.,''<>'/
      DATA SETB/'0123456789abcdefghijklmnopqrstuvwxyz ();|+-*/$=.,"[]'/
      SAVE SETB, SETA
      INTEGER ALPHA(52),ALPHB(52)
      DATA ALPHA /1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,&
          1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,&
          1HK,1HL,1HM,1HN,1HO,1HP,1HQ,1HR,1HS,1HT,&
          1HU,1HV,1HW,1HX,1HY,1HZ,1H ,1H(,1H),1H;,&
          1H:,1H+,1H-,1H*,1H/,1H\,1H=,1H.,1H,,1H',&          !' -JW : just to fix the syntax highlighting...
          1H<,1H>/
      DATA ALPHB /1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,&
          1Ha,1Hb,1Hc,1Hd,1He,1Hf,1Hg,1Hh,1Hi,1Hj,&
          1Hk,1Hl,1Hm,1Hn,1Ho,1Hp,1Hq,1Hr,1Hs,1Ht,&
          1Hu,1Hv,1Hw,1Hx,1Hy,1Hz,1H ,1H(,1H),1H;,&
          1H|,1H+,1H-,1H*,1H/,1H$,1H=,1H.,1H,,1H",&          !" -JW : just to fix the syntax highlighting...
          1H[,1H]/
      SAVE ALPHB, ALPHA
      DATA EPS/14,25,28,36/,FLOPS/15,21,24,25/
      DATA EYE/14,34,14,36/,RAND/27,10,23,13/
      SAVE EPS, EYE, FLOPS, RAND
      IF (INIT > 0) GOTO 90
      RTE = 5
      CALL FILES(RTE,BUF)
      RIO = RTE
      WTE = 6
      CALL FILES(WTE,BUF)
      WIO = 0
      IF (INIT >= 0) WRITE(WTE,100)
  100 FORMAT(//1X,'     < M A T L A B >',/,1X,'   Version of 05/25/82')
      HIO = 11
      CALL FILES(HIO,BUF)
      RAN(1) = 0
      LCT(2) = 25
      ALFL = 52
      CASE = 0
      DO 20 I = 1, ALFL
         ALFA(I) = ALPHA(I)
         ALFB(I) = ALPHB(I)
   20 CONTINUE
      VSIZE = 50505
      LSIZE = 48
      PSIZE = 32
      BOT = LSIZE-3
      CALL WSET(5,0.0D0,0.0D0,STKR(VSIZE-4),STKI(VSIZE-4),1)
      CALL PUTID(IDSTK(1,LSIZE-3),EPS)
      LSTK(LSIZE-3) = VSIZE-4
      MSTK(LSIZE-3) = 1
      NSTK(LSIZE-3) = 1
      S = 1.0D0
   30 S = S/2.0D0
      T = 1.0D0 + S
      IF (T > 1.0D0) GOTO 30
      STKR(VSIZE-4) = 2.0D0*S
      CALL PUTID(IDSTK(1,LSIZE-2),FLOPS)
      LSTK(LSIZE-2) = VSIZE-3
      MSTK(LSIZE-2) = 1
      NSTK(LSIZE-2) = 2
      CALL PUTID(IDSTK(1,LSIZE-1), EYE)
      LSTK(LSIZE-1) = VSIZE-1
      MSTK(LSIZE-1) = -1
      NSTK(LSIZE-1) = -1
      STKR(VSIZE-1) = 1.0D0
      CALL PUTID(IDSTK(1,LSIZE), RAND)
      LSTK(LSIZE) = VSIZE
      MSTK(LSIZE) = 1
      NSTK(LSIZE) = 1
      FMT = 1
      FLP(1) = 0
      FLP(2) = 0
      DDT = 0
      RAN(2) = 0
      PTZ = 0
      PT = PTZ
      ERR = 0
      IF (INIT < 0) RETURN
   90 CALL PARSE
      IF (FUN == 1) CALL MATFN1
      IF (FUN == 2) CALL MATFN2
      IF (FUN == 3) CALL MATFN3
      IF (FUN == 4) CALL MATFN4
      IF (FUN == 5) CALL MATFN5
      IF (FUN == 6) CALL MATFN6
      IF (FUN == 21) CALL MATFN1
      IF (FUN /= 99) GOTO 90
      RETURN
      END SUBROUTINE MATLAB

      SUBROUTINE PARSE
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      LOGICAL EQID
      INTEGER SEMI,EQUAL,EOL,ID(4),EXCNT,LPAREN,RPAREN,COLON,PTS,ALFL
      INTEGER BLANK,COMMA,LESS,GREAT,NAME,ANS(4),ENND(4),ELSE(4),P,R
      DATA BLANK/36/,SEMI/39/,EQUAL/46/,EOL/99/,COMMA/48/,COLON/40/
      DATA LPAREN/37/,RPAREN/38/,LESS/50/,GREAT/51/,NAME/1/,ALFL/52/
      DATA ANS/10,23,28,36/,ENND/14,23,13,36/,ELSE/14,21,28,14/
      save BLANK,SEMI,EQUAL,EOL,COMMA,COLON
      save LPAREN,RPAREN,LESS,GREAT,NAME,ALFL
      save ANS,ENND,ELSE
   01 R = 0
      IF (ERR > 0) PTZ = 0
      IF (ERR<=0 .AND. PT>PTZ) R = RSTK(PT)
      IF (DDT == 1) WRITE(WTE,100) PT,R,PTZ,ERR
  100 FORMAT(1X,'PARSE ',4I4)
      IF (R==15) GOTO 93
      IF (R==16 .OR. R==17) GOTO 94
      SYM = EOL
      TOP = 0
      IF (RIO /= RTE) CALL FILES(-RIO,BUF)
      RIO = RTE
      LCT(3) = 0
      LCT(4) = 2
      LPT(1) = 1
   10 IF (SYM==EOL .AND. MOD(LCT(4)/2,2)==1) CALL PROMPT(LCT(4)/4)
      IF (SYM == EOL) CALL GETLIN
      ERR = 0
      PT = PTZ
   15 EXCNT = 0
      IF (DDT == 1) WRITE(WTE,115) PT,TOP
  115 FORMAT(1X,'STATE ',2I4)
      LHS = 1
      CALL PUTID(ID,ANS)
      CALL GETSYM
      IF (SYM==COLON .AND. CHRA==EOL) DDT = 1-DDT
      IF (SYM == COLON) CALL GETSYM
      IF (SYM==SEMI .OR. SYM==COMMA .OR. SYM==EOL) GOTO 80
      IF (SYM == NAME) GOTO 20
      IF (SYM == LESS) GOTO 40
      IF (SYM == GREAT) GOTO 45
      GOTO 50
   20 CALL COMAND(SYN)
      IF (ERR > 0) GOTO 01
      IF (FUN == 99) GOTO 95
      IF (FIN == -15) GOTO 80
      IF (FIN < 0) GOTO 91
      IF (FIN > 0) GOTO 70
      RHS = 0
      CALL FUNS(SYN)
      IF (FIN /= 0) GOTO 50
      IF (CHRA==SEMI .OR. CHRA==COMMA .OR. CHRA==EOL)&
            CALL PUTID(ID,SYN)
      IF (CHRA == EQUAL) GOTO 25
      IF (CHRA == LPAREN) GOTO 30
      GOTO 50
   25 CALL PUTID(ID,SYN)
      CALL GETSYM
      CALL GETSYM
      GOTO 50
   30 LPT(5) = LPT(4)
      CALL PUTID(ID,SYN)
      CALL GETSYM
   32 CALL GETSYM
      EXCNT = EXCNT+1
      PT = PT+1
      CALL PUTID(IDS(1,PT), ID)
      PSTK(PT) = EXCNT
      RSTK(PT) = 1
      GOTO 92
   35 CALL PUTID(ID,IDS(1,PT))
      EXCNT = PSTK(PT)
      PT = PT-1
      IF (SYM == COMMA) GOTO 32
      IF (SYM /= RPAREN) CALL ERROR(3)
      IF (ERR > 0) GOTO 01
      IF (ERR > 0) RETURN
      IF (SYM == RPAREN) CALL GETSYM
      IF (SYM == EQUAL) GOTO 50
      TOP = TOP - EXCNT
      LPT(4) = LPT(5)
      CHRA = LPAREN
      SYM = NAME
      CALL PUTID(SYN,ID)
      CALL PUTID(ID,ANS)
      EXCNT = 0
      GOTO 50
   40 LPT(5) = LPT(4)
      PTS = PT
      CALL GETSYM
   41 IF (SYM /= NAME) GOTO 43
      CALL PUTID(ID,SYN)
      CALL GETSYM
      IF (SYM == GREAT) GOTO 42
      IF (SYM == COMMA) CALL GETSYM
      PT = PT+1
      LHS = LHS+1
      PSTK(PT) = 0
      CALL PUTID(IDS(1,PT),ID)
      GOTO 41
   42 CALL GETSYM
      IF (SYM == EQUAL) GOTO 50
   43 LPT(4) = LPT(5)
      PT = PTS
      LHS = 1
      SYM = LESS
      CHRA = LPT(4)-1
      CHRA = LIN(CHRA)
      CALL PUTID(ID,ANS)
      GOTO 50
   45 CALL GETSYM
      IF (DDT == 1) WRITE(WTE,145) PT,TOP
  145 FORMAT(1X,'MACRO ',2I4)
      IF (SYM==LESS .AND. CHRA==EOL) CALL ERROR(28)
      IF (ERR > 0) GOTO 01
      PT = PT+1
      RSTK(PT) = 20
      GOTO 92
   46 PT = PT-1
      IF (SYM/=LESS .AND. SYM/=EOL) CALL ERROR(37)
      IF (ERR > 0) GOTO 01
      IF (SYM == LESS) CALL GETSYM
      K = LPT(6)
      LIN(K+1) = LPT(1)
      LIN(K+2) = LPT(2)
      LIN(K+3) = LPT(6)
      LPT(1) = K + 4
      K = LPT(1)
      L = LSTK(TOP)
      N = MSTK(TOP)*NSTK(TOP)
      DO 48 J = 1, N
         LS = L + J-1
         LIN(K) = IDINT(STKR(LS))
         IF (LIN(K)<0 .OR. LIN(K)>=ALFL) CALL ERROR(37)
         IF (ERR > 0) RETURN
         IF (K<1024) K = K+1
         IF (K==1024) WRITE(WTE,47) K
   47    FORMAT(1X,'INPUT BUFFER LIMIT IS ',I4,' CHARACTERS.')
   48 CONTINUE
      TOP = TOP-1
      LIN(K) = EOL
      LPT(6) = K
      LPT(4) = LPT(1)
      LPT(3) = 0
      LPT(2) = 0
      LCT(1) = 0
      CHRA = BLANK
      PT = PT+1
      PSTK(PT) = LPT(1)
      RSTK(PT) = 21
      GOTO 15
   49 PT = PT-1
      IF (DDT == 1) WRITE(WTE,149) PT,TOP
  149 FORMAT(1X,'MACEND',2I4)
      K = LPT(1) - 4
      LPT(1) = LIN(K+1)
      LPT(4) = LIN(K+2)
      LPT(6) = LIN(K+3)
      CHRA = BLANK
      CALL GETSYM
      GOTO 80
   50 IF (SYM == EQUAL) CALL GETSYM
      PT = PT+1
      CALL PUTID(IDS(1,PT),ID)
      PSTK(PT) = EXCNT
      RSTK(PT) = 2
      GOTO 92
   55 IF (SYM==SEMI .OR. SYM==COMMA .OR. SYM==EOL) GOTO 60
      IF (SYM==NAME .AND. EQID(SYN,ELSE)) GOTO 60
      IF (SYM==NAME .AND. EQID(SYN,ENND)) GOTO 60
      CALL ERROR(40)
      IF (ERR > 0) GOTO 01
   60 RHS = PSTK(PT)
      CALL STACKP(IDS(1,PT))
      IF (ERR > 0) GOTO 01
      PT = PT-1
      LHS = LHS-1
      IF (LHS > 0) GOTO 60
      GOTO 70
   70 K = FLP(1)
      IF (K /= 0) STKR(VSIZE-3) = DFLOAT(K)
      STKR(VSIZE-2) = STKR(VSIZE-2) + DFLOAT(K)
      FLP(1) = 0
      IF (.NOT.(CHRA==COMMA .OR. (SYM==COMMA .AND. CHRA==EOL)))&
             GOTO 80
      CALL GETSYM
      I5 = 10**5
      LUNIT = WTE
   71 IF (K == 0) WRITE(LUNIT,171)
  171 FORMAT(/1X,'   no flops')
      IF (K == 1) WRITE(LUNIT,172)
  172 FORMAT(/1X,'    1 flop')
      IF (1<K .AND. K<100000) WRITE(LUNIT,173) K
  173 FORMAT(/1X,I5,' flops')
      IF (100000 <= K) WRITE(LUNIT,174) K
  174 FORMAT(/1X,I9,' flops')
      IF (LUNIT==WIO .OR. WIO==0) GOTO 80
      LUNIT = WIO
      GOTO 71
   80 FIN = 0
      P = 0
      R = 0
      IF (PT > 0) P = PSTK(PT)
      IF (PT > 0) R = RSTK(PT)
      IF (DDT == 1) WRITE(WTE,180) PT,PTZ,P,R,LPT(1)
  180 FORMAT(1X,'FINISH',5I4)
      IF (SYM==COMMA .OR. SYM==SEMI) GOTO 15
      IF (R==21 .AND. P==LPT(1)) GOTO 49
      IF (PT > PTZ) GOTO 91
      GOTO 10
   91 CALL CLAUSE
      IF (ERR > 0) GOTO 01
      IF (PT <= PTZ) GOTO 15
      R = RSTK(PT)
      IF (R == 21) GOTO 49
      GOTO (99,99,92,92,92,99,99,99,99,99,99,99,15,15,99,99,99,99,99),R
   92 CALL EXPR
      IF (ERR > 0) GOTO 01
      R = RSTK(PT)
      GOTO (35,55,91,91,91,93,93,99,99,94,94,99,99,99,99,99,99,94,94,&
             46),R
   93 CALL TERM
      IF (ERR > 0) GOTO 01
      R = RSTK(PT)
      GOTO (99,99,99,99,99,92,92,94,94,99,99,99,99,99,95,99,99,99,99),R
   94 CALL FACTOR
      IF (ERR > 0) GOTO 01
      R = RSTK(PT)
      GOTO (99,99,99,99,99,99,99,93,93,92,92,94,99,99,99,95,95,92,92),R
   95 IF (FIN>0 .AND. MSTK(TOP)<0) CALL ERROR(14)
      IF (ERR > 0) GOTO 01
      RETURN
   99 CALL ERROR(22)
      GOTO 01
      END SUBROUTINE PARSE
      SUBROUTINE PLOT(LUNIT,X,Y,N,P,K)
      DOUBLE PRECISION X(N),Y(N),P(1)
      CHARACTER BUF*79
      DOUBLE PRECISION XMIN,YMIN,XMAX,YMAX,DY,DX,Y1,Y0
      INTEGER H,W
      parameter(H=20,W=79)
      IF (K > 0) WRITE(LUNIT,01) (P(I), I=1,K)
   01 FORMAT('Extra parameters',10f5.1)
      XMIN = X(1)
      XMAX = X(1)
      YMIN = Y(1)
      YMAX = Y(1)
      DO 10 I = 1, N
         XMIN = DMIN1(XMIN,X(I))
         XMAX = DMAX1(XMAX,X(I))
         YMIN = DMIN1(YMIN,Y(I))
         YMAX = DMAX1(YMAX,Y(I))
   10 CONTINUE
      DX = XMAX - XMIN
      IF (DX == 0.0D0) DX = 1.0D0
      DY = YMAX - YMIN
      WRITE(LUNIT,'(80X)')
      DO 40 L = 1, H
         BUF(:)=' '  ! blank out the line
         Y1 = YMIN + (H-L+1)*DY/H
         Y0 = YMIN + (H-L)*DY/H
         JMAX = 1
         DO 30 I = 1, N
            IF (Y(I) > Y1) GOTO 30
            IF (L/=H .AND. Y(I)<=Y0) GOTO 30
            J = 1 + (W-1)*(X(I) - XMIN)/DX
            BUF(J:J) = '*'
            JMAX = MAX0(JMAX,J)
   30    CONTINUE
         WRITE(LUNIT,'(1X,A)') BUF(1:JMAX)
   40 CONTINUE
      RETURN
      END SUBROUTINE PLOT

      SUBROUTINE PRINT(ID,K)
      INTEGER ID(4),K
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION S,TR,TI,PR(12),PI(12),ROUND
      INTEGER FNO(11),FNL(11),SIG(12),PLUS,MINUS,BLANK,TYP,F
      DATA PLUS/41/,MINUS/42/,BLANK/36/
      DATA FNO /11,12,21,22,23,24,31,32,33,34,-1/
      DATA FNL /12, 6, 8, 4, 6, 3, 4, 2, 3, 1, 1/
      save fno, fnl
      IF (LCT(1) < 0) GOTO 99
      L = LSTK(K)
      M = MSTK(K)
      N = NSTK(K)
      MN = M*N
      TYP = 1
      S = 0.0D0
      DO 10 I = 1, MN
        LS = L+I-1
        TR = STKR(LS)
        TI = STKI(LS)
        S = DMAX1(S,DABS(TR),DABS(TI))
        IF (ROUND(TR) /= TR) TYP = MAX0(2,TYP)
        IF (TI /= 0.0D0) TYP = 3
   10 CONTINUE
      IF (S /= 0.0D0) S = DLOG10(S)
      KS = IDINT(S)
      IF (-2 <= KS .AND. KS <= 1) KS = 0
      IF (KS == 2 .AND. FMT == 1 .AND. TYP == 2) KS = 0
      IF (TYP == 1 .AND. KS <= 2) F = 1
      IF (TYP == 1 .AND. KS > 2) F = 2
      IF (TYP == 1 .AND. KS > 9) TYP = 2
      IF (TYP == 2) F = FMT + 2
      IF (TYP == 3) F = FMT + 6
      IF (MN==1 .AND. KS/=0 .AND. FMT<3 .AND. TYP/=1) F = F+2
      IF (FMT == 5) F = 11
      JINC = FNL(F)
      F = FNO(F)
      S = 1.0D0
      IF (F==21 .OR. F==22 .OR. F==31 .OR. F==32) S = 10.0D0**KS
      LS = ((N-1)/JINC+1)*M + 2
      IF (LCT(1) + LS <= LCT(2)) GOTO 20
         LCT(1) = 0
         WRITE(WTE,43) LS
         READ(RTE,44,END=19) LS
         IF (LS == ALFA(BLANK+1)) GOTO 20
         LCT(1) = -1
         GOTO 99
   19    CALL FILES(-RTE,BUF)
   20 CONTINUE
      WRITE(WTE,44)
      IF (WIO /= 0) WRITE(WIO,44)
      CALL PRNTID(ID,-1)
      LCT(1) = LCT(1)+2
      LUNIT = WTE
   50 IF (S /= 1.0D0) WRITE(LUNIT,41) S
      DO 80 J1 = 1, N, JINC
        J2 = MIN0(N, J1+JINC-1)
        WRITE(LUNIT,44)
        IF (N > JINC) WRITE(LUNIT,42) J1,J2
        DO 70 I = 1, M
          JM = J2-J1+1
          DO 60 J = 1, JM
             LS = L+I-1+(J+J1-2)*M
             PR(J) = STKR(LS)/S
             PI(J) = DABS(STKI(LS)/S)
             SIG(J) = ALFA(PLUS+1)
             IF (STKI(LS) < 0.0D0) SIG(J) = ALFA(MINUS+1)
   60     CONTINUE
          IF (F == 11) WRITE(LUNIT,11)(PR(J),J=1,JM)
          IF (F == 12) WRITE(LUNIT,12)(PR(J),J=1,JM)
          IF (F == 21) WRITE(LUNIT,21)(PR(J),J=1,JM)
          IF (F == 22) WRITE(LUNIT,22)(PR(J),J=1,JM)
          IF (F == 23) WRITE(LUNIT,23)(PR(J),J=1,JM)
          IF (F == 24) WRITE(LUNIT,24)(PR(J),J=1,JM)
          IF (F == 31) WRITE(LUNIT,31)(PR(J),SIG(J),PI(J),J=1,JM)
          IF (F == 32) WRITE(LUNIT,32)(PR(J),SIG(J),PI(J),J=1,JM)
          IF (F == 33) WRITE(LUNIT,33)(PR(J),SIG(J),PI(J),J=1,JM)
          IF (F == 34) WRITE(LUNIT,34)(PR(J),SIG(J),PI(J),J=1,JM)
          IF (F == -1) CALL FORMZ(LUNIT,STKR(LS),STKI(LS))
          LCT(1) = LCT(1)+1
   70   CONTINUE
   80 CONTINUE
      IF (LUNIT==WIO .OR. WIO==0) GOTO 99
      LUNIT = WIO
      GOTO 50
   99 CONTINUE
      RETURN
   11 FORMAT(1X,12F6.0)
   12 FORMAT(1X,6F12.0)
   21 FORMAT(1X,F9.4,7F10.4)
   22 FORMAT(1X,F19.15,3F20.15)
   23 FORMAT(1X,1P6D13.4)
   24 FORMAT(1X,1P3D24.15)
   31 FORMAT(1X,4(F9.4,' ',A1,F7.4,'i'))
   32 FORMAT(1X,F19.15,A1,F18.15,'i',F20.15,A1,F18.15,'i')
   33 FORMAT(1X,3(1PD13.4,' ',A1,1PD10.4,'i'))
   34 FORMAT(1X,1PD24.15,' ',A1,1PD21.15,'i')
   41 FORMAT(/1X,' ',1PD9.1,2H *)
   42 FORMAT(1X,'    COLUMNS',I3,' THRU',I3)
   43 FORMAT(/1X,'AT LEAST ',I5,' MORE LINES.',&
             '  ENTER BLANK LINE TO CONTINUE OUTPUT.')
   44 FORMAT(A1)
      END SUBROUTINE PRINT

      SUBROUTINE PRNTID(ID,ARGCNT)
      INTEGER ID(4,1),ARGCNT
      INTEGER ALFA(52),ALFB(52),ALFL,CASE
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /ALFS/ ALFA,ALFB,ALFL,CASE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER EQUAL
      DATA EQUAL/46/
      save equal
      J1 = 1
   10 J2 = MIN0(J1+7,IABS(ARGCNT))
      L = 0
      DO 15 J = J1,J2
      DO 15 I = 1, 4
      K = ID(I,J)+1
      L = L+1
      BUF(L) = ALFA(K)
   15 CONTINUE
      IF (ARGCNT == -1) L=L+1
      IF (ARGCNT == -1) BUF(L) = ALFA(EQUAL+1)
      WRITE(WTE,20) (BUF(I),I=1,L)
      IF (WIO /= 0) WRITE(WIO,20) (BUF(I),I=1,L)
   20 FORMAT(1X,8(4A1,2H  ))
      J1 = J1+8
      IF (J1 <= IABS(ARGCNT)) GOTO 10
      RETURN
      END SUBROUTINE PRNTID

      SUBROUTINE PROMPT(PAUSE)
      INTEGER PAUSE
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      WRITE(WTE,10)
      IF (WIO /= 0) WRITE(WIO,10)
   10 FORMAT(/1X,'<>',$)
      IF (PAUSE == 1) READ(RTE,20) DUMMY
   20 FORMAT(A1)
      RETURN
      END SUBROUTINE PROMPT

      SUBROUTINE SAVLOD(LUNIT,ID,M,N,IMG,JOB,XREAL,XIMAG)
      INTEGER LUNIT,ID(4),M,N,IMG,JOB
      DOUBLE PRECISION XREAL(1),XIMAG(1)
  101 FORMAT(4A1,3I4)
  102 FORMAT(4Z18)
      IF (JOB > 0) GOTO 20
   10 WRITE(LUNIT,101) ID,M,N,IMG
      DO 15 J = 1, N
         K = (J-1)*M+1
         L = J*M
         WRITE(LUNIT,102) (XREAL(I),I=K,L)
         IF (IMG /= 0) WRITE(LUNIT,102) (XIMAG(I),I=K,L)
   15 CONTINUE
      RETURN
   20 READ(LUNIT,101,END=30) ID,M,N,IMG
      IF (M*N > JOB) GOTO 30
      DO 25 J = 1, N
         K = (J-1)*M+1
         L = J*M
         READ(LUNIT,102,END=30) (XREAL(I),I=K,L)
         IF (IMG /= 0) READ(LUNIT,102,END=30) (XIMAG(I),I=K,L)
   25 CONTINUE
      RETURN
   30 M = 0
      N = 0
      RETURN
      END SUBROUTINE SAVLOD

      SUBROUTINE STACK1(OP)
      INTEGER OP
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER QUOTE
      DATA QUOTE/49/
      save quote
      IF (DDT == 1) WRITE(WTE,100) OP
  100 FORMAT(1X,'STACK1',I4)
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      MN = M*N
      IF (MN == 0) GOTO 99
      IF (OP == QUOTE) GOTO 30
      CALL WRSCAL(MN,-1.0D0,STKR(L),STKI(L),1)
      GOTO 99
   30 LL = L + MN
      ERR = LL+MN - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(MN,STKR(L),STKI(L),1,STKR(LL),STKI(LL),1)
      M = NSTK(TOP)
      N = MSTK(TOP)
      MSTK(TOP) = M
      NSTK(TOP) = N
      DO 50 I = 1, M
      DO 50 J = 1, N
        LS = L+MN+(J-1)+(I-1)*N
        LL = L+(I-1)+(J-1)*M
        STKR(LL) = STKR(LS)
        STKI(LL) = -STKI(LS)
   50 CONTINUE
      GOTO 99
   99 RETURN
      END SUBROUTINE STACK1

      SUBROUTINE STACK2(OP)
      INTEGER OP
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      DOUBLE PRECISION WDOTUR,WDOTUI
      DOUBLE PRECISION SR,SI,E1,ST,E2,FLOP
      INTEGER PLUS,MINUS,STAR,DSTAR,SLASH,BSLASH,DOT,COLON
      DATA PLUS/41/,MINUS/42/,STAR/43/,DSTAR/54/,SLASH/44/
      DATA BSLASH/45/,DOT/47/,COLON/40/
      SAVE PLUS,MINUS,STAR,DSTAR,SLASH,BSLASH,DOT,COLON
      IF (DDT == 1) WRITE(WTE,100) OP
  100 FORMAT(1X,'STACK2',I4)
      L2 = LSTK(TOP)
      M2 = MSTK(TOP)
      N2 = NSTK(TOP)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      FUN = 0
      IF (OP == PLUS) GOTO 01
      IF (OP == MINUS) GOTO 03
      IF (OP == STAR) GOTO 05
      IF (OP == DSTAR) GOTO 30
      IF (OP == SLASH) GOTO 20
      IF (OP == BSLASH) GOTO 25
      IF (OP == COLON) GOTO 60
      IF (OP > 2*DOT) GOTO 80
      IF (OP > DOT) GOTO 70
   01 IF (M < 0) GOTO 50
      IF (M2 < 0) GOTO 52
      IF (M /= M2) CALL ERROR(8)
      IF (ERR > 0) RETURN
      IF (N /= N2) CALL ERROR(8)
      IF (ERR > 0) RETURN
      CALL WAXPY(M*N,1.0D0,0.0D0,STKR(L2),STKI(L2),1,&
                  STKR(L),STKI(L),1)
      GOTO 99
   03 IF (M < 0) GOTO 54
      IF (M2 < 0) GOTO 56
      IF (M /= M2) CALL ERROR(9)
      IF (ERR > 0) RETURN
      IF (N /= N2) CALL ERROR(9)
      IF (ERR > 0) RETURN
      CALL WAXPY(M*N,-1.0D0,0.0D0,STKR(L2),STKI(L2),1,&
                  STKR(L),STKI(L),1)
      GOTO 99
   05 IF (M2*M2*N2 == 1) GOTO 10
      IF (M*N == 1) GOTO 11
      IF (M2*N2 == 1) GOTO 10
      IF (N /= M2) CALL ERROR(10)
      IF (ERR > 0) RETURN
      MN = M*N2
      LL = L + MN
      ERR = LL+M*N+M2*N2 - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(M*N+M2*N2,STKR(L),STKI(L),-1,STKR(LL),STKI(LL),-1)
      DO 08 J = 1, N2
      DO 08 I = 1, M
        K1 = L + MN + (I-1)
        K2 = L2 + MN + (J-1)*M2
        K = L + (I-1) + (J-1)*M
        STKR(K) = WDOTUR(N,STKR(K1),STKI(K1),M,STKR(K2),STKI(K2),1)
        STKI(K) = WDOTUI(N,STKR(K1),STKI(K1),M,STKR(K2),STKI(K2),1)
   08 CONTINUE
      NSTK(TOP) = N2
      GOTO 99
   10 SR = STKR(L2)
      SI = STKI(L2)
      L1 = L
      GOTO 13
   11 SR = STKR(L)
      SI = STKI(L)
      L1 = L+1
      MSTK(TOP) = M2
      NSTK(TOP) = N2
   13 MN = MSTK(TOP)*NSTK(TOP)
      CALL WSCAL(MN,SR,SI,STKR(L1),STKI(L1),1)
      IF (L1/=L)&
         CALL WCOPY(MN,STKR(L1),STKI(L1),1,STKR(L),STKI(L),1)
      GOTO 99
   20 IF (M2*N2 == 1) GOTO 21
      IF (M2 == N2) FUN = 1
      IF (M2 /= N2) FUN = 4
      FIN = -1
      RHS = 2
      GOTO 99
   21 SR = STKR(L2)
      SI = STKI(L2)
      MN = M*N
      DO 22 I = 1, MN
         LL = L+I-1
         CALL WDIV(STKR(LL),STKI(LL),SR,SI,STKR(LL),STKI(LL))
         IF (ERR > 0) RETURN
   22 CONTINUE
      GOTO 99
   25 IF (M*N == 1) GOTO 26
      IF (M == N) FUN = 1
      IF (M /= N) FUN = 4
      FIN = -2
      RHS = 2
      GOTO 99
   26 SR = STKR(L)
      SI = STKI(L)
      MSTK(TOP) = M2
      NSTK(TOP) = N2
      MN = M2*N2
      DO 27 I = 1, MN
         LL = L+I-1
         CALL WDIV(STKR(LL+1),STKI(LL+1),SR,SI,STKR(LL),STKI(LL))
         IF (ERR > 0) RETURN
   27 CONTINUE
      GOTO 99
   30 IF (M2*N2 /= 1) CALL ERROR(30)
      IF (ERR > 0) RETURN
      IF (M /= N) CALL ERROR(20)
      IF (ERR > 0) RETURN
      NEXP = IDINT(STKR(L2))
      IF (STKR(L2) /= DFLOAT(NEXP)) GOTO 39
      IF (STKI(L2) /= 0.0D0) GOTO 39
      IF (NEXP < 2) GOTO 39
      MN = M*N
      ERR = L2+MN+N - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(MN,STKR(L),STKI(L),1,STKR(L2),STKI(L2),1)
      L3 = L2+MN
      DO 36 KEXP = 2, NEXP
        DO 35 J = 1, N
          LS = L+(J-1)*N
          CALL WCOPY(N,STKR(LS),STKI(LS),1,STKR(L3),STKI(L3),1)
          DO 34 I = 1, N
            LS = L2+I-1
            LL = L+I-1+(J-1)*N
            STKR(LL) = WDOTUR(N,STKR(LS),STKI(LS),N,STKR(L3),STKI(L3),1)
            STKI(LL) = WDOTUI(N,STKR(LS),STKI(LS),N,STKR(L3),STKI(L3),1)
   34     CONTINUE
   35   CONTINUE
   36 CONTINUE
      GOTO 99
   39 FUN = 2
      FIN = 0
      GOTO 99
   50 IF (M2 /= N2) CALL ERROR(8)
      IF (ERR > 0) RETURN
      M = M2
      N = N2
      MSTK(TOP) = M
      NSTK(TOP) = N
      SR = STKR(L)
      SI = STKI(L)
      CALL WCOPY(M*N,STKR(L+1),STKI(L+1),1,STKR(L),STKI(L),1)
      GOTO 58
   52 IF (M /= N) CALL ERROR(8)
      IF (ERR > 0) RETURN
      SR = STKR(L2)
      SI = STKI(L2)
      GOTO 58
   54 IF (M2 /= N2) CALL ERROR(9)
      IF (ERR > 0) RETURN
      M = M2
      N = N2
      MSTK(TOP) = M
      NSTK(TOP) = N
      SR = STKR(L)
      SI = STKI(L)
      CALL WCOPY(M*N,STKR(L+1),STKI(L+1),1,STKR(L),STKI(L),1)
      CALL WRSCAL(M*N,-1.0D0,STKR(L),STKI(L),1)
      GOTO 58
   56 IF (M /= N) CALL ERROR(9)
      IF (ERR > 0) RETURN
      SR = -STKR(L2)
      SI = -STKI(L2)
      GOTO 58
   58 DO 59 I = 1, N
         LL = L + (I-1)*(N+1)
         STKR(LL) = FLOP(STKR(LL)+SR)
         STKI(LL) = FLOP(STKI(LL)+SI)
   59 CONTINUE
      GOTO 99
   60 E2 = STKR(L2)
      ST = 1.0D0
      N = 0
      IF (RHS < 3) GOTO 61
      ST = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      IF (ST == 0.0D0) GOTO 63
   61 E1 = STKR(L)
      IF (RSTK(PT) == 3) GOTO 64
      ERR = L + MAX0(3,IDINT((E2-E1)/ST)) - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
   62 IF (ST > 0.0D0 .AND. STKR(L) > E2) GOTO 63
      IF (ST < 0.0D0 .AND. STKR(L) < E2) GOTO 63
        N = N+1
        L = L+1
        STKR(L) = E1 + DFLOAT(N)*ST
        STKI(L) = 0.0D0
        GOTO 62
   63 NSTK(TOP) = N
      MSTK(TOP) = 1
      IF (N == 0) MSTK(TOP) = 0
      GOTO 99
   64 STKR(L) = E1
      STKR(L+1) = ST
      STKR(L+2) = E2
      MSTK(TOP) = -3
      NSTK(TOP) = -1
      GOTO 99
   70 OP = OP - DOT
      IF (M/=M2 .OR. N/=N2) CALL ERROR(10)
      IF (ERR > 0) RETURN
      MN = M*N
      DO 72 I = 1, MN
         J = L+I-1
         K = L2+I-1
         IF (OP == STAR)&
            CALL WMUL(STKR(J),STKI(J),STKR(K),STKI(K),STKR(J),STKI(J))
         IF (OP == SLASH)&
            CALL WDIV(STKR(J),STKI(J),STKR(K),STKI(K),STKR(J),STKI(J))
         IF (OP == BSLASH)&
            CALL WDIV(STKR(K),STKI(K),STKR(J),STKI(J),STKR(J),STKI(J))
         IF (ERR > 0) RETURN
   72 CONTINUE
      GOTO 99
   80 FIN = OP - 2*DOT - STAR + 11
      FUN = 6
      TOP = TOP + 1
      RHS = 2
      GOTO 99
   99 RETURN
      END SUBROUTINE STACK2

      SUBROUTINE STACKG(ID)
      INTEGER ID(4)
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      LOGICAL EQID
      IF (DDT == 1) WRITE(WTE,100) ID
  100 FORMAT(1X,'STACKG',4I4)
      CALL PUTID(IDSTK(1,BOT-1), ID)
      K = LSIZE+1
   10 K = K-1
      IF (.NOT.EQID(IDSTK(1,K), ID)) GOTO 10
      IF (K >= LSIZE-1 .AND. RHS > 0) GOTO 98
      IF (K == BOT-1) GOTO 98
      LK = LSTK(K)
      IF (RHS == 1) GOTO 40
      IF (RHS == 2) GOTO 60
      IF (RHS > 2) CALL ERROR(21)
      IF (ERR > 0) RETURN
      L = 1
      IF (TOP > 0) L = LSTK(TOP) + MSTK(TOP)*NSTK(TOP)
      IF (TOP+1 >= BOT) CALL ERROR(18)
      IF (ERR > 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L
      MSTK(TOP) = MSTK(K)
      NSTK(TOP) = NSTK(K)
      MN = MSTK(K)*NSTK(K)
      ERR = L+MN - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      IF (K == LSIZE) GOTO 97
      CALL WCOPY(MN,STKR(LK),STKI(LK),1,STKR(L),STKI(L),1)
      GOTO 99
   40 IF (MSTK(TOP) == 0) GOTO 99
      L = LSTK(TOP)
      MN = MSTK(TOP)*NSTK(TOP)
      MNK = MSTK(K)*NSTK(K)
      IF (MSTK(TOP) < 0) MN = MNK
      DO 50 I = 1, MN
        LL = L+I-1
        LS = LK+I-1
        IF (MSTK(TOP) > 0) LS = LK + IDINT(STKR(LL)) - 1
        IF (LS < LK .OR. LS >= LK+MNK) CALL ERROR(21)
        IF (ERR > 0) RETURN
        STKR(LL) = STKR(LS)
        STKI(LL) = STKI(LS)
   50 CONTINUE
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      IF (MSTK(K) > 1) MSTK(TOP) = MN
      IF (MSTK(K) == 1) NSTK(TOP) = MN
      GOTO 99
   60 TOP = TOP-1
      L = LSTK(TOP)
      IF (MSTK(TOP+1) == 0) MSTK(TOP) = 0
      IF (MSTK(TOP) == 0) GOTO 99
      L2 = LSTK(TOP+1)
      M = MSTK(TOP)*NSTK(TOP)
      IF (MSTK(TOP) < 0) M = MSTK(K)
      N = MSTK(TOP+1)*NSTK(TOP+1)
      IF (MSTK(TOP+1) < 0) N = NSTK(K)
      L3 = L2 + N
      MK = MSTK(K)
      MNK = MSTK(K)*NSTK(K)
      DO 70 J = 1, N
      DO 70 I = 1, M
        LI = L+I-1
        IF (MSTK(TOP) > 0) LI = L + IDINT(STKR(LI)) - 1
        LJ = L2+J-1
        IF (MSTK(TOP+1) > 0) LJ = L2 + IDINT(STKR(LJ)) - 1
        LS = LK + LI-L + (LJ-L2)*MK
        IF (LS<LK .OR. LS>=LK+MNK) CALL ERROR(21)
        IF (ERR > 0) RETURN
        LL = L3 + I-1 + (J-1)*M
        STKR(LL) = STKR(LS)
        STKI(LL) = STKI(LS)
   70 CONTINUE
      MN = M*N
      CALL WCOPY(MN,STKR(L3),STKI(L3),1,STKR(L),STKI(L),1)
      MSTK(TOP) = M
      NSTK(TOP) = N
      GOTO 99
   97 FIN = 7
      FUN = 6
      RETURN
   98 FIN = 0
      RETURN
   99 FIN = -1
      FUN = 0
      RETURN
      END SUBROUTINE STACKG

      SUBROUTINE STACKP(ID)
      INTEGER ID(4)
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      LOGICAL EQID
      INTEGER SEMI
      DATA SEMI/39/
      save semi
      IF (DDT == 1) WRITE(WTE,100) ID
  100 FORMAT(1X,'STACKP',4I4)
      IF (TOP <= 0) CALL ERROR(1)
      IF (ERR > 0) RETURN
      CALL FUNS(ID)
      IF (FIN /= 0) CALL ERROR(25)
      IF (ERR > 0) RETURN
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (M > 0) L = LSTK(TOP)
      IF (M < 0) CALL ERROR(14)
      IF (ERR > 0) RETURN
      IF (M == 0 .AND. N /= 0) GOTO 99
      MN = M*N
      LK = 0
      MK = 1
      NK = 0
      LT = 0
      MT = 0
      NT = 0
      CALL PUTID(IDSTK(1,BOT-1),ID)
      K = LSIZE+1
   05 K = K-1
      IF (.NOT.EQID(IDSTK(1,K),ID)) GOTO 05
      IF (K == BOT-1) GOTO 30
      LK = LSTK(K)
      MK = MSTK(K)
      NK = NSTK(K)
      MNK = MK*NK
      IF (RHS == 0) GOTO 20
      IF (RHS > 2) CALL ERROR(15)
      IF (ERR > 0) RETURN
      MT = MK
      NT = NK
      LT = L + MN
      ERR = LT + MNK - LSTK(BOT)
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      CALL WCOPY(MNK,STKR(LK),STKI(LK),1,STKR(LT),STKI(LT),1)
   20 IF (RHS==0 .AND. MN==MNK) GOTO 40
      IF (K >= LSIZE-3) CALL ERROR(13)
      IF (ERR > 0) RETURN
      IF (K == BOT) GOTO 25
      LS = LSTK(BOT)
      LL = LS + MNK
      CALL WCOPY(LK-LS,STKR(LS),STKI(LS),-1,STKR(LL),STKI(LL),-1)
      KM1 = K-1
      DO 24 IB = BOT, KM1
        I = BOT+KM1-IB
        CALL PUTID(IDSTK(1,I+1),IDSTK(1,I))
        MSTK(I+1) = MSTK(I)
        NSTK(I+1) = NSTK(I)
        LSTK(I+1) = LSTK(I)+MNK
   24 CONTINUE
   25 BOT = BOT+1
   30 IF (MN == 0) GOTO 99
      IF (BOT-2 <= TOP) CALL ERROR(18)
      IF (ERR > 0) RETURN
      K = BOT-1
      CALL PUTID(IDSTK(1,K), ID)
      IF (RHS == 1) GOTO 50
      IF (RHS == 2) GOTO 55
   40 IF (K < LSIZE) LSTK(K) = LSTK(K+1) - MN
      MSTK(K) = M
      NSTK(K) = N
      LK = LSTK(K)
      CALL WCOPY(MN,STKR(L),STKI(L),-1,STKR(LK),STKI(LK),-1)
      GOTO 90
   50 IF (MSTK(TOP-1) < 0) GOTO 59
      MN1 = 1
      MN2 = 1
      L1 = 0
      L2 = 0
      IF (N/=1 .OR. NK/=1) GOTO 52
      L1 = LSTK(TOP-1)
      M1 = MSTK(TOP-1)
      MN1 = M1*NSTK(TOP-1)
      M2 = -1
      GOTO 60
   52 IF (M/=1 .OR. MK/=1) CALL ERROR(15)
      IF (ERR > 0) RETURN
      L2 = LSTK(TOP-1)
      M2 = MSTK(TOP-1)
      MN2 = M2*NSTK(TOP-1)
      M1 = -1
      GOTO 60
   55 IF (MSTK(TOP-1)<0 .AND. MSTK(TOP-2)<0) GOTO 59
      L2 = LSTK(TOP-1)
      M2 = MSTK(TOP-1)
      MN2 = M2*NSTK(TOP-1)
      IF (M2 < 0) MN2 = N
      L1 = LSTK(TOP-2)
      M1 = MSTK(TOP-2)
      MN1 = M1*NSTK(TOP-2)
      IF (M1 < 0) MN1 = M
      GOTO 60
   59 IF (MN /= MNK) CALL ERROR(15)
      IF (ERR > 0) RETURN
      LK = LSTK(K)
      CALL WCOPY(MN,STKR(L),STKI(L),-1,STKR(LK),STKI(LK),-1)
      GOTO 90
   60 IF (MN1/=M .OR. MN2/=N) CALL ERROR(15)
      IF (ERR > 0) RETURN
      LL = 1
      IF (M1 < 0) GOTO 62
      DO 61 I = 1, MN1
         LS = L1+I-1
         MK = MAX0(MK,IDINT(STKR(LS)))
         LL = MIN0(LL,IDINT(STKR(LS)))
   61 CONTINUE
   62 MK = MAX0(MK,M)
      IF (M2 < 0) GOTO 64
      DO 63 I = 1, MN2
         LS = L2+I-1
         NK = MAX0(NK,IDINT(STKR(LS)))
         LL = MIN0(LL,IDINT(STKR(LS)))
   63 CONTINUE
   64 NK = MAX0(NK,N)
      IF (LL < 1) CALL ERROR(21)
      IF (ERR > 0) RETURN
      MNK = MK*NK
      LK = LSTK(K+1) - MNK
      ERR = LT + MT*NT - LK
      IF (ERR > 0) CALL ERROR(17)
      IF (ERR > 0) RETURN
      LSTK(K) = LK
      MSTK(K) = MK
      NSTK(K) = NK
      CALL WSET(MNK,0.0D0,0.0D0,STKR(LK),STKI(LK),1)
      IF (NT < 1) GOTO 67
      DO 66 J = 1, NT
         LS = LT+(J-1)*MT
         LL = LK+(J-1)*MK
         CALL WCOPY(MT,STKR(LS),STKI(LS),-1,STKR(LL),STKI(LL),-1)
   66 CONTINUE
   67 DO 68 J = 1, N
      DO 68 I = 1, M
        LI = L1+I-1
        IF (M1 > 0) LI = L1 + IDINT(STKR(LI)) - 1
        LJ = L2+J-1
        IF (M2 > 0) LJ = L2 + IDINT(STKR(LJ)) - 1
        LL = LK+LI-L1+(LJ-L2)*MK
        LS = L+I-1+(J-1)*M
        STKR(LL) = STKR(LS)
        STKI(LL) = STKI(LS)
   68 CONTINUE
      GOTO 90
   90 IF (SYM/=SEMI .AND. LCT(3)==0) CALL PRINT(ID,K)
      IF (SYM==SEMI .AND. LCT(3)==1) CALL PRINT(ID,K)
      IF (K == BOT-1) BOT = BOT-1
   99 IF (M /= 0) TOP = TOP - 1 - RHS
      IF (M == 0) TOP = TOP - 1
      RETURN
      END SUBROUTINE STACKP

      SUBROUTINE TERM
      DOUBLE PRECISION STKR(50505),STKI(50505)
      INTEGER IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
      INTEGER IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
      INTEGER DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,WIO,RTE,WTE,FE
      INTEGER SYM,SYN(4),BUF(256),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
      COMMON /VSTK/ STKR,STKI,IDSTK,LSTK,MSTK,NSTK,VSIZE,LSIZE,BOT,TOP
      COMMON /RECU/ IDS,PSTK,RSTK,PSIZE,PT,PTZ
      COMMON /IOP/ DDT,ERR,FMT,LCT,LIN,LPT,HIO,RIO,WIO,RTE,WTE,FE
      COMMON /COM/ SYM,SYN,BUF,CHRA,FLP,FIN,FUN,LHS,RHS,RAN
      INTEGER R,OP,BSLASH,STAR,SLASH,DOT
      DATA BSLASH/45/,STAR/43/,SLASH/44/,DOT/47/
      save bslash,star,slash,dot
      IF (DDT == 1) WRITE(WTE,100) PT,RSTK(PT)
  100 FORMAT(1X,'TERM  ',2I4)
      R = RSTK(PT)
      GOTO (99,99,99,99,99,01,01,05,25,99,99,99,99,99,35,99,99,99,99),R
   01 PT = PT+1
      RSTK(PT) = 8
      RETURN
   05 PT = PT-1
   10 OP = 0
      IF (SYM == DOT) OP = DOT
      IF (SYM == DOT) CALL GETSYM
      IF (SYM==STAR .OR. SYM==SLASH .OR. SYM==BSLASH) GOTO 20
      RETURN
   20 OP = OP + SYM
      CALL GETSYM
      IF (SYM == DOT) OP = OP + SYM
      IF (SYM == DOT) CALL GETSYM
      PT = PT+1
      PSTK(PT) = OP
      RSTK(PT) = 9
      RETURN
   25 OP = PSTK(PT)
      PT = PT-1
      CALL STACK2(OP)
      IF (ERR > 0) RETURN
      IF (FUN == 0) GOTO 10
      PT = PT+1
      RSTK(PT) = 15
      RETURN
   35 PT = PT-1
      GOTO 10
   99 CALL ERROR(22)
      IF (ERR > 0) RETURN
      RETURN
      END SUBROUTINE TERM

      SUBROUTINE USER(A,M,N,S,T)
      DOUBLE PRECISION A(M,N),S,T
      write(*,*)'USER'
      DO I = 1,m
         do J = 1,n
            A(I,J) =A(I,J)+1
         enddo
      enddo
      M = M
      N = N
      RETURN
      END SUBROUTINE USER

      SUBROUTINE XCHAR(BUF,K)
      INTEGER BUF(*),K
      INTEGER BACK,MASK
      DATA BACK/Z'20202008'/,MASK/Z'000000FF'/
      save back, mask
      IF (BUF(1) == BACK) K = -1
      !L = BUF(1) .AND. MASK
      !IF(BUF(1)<30.OR.BUF(1)>70)
      L = IAND(BUF(1),MASK)
      IF (K /= -1) WRITE(6,10) BUF(1),L
   10 FORMAT(1X,1H',A1,4H' = ,Z2,' hex is not a MATLAB character.')
      RETURN
      END SUBROUTINE XCHAR


      SUBROUTINE BASE(X,B,EPS,S,N)
      DOUBLE PRECISION X,B,EPS,S(1),T
      INTEGER PLUS,MINUS,DOT,ZERO,COMMA
      DATA PLUS/41/,MINUS/42/,DOT/47/,ZERO/0/,COMMA/48/
      save plus, minus, dot, zero, comma
      L = 1
      IF (X >= 0.0D0) S(L) = PLUS
      IF (X < 0.0D0) S(L) = MINUS
      S(L+1) = ZERO
      S(L+2) = DOT
      X = DABS(X)
      IF (X /= 0.0D0) THEN
         K = DLOG(X)/DLOG(B)
      ELSE
         K = 0
      ENDIF
      IF (X > 1.0D0) K = K + 1
      X = X/B**K
      IF (B*X >= B) K = K + 1
      IF (B*X >= B) X = X/B
      IF (EPS /= 0.0D0)THEN
         M = (-1)*DLOG(EPS)/DLOG(B) + 4
      ELSE
         M = 54
      ENDIF
      DO 10 L = 4, M
      X = B*X
      J = IDINT(X)
      S(L) = DFLOAT(J)
      X = X - S(L)
   10 CONTINUE
      S(M+1) = COMMA
      IF (K >= 0) S(M+2) = PLUS
      IF (K < 0) S(M+2) = MINUS
      T = DABS(DFLOAT(K))
      N = M + 3
      IF (T >= B) N = N + IDINT(DLOG(T)/DLOG(B))
      L = N
   20 J = IDINT(DMOD(T,B))
      S(L) = DFLOAT(J)
      L = L - 1
      T = T/B
      IF (L >= M+3) GOTO 20
      RETURN
      END SUBROUTINE BASE

      SUBROUTINE WCOPY(N,XR,XI,INCX,YR,YI,INCY)
      DOUBLE PRECISION XR(1),XI(1),YR(1),YI(1)
      IF (N <= 0) RETURN
      IX = 1
      IY = 1
      IF (INCX<0) IX = (-N+1)*INCX + 1
      IF (INCY<0) IY = (-N+1)*INCY + 1
      DO 10 I = 1, N
         YR(IY) = XR(IX)
         YI(IY) = XI(IX)
         IX = IX + INCX
         IY = IY + INCY
   10 CONTINUE
      RETURN
      END SUBROUTINE WCOPY

      SUBROUTINE WSET(N,XR,XI,YR,YI,INCY)
      INTEGER N,INCY
      DOUBLE PRECISION XR,XI,YR(1),YI(1)
      IY = 1
      IF (N <= 0 ) RETURN
      DO 10 I = 1,N
         YR(IY) = XR
         YI(IY) = XI
         IY = IY + INCY
   10 CONTINUE
      RETURN
      END SUBROUTINE WSET

      SUBROUTINE WSWAP(N,XR,XI,INCX,YR,YI,INCY)
      DOUBLE PRECISION XR(1),XI(1),YR(1),YI(1),T
      IF (N <= 0) RETURN
      IX = 1
      IY = 1
      IF (INCX<0) IX = (-N+1)*INCX + 1
      IF (INCY<0) IY = (-N+1)*INCY + 1
      DO 10 I = 1, N
         T = XR(IX)
         XR(IX) = YR(IY)
         YR(IY) = T
         T = XI(IX)
         XI(IX) = YI(IY)
         YI(IY) = T
         IX = IX + INCX
         IY = IY + INCY
   10 CONTINUE
      RETURN
      END SUBROUTINE WSWAP

      SUBROUTINE RSET(N,DX,DY,INCY)
      DOUBLE PRECISION DX,DY(1)
      IF (N<=0) RETURN
      IY = 1
      IF (INCY<0) IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DX
        IY = IY + INCY
   10 CONTINUE
      RETURN
      END SUBROUTINE RSET

      SUBROUTINE RSWAP(N,X,INCX,Y,INCY)
      DOUBLE PRECISION X(1),Y(1),T
      IF (N <= 0) RETURN
      IX = 1
      IY = 1
      IF (INCX<0) IX = (-N+1)*INCX+1
      IF (INCY<0) IY = (-N+1)*INCY+1
      DO 10 I = 1, N
         T = X(IX)
         X(IX) = Y(IY)
         Y(IY) = T
         IX = IX + INCX
         IY = IY + INCY
   10 CONTINUE
      RETURN
      END SUBROUTINE RSWAP

      LOGICAL FUNCTION EQID(X,Y)
      INTEGER X(4),Y(4)
      EQID = .TRUE.
      DO 10 I = 1, 4
   10 EQID = EQID .AND. (X(I)==Y(I))
      RETURN
      END FUNCTION EQID
      SUBROUTINE PUTID(X,Y)
      INTEGER X(4),Y(4)
      DO 10 I = 1, 4
   10 X(I) = Y(I)
      RETURN
      END SUBROUTINE PUTID
