<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M_strings: m_matrix::lala Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M_strings
   </div>
   <div id="projectbrief">M_strings module (Fortran)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacem__matrix.html">m_matrix</a></li><li class="navelem"><a class="el" href="interfacem__matrix_1_1lala.html">lala</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfacem__matrix_1_1lala-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">m_matrix::lala Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0518fa318b6499db6d2c8a361363235e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__matrix_1_1lala.html#a0518fa318b6499db6d2c8a361363235e">lala_init</a> (init, echo)</td></tr>
<tr class="separator:a0518fa318b6499db6d2c8a361363235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab499a9a9b4ed9f933cf1d0da2433a291"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__matrix_1_1lala.html#ab499a9a9b4ed9f933cf1d0da2433a291">lala_cmd</a> (input_string, echo)</td></tr>
<tr class="separator:ab499a9a9b4ed9f933cf1d0da2433a291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab920520b0edb78ff9f19301b115a4470"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__matrix_1_1lala.html#ab920520b0edb78ff9f19301b115a4470">lala_cmds</a> (pseudo_file, echo)</td></tr>
<tr class="separator:ab920520b0edb78ff9f19301b115a4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function/Subroutine Documentation</h2>
<a id="ab499a9a9b4ed9f933cf1d0da2433a291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab499a9a9b4ed9f933cf1d0da2433a291">&#9670;&nbsp;</a></span>lala_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_matrix::lala::lala_cmd </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>input_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>echo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab920520b0edb78ff9f19301b115a4470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab920520b0edb78ff9f19301b115a4470">&#9670;&nbsp;</a></span>lala_cmds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_matrix::lala::lala_cmds </td>
          <td>(</td>
          <td class="paramtype">character(len=*), dimension(:), intent(in), optional&#160;</td>
          <td class="paramname"><em>pseudo_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>echo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0518fa318b6499db6d2c8a361363235e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0518fa318b6499db6d2c8a361363235e">&#9670;&nbsp;</a></span>lala_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_matrix::lala::lala_init </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>echo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md4"></a>
NAME</h2>
<p>LALA(3f) - [M_matrix] initialize and/or pass commands to matrix laboratory interpreter LICENSE(MIT) </p>
<h2><a class="anchor" id="autotoc_md5"></a>
SYNOPSIS</h2>
<pre class="fragment"> subroutine lala(init,cmd)

  integer,intent(in),optional :: init
  character(len=*),intent(in),optional :: cmd
     or
  character(len=*),intent(in),optional :: cmd(:)
</pre><h2><a class="anchor" id="autotoc_md6"></a>
DESCRIPTION</h2>
<p>LALA(3f) is modeled on MATLAB(3f) (MATrix LABoratory), a FORTRAN package developed by Argonne National Laboratories for in-house use. It provides comprehensive vector and tensor operations in a package which may be programmed, either through a macro language or through execution of script files.</p>
<p>LALA(3f) Functions supported include (but are not by any means limited to) sin, cos, tan, arcfunctions, upper triangular, lower triangular, determinants, matrix multiplication, identity, Hilbert matrices, eigenvalues and eigenvectors, matrix roots and products, inversion and so on and so forth.</p>
<p>LALA() can be used</p><ul>
<li>as a stand-alone utility for working with lala() files and for basic computations.</li>
<li>embedded in a Fortran program, passing variables back and forth between the calling program and the utility.</li>
<li>to read configuration and data files that contain expressions and conditionally selected values.</li>
<li>for interactively inspecting data generated by the calling program.</li>
<li>for creating unit tests that allow for further interactive examination.</li>
</ul>
<p>The HELP command describes using the interpreter.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
OPTIONS</h2>
<p>INIT indicate size of scratch space to allocate and (re)initialize LALA.</p>
<p>CMD LALA command(s) to perform. May be CHARACTER scalar or vector</p>
<p>INIT and CMD cannot be combined on a single call.</p>
<p>The first call may be an initialization declaring the number of doubleprecision complex values to allocate for the combined scratch and variable storage area. This form may be repeated and reinitializes the utility at each call. A size of zero will deallocate any allocated storage (after which the routine cannot be called with commands until reallocated by another call to lala()).</p>
<p>If no parameters are supplied interactive mode is entered.</p>
<p>If a CMD is passed and no previous initialization call was made the scratch space will be allocated to 200000.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
EXAMPLE</h2>
<p>Example 1: </p><pre class="fragment">program demo_LALA
use M_matrix, only : lala

   write(*,'(a)')'optionally initialize scratch area size'
   call LALA(20000)

   write(*,'(a)')'do some commands'
   call LALA([character(len=80) :: &amp;
   &amp; 'semi;                         ',&amp;
   &amp; 'a=magic(4),b=-a               ',&amp;
   &amp; 'a+b;a;b                       ',&amp;
   &amp; "display('That is all Folks!') "])

   write(*,'(a)')'do a single command'
   call LALA('who')

   write(*,'(a)')'enter interactive mode'
   call LALA()

   write(*,'(a)')'ending program'
end program demo_LALA
</pre><p>Example 2:</p>
<p>program bigmat use M_matrix, only : lala ! pass strings to LALA but do not enter interactive mode call lala(20000) ! initialize silently call lala( 'a=[1 2 3 4; 5 6 7 8]') call lala( [character(len=80) :: &amp; &amp; 'semi;lines(999999) ',&amp; &amp; '// create a magic square and add 100 to all the values',&amp; &amp; 'A=magic(4),&lt;X,Y&gt;=shape(A) ',&amp; &amp; 'B=A+ones(X,Y)*100 ',&amp; &amp; '// save all current values to a file ',&amp; &amp; "save('sample.laf')                                    ",&amp; &amp; '// clear all user values ',&amp; &amp; 'clear ',&amp; &amp; '// show variable names, load values from file ',&amp; &amp; '// and show again to show the variables are restored ',&amp; &amp; "who;load('sample.laf');who                            "]) end program bigmat</p>
<p>Example 3: Sample program with custom user function </p><pre class="fragment">program custom_user
use M_matrix
implicit none
call set_usersub(lala_user)
call lala()
contains
!-------------------------------------------------------------
subroutine lala_user(a,m,n,s,t)  ! sample user routine
! Allows personal  Fortran  subroutines  to  be  linked  into
! LALA. The subroutine should have the heading
!
!    subroutine name(a,m,n,s,t)
!    integer :: m,n
!    doubleprecision a(:),s,t
!
! The LALA statement Y = USER(X,s,t) results in a call to
! the subroutine with a copy of the matrix X stored in the
! argument A, its column and row dimensions in M and N,
! and the scalar parameters S and T stored in S and T.
! If S and T are omitted, they are set to 0.0. After
! the return, A is stored in Y. The dimensions M and
! N may be reset within the subroutine. The statement Y =
! USER(K) results in a call with M = 1, N = 1 and A(1,1) =
! FLOAT(K). After the subroutine has been written, it must
! be compiled and linked to the LALA object code within the
! local programming environment.
!
implicit none
integer                    :: m,n
doubleprecision            :: a(:)
doubleprecision            :: s,t
integer                    :: i, j, k
   write(*,*)'MY ROUTINE'
   write(*,*)'M=',m
   write(*,*)'N=',n
   write(*,*)'S=',s
   write(*,*)'T=',t
   k=0
   do i = 1, m
      do j = 1, n
         k=k+1
         write(*,*)i,j,a(k)
      enddo
   enddo
   k=0
   if(s.eq.0)s=1
   do i = 1, m
      do j = 1, n
         k=k+1
         a(k)=a(k)*s+t
      enddo
   enddo
end subroutine lala_user
end program custom_user
</pre><p>Example inputs </p><pre class="fragment">&gt;:avg:

&gt;for i = 2:2:n, for j = 2:2:n, t = (a(i-1,j-1)+a(i-1,j)+a(i,j-1)+a(i,j))/4; ...
&gt;a(i-1,j-1) = t; a(i,j-1) = t; a(i-1,j) = t; a(i,j) = t;

&gt;:cdiv:

&gt;// ======================================================
&gt;// cdiv
&gt;a=sqrt(random(8))
&gt;ar = real(a); ai = imag(a); br = real(b); bi = imag(b);
&gt;p = bi/br;
&gt;t = (ai - p*ar)/(br + p*bi);
&gt;cr = p*t + ar/br;
&gt;ci = t;
&gt;p2 = br/bi;
&gt;t2 = (ai + p2*ar)/(bi + p2*br);
&gt;ci2 = p2*t2 - ar/bi;
&gt;cr2 = t2;
&gt;s = abs(br) + abs(bi);
&gt;ars = ar/s;
&gt;ais = ai/s;
&gt;brs = br/s;
&gt;bis = bi/s;
&gt;s = brs**2 + bis**2;
&gt;cr3 = (ars*brs + ais*bis)/s;
&gt;ci3 = (ais*brs - ars*bis)/s;
&gt;[cr ci; cr2 ci2; cr3 ci3]
&gt;// ======================================================

&gt;:exp:

&gt;t = 0*x + eye; s = 0*eye(x); n = 1;
&gt;while abs(s+t-s) &gt; 0, s = s+t, t = x*t/n, n = n + 1

&gt;:four:
&gt; n
&gt; pi = 4*atan(1);
&gt; i = sqrt(-1);
&gt; w = exp(2*pi*i/n);
&gt; F = [];
&gt; for k = 1:n, for j = 1:n, F(k,j) = w**((j-1)*(k-1));
&gt; F = F/sqrt(n);
&gt; alpha = r*pi;
&gt; rho = exp(i*alpha);
&gt; S = log(rho*F)/i - alpha*eye;
&gt; serr = norm(imag(S),1);
&gt; S = real(S);
&gt; serr = serr + norm(S-S',1)
&gt; S = (S + S')/2;
&gt; ferr = norm(F-exp(i*S),1)

&gt; :gs:
&gt; for k = 1:n, for j = 1:k-1, d = x(k,:)*x(j,:)'; x(k,:) = x(k,:) - d*x(j,:); ...
&gt; end, s = norm(x(k,:)), x(k,:) = x(k,:)/s;

&gt; :jacobi:
&gt; [n, n] = shape(A);
&gt; X = eye(n);
&gt; anorm = norm(A,'fro');
&gt; cnt = 1;
&gt; while cnt &gt; 0, ...
&gt;   cnt = 0; ...
&gt;   for p = 1:n-1, ...
&gt;     for q = p+1:n, ...
&gt;       if anorm + abs(a(p,q)) &gt; anorm, ...
&gt;         cnt = cnt + 1; ...
&gt;         exec('jacstep'); ...
&gt;       end, ...
&gt;     end, ...
&gt;   end, ...
&gt;   display(rat(A)), ...
&gt; end

&gt; :jacstep:

&gt; d = (a(q,q)-a(p,p))*0.5/a(p,q);
&gt; t = 1/(abs(d)+sqrt(d*d+1));
&gt; if d &lt; 0, t = -t; end;
&gt; c = 1/sqrt(1+t*t);  s = t*c;
&gt; R = eye(n); r(p,p)=c; r(q,q)=c; r(p,q)=s; r(q,p)=-s;
&gt; X = X*R;
&gt; A = R'*A*R;

&gt; :kron:

&gt; //  C = Kronecker product of A and B
&gt; [m, n] = shape(A);
&gt; for i = 1:m, ...
&gt;    ci = a(i,1)*B; ...
&gt;    for j = 2:n, ci = [ci a(i,j)*B]; end ...
&gt;    if i = 1, C = ci; else, C = [C; ci];

&gt; :lanczos:

&gt; [n,n] = shape(A);
&gt; q1 = rand(n,1);
&gt; ort
&gt; alpha = []; beta = [];
&gt; q = q1/norm(q1); r = A*q(:,1);
&gt; for j = 1:n, exec('lanstep',0);

&gt; :lanstep:

&gt; alpha(j) = q(:,j)'*r;
&gt; r = r - alpha(j)*q(:,j);
&gt; if ort &lt;&gt; 0, for k = 1:j-1, r = r - r'*q(:,k)*q(:,k);
&gt; beta(j) = norm(r);
&gt; q(:,j+1) = r/beta(j);
&gt; r = A*q(:,j+1) - beta(j)*q(:,j);
&gt; if j &gt; 1, T = diag(beta(1:j-1),1); T = diag(alpha) + T + T'; eig(T)

&gt; :mgs:

&gt; for k = 1:n, s = norm(x(k,:)), x(k,:) = x(k,:)/s; ...
&gt;    for j = k+1:n, d = x(j,:)*x(k,:)'; x(j,:) = x(j,:) - d*x(k,:);

&gt; :net:

&gt; C = [
&gt; 1   2   15  .   .   .
&gt; 2   1   3   .   .   .
&gt; 3   2   4   11  .   .
&gt; 4   3   5   .   .   .
&gt; 5   4   6   7   .   .
&gt; 6   5   8   .   .   .
&gt; 7   5   9   30  .   .
&gt; 8   6   9   10  11  .
&gt; 9   7   8   30  .   .
&gt; 10  8   12  30  31  34
&gt; 11  3   8   12  13  .
&gt; 12  10  11  34  36  .
&gt; 13  11  14  .   .   .
&gt; 14  13  15  16  38  .
&gt; 15  1   14  .   .   .
&gt; 16  14  17  20  35  37
&gt; 17  16  18  .   .   .
&gt; 18  17  19  .   .   .
&gt; 19  18  20  .   .   .
&gt; 20  16  19  21  .   .
&gt; 21  20  22  .   .   .
&gt; 22  21  23  .   .   .
&gt; 23  22  24  35  .   .
&gt; 24  23  25  39  .   .
&gt; 25  24  .   .   .   .
&gt; 26  27  33  39  .   .
&gt; 27  26  32  .   .   .
&gt; 28  29  32  .   .   .
&gt; 29  28  30  .   .   .
&gt; 30  7   9   10  29  .
&gt; 31  10  32  .   .   .
&gt; 32  27  28  31  34  .
&gt; 33  26  34  .   .   .
&gt; 34  10  12  32  33  35
&gt; 35  16  23  34  36  .
&gt; 36  12  35  38  .   .
&gt; 37  16  38  .   .   .
&gt; 38  14  36  37  .   .
&gt; 39  24  26  .   .   .
&gt; ];
&gt; [n, m] = shape(C);
&gt; A = 0*ones(n,n);
&gt; for i=1:n, for j=2:m, k=c(i,j); if k&gt;0, a(i,k)=1;
&gt; check = norm(A-A',1), if check &gt; 0, quit
&gt; [X,D] = eig(A+eye);
&gt; D = diag(D);  D = D(n:-1:1)
&gt; X = X(:,n:-1:1);
&gt; [x(:,1)/sum(x(:,1)) x(:,2) x(:,3) x(:,19)]

&gt; :pascal:

&gt; //Generate next Pascal matrix
&gt; [k,k] = shape(L);
&gt; k = k + 1;
&gt; L(k,1:k) = [L(k-1,:) 0] + [0 L(k-1,:)];

&gt; :pdq:

&gt; alpha = []; beta = 0; q = []; p = p(:,1)/norm(p(:,1));
&gt; t = A'*p(:,1);
&gt; alpha(1) = norm(t);
&gt; q(:,1) = t/alpha(1);
&gt; X = p(:,1)*(alpha(1)*q(:,1))'
&gt; e(1) = norm(A-X,1)
&gt; for j = 2:r, exec('pdqstep',ip); ...
&gt;    X = X + p(:,j)*(alpha(j)*q(:,j)+beta(j)*q(:,j-1))', ...
&gt;    e(j) = norm(A-X,1)

&gt; :pdqstep:

&gt; t = A*q(:,j-1) - alpha(j-1)*p(:,j-1);
&gt;    if ort&gt;0, for i = 1:j-1, t = t - t'*p(:,i)*p(:,i);
&gt; beta(j) = norm(t);
&gt; p(:,j) = t/beta(j);
&gt; t = A'*p(:,j) - beta(j)*q(:,j-1);
&gt;    if ort&gt;0, for i = 1:j-1, t = t - t'*q(:,i)*q(:,i);
&gt; alpha(j) = norm(t);
&gt; q(:,j) = t/alpha(j);

&gt; :pop:

&gt; y = [ 75.995   91.972  105.711  123.203   ...
&gt;      131.669  150.697  179.323  203.212]'
&gt; t = [ 1900:10:1970 ]'
&gt; t = (t - 1940*ones(t))/40;   [t y]
&gt; n = 8;  A(:,1) = ones(t);  for j = 2:n, A(:,j) = t .* A(:,j-1);
&gt; A
&gt; c = A\y

&gt; :qr:

&gt; scale = s(m);
&gt; sm = s(m)/scale; smm1 = s(m-1)/scale; emm1 = e(m-1)/scale;
&gt; sl = s(l)/scale; el = e(l)/scale;
&gt; b = ((smm1 + sm)*(smm1 - sm) + emm1**2)/2;
&gt; c = (sm*emm1)**2;
&gt; shift = sqrt(b**2+c); if b &lt; 0, shift = -shift;
&gt; shift = c/(b + shift)
&gt; f = (sl + sm)*(sl-sm) - shift
&gt; g = sl*el
&gt; for k = l: m-1, exec('qrstep',ip)
&gt; e(m-1) = f

&gt; :qrstep:

&gt; exec('rot');
&gt; if k &lt;&gt; l, e(k-1) = f
&gt; f = cs*s(k) + sn*e(k)
&gt; e(k) = cs*e(k) - sn*s(k)
&gt; g = sn*s(k+1)
&gt; s(k+1) = cs*s(k+1)
&gt; exec('rot');
&gt; s(k) = f
&gt; f = cs*e(k) + sn*s(k+1)
&gt; s(k+1) = -sn*e(k) + cs*s(k+1)
&gt; g = sn*e(k+1)
&gt; e(k+1) = cs*e(k+1)

&gt; :rho:

&gt; //Conductivity example.
&gt; //Parameters ---
&gt;    rho       //radius of cylindrical inclusion
&gt;    n         //number of terms in solution
&gt;    m         //number of boundary points
&gt; //initialize operation counter
&gt;    flop = [0 0];
&gt; //initialize variables
&gt;    m1 = round(m/3);   //number of points on each straight edge
&gt;    m2 = m - m1;       //number of points with Dirichlet conditions
&gt;    pi = 4*atan(1);
&gt; //generate points in Cartesian coordinates
&gt;    //right hand edge
&gt;    for i = 1:m1, x(i) = 1; y(i) = (1-rho)*(i-1)/(m1-1);
&gt;    //top edge
&gt;    for i = m2+1:m, x(i) = (1-rho)*(m-i)/(m-m2-1); y(i) = 1;
&gt;    //circular edge
&gt;    for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); ...
&gt;       x(i) = 1-rho*sin(t);  y(i) = 1-rho*cos(t);
&gt; //convert to polar coordinates
&gt;    for i = 1:m-1, th(i) = atan(y(i)/x(i));  ...
&gt;       r(i) = sqrt(x(i)**2+y(i)**2);
&gt;    th(m) = pi/2;  r(m) = 1;
&gt; //generate matrix
&gt;    //Dirichlet conditions
&gt;    for i = 1:m2, for j = 1:n, k = 2*j-1; ...
&gt;       a(i,j) = r(i)**k*cos(k*th(i));
&gt;    //Neumann conditions
&gt;    for i = m2+1:m, for j = 1:n, k = 2*j-1; ...
&gt;       a(i,j) = k*r(i)**(k-1)*sin((k-1)*th(i));
&gt; //generate right hand side
&gt;    for i = 1:m2, b(i) = 1;
&gt;    for i = m2+1:m, b(i) = 0;
&gt; //solve for coefficients
&gt;    c = A\b
&gt; //compute effective conductivity
&gt;    c(2:2:n) = -c(2:2:n)
&gt;    sigma = sum(c)
&gt; //output total operation count
&gt;    ops = flop(2)

&gt; :rogers.exec:

&gt; exec('d.boug');                // reads data
&gt; [g,k] = shape(p);              // p is matrix of gene frequencies
&gt; wv = ncen/sum(ncen);           // ncen contains population sizes
&gt; pbar = wv*p;                   // weighted average of p
&gt; p = p - ones(g,1)*pbar;        // deviations from mean
&gt; p = sqrt(diag(wv)) * p;        // weight rows of p by sqrt of pop size
&gt; h = diag(pbar); h = h*(eye-h); // diagonal contains binomial variance: p*(1-p)
&gt; r = p*inv(h)*p'/k;             // normalized covariance matrix
&gt; eig(r)'

&gt; :rosser:

&gt; A  = [
&gt;   611.  196. -192.  407.   -8.  -52.  -49.   29.
&gt;   196.  899.  113. -192.  -71.  -43.   -8.  -44.
&gt;  -192.  113.  899.  196.   61.   49.    8.   52.
&gt;   407. -192.  196.  611.    8.   44.   59.  -23.
&gt;    -8.  -71.   61.    8.  411. -599.  208.  208.
&gt;   -52.  -43.   49.   44. -599.  411.  208.  208.
&gt;   -49.   -8.    8.   59.  208.  208.   99. -911.
&gt;    29.  -44.   52.  -23.  208.  208. -911.   99.  ];

&gt; :rot:

&gt; // subexec rot(f,g,cs,sn)
&gt;    rho = g; if abs(f) &gt; abs(g), rho = f;
&gt;    cs = 1.0; sn = 0.0; z = 1.0;
&gt;    r = norm([f g]); if rho &lt; 0, r = -r; r
&gt;    if r &lt;&gt; 0.0, cs = f/r
&gt;    if r &lt;&gt; 0.0, sn = g/r
&gt;    if abs(f) &gt; abs(g), z = sn;
&gt;    if abs(g) &gt;= abs(f), if cs &lt;&gt; 0, z = 1/cs;
&gt;    f = r;
&gt;    g = z;

&gt; :rqi:

&gt; rho = (x'*A*x)
&gt; x = (A-rho*eye)\x;
&gt; x = x/norm(x)

&gt; :setup:

&gt; diary('xxx')
&gt; !tail -f xxx &gt; /dev/tty1 &amp;
&gt; !tail -f xxx &gt; /dev/tty2 &amp;

&gt; :sigma:

&gt; RHO = .5  M = 20  N = 10   SIGMA =  1.488934271883534
&gt; RHO = .5  M = 40  N = 20   SIGMA =  1.488920312974229
&gt; RHO = .5  M = 60  N = 30   SIGMA =  1.488920697912116

&gt; :strut.laf:

&gt; // Structure problem, Forsythe, Malcolm and Moler, p. 62
&gt; s =  sqrt(2)/2;
&gt; A = [
&gt; -s  .  .  1  s   .  .  .  .  .  .  .  .  .  .  .  .
&gt; -s  . -1  . -s   .  .  .  .  .  .  .  .  .  .  .  .
&gt;  . -1  .  .  .   1  .  .  .  .  .  .  .  .  .  .  .
&gt;  .  .  1  .  .   .  .  .  .  .  .  .  .  .  .  .  .
&gt;  .  .  . -1  .   .  .  1  .  .  .  .  .  .  .  .  .
&gt;  .  .  .  .  .   . -1  .  .  .  .  .  .  .  .  .  .
&gt;  .  .  .  . -s -1  .  .  s  1  .  .  .   .  .  .  .
&gt;  .  .  .  .  s   .  1  .  s  .  .  .  .  .  .  .  .
&gt;  .  .  .  .  .   .  . -1 -s  .  .  1  s  .  .  .  .
&gt;  .  .  .  .  .   .  .  . -s  . -1  . -s  .  .  .  .
&gt;  .  .  .  .  .   .  .  .  . -1  .  .  .  1  .  .  .
&gt;  .  .  .  .  .   .  .  .  .  .  1  .  .  .  .  .  .
&gt;  .  .  .  .  .   .  .  .  .  .  . -1  .  .  .  s  .
&gt;  .  .  .  .  .   .  .  .  .  .  .  .  .  . -1 -s  .
&gt;  .  .  .  .  .   .  .  .  .  .  .  . -s -1  .  .  1
&gt;  .  .  .  .  .   .  .  .  .  .  .  .  s  .  1  .  .
&gt;  .  .  .  .  .   .  .  .  .  .  .  .  .  .  . -s -1];
&gt; b = [
&gt;  .  .  . 10  .   .  . 15  .  .  .  .  .  .  . 10  .]';

&gt; :test1:

&gt; // -----------------------------------------------------------------
&gt; // start a new log file
&gt; sh rm -fv log.txt
&gt; diary('log.txt')
&gt; // -----------------------------------------------------------------
&gt; titles=['GNP deflator'
&gt;  'GNP         '
&gt;  'Unemployment'
&gt;  'Armed Force '
&gt;  'Population  '
&gt;  'Year        '
&gt;  'Employment  '];
&gt; data = ...
&gt; [ 83.0  234.289  235.6  159.0  107.608  1947  60.323
&gt;   88.5  259.426  232.5  145.6  108.632  1948  61.122
&gt;   88.2  258.054  368.2  161.6  109.773  1949  60.171
&gt;   89.5  284.599  335.1  165.0  110.929  1950  61.187
&gt;   96.2  328.975  209.9  309.9  112.075  1951  63.221
&gt;   98.1  346.999  193.2  359.4  113.270  1952  63.639
&gt;   99.0  365.385  187.0  354.7  115.094  1953  64.989
&gt;  100.0  363.112  357.8  335.0  116.219  1954  63.761
&gt;  101.2  397.469  290.4  304.8  117.388  1955  66.019
&gt;  104.6  419.180  282.2  285.7  118.734  1956  67.857
&gt;  108.4  442.769  293.6  279.8  120.445  1957  68.169
&gt;  110.8  444.546  468.1  263.7  121.950  1958  66.513
&gt;  112.6  482.704  381.3  255.2  123.366  1959  68.655
&gt;  114.2  502.601  393.1  251.4  125.368  1960  69.564
&gt;  115.7  518.173  480.6  257.2  127.852  1961  69.331
&gt;  116.9  554.894  400.7  282.7  130.081  1962  70.551];
&gt; short
&gt; X = data;
&gt; [n,p] = shape(X)
&gt; mu = ones(1,n)*X/n
&gt; X = X - ones(n,1)*mu;  X = X/diag(sqrt(diag(X'*X)))
&gt; corr = X'*X
&gt; y = data(:,p); X = [ones(y) data(:,1:p-1)];
&gt; long e
&gt; beta = X\y
&gt; expected = [ ...
&gt;    -3.482258634594421D+03
&gt;     1.506187227124484D-02
&gt;    -3.581917929257409D-02
&gt;    -2.020229803816908D-02
&gt;    -1.033226867173703D-02
&gt;    -5.110410565317738D-02
&gt;     1.829151464612817D+00
&gt; ]
&gt; display('EXPE and BETA should be the same')

&gt; :tryall:

&gt; diary('log.txt')
&gt; a=magic(8)
&gt; n=3
&gt; exec('avg')
&gt; b=random(8,8)
&gt; exec('cdiv')
&gt; exec('exp')
&gt; exec('four')
&gt; exec('gs')
&gt; exec('jacobi')
&gt; // jacstep
&gt; exec('kron')
&gt; exec('lanczos')
&gt; // lanstep
&gt; exec('longley')
&gt; exec('mgs')
&gt; exec('net')
&gt; exec('pascal')
&gt; exec('pdq')
&gt; // pdqstep
&gt; exec('pop')
&gt; exec('qr')
&gt; // qrstep
&gt; exec('rho')
&gt; exec('rosser')
&gt; // rot
&gt; exec('rqi')
&gt; exec('setup')
&gt; exec('sigma')
&gt; exec('strut.laf')
&gt; exec('w5')
&gt; exec('rogers.exec
&gt; exec('rogers.load

&gt; :w5:

&gt; w5 = [
&gt;         1.     1.      0.      0.      0.
&gt;       -10.     1.      1.      0.      0.
&gt;        40.     0.      1.      1.      0.
&gt;       205.     0.      0.      1.      1.
&gt;       024.     0.      0.      0.     -4.
&gt;      ]
</pre> 
</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>/home/urbanjs/venus/V600/github/FIXME/M_matrix/src/<a class="el" href="M__matrix_8f90.html">M_matrix.f90</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
