<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M_strings: /home/urbanjs/venus/V600/github/M_matrix/src/mainpage.txt File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M_strings
   </div>
   <div id="projectbrief">M_strings module (Fortran)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">/home/urbanjs/venus/V600/github/M_matrix/src/mainpage.txt File Reference</div>  </div>
</div><!--header-->
<div class="contents">
</div><!-- contents -->
<div class="ttc" id="anamespacem__matrix_html_aa4dc37ac26215b5a9d65c426e9135536"><div class="ttname"><a href="namespacem__matrix.html#aa4dc37ac26215b5a9d65c426e9135536">m_matrix::ch_a</a></div><div class="ttdeci">character(len=ialf), parameter ch_a</div><div class="ttdef"><b>Definition:</b> mmm.f90:91</div></div>
<div class="ttc" id="atest1_8txt_html_a0615ca6af397709808a3efdd1d073b45"><div class="ttname"><a href="test1_8txt.html#a0615ca6af397709808a3efdd1d073b45">Computations</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Computations</div><div class="ttdef"><b>Definition:</b> test1.txt:2126</div></div>
<div class="ttc" id="atest1_8txt_html_a0dff8aa92ee5a1a62fafed52cf2ff161"><div class="ttname"><a href="test1_8txt.html#a0dff8aa92ee5a1a62fafed52cf2ff161">ROOTS</a></div><div class="ttdeci">C This recursion is easily derived by expanding the ROOTS(C) finds the roots of the polynomial of degree n</div></div>
<div class="ttc" id="atest1_8txt_html_a804c93a768180145c702b43a0988f83c"><div class="ttname"><a href="test1_8txt.html#a804c93a768180145c702b43a0988f83c">eigenvalue</a></div><div class="ttdeci">X *D X This is essentially method number out of the dubious possibilities described in[8] It is dubious because it doesn t always work The matrix of eigenvectors X can be arbitrarily badly conditioned and all accuracy lost in the computation of X *D X A warning message is printed if but this only catches the extreme cases An example of a case not detected is when A has a double eigenvalue</div><div class="ttdef"><b>Definition:</b> test1.txt:1669</div></div>
<div class="ttc" id="atest1_8txt_html_a3dd2dba3ae69eb269b78b5e09f74bb26"><div class="ttname"><a href="test1_8txt.html#a3dd2dba3ae69eb269b78b5e09f74bb26">I</a></div><div class="ttdeci">A T N DO I</div><div class="ttdef"><b>Definition:</b> test1.txt:1927</div></div>
<div class="ttc" id="atest1_8txt_html_ab6a22d58b2a0617d0c7b04b4c1985cbe"><div class="ttname"><a href="test1_8txt.html#ab6a22d58b2a0617d0c7b04b4c1985cbe">IF</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc X saves only X See FILE The variables may be retrieved later by then REAL or DOUBLEPRECISION NMAX IMG DO N M IF(IMG .NE. 0) READ(lunit</div></div>
<div class="ttc" id="amold_8f90_html_a9fa04fcf75831125d0113832399d3048"><div class="ttname"><a href="mold_8f90.html#a9fa04fcf75831125d0113832399d3048">wgeco</a></div><div class="ttdeci">subroutine wgeco(AR, AI, LDA, N, IPVT, RCOND, ZR, ZI)</div><div class="ttdef"><b>Definition:</b> mold.f90:4294</div></div>
<div class="ttc" id="atest1_8txt_html_add132dbc46e62020324a710242f60a68"><div class="ttname"><a href="test1_8txt.html#add132dbc46e62020324a710242f60a68">Morrison</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Morrison</div><div class="ttdef"><b>Definition:</b> test1.txt:2128</div></div>
<div class="ttc" id="amold_8f90_html_a36110a70a260ab07b464057abdbf8732"><div class="ttname"><a href="mold_8f90.html#a36110a70a260ab07b464057abdbf8732">rrot</a></div><div class="ttdeci">subroutine rrot(N, DX, INCX, DY, INCY, C, S)</div><div class="ttdef"><b>Definition:</b> mold.f90:7633</div></div>
<div class="ttc" id="atest1_8txt_html_a298610cb7d127a8ce5f4e9defb0bfa4d"><div class="ttname"><a href="test1_8txt.html#a298610cb7d127a8ce5f4e9defb0bfa4d">edition</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second edition</div><div class="ttdef"><b>Definition:</b> test1.txt:2100</div></div>
<div class="ttc" id="atest1_8txt_html_a962e4e9f4c0fc027ce911f2895609760"><div class="ttname"><a href="test1_8txt.html#a962e4e9f4c0fc027ce911f2895609760">LOAD</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the LOAD</div><div class="ttdef"><b>Definition:</b> test1.txt:2829</div></div>
<div class="ttc" id="atest1_8txt_html_a883da709bc4c895ae385e32ed7130398"><div class="ttname"><a href="test1_8txt.html#a883da709bc4c895ae385e32ed7130398">clauses</a></div><div class="ttdeci">is a by matrix The semicolon ends the first row Vectors and matrices can be used inside&lt; &gt; brackets&lt; A B;C &gt; is allowed if the number of rows of A equals the number of rows of B and the number of columns of A plus the number of columns of B equals the number of columns of C This rule generalizes in a hopefully obvious way to allow fairly complicated constructions thereby removing it from the list of current variables For the use of&lt; and &gt; on the left of see SVD and so on In WHILE and IF clauses</div><div class="ttdef"><b>Definition:</b> test1.txt:2226</div></div>
<div class="ttc" id="anamespacem__matrix_html_ad72fa702c69ab23dc80985b6a48a4a0d"><div class="ttname"><a href="namespacem__matrix.html#ad72fa702c69ab23dc80985b6a48a4a0d">m_matrix::alfa</a></div><div class="ttdeci">integer, dimension(ialf) alfa</div><div class="ttdef"><b>Definition:</b> mmm.f90:83</div></div>
<div class="ttc" id="anamespacem__matrix_html_af894f9800c66df4f81aad9e96d7dbdc6"><div class="ttname"><a href="namespacem__matrix.html#af894f9800c66df4f81aad9e96d7dbdc6">m_matrix::ids</a></div><div class="ttdeci">integer, dimension(4, 32) ids</div><div class="ttdef"><b>Definition:</b> mmm.f90:84</div></div>
<div class="ttc" id="amold_8f90_html_af1512ec1a1c51805cfc84b3ac7db321f"><div class="ttname"><a href="mold_8f90.html#af1512ec1a1c51805cfc84b3ac7db321f">urand</a></div><div class="ttdeci">double precision function urand(IY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7230</div></div>
<div class="ttc" id="ammm_8f90_html_a8b3ad80d5d70a3732ad0e28b38d61ebd"><div class="ttname"><a href="mmm_8f90.html#a8b3ad80d5d70a3732ad0e28b38d61ebd">ml_wgeco</a></div><div class="ttdeci">subroutine ml_wgeco(AR, AI, LDA, N, IPVT, RCOND, ZR, ZI)</div><div class="ttdef"><b>Definition:</b> mmm.f90:8612</div></div>
<div class="ttc" id="atest1_8txt_html_a44ef7579639033a971c67f5c80d5fa12"><div class="ttname"><a href="test1_8txt.html#a44ef7579639033a971c67f5c80d5fa12">MAT88</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to MAT88(0) produces the MAT88 greeting</div></div>
<div class="ttc" id="anamespacem__matrix_html_a5dc9d7944c7d022af3d46942779752fd"><div class="ttname"><a href="namespacem__matrix.html#a5dc9d7944c7d022af3d46942779752fd">m_matrix::mat_buf2str</a></div><div class="ttdeci">subroutine mat_buf2str(string, buf, lrecl)</div><div class="ttdef"><b>Definition:</b> mmm.f90:639</div></div>
<div class="ttc" id="atest1_8txt_html_a005a3056880026d7e5d31b3da074a132"><div class="ttname"><a href="test1_8txt.html#a005a3056880026d7e5d31b3da074a132">cond</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of which are the are so far from being orthonormal is our first indication that the eigenvalues are sensitive To see this we display more figures of the computed eigenvalues on this the last five significant figures are contaminated by roundoff error A somewhat superficial explanation of this is provided by cond(X) ANS</div></div>
<div class="ttc" id="amold_8f90_html_aa27909f160fc4043129f6f853ae553ea"><div class="ttname"><a href="mold_8f90.html#aa27909f160fc4043129f6f853ae553ea">eqid</a></div><div class="ttdeci">logical function eqid(X, Y)</div><div class="ttdef"><b>Definition:</b> mold.f90:7677</div></div>
<div class="ttc" id="atest1_8txt_html_a05eb49381e9139a5eeba716c1c9647f8"><div class="ttname"><a href="test1_8txt.html#a05eb49381e9139a5eeba716c1c9647f8">EXEC</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an EXEC</div><div class="ttdef"><b>Definition:</b> test1.txt:2823</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4083a14a17631da2203a6b2689949310"><div class="ttname"><a href="namespacem__matrix.html#a4083a14a17631da2203a6b2689949310">m_matrix::mat_make_manual</a></div><div class="ttdeci">subroutine mat_make_manual(io)</div><div class="ttdef"><b>Definition:</b> mmm.f90:2790</div></div>
<div class="ttc" id="atest1_8txt_html_a9e460bd06b1e66a77686e0b83a40a56b"><div class="ttname"><a href="test1_8txt.html#a9e460bd06b1e66a77686e0b83a40a56b">Wirth</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Wirth</div><div class="ttdef"><b>Definition:</b> test1.txt:2114</div></div>
<div class="ttc" id="anamespacem__matrix_html_aa32ddd74848884013fbee9479be00fc9"><div class="ttname"><a href="namespacem__matrix.html#aa32ddd74848884013fbee9479be00fc9">m_matrix::mat_wdotur</a></div><div class="ttdeci">doubleprecision function mat_wdotur(n, xr, xi, incx, yr, yi, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1100</div></div>
<div class="ttc" id="atest1_8txt_html_abbe8cdd430eceec895688d4bda59b533"><div class="ttname"><a href="test1_8txt.html#abbe8cdd430eceec895688d4bda59b533">POLY</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square HTRIBK if A is Hermitian COMQR2 if A is not Hermitian this was not an extensive change It also facilitated implementation of the FLOP and CHOP features which count and optionally truncate each floating point operation The EISPACK subroutine COMQR2 was modified to allow access to the Schur triangular ordinarily just an intermediate result IMTQL2 was modified to make computation of the eigenvectors optional Both subroutines were modified to eliminate the machine dependent accuracy parameter and all the EISPACK subroutines were changed to include FLOP and CHOP The algorithms employed for the POLY and ROOTS functions illustrate an interesting aspect of the modern approach to eigenvalue computation POLY(A) generates the characteristic polynomial of A and ROOTS(POLY(A)) finds the roots of that polynomial</div></div>
<div class="ttc" id="ammm_8f90_html_a89296050120ea25dbb88dabc8705d5df"><div class="ttname"><a href="mmm_8f90.html#a89296050120ea25dbb88dabc8705d5df">ml_matfn3</a></div><div class="ttdeci">subroutine ml_matfn3()</div><div class="ttdef"><b>Definition:</b> mmm.f90:7058</div></div>
<div class="ttc" id="atest1_8txt_html_aa991fd2c444a4cd2fb5cbc57fb6389f8"><div class="ttname"><a href="test1_8txt.html#aa991fd2c444a4cd2fb5cbc57fb6389f8">Corp</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing Corp</div><div class="ttdef"><b>Definition:</b> test1.txt:2108</div></div>
<div class="ttc" id="anamespacem__matrix_html_ab8f20fead6a121b69dc787faf2e43e85"><div class="ttname"><a href="namespacem__matrix.html#ab8f20fead6a121b69dc787faf2e43e85">m_matrix::mat_appnum</a></div><div class="ttdeci">subroutine mat_appnum(rval, string, ilen, ierr)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1133</div></div>
<div class="ttc" id="atest1_8txt_html_abe9e72bf080de163a4850e92a0c54755"><div class="ttname"><a href="test1_8txt.html#abe9e72bf080de163a4850e92a0c54755">parentheses</a></div><div class="ttdeci">&lt; 4 2 0 &gt; x since they can easily be added to the system COLUMNS AND SUBMATRICES Individual elements of a matrix can be accessed by giving their subscripts in parentheses</div><div class="ttdef"><b>Definition:</b> test1.txt:343</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4fe1023fe56c9bbbb2c543cf41c9d889"><div class="ttname"><a href="namespacem__matrix.html#a4fe1023fe56c9bbbb2c543cf41c9d889">m_matrix::pt</a></div><div class="ttdeci">integer pt</div><div class="ttdef"><b>Definition:</b> mmm.f90:84</div></div>
<div class="ttc" id="anamespacem__matrix_html_a5055a3c0fb5f8b1d81c9e550b7a7f15f"><div class="ttname"><a href="namespacem__matrix.html#a5055a3c0fb5f8b1d81c9e550b7a7f15f">m_matrix::initq</a></div><div class="ttdeci">integer, save initq</div><div class="ttdef"><b>Definition:</b> mmm.f90:78</div></div>
<div class="ttc" id="atest1_8txt_html_a7df000159ba035ea896c4ca7b1cd369f"><div class="ttname"><a href="test1_8txt.html#a7df000159ba035ea896c4ca7b1cd369f">WRITE</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N WRITE(1, 102)(A(I</div></div>
<div class="ttc" id="atest1_8txt_html_aa7fb79750993e7512e30b1124da6563c"><div class="ttname"><a href="test1_8txt.html#aa7fb79750993e7512e30b1124da6563c">m1</a></div><div class="ttdeci">m1</div><div class="ttdef"><b>Definition:</b> test1.txt:908</div></div>
<div class="ttc" id="ammm_8f90_html_a7eb0a072e572f9f6bb78762d6f52b6a2"><div class="ttname"><a href="mmm_8f90.html#a7eb0a072e572f9f6bb78762d6f52b6a2">ml_wsvdc</a></div><div class="ttdeci">subroutine ml_wsvdc(XR, XI, LDX, N, P, SR, SI, ER, EI, UR, UI, LDU, VR, VI, LDV, WORKR, WORKI, JOB, INFO)</div><div class="ttdef"><b>Definition:</b> mmm.f90:10258</div></div>
<div class="ttc" id="amold_8f90_html_a835edc5a385628bff9dbc6155b512c3c"><div class="ttname"><a href="mold_8f90.html#a835edc5a385628bff9dbc6155b512c3c">savlod</a></div><div class="ttdeci">subroutine savlod(LUNIT, ID, M, N, IMG, JOB, XREAL, XIMAG)</div><div class="ttdef"><b>Definition:</b> mold.f90:3538</div></div>
<div class="ttc" id="atest1_8txt_html_a7e828e7f2b643f767d08f4f12faf5041"><div class="ttname"><a href="test1_8txt.html#a7e828e7f2b643f767d08f4f12faf5041">loop</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a loop</div><div class="ttdef"><b>Definition:</b> test1.txt:2818</div></div>
<div class="ttc" id="atest1_8txt_html_af0ee69b7d83695fb58c31eb614a98986"><div class="ttname"><a href="test1_8txt.html#af0ee69b7d83695fb58c31eb614a98986">exec</a></div><div class="ttdeci">exec('PDE') The resulting output is RHO</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4477313ab2a3c37e9d026a9e6d0ec00a"><div class="ttname"><a href="namespacem__matrix.html#a4477313ab2a3c37e9d026a9e6d0ec00a">m_matrix::fmt</a></div><div class="ttdeci">integer fmt</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="ammm_8f90_html_a046a357c15ee4a86ab1936c235af8c42"><div class="ttname"><a href="mmm_8f90.html#a046a357c15ee4a86ab1936c235af8c42">ml_wgefa</a></div><div class="ttdeci">subroutine ml_wgefa(AR, AI, LDA, N, IPVT, INFO)</div><div class="ttdef"><b>Definition:</b> mmm.f90:8837</div></div>
<div class="ttc" id="atest1_8txt_html_a414648a67854e34b952cf7c6d1cbc67f"><div class="ttname"><a href="test1_8txt.html#a414648a67854e34b952cf7c6d1cbc67f">XIMAG</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc X saves only X See FILE The variables may be retrieved later by then REAL or DOUBLEPRECISION NMAX IMG DO N M XIMAG(I, J)</div></div>
<div class="ttc" id="atest1_8txt_html_a794f914f9d95e1133c90f4a8a4839746"><div class="ttname"><a href="test1_8txt.html#a794f914f9d95e1133c90f4a8a4839746">STKI</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple except that MAT88 is programmed in which does not have recursion The interrelation of the primary subroutines is shown in the following diagram MAIN MAT88 CLAUSE PARSE EXPR TERM FACTOR STACK1 STACK2 STACKG STACKP PRINT COMAND CGECO CGEFA MATFN1 CGESL CGEDI CPOFA IMTQL2 HTRIDI MATFN2 HTRIBK CORTH COMQR3 MATFN3 CSVDC CQRDC MATFN4 CQRSL FILES MATFN5 SAVLOD Subroutine PARSE controls the interpretation of each statement It calls subroutines that process the various syntactic quantities such as term and factor A fairly simple program stack mechanism allows these subroutines to recursively call each other along the lines allowed by the syntax diagrams The four STACK subroutines manage the variable memory and perform elementary such as matrix addition and transposition The four subroutines MATFN1 though MATFN4 are called whenever serious matrix computations are required They are interface routines which call the various LINPACK and EISPACK subroutines MATFN5 primarily handles the file access tasks Two large real STKR and STKI</div><div class="ttdef"><b>Definition:</b> test1.txt:1488</div></div>
<div class="ttc" id="anamespacem__matrix_html_aa797150a16e3ea587a070309dab591de"><div class="ttname"><a href="namespacem__matrix.html#aa797150a16e3ea587a070309dab591de">m_matrix::istringq</a></div><div class="ttdeci">integer, save istringq</div><div class="ttdef"><b>Definition:</b> mmm.f90:77</div></div>
<div class="ttc" id="atest1_8txt_html_aa6c8a54562a1cca01fd261c9af754463"><div class="ttname"><a href="test1_8txt.html#aa6c8a54562a1cca01fd261c9af754463">e</a></div><div class="ttdeci">while s r e</div><div class="ttdef"><b>Definition:</b> test1.txt:1197</div></div>
<div class="ttc" id="atest1_8txt_html_a0a0736d2a8d9ba8dbc8eff08faaeda8e"><div class="ttname"><a href="test1_8txt.html#a0a0736d2a8d9ba8dbc8eff08faaeda8e">EPS</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except EPS</div><div class="ttdef"><b>Definition:</b> test1.txt:472</div></div>
<div class="ttc" id="ammm_8f90_html_ae415203c69b8c8793bb826be86c73547"><div class="ttname"><a href="mmm_8f90.html#ae415203c69b8c8793bb826be86c73547">ml_rswap</a></div><div class="ttdeci">subroutine ml_rswap(n, x, incx, y, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11502</div></div>
<div class="ttc" id="atest1_8txt_html_a683f09a8fde8fd5aca2637267de85ef4"><div class="ttname"><a href="test1_8txt.html#a683f09a8fde8fd5aca2637267de85ef4">m2</a></div><div class="ttdeci">m2</div><div class="ttdef"><b>Definition:</b> test1.txt:909</div></div>
<div class="ttc" id="anamespacem__matrix_html_a8ed42a2709c8d700898a7fe14f732cb8"><div class="ttname"><a href="namespacem__matrix.html#a8ed42a2709c8d700898a7fe14f732cb8">m_matrix::hio</a></div><div class="ttdeci">integer hio</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="ammm_8f90_html_ac2f808a338d088195bfffedc2c63cf51"><div class="ttname"><a href="mmm_8f90.html#ac2f808a338d088195bfffedc2c63cf51">ml_wmul</a></div><div class="ttdeci">subroutine ml_wmul(ar, ai, br, bi, cr, ci)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11435</div></div>
<div class="ttc" id="atest1_8txt_html_ab058871c43dd3d7a0111189f937f3127"><div class="ttname"><a href="test1_8txt.html#ab058871c43dd3d7a0111189f937f3127">expression</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or expression</div><div class="ttdef"><b>Definition:</b> test1.txt:502</div></div>
<div class="ttc" id="atest1_8txt_html_a974e4629be312c16d7c8392d9e417eba"><div class="ttname"><a href="test1_8txt.html#a974e4629be312c16d7c8392d9e417eba">perturbation</a></div><div class="ttdeci">which produces the eigenvalues of B and since B is not these eigenvalues are slightly sensitive to perturbation(The value b(1, 3)=7 was chosen so that the elements of the matrix A below are less than 1000.) We now generate a similarity transformation to disguise the eigenvalues and make them more sensitive. L</div></div>
<div class="ttc" id="atest1_8txt_html_a499b3ef5517384e54ba20a0d173eee2c"><div class="ttname"><a href="test1_8txt.html#a499b3ef5517384e54ba20a0d173eee2c">DOC</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc DOC('file') stores the user guide and all the help text(as an Appendix) in the specified file if the file does not already exist. save SAVE('file') stores all the current variables in a file. SAVE('file'</div></div>
<div class="ttc" id="atest1_8txt_html_a6c428c51b724dca9760ad8d1840e6d6b"><div class="ttname"><a href="test1_8txt.html#a6c428c51b724dca9760ad8d1840e6d6b">say</a></div><div class="ttdeci">A T N DO N say</div><div class="ttdef"><b>Definition:</b> test1.txt:1945</div></div>
<div class="ttc" id="amold_8f90_html_ae021b0a6289bc0fdee0cf173dd9b4c9c"><div class="ttname"><a href="mold_8f90.html#ae021b0a6289bc0fdee0cf173dd9b4c9c">comand</a></div><div class="ttdeci">subroutine comand(ID)</div><div class="ttdef"><b>Definition:</b> mold.f90:196</div></div>
<div class="ttc" id="atest1_8txt_html_a9336ebf25087d91c818ee6e9ec29f8c1"><div class="ttname"><a href="test1_8txt.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a></div><div class="ttdeci">x</div><div class="ttdef"><b>Definition:</b> test1.txt:18</div></div>
<div class="ttc" id="anamespacem__matrix_html_aacf5d8da911e431c90dcbea1fd7b6b98"><div class="ttname"><a href="namespacem__matrix.html#aacf5d8da911e431c90dcbea1fd7b6b98">m_matrix::lpt</a></div><div class="ttdeci">integer, dimension(6) lpt</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="anamespacem__matrix_html_ab20809aecb199ab57e9159573b9c901a"><div class="ttname"><a href="namespacem__matrix.html#ab20809aecb199ab57e9159573b9c901a">m_matrix::lsize</a></div><div class="ttdeci">integer lsize</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="amold_8f90_html_ac7f36e7a75160e5ab83eae9147120bd1"><div class="ttname"><a href="mold_8f90.html#ac7f36e7a75160e5ab83eae9147120bd1">pythag</a></div><div class="ttdeci">double precision function pythag(A, B)</div><div class="ttdef"><b>Definition:</b> mold.f90:3476</div></div>
<div class="ttc" id="ammm_8f90_html_a61796e453d09329bce39b2858bf05c16"><div class="ttname"><a href="mmm_8f90.html#a61796e453d09329bce39b2858bf05c16">ml_wscal</a></div><div class="ttdeci">subroutine ml_wscal(N, SR, SI, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11581</div></div>
<div class="ttc" id="atest1_8txt_html_a2a3e113e5b8e090e5c65a99e81e23c23"><div class="ttname"><a href="test1_8txt.html#a2a3e113e5b8e090e5c65a99e81e23c23">E</a></div><div class="ttdeci">while E</div><div class="ttdef"><b>Definition:</b> test1.txt:437</div></div>
<div class="ttc" id="atest1_8txt_html_a6061fb97b4e051c1c08c25703d1aca10"><div class="ttname"><a href="test1_8txt.html#a6061fb97b4e051c1c08c25703d1aca10">algebra</a></div><div class="ttdeci">for the reduced row echelon is of some interest in theoretical linear algebra</div><div class="ttdef"><b>Definition:</b> test1.txt:1694</div></div>
<div class="ttc" id="anamespacem__matrix_html_a135bc713086a5fcae06dbafbbdf66763"><div class="ttname"><a href="namespacem__matrix.html#a135bc713086a5fcae06dbafbbdf66763">m_matrix::err</a></div><div class="ttdeci">integer err</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="amold_8f90_html_ae0123dc7d93822f203682a780a26d87d"><div class="ttname"><a href="mold_8f90.html#ae0123dc7d93822f203682a780a26d87d">wsqrt</a></div><div class="ttdeci">subroutine wsqrt(XR, XI, YR, YI)</div><div class="ttdef"><b>Definition:</b> mold.f90:7332</div></div>
<div class="ttc" id="anamespacem__matrix_html_adfeacb93e0805b63ce123924f4b5248f"><div class="ttname"><a href="namespacem__matrix.html#adfeacb93e0805b63ce123924f4b5248f">m_matrix::sym</a></div><div class="ttdeci">integer sym</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="amold_8f90_html_a5f37835f053798a75e9be26349834cbf"><div class="ttname"><a href="mold_8f90.html#a5f37835f053798a75e9be26349834cbf">rrotg</a></div><div class="ttdeci">subroutine rrotg(DA, DB, C, S)</div><div class="ttdef"><b>Definition:</b> mold.f90:7655</div></div>
<div class="ttc" id="atest1_8txt_html_ac39bc7f2bd4cbf4570a302a16a85b867"><div class="ttname"><a href="test1_8txt.html#ac39bc7f2bd4cbf4570a302a16a85b867">XREAL</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc X saves only X See FILE The variables may be retrieved later by then REAL or DOUBLEPRECISION XREAL(MMAX, NMAX) REAL or DOUBLEPRECISION XIMAG(MMAX</div></div>
<div class="ttc" id="atest1_8txt_html_adc2185da0dc4b67332d77d61d41d56c5"><div class="ttname"><a href="test1_8txt.html#adc2185da0dc4b67332d77d61d41d56c5">eps</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for&lt; h, cos(pi *h)&gt; prints a table of cosines&lt; X, D &gt; for A *v displays one at a time The WHILE clause allows statements to be repeated an indefinite number of times The general form is WHILE expr relop END where relop&lt;, &gt;&lt;=, &gt; or(not equal). The statements are repeatedly executed as long as the indicated comparison between the real parts of the first components of the two expressions is true. Here are two examples.(Exercise for the reader while eps</div><div class="ttdef"><b>Definition:</b> test1.txt:426</div></div>
<div class="ttc" id="atest1_8txt_html_ab631344454190053f6ff38ac01e1dc15"><div class="ttname"><a href="test1_8txt.html#ab631344454190053f6ff38ac01e1dc15">is</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for&lt; h, cos(pi *h)&gt; prints a table of cosines&lt; X, D &gt; for A *v displays one at a time The WHILE clause allows statements to be repeated an indefinite number of times The general form is WHILE expr relop END where relop is</div><div class="ttdef"><b>Definition:</b> test1.txt:426</div></div>
<div class="ttc" id="ammm_8f90_html_ad0a644c53b23729bd094c9de68193363"><div class="ttname"><a href="mmm_8f90.html#ad0a644c53b23729bd094c9de68193363">ml_stack1</a></div><div class="ttdeci">subroutine ml_stack1(OP)</div><div class="ttdef"><b>Definition:</b> mmm.f90:7898</div></div>
<div class="ttc" id="anamespacem__matrix_html_ad8377b0b66cfa16d36020c79bef675ec"><div class="ttname"><a href="namespacem__matrix.html#ad8377b0b66cfa16d36020c79bef675ec">m_matrix::top</a></div><div class="ttdeci">integer top</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="atest1_8txt_html_a4a7d10dc181e801108a62747639b9ddb"><div class="ttname"><a href="test1_8txt.html#a4a7d10dc181e801108a62747639b9ddb">EYE</a></div><div class="ttdeci">RAND and EYE</div><div class="ttdef"><b>Definition:</b> test1.txt:1535</div></div>
<div class="ttc" id="ammm_8f90_html_a8b2dd21aed924ce9472b73944295c826"><div class="ttname"><a href="mmm_8f90.html#a8b2dd21aed924ce9472b73944295c826">ml_prntid</a></div><div class="ttdeci">subroutine ml_prntid(ID, ARGCNT)</div><div class="ttdef"><b>Definition:</b> mmm.f90:6445</div></div>
<div class="ttc" id="anamespacem__matrix_html_a7f444a58fb151b75e8b2d4fd2b96f7a9"><div class="ttname"><a href="namespacem__matrix.html#a7f444a58fb151b75e8b2d4fd2b96f7a9">m_matrix::mat_files</a></div><div class="ttdeci">subroutine mat_files(lunit, iname)</div><div class="ttdef"><b>Definition:</b> mmm.f90:425</div></div>
<div class="ttc" id="anamespacem__matrix_html_a2519aae3a73bbea07dddfdce5cabc834"><div class="ttname"><a href="namespacem__matrix.html#a2519aae3a73bbea07dddfdce5cabc834">m_matrix::fe</a></div><div class="ttdeci">integer fe</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="atest1_8txt_html_aaa9032ba8ed711acb2de83b0bfe8c1bd"><div class="ttname"><a href="test1_8txt.html#aaa9032ba8ed711acb2de83b0bfe8c1bd">etc</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement etc(The complete list is in the appendix under CHAR.) For example '2 *A+3' is the same as&lt; 2 43 10 36 41 36 3 &gt; It is possible</div></div>
<div class="ttc" id="amold_8f90_html_a9d28dd97f1987edbb3b7fb88fff351ee"><div class="ttname"><a href="mold_8f90.html#a9d28dd97f1987edbb3b7fb88fff351ee">magic</a></div><div class="ttdeci">subroutine magic(A, LDA, N)</div><div class="ttdef"><b>Definition:</b> mold.f90:7103</div></div>
<div class="ttc" id="anamespacem__matrix_html_ab95c5ec37a5410c257b4de139812ccc9"><div class="ttname"><a href="namespacem__matrix.html#ab95c5ec37a5410c257b4de139812ccc9">m_matrix::fin</a></div><div class="ttdeci">integer fin</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="anamespacem__matrix_html_a6bbbf898cfba3eee23cbe9ea947bb6f9"><div class="ttname"><a href="namespacem__matrix.html#a6bbbf898cfba3eee23cbe9ea947bb6f9">m_matrix::rhs</a></div><div class="ttdeci">integer rhs</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="ammm_8f90_html_a3859480e82945f1d4b1c09963d221159"><div class="ttname"><a href="mmm_8f90.html#a3859480e82945f1d4b1c09963d221159">ml_clause</a></div><div class="ttdeci">subroutine ml_clause()</div><div class="ttdef"><b>Definition:</b> mmm.f90:5437</div></div>
<div class="ttc" id="ammm_8f90_html_a07bece78a0445e5fe4d8eb49c00791ab"><div class="ttname"><a href="mmm_8f90.html#a07bece78a0445e5fe4d8eb49c00791ab">ml_wdotci</a></div><div class="ttdeci">doubleprecision function ml_wdotci(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11733</div></div>
<div class="ttc" id="amold_8f90_html_a43152b13f33a1af9e98c01f204027c18"><div class="ttname"><a href="mold_8f90.html#a43152b13f33a1af9e98c01f204027c18">xchar</a></div><div class="ttdeci">subroutine xchar(BUF, K)</div><div class="ttdef"><b>Definition:</b> mold.f90:4278</div></div>
<div class="ttc" id="anamespacem__matrix_html_aaf11cfe0ebb5444761babd1a85b22647"><div class="ttname"><a href="namespacem__matrix.html#aaf11cfe0ebb5444761babd1a85b22647">m_matrix::mat_round</a></div><div class="ttdeci">doubleprecision function mat_round(x)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1860</div></div>
<div class="ttc" id="atest1_8txt_html_a8183c2bf8d1e67778b6cf80018c89d6b"><div class="ttname"><a href="test1_8txt.html#a8183c2bf8d1e67778b6cf80018c89d6b">example</a></div><div class="ttdeci">E The IF clause allows conditional execution of statements The general form is IF expr relop ELSE statement The first group of statements are executed if the relation is true and the second group are executed if the relation is false The ELSE and the statements following it may be omitted For example</div><div class="ttdef"><b>Definition:</b> test1.txt:444</div></div>
<div class="ttc" id="atest1_8txt_html_a16d5d24f5b09a1991bd4e5f57bf11237"><div class="ttname"><a href="test1_8txt.html#a16d5d24f5b09a1991bd4e5f57bf11237">pi</a></div><div class="ttdeci">pi</div><div class="ttdef"><b>Definition:</b> test1.txt:910</div></div>
<div class="ttc" id="ammm_8f90_html_ab6bcbaebdc02ea9a99cf662c862a9df1"><div class="ttname"><a href="mmm_8f90.html#ab6bcbaebdc02ea9a99cf662c862a9df1">ml_htridi</a></div><div class="ttdeci">subroutine ml_htridi(NM, N, AR, AI, D, E, E2, TAU)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9260</div></div>
<div class="ttc" id="atest1_8txt_html_a5ef19f0ec01188b6b19a4534229d6c66"><div class="ttname"><a href="test1_8txt.html#a5ef19f0ec01188b6b19a4534229d6c66">II</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume II</div><div class="ttdef"><b>Definition:</b> test1.txt:2111</div></div>
<div class="ttc" id="anamespacem__matrix_html_a2df620f9003aec7b5239253df0748e57"><div class="ttname"><a href="namespacem__matrix.html#a2df620f9003aec7b5239253df0748e57">m_matrix::bigmem</a></div><div class="ttdeci">integer, parameter bigmem</div><div class="ttdef"><b>Definition:</b> mmm.f90:72</div></div>
<div class="ttc" id="amold_8f90_html_a1370996dc7e07ded1df11b1ace132be6"><div class="ttname"><a href="mold_8f90.html#a1370996dc7e07ded1df11b1ace132be6">prntid</a></div><div class="ttdeci">subroutine prntid(ID, ARGCNT)</div><div class="ttdef"><b>Definition:</b> mold.f90:3428</div></div>
<div class="ttc" id="anamespacem__matrix_html_a05b16fca9f932eb90f1f833c8b753385"><div class="ttname"><a href="namespacem__matrix.html#a05b16fca9f932eb90f1f833c8b753385">m_matrix::mat_iwamax</a></div><div class="ttdeci">integer function mat_iwamax(n, xr, xi, incx)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1753</div></div>
<div class="ttc" id="atest1_8txt_html_a3d9538089cd99c74b78e3e90a6e2363a"><div class="ttname"><a href="test1_8txt.html#a3d9538089cd99c74b78e3e90a6e2363a">derivative</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal derivative</div><div class="ttdef"><b>Definition:</b> test1.txt:877</div></div>
<div class="ttc" id="atest1_8txt_html_a82f0145ce7db26d1cc0e83199b7b416a"><div class="ttname"><a href="test1_8txt.html#a82f0145ce7db26d1cc0e83199b7b416a">DIARY</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the DIARY</div><div class="ttdef"><b>Definition:</b> test1.txt:2829</div></div>
<div class="ttc" id="anamespacem__matrix_html_ad89f776daa725da2d826873024da517e"><div class="ttname"><a href="namespacem__matrix.html#ad89f776daa725da2d826873024da517e">m_matrix::eol</a></div><div class="ttdeci">integer, parameter eol</div><div class="ttdef"><b>Definition:</b> mmm.f90:99</div></div>
<div class="ttc" id="atest1_8txt_html_aadd8afaa3503376a24962f9ddc34a8df"><div class="ttname"><a href="test1_8txt.html#aadd8afaa3503376a24962f9ddc34a8df">eigenvalues</a></div><div class="ttdeci">C the first eigenvalue has the largest sensitivity We now proceed to show that A is close to a matrix with a double eigenvalue The direction of the required perturbation is given by we bracket the point where two eigenvalues of a perturbed A coalesce and then become complex a bisecting driven by the imaginary part of one of the eigenvalues</div><div class="ttdef"><b>Definition:</b> test1.txt:1192</div></div>
<div class="ttc" id="atest1_8txt_html_ab63be247e78c33a536d8726cff2164c0"><div class="ttname"><a href="test1_8txt.html#ab63be247e78c33a536d8726cff2164c0">SAVE</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the SAVE</div><div class="ttdef"><b>Definition:</b> test1.txt:2829</div></div>
<div class="ttc" id="amold_8f90_html_a665cf277c8d56c96300360568a8be7c3"><div class="ttname"><a href="mold_8f90.html#a665cf277c8d56c96300360568a8be7c3">wgesl</a></div><div class="ttdeci">subroutine wgesl(AR, AI, LDA, N, IPVT, BR, BI, JOB)</div><div class="ttdef"><b>Definition:</b> mold.f90:4642</div></div>
<div class="ttc" id="anamespacem__matrix_html_aedf9eb7ce4227c90856f9ae6ab7215bb"><div class="ttname"><a href="namespacem__matrix.html#aedf9eb7ce4227c90856f9ae6ab7215bb">m_matrix::bot</a></div><div class="ttdeci">integer bot</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="amold_8f90_html_aabbb97adab07865cfd78fa3828eeffc2"><div class="ttname"><a href="mold_8f90.html#aabbb97adab07865cfd78fa3828eeffc2">rset</a></div><div class="ttdeci">subroutine rset(N, DX, DY, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7599</div></div>
<div class="ttc" id="atest1_8txt_html_a73b52bb10772a6ec22fce9998c6549aa"><div class="ttname"><a href="test1_8txt.html#a73b52bb10772a6ec22fce9998c6549aa">COMMANDS</a></div><div class="ttdeci">COMMANDS</div><div class="ttdef"><b>Definition:</b> test1.txt:453</div></div>
<div class="ttc" id="amold_8f90_html_aefa4e7da392c8386c442fa5c5960ca74"><div class="ttname"><a href="mold_8f90.html#aefa4e7da392c8386c442fa5c5960ca74">user</a></div><div class="ttdeci">subroutine user(A, M, N, S, T)</div><div class="ttdef"><b>Definition:</b> mold.f90:4262</div></div>
<div class="ttc" id="ammm_8f90_html_a9fdf7b81fe7cb65fe3d76f789d4b4ef5"><div class="ttname"><a href="mmm_8f90.html#a9fdf7b81fe7cb65fe3d76f789d4b4ef5">ml_term</a></div><div class="ttdeci">subroutine ml_term()</div><div class="ttdef"><b>Definition:</b> mmm.f90:8545</div></div>
<div class="ttc" id="anamespacem__matrix_html_ab5df49cd4b9b571665f50fb8df564472"><div class="ttname"><a href="namespacem__matrix.html#ab5df49cd4b9b571665f50fb8df564472">m_matrix::rio</a></div><div class="ttdeci">integer rio</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="ammm_8f90_html_abcfb02c86f3f00a375590072e6500bde"><div class="ttname"><a href="mmm_8f90.html#abcfb02c86f3f00a375590072e6500bde">ml_prompt</a></div><div class="ttdeci">subroutine ml_prompt(PAUSE)</div><div class="ttdef"><b>Definition:</b> mmm.f90:6499</div></div>
<div class="ttc" id="ammm_8f90_html_a82de947baa4dee4e201d86a3b5a3f191"><div class="ttname"><a href="mmm_8f90.html#a82de947baa4dee4e201d86a3b5a3f191">ml_wrscal</a></div><div class="ttdeci">subroutine ml_wrscal(N, S, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11567</div></div>
<div class="ttc" id="atest1_8txt_html_ab8eed843805517e8adec312701a98928"><div class="ttname"><a href="test1_8txt.html#ab8eed843805517e8adec312701a98928">Guide</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Guide</div><div class="ttdef"><b>Definition:</b> test1.txt:2094</div></div>
<div class="ttc" id="atest1_8txt_html_a7690fee9a1419ae832b63702d718414b"><div class="ttname"><a href="test1_8txt.html#a7690fee9a1419ae832b63702d718414b">COMMAND</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the COMMAND</div><div class="ttdef"><b>Definition:</b> test1.txt:1252</div></div>
<div class="ttc" id="anamespacem__matrix_html_ac02e03c9400db34acd33ee7f60de2b20"><div class="ttname"><a href="namespacem__matrix.html#ac02e03c9400db34acd33ee7f60de2b20">m_matrix::stkr</a></div><div class="ttdeci">doubleprecision, dimension(bigmem) stkr</div><div class="ttdef"><b>Definition:</b> mmm.f90:81</div></div>
<div class="ttc" id="ammm_8f90_html_aee7442e99d5b9029e7333af29c175e69"><div class="ttname"><a href="mmm_8f90.html#aee7442e99d5b9029e7333af29c175e69">ml_stackg</a></div><div class="ttdeci">subroutine ml_stackg(ID)</div><div class="ttdef"><b>Definition:</b> mmm.f90:8220</div></div>
<div class="ttc" id="amold_8f90_html_a362949c4b812c67ebcf053e7fc5e959a"><div class="ttname"><a href="mold_8f90.html#a362949c4b812c67ebcf053e7fc5e959a">wmul</a></div><div class="ttdeci">subroutine wmul(AR, AI, BR, BI, CR, CI)</div><div class="ttdef"><b>Definition:</b> mold.f90:7290</div></div>
<div class="ttc" id="atest1_8txt_html_ad291d89d91e024d912b06edee2210b7c"><div class="ttname"><a href="test1_8txt.html#ad291d89d91e024d912b06edee2210b7c">Philadelphia</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied Philadelphia</div><div class="ttdef"><b>Definition:</b> test1.txt:2095</div></div>
<div class="ttc" id="anamespacem__matrix_html_a2bf34bb1b3692ea2b4884ef60a7eeda9"><div class="ttname"><a href="namespacem__matrix.html#a2bf34bb1b3692ea2b4884ef60a7eeda9">m_matrix::mat_wlog</a></div><div class="ttdeci">subroutine mat_wlog(xr, xi, yr, yi)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1661</div></div>
<div class="ttc" id="atest1_8txt_html_abfad054eff90079a97871cd5232dfd7e"><div class="ttname"><a href="test1_8txt.html#abfad054eff90079a97871cd5232dfd7e">search</a></div><div class="ttdeci">C the first eigenvalue has the largest sensitivity We now proceed to show that A is close to a matrix with a double eigenvalue The direction of the required perturbation is given by we bracket the point where two eigenvalues of a perturbed A coalesce and then become complex a bisecting search</div><div class="ttdef"><b>Definition:</b> test1.txt:1191</div></div>
<div class="ttc" id="ammm_8f90_html_a32b15bcc2ebd1443b55676ea8fad0ac4"><div class="ttname"><a href="mmm_8f90.html#a32b15bcc2ebd1443b55676ea8fad0ac4">ml_wqrdc</a></div><div class="ttdeci">subroutine ml_wqrdc(XR, XI, LDX, N, P, QRAUXR, QRAUXI, JPVT, WORKR, WORKI, JOB)</div><div class="ttdef"><b>Definition:</b> mmm.f90:10810</div></div>
<div class="ttc" id="amold_8f90_html_a328614c7b3a63aa4f11dba7a242a9d40"><div class="ttname"><a href="mold_8f90.html#a328614c7b3a63aa4f11dba7a242a9d40">matfn2</a></div><div class="ttdeci">subroutine matfn2</div><div class="ttdef"><b>Definition:</b> mold.f90:1595</div></div>
<div class="ttc" id="atest1_8txt_html_ae125978a34fea7849d19c630710ad8c2"><div class="ttname"><a href="test1_8txt.html#ae125978a34fea7849d19c630710ad8c2">T</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say T</div><div class="ttdef"><b>Definition:</b> test1.txt:501</div></div>
<div class="ttc" id="anamespacem__matrix_html_ac94ccaf7084465ba8171d926ced932f7"><div class="ttname"><a href="namespacem__matrix.html#ac94ccaf7084465ba8171d926ced932f7">m_matrix::ddt</a></div><div class="ttdeci">integer ddt</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="atest1_8txt_html_aea7cc0ff9e75deadea15b616599de8e6"><div class="ttname"><a href="test1_8txt.html#aea7cc0ff9e75deadea15b616599de8e6">dimensions</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple except that MAT88 is programmed in which does not have recursion The interrelation of the primary subroutines is shown in the following diagram MAIN MAT88 CLAUSE PARSE EXPR TERM FACTOR STACK1 STACK2 STACKG STACKP PRINT COMAND CGECO CGEFA MATFN1 CGESL CGEDI CPOFA IMTQL2 HTRIDI MATFN2 HTRIBK CORTH COMQR3 MATFN3 CSVDC CQRDC MATFN4 CQRSL FILES MATFN5 SAVLOD Subroutine PARSE controls the interpretation of each statement It calls subroutines that process the various syntactic quantities such as term and factor A fairly simple program stack mechanism allows these subroutines to recursively call each other along the lines allowed by the syntax diagrams The four STACK subroutines manage the variable memory and perform elementary such as matrix addition and transposition The four subroutines MATFN1 though MATFN4 are called whenever serious matrix computations are required They are interface routines which call the various LINPACK and EISPACK subroutines MATFN5 primarily handles the file access tasks Two large real STKR and are used to store all the matrices Four integer arrays are used to store the the row and column dimensions</div><div class="ttdef"><b>Definition:</b> test1.txt:1490</div></div>
<div class="ttc" id="atest1_8txt_html_a339c66297df8d20f247e4e17490bb48a"><div class="ttname"><a href="test1_8txt.html#a339c66297df8d20f247e4e17490bb48a">i</a></div><div class="ttdeci">&lt; 4 2 0 &gt; x since they can easily be added to the system COLUMNS AND SUBMATRICES Individual elements of a matrix can be accessed by giving their subscripts in eg TAB(ind(k)+1). An expression used as a subscript is rounded to the nearest integer. Individual rows and columns can be accessed using a colon ' generates the Hilbert matrix for for i</div><div class="ttdef"><b>Definition:</b> test1.txt:407</div></div>
<div class="ttc" id="atest1_8txt_html_ad9b6675ebe65af3eeb9e0dc58e717883"><div class="ttname"><a href="test1_8txt.html#ad9b6675ebe65af3eeb9e0dc58e717883">Forsythe</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E Forsythe</div><div class="ttdef"><b>Definition:</b> test1.txt:2123</div></div>
<div class="ttc" id="amold_8f90_html_a5cdc5b24094db542886c04283ee3ecf2"><div class="ttname"><a href="mold_8f90.html#a5cdc5b24094db542886c04283ee3ecf2">imtql2</a></div><div class="ttdeci">subroutine imtql2(NM, N, D, E, Z, IERR, JOB)</div><div class="ttdef"><b>Definition:</b> mold.f90:5242</div></div>
<div class="ttc" id="anamespacem__matrix_html_a25f553ad0d2bb3041a5ed952ad847cbc"><div class="ttname"><a href="namespacem__matrix.html#a25f553ad0d2bb3041a5ed952ad847cbc">m_matrix::lhs</a></div><div class="ttdeci">integer lhs</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="atest1_8txt_html_a2413cc18f94743dbbe45828eb3930236"><div class="ttname"><a href="test1_8txt.html#a2413cc18f94743dbbe45828eb3930236">round</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at round(2 *(n-1) *X). ACKNOWLEDGEMENT Most of the work on MAT88 has been carried out at the University of New Mexico</div></div>
<div class="ttc" id="atest1_8txt_html_a4022e3ba0b80add8a3f7296344f89334"><div class="ttname"><a href="test1_8txt.html#a4022e3ba0b80add8a3f7296344f89334">N</a></div><div class="ttdeci">A T N</div><div class="ttdef"><b>Definition:</b> test1.txt:1924</div></div>
<div class="ttc" id="ammm_8f90_html_aaa6fca4ed8ba7e8d98a0665901d2d2ac"><div class="ttname"><a href="mmm_8f90.html#aaa6fca4ed8ba7e8d98a0665901d2d2ac">ml_matfn2</a></div><div class="ttdeci">subroutine ml_matfn2()</div><div class="ttdef"><b>Definition:</b> mmm.f90:6824</div></div>
<div class="ttc" id="atest1_8txt_html_a0c81ae67e0d2bf71c4b389e54eb99816"><div class="ttname"><a href="test1_8txt.html#a0c81ae67e0d2bf71c4b389e54eb99816">READ</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N READ(1, 102)(X(I</div></div>
<div class="ttc" id="ammm_8f90_html_a26d570b231671c8643db8f7f3954f081"><div class="ttname"><a href="mmm_8f90.html#a26d570b231671c8643db8f7f3954f081">ml_wqrsl</a></div><div class="ttdeci">subroutine ml_wqrsl(XR, XI, LDX, N, K, QRAUXR, QRAUXI, YR, YI, QYR, QYI, QTYR, QTYI, BR, BI, RSDR, RSDI, XBR, XBI, JOB, INFO)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11041</div></div>
<div class="ttc" id="anamespacem__matrix_html_a7804dfbf3cb119895f1d689309d35a98"><div class="ttname"><a href="namespacem__matrix.html#a7804dfbf3cb119895f1d689309d35a98">m_matrix::rstk</a></div><div class="ttdeci">integer, dimension(32) rstk</div><div class="ttdef"><b>Definition:</b> mmm.f90:84</div></div>
<div class="ttc" id="atest1_8txt_html_a2a57095060c46385e7166f473a1bd55a"><div class="ttname"><a href="test1_8txt.html#a2a57095060c46385e7166f473a1bd55a">EXP</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more more efficient methods for finding polynomial but this approach has the crucial advantage that it does not require very much additional code The elementary functions EXP</div><div class="ttdef"><b>Definition:</b> test1.txt:1654</div></div>
<div class="ttc" id="anamespacem__matrix_html_af206c220f80986d937f1a93c2867f217"><div class="ttname"><a href="namespacem__matrix.html#af206c220f80986d937f1a93c2867f217">m_matrix::syn</a></div><div class="ttdeci">integer, dimension(4) syn</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="ammm_8f90_html_a34b446d15642fc6ef08782fd9961e0af"><div class="ttname"><a href="mmm_8f90.html#a34b446d15642fc6ef08782fd9961e0af">ml_wgesl</a></div><div class="ttdeci">subroutine ml_wgesl(AR, AI, LDA, N, IPVT, BR, BI, JOB)</div><div class="ttdef"><b>Definition:</b> mmm.f90:8953</div></div>
<div class="ttc" id="atest1_8txt_html_a5b7d43e28f3684aaff673e2a784fff8e"><div class="ttname"><a href="test1_8txt.html#a5b7d43e28f3684aaff673e2a784fff8e">y</a></div><div class="ttdeci">y(i)</div></div>
<div class="ttc" id="anamespacem__matrix_html_a9fbdc7646839bcc22ce9a82a9e8193e0"><div class="ttname"><a href="namespacem__matrix.html#a9fbdc7646839bcc22ce9a82a9e8193e0">m_matrix::mat_getsym</a></div><div class="ttdeci">subroutine mat_getsym()</div><div class="ttdef"><b>Definition:</b> mmm.f90:503</div></div>
<div class="ttc" id="atest1_8txt_html_a26f65c7c7a733e02024285362d932d18"><div class="ttname"><a href="test1_8txt.html#a26f65c7c7a733e02024285362d932d18">Inclusions</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical Inclusions</div><div class="ttdef"><b>Definition:</b> test1.txt:2118</div></div>
<div class="ttc" id="atest1_8txt_html_a50a8440744d145ae19dbd00ceeb34b13"><div class="ttname"><a href="test1_8txt.html#a50a8440744d145ae19dbd00ceeb34b13">NAME</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the NAME</div><div class="ttdef"><b>Definition:</b> test1.txt:1252</div></div>
<div class="ttc" id="amold_8f90_html_a1f3e61837b8292da82045282f2fb520e"><div class="ttname"><a href="mold_8f90.html#a1f3e61837b8292da82045282f2fb520e">iwamax</a></div><div class="ttdeci">integer function iwamax(N, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mold.f90:7411</div></div>
<div class="ttc" id="atest1_8txt_html_a8eee149f4149309724d95d04c8c53b70"><div class="ttname"><a href="test1_8txt.html#a8eee149f4149309724d95d04c8c53b70">function</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis function</div><div class="ttdef"><b>Definition:</b> test1.txt:877</div></div>
<div class="ttc" id="atest1_8txt_html_ab8ec92cc3ea8422c9349409bae98d2a0"><div class="ttname"><a href="test1_8txt.html#ab8ec92cc3ea8422c9349409bae98d2a0">rho</a></div><div class="ttdeci">rho</div><div class="ttdef"><b>Definition:</b> test1.txt:944</div></div>
<div class="ttc" id="amold_8f90_html_aa6032698ebeb39057a70c91a084b9687"><div class="ttname"><a href="mold_8f90.html#aa6032698ebeb39057a70c91a084b9687">putid</a></div><div class="ttdeci">subroutine putid(X, Y)</div><div class="ttdef"><b>Definition:</b> mold.f90:7687</div></div>
<div class="ttc" id="aGPF_8txt_html_a9bda2b28ad5d062060dfc8ae1f497a2e"><div class="ttname"><a href="GPF_8txt.html#a9bda2b28ad5d062060dfc8ae1f497a2e">ibclr</a></div><div class="ttdeci">shape(3fortran) -[ARRAY flips all bits in an integer ibclr(3fortran) -[BIT</div><div class="ttdef"><b>Definition:</b> GPF.txt:283</div></div>
<div class="ttc" id="atest1_8txt_html_acecba6895729c2dd377db8a352a7bc7d"><div class="ttname"><a href="test1_8txt.html#acecba6895729c2dd377db8a352a7bc7d">PL</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple PL</div><div class="ttdef"><b>Definition:</b> test1.txt:1420</div></div>
<div class="ttc" id="atest1_8txt_html_a5791bcbaa52bb6ab19612d6ce890779c"><div class="ttname"><a href="test1_8txt.html#a5791bcbaa52bb6ab19612d6ce890779c">PRINT</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print PRINT('file', X) prints X on the file using the current format determined by SHORT</div></div>
<div class="ttc" id="atest1_8txt_html_a68ba7f47aebc0631df91eb227601a0c2"><div class="ttname"><a href="test1_8txt.html#a68ba7f47aebc0631df91eb227601a0c2">accurate</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more accurate</div><div class="ttdef"><b>Definition:</b> test1.txt:1650</div></div>
<div class="ttc" id="atest1_8txt_html_aed2591d2a093ce087083aeb946df7f2f"><div class="ttname"><a href="test1_8txt.html#aed2591d2a093ce087083aeb946df7f2f">ANS</a></div><div class="ttdeci">ends with an extra comma Two by random matrices are generated and multiplied together The result is assigned to ANS</div><div class="ttdef"><b>Definition:</b> test1.txt:1759</div></div>
<div class="ttc" id="amold_8f90_html_a2815ebbb4b84bbcfc9f1f8e36ed47f57"><div class="ttname"><a href="mold_8f90.html#a2815ebbb4b84bbcfc9f1f8e36ed47f57">getval</a></div><div class="ttdeci">subroutine getval(S)</div><div class="ttdef"><b>Definition:</b> mold.f90:1311</div></div>
<div class="ttc" id="amold_8f90_html_af279a80e34b98e1c3c3c7cf80cdda3ce"><div class="ttname"><a href="mold_8f90.html#af279a80e34b98e1c3c3c7cf80cdda3ce">clause</a></div><div class="ttdeci">subroutine clause</div><div class="ttdef"><b>Definition:</b> mold.f90:15</div></div>
<div class="ttc" id="atest1_8txt_html_aba48dd9b4da94f9b3fa3a8b8cbca3907"><div class="ttname"><a href="test1_8txt.html#aba48dd9b4da94f9b3fa3a8b8cbca3907">CQRDC</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRDC</div><div class="ttdef"><b>Definition:</b> test1.txt:1577</div></div>
<div class="ttc" id="atest1_8txt_html_aaa53ca0b650dfd85c4f59fa156f7a2cc"><div class="ttname"><a href="test1_8txt.html#aaa53ca0b650dfd85c4f59fa156f7a2cc">C</a></div><div class="ttdeci">C C</div><div class="ttdef"><b>Definition:</b> test1.txt:1146</div></div>
<div class="ttc" id="amold_8f90_html_a61419dbac8759257c2cb8e6f1ada3911"><div class="ttname"><a href="mold_8f90.html#a61419dbac8759257c2cb8e6f1ada3911">round</a></div><div class="ttdeci">double precision function round(X)</div><div class="ttdef"><b>Definition:</b> mold.f90:7696</div></div>
<div class="ttc" id="amold_8f90_html_a2adcb247b188aa06ee9df4b6b9e3c578"><div class="ttname"><a href="mold_8f90.html#a2adcb247b188aa06ee9df4b6b9e3c578">getsym</a></div><div class="ttdeci">subroutine getsym</div><div class="ttdef"><b>Definition:</b> mold.f90:1224</div></div>
<div class="ttc" id="atest1_8txt_html_aaa17959a339bab1b87c975c567c8b62f"><div class="ttname"><a href="test1_8txt.html#aaa17959a339bab1b87c975c567c8b62f">flops</a></div><div class="ttdeci">ends with an extra comma Two by random matrices are generated and multiplied together The result is assigned to but the semicolon suppresses its printing The only output is flops This is n ***n ** flops</div><div class="ttdef"><b>Definition:</b> test1.txt:1768</div></div>
<div class="ttc" id="ammm_8f90_html_a93299ffd6783124d58177a91562bdd31"><div class="ttname"><a href="mmm_8f90.html#a93299ffd6783124d58177a91562bdd31">ml_rat</a></div><div class="ttdeci">subroutine ml_rat(x, len, maxd, a, b, d)</div><div class="ttdef"><b>Definition:</b> mmm.f90:7796</div></div>
<div class="ttc" id="amold_8f90_html_a76dd74c90d9651d48ec3fe8e8693d0a2"><div class="ttname"><a href="mold_8f90.html#a76dd74c90d9651d48ec3fe8e8693d0a2">hilber</a></div><div class="ttdeci">subroutine hilber(A, LDA, N)</div><div class="ttdef"><b>Definition:</b> mold.f90:4978</div></div>
<div class="ttc" id="ammm_8f90_html_a1aadd2c33e59374b5c147b9c0687db1c"><div class="ttname"><a href="mmm_8f90.html#a1aadd2c33e59374b5c147b9c0687db1c">ml_plot</a></div><div class="ttdeci">subroutine ml_plot(LPLOT, X, Y, N, P, K)</div><div class="ttdef"><b>Definition:</b> mmm.f90:6397</div></div>
<div class="ttc" id="amold_8f90_html_ab21f5cdd1fd3278c14bacf92e8a22f71"><div class="ttname"><a href="mold_8f90.html#ab21f5cdd1fd3278c14bacf92e8a22f71">wrscal</a></div><div class="ttdeci">subroutine wrscal(N, S, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mold.f90:7430</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4f6462b4bde43cc5eaabafe13ac2edff"><div class="ttname"><a href="namespacem__matrix.html#a4f6462b4bde43cc5eaabafe13ac2edff">m_matrix::alfb</a></div><div class="ttdeci">integer, dimension(ialf) alfb</div><div class="ttdef"><b>Definition:</b> mmm.f90:83</div></div>
<div class="ttc" id="atest1_8txt_html_a29faf1efa547eee7395013df5586bda5"><div class="ttname"><a href="test1_8txt.html#a29faf1efa547eee7395013df5586bda5">with</a></div><div class="ttdeci">Then to repeat the command changing to enter the previous command is then displayed Now enter c and then enter a carriage return and the edited line will be executed The first command can appear on the same line if the line starts with(a period followed by a space). For example ./rand would take you into edit mode on the last command containing the string &quot;rand&quot; Enter &quot;?&quot; in edit mode to display further help on editor mode. eps Floating point relative accuracy. A permanent variable whose value is initially the distance from 1.0 to the next largest floating point number. The value is changed by CHOP</div></div>
<div class="ttc" id="atest1_8txt_html_ab42fe1e07cb208167afaa95eba718ab8"><div class="ttname"><a href="test1_8txt.html#ab42fe1e07cb208167afaa95eba718ab8">LINES</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc X saves only X See FILE The variables may be retrieved later by then REAL or DOUBLEPRECISION NMAX IMG DO N M M enddo The formats used are system dependent The following are typical See SUBROUTINE ML_SAVLOD in your implementation of MAT88 the user is asked whether or not to suppress printing until the next input Initially the limit is LINES(N) resets the limit to N . long Determine output format. All computations are done in complex arithmetic and double precision if it is available. SHORT and LONG merely switch between different output formats. SHORT Scaled fixed point format with about 5 digits. LONG Scaled fixed point format with about 15 digits. SHORT E Floating point format with about 5 digits. LONG E Floating point format with about 15 digits. LONG Z System dependent format</div></div>
<div class="ttc" id="atest1_8txt_html_a7ddb11aef4341eadfc5f36048a9bc849"><div class="ttname"><a href="test1_8txt.html#a7ddb11aef4341eadfc5f36048a9bc849">X</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of X</div><div class="ttdef"><b>Definition:</b> test1.txt:1077</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4a806caeb6c3f3107ea313316b200644"><div class="ttname"><a href="namespacem__matrix.html#a4a806caeb6c3f3107ea313316b200644">m_matrix::mat_rref</a></div><div class="ttdeci">subroutine mat_rref(ar, ai, lda, m, n, eps)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1705</div></div>
<div class="ttc" id="amold_8f90_html_a1c27eba24685f1ce3698ecdd40d81c9f"><div class="ttname"><a href="mold_8f90.html#a1c27eba24685f1ce3698ecdd40d81c9f">parse</a></div><div class="ttdeci">subroutine parse</div><div class="ttdef"><b>Definition:</b> mold.f90:2975</div></div>
<div class="ttc" id="atest1_8txt_html_a760f6e6282bacba8d84fce1162bdcc89"><div class="ttname"><a href="test1_8txt.html#a760f6e6282bacba8d84fce1162bdcc89">D</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more more efficient methods for finding polynomial but this approach has the crucial advantage that it does not require very much additional code The elementary functions COS and ATAN are applied to square matrices by diagonalizing the applying the functions to the individual eigenvalues and then transforming back For D</div><div class="ttdef"><b>Definition:</b> test1.txt:1659</div></div>
<div class="ttc" id="amold_8f90_html_a31ecfd158a683ad0896292f1d3983f8c"><div class="ttname"><a href="mold_8f90.html#a31ecfd158a683ad0896292f1d3983f8c">stackp</a></div><div class="ttdeci">subroutine stackp(ID)</div><div class="ttdef"><b>Definition:</b> mold.f90:4016</div></div>
<div class="ttc" id="atest1_8txt_html_aef1a5d48094da6306b7a38afb8aa1981"><div class="ttname"><a href="test1_8txt.html#aef1a5d48094da6306b7a38afb8aa1981">additions</a></div><div class="ttdeci">or as the last statement on the line HELP FLPS gives more details flps More detail on FLOPS It is not feasible to count absolutely all floating point but most of the important ones are counted Each multiply and add in a real vector operation such as a dot product or a saxpy counts one flop Each multiply and add in a complex vector operation counts two flops Other additions</div><div class="ttdef"><b>Definition:</b> test1.txt:3005</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4d04559d8caa0812860e8b1095ab4774"><div class="ttname"><a href="namespacem__matrix.html#a4d04559d8caa0812860e8b1095ab4774">m_matrix::mat_wcopy</a></div><div class="ttdeci">subroutine mat_wcopy(n, xr, xi, incx, yr, yi, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1171</div></div>
<div class="ttc" id="atest1_8txt_html_ab997fb21bef012bb466f3fafefe8f35d"><div class="ttname"><a href="test1_8txt.html#ab997fb21bef012bb466f3fafefe8f35d">then</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff then</div><div class="ttdef"><b>Definition:</b> test1.txt:1058</div></div>
<div class="ttc" id="anamespacem__matrix_html_a109fdc471a0faeb042e620f6c8c7b095"><div class="ttname"><a href="namespacem__matrix.html#a109fdc471a0faeb042e620f6c8c7b095">m_matrix::ch_b</a></div><div class="ttdeci">character(len=ialf), parameter ch_b</div><div class="ttdef"><b>Definition:</b> mmm.f90:96</div></div>
<div class="ttc" id="atest1_8txt_html_a6d4e164739bb3d14a7e820f8236dcb0d"><div class="ttname"><a href="test1_8txt.html#a6d4e164739bb3d14a7e820f8236dcb0d">computed</a></div><div class="ttdeci">for the reduced row echelon is of some interest in theoretical linear although it has little computational value It is included in MAT88 for pedagogical reasons The algorithm is essentially Gauss Jordan elimination with detection of negligible columns applied to rectangular matrices There are three separate places in MAT88 where the rank of a matrix is implicitly computed</div><div class="ttdef"><b>Definition:</b> test1.txt:1700</div></div>
<div class="ttc" id="anamespacem__matrix_html_a46f847b458c7d52ae2dd868867d4fe10"><div class="ttname"><a href="namespacem__matrix.html#a46f847b458c7d52ae2dd868867d4fe10">m_matrix::lstk</a></div><div class="ttdeci">integer, dimension(48) lstk</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="atest1_8txt_html_af663590be765e359bbba03df2f670888"><div class="ttname"><a href="test1_8txt.html#af663590be765e359bbba03df2f670888">J</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N J</div><div class="ttdef"><b>Definition:</b> test1.txt:1974</div></div>
<div class="ttc" id="atest1_8txt_html_af864c3cbc46f83186db1258c56676f2e"><div class="ttname"><a href="test1_8txt.html#af864c3cbc46f83186db1258c56676f2e">Z</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG Z</div><div class="ttdef"><b>Definition:</b> test1.txt:2874</div></div>
<div class="ttc" id="amold_8f90_html_a13096d8980618449ae5284addda560a2"><div class="ttname"><a href="mold_8f90.html#a13096d8980618449ae5284addda560a2">comqr3</a></div><div class="ttdeci">subroutine comqr3(NM, N, LOW, IGH, ORTR, ORTI, HR, HI, WR, WI, ZR, ZI, IERR, JOB)</div><div class="ttdef"><b>Definition:</b> mold.f90:5542</div></div>
<div class="ttc" id="anamespacem__matrix_html_a777213fcd2f5bc323b231ee472914470"><div class="ttname"><a href="namespacem__matrix.html#a777213fcd2f5bc323b231ee472914470">m_matrix::mat_pythag</a></div><div class="ttdeci">doubleprecision function mat_pythag(a, b)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1351</div></div>
<div class="ttc" id="atest1_8txt_html_a4ca86429c99a51a880c211ec3b9289b8"><div class="ttname"><a href="test1_8txt.html#a4ca86429c99a51a880c211ec3b9289b8">course</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square HTRIBK if A is Hermitian COMQR2 if A is not Hermitian this was not an extensive change It also facilitated implementation of the FLOP and CHOP features which count and optionally truncate each floating point operation The EISPACK subroutine COMQR2 was modified to allow access to the Schur triangular ordinarily just an intermediate result IMTQL2 was modified to make computation of the eigenvectors optional Both subroutines were modified to eliminate the machine dependent accuracy parameter and all the EISPACK subroutines were changed to include FLOP and CHOP The algorithms employed for the POLY and ROOTS functions illustrate an interesting aspect of the modern approach to eigenvalue computation which of course</div><div class="ttdef"><b>Definition:</b> test1.txt:1604</div></div>
<div class="ttc" id="amold_8f90_html_a98f3188ef2e648be4f02642da49b71b7"><div class="ttname"><a href="mold_8f90.html#a98f3188ef2e648be4f02642da49b71b7">wset</a></div><div class="ttdeci">subroutine wset(N, XR, XI, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7564</div></div>
<div class="ttc" id="atest1_8txt_html_a1e4966206d622b4bd9fd5ae25475e375"><div class="ttname"><a href="test1_8txt.html#a1e4966206d622b4bd9fd5ae25475e375">Ikebe</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y Ikebe</div><div class="ttdef"><b>Definition:</b> test1.txt:2098</div></div>
<div class="ttc" id="anamespacem__matrix_html_a1b8d610f60e5747a3e78316966512265"><div class="ttname"><a href="namespacem__matrix.html#a1b8d610f60e5747a3e78316966512265">m_matrix::rte</a></div><div class="ttdeci">integer rte</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="atest1_8txt_html_a2e36a0b0aa55472e98190b9926d4f32a"><div class="ttname"><a href="test1_8txt.html#a2e36a0b0aa55472e98190b9926d4f32a">COND</a></div><div class="ttdeci">or COND(A)</div></div>
<div class="ttc" id="atest1_8txt_html_af84d25d7da787f044c8cdbc2862144a9"><div class="ttname"><a href="test1_8txt.html#af84d25d7da787f044c8cdbc2862144a9">Boyle</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M Boyle</div><div class="ttdef"><b>Definition:</b> test1.txt:2097</div></div>
<div class="ttc" id="amold_8f90_html_a61ae434811573402478b4d022aae653a"><div class="ttname"><a href="mold_8f90.html#a61ae434811573402478b4d022aae653a">wgefa</a></div><div class="ttdeci">subroutine wgefa(AR, AI, LDA, N, IPVT, INFO)</div><div class="ttdef"><b>Definition:</b> mold.f90:4527</div></div>
<div class="ttc" id="atest1_8txt_html_adcd9fbf5d8e8ca746ed0ed33e6f2deea"><div class="ttname"><a href="test1_8txt.html#adcd9fbf5d8e8ca746ed0ed33e6f2deea">Ill</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing Ill</div><div class="ttdef"><b>Definition:</b> test1.txt:2108</div></div>
<div class="ttc" id="anamespacem__matrix_html_aca0ee8937e49eea64380f3a16f73e576"><div class="ttname"><a href="namespacem__matrix.html#aca0ee8937e49eea64380f3a16f73e576">m_matrix::mat_base</a></div><div class="ttdeci">subroutine mat_base(x, b, eps, s, n)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1252</div></div>
<div class="ttc" id="atest1_8txt_html_ac85dc229b2502a0d520eb1d09776ca27"><div class="ttname"><a href="test1_8txt.html#ac85dc229b2502a0d520eb1d09776ca27">sensitivity</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of which are the are so far from being orthonormal is our first indication that the eigenvalues are sensitive To see this sensitivity</div><div class="ttdef"><b>Definition:</b> test1.txt:1080</div></div>
<div class="ttc" id="atest1_8txt_html_a7b3cd0ba638134b51bc9f710c31b282b"><div class="ttname"><a href="test1_8txt.html#a7b3cd0ba638134b51bc9f710c31b282b">standard</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not standard</div><div class="ttdef"><b>Definition:</b> test1.txt:1551</div></div>
<div class="ttc" id="amold_8f90_html_aef338f5ae4894a4976174ccb8bf36c32"><div class="ttname"><a href="mold_8f90.html#aef338f5ae4894a4976174ccb8bf36c32">wsvdc</a></div><div class="ttdeci">subroutine wsvdc(XR, XI, LDX, N, P, SR, SI, ER, EI, UR, UI, LDU, VR, VI, LDV, WORKR, WORKI, JOB, INFO)</div><div class="ttdef"><b>Definition:</b> mold.f90:5972</div></div>
<div class="ttc" id="atest1_8txt_html_ac470fd7abe5b22aadcd2ad3cd9e15d3e"><div class="ttname"><a href="test1_8txt.html#ac470fd7abe5b22aadcd2ad3cd9e15d3e">consuming</a></div><div class="ttdeci">for the reduced row echelon is of some interest in theoretical linear although it has little computational value It is included in MAT88 for pedagogical reasons The algorithm is essentially Gauss Jordan elimination with detection of negligible columns applied to rectangular matrices There are three separate places in MAT88 where the rank of a matrix is implicitly in A B for non square and in the pseudoinverse the rank of A is the number of nonzero rows The elimination algorithm used for RREF is the fastest of the three rank determining but it is the least sophisticated numerically and the least reliable With A the algorithm is essentially that used by example subroutine SQRST in chapter of the LINPACK guide With the algorithm is based on the singular value decomposition and is described in chapter of the LINPACK guide The SVD algorithm is the most time consuming</div><div class="ttdef"><b>Definition:</b> test1.txt:1712</div></div>
<div class="ttc" id="atest1_8txt_html_a260d2cd947a9b86445d8665e26b8f973"><div class="ttname"><a href="test1_8txt.html#a260d2cd947a9b86445d8665e26b8f973">requested</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is requested</div><div class="ttdef"><b>Definition:</b> test1.txt:1536</div></div>
<div class="ttc" id="atest1_8txt_html_a9cc0073fd1ceacff9e2d786067855530"><div class="ttname"><a href="test1_8txt.html#a9cc0073fd1ceacff9e2d786067855530">Center</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Center</div><div class="ttdef"><b>Definition:</b> test1.txt:2087</div></div>
<div class="ttc" id="atest1_8txt_html_a299fe281a9836080894d14b572094b33"><div class="ttname"><a href="test1_8txt.html#a299fe281a9836080894d14b572094b33">p</a></div><div class="ttdeci">C This recursion is easily derived by expanding the p(z)</div></div>
<div class="ttc" id="atest1_8txt_html_a50bb17654285ab47c528bd15c11e15ce"><div class="ttname"><a href="test1_8txt.html#a50bb17654285ab47c528bd15c11e15ce">way</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the way</div><div class="ttdef"><b>Definition:</b> test1.txt:2079</div></div>
<div class="ttc" id="amold_8f90_html_a0ecdebfc36528695c4fc4cabf0391b1c"><div class="ttname"><a href="mold_8f90.html#a0ecdebfc36528695c4fc4cabf0391b1c">stackg</a></div><div class="ttdeci">subroutine stackg(ID)</div><div class="ttdef"><b>Definition:</b> mold.f90:3908</div></div>
<div class="ttc" id="atest1_8txt_html_adf2868a976007afd25cf5463c97a4f37"><div class="ttname"><a href="test1_8txt.html#adf2868a976007afd25cf5463c97a4f37">NUMBER</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the NUMBER</div><div class="ttdef"><b>Definition:</b> test1.txt:1252</div></div>
<div class="ttc" id="amold_8f90_html_abb645657150deb849d5ba8d8fd824745"><div class="ttname"><a href="mold_8f90.html#abb645657150deb849d5ba8d8fd824745">watan</a></div><div class="ttdeci">subroutine watan(XR, XI, YR, YI)</div><div class="ttdef"><b>Definition:</b> mold.f90:7362</div></div>
<div class="ttc" id="anamespacem__matrix_html_a2a89e17c77411dba8c58af33e327106f"><div class="ttname"><a href="namespacem__matrix.html#a2a89e17c77411dba8c58af33e327106f">m_matrix::wte</a></div><div class="ttdeci">integer wte</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="anamespacem__matrix_html_a19f17c04f7acfdefaf474799ed1107d8"><div class="ttname"><a href="namespacem__matrix.html#a19f17c04f7acfdefaf474799ed1107d8">m_matrix::stringq</a></div><div class="ttdeci">character(len=1024), save stringq</div><div class="ttdef"><b>Definition:</b> mmm.f90:76</div></div>
<div class="ttc" id="atest1_8txt_html_ab75bd370692b59306bac2b5c864b4ab6"><div class="ttname"><a href="test1_8txt.html#ab75bd370692b59306bac2b5c864b4ab6">INTEGER</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the INTEGER</div><div class="ttdef"><b>Definition:</b> test1.txt:1252</div></div>
<div class="ttc" id="anamespacem__matrix_html_a674132bb50b24db875a4a0af41007f2a"><div class="ttname"><a href="namespacem__matrix.html#a674132bb50b24db875a4a0af41007f2a">m_matrix::lin</a></div><div class="ttdeci">integer, dimension(1024) lin</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="amold_8f90_html_af1a400def397906518f6e14fe644cf02"><div class="ttname"><a href="mold_8f90.html#af1a400def397906518f6e14fe644cf02">waxpy</a></div><div class="ttdeci">subroutine waxpy(N, SR, SI, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7454</div></div>
<div class="ttc" id="ammm_8f90_html_a257a5073a02f4513131eea577acb8fd2"><div class="ttname"><a href="mmm_8f90.html#a257a5073a02f4513131eea577acb8fd2">ml_imtql2</a></div><div class="ttdeci">subroutine ml_imtql2(NM, N, D, E, Z, IERR, JOB)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9508</div></div>
<div class="ttc" id="atest1_8txt_html_a402aa23901e7ecbf52166054811e697c"><div class="ttname"><a href="test1_8txt.html#a402aa23901e7ecbf52166054811e697c">volume</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer volume</div><div class="ttdef"><b>Definition:</b> test1.txt:2100</div></div>
<div class="ttc" id="amold_8f90_html_a65c17af78a702b5107488477235f3637"><div class="ttname"><a href="mold_8f90.html#a65c17af78a702b5107488477235f3637">wlog</a></div><div class="ttdeci">subroutine wlog(XR, XI, YR, YI)</div><div class="ttdef"><b>Definition:</b> mold.f90:7348</div></div>
<div class="ttc" id="atest1_8txt_html_ac12c6f683435b156110d7c81beb90880"><div class="ttname"><a href="test1_8txt.html#ac12c6f683435b156110d7c81beb90880">systems</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most systems</div><div class="ttdef"><b>Definition:</b> test1.txt:2831</div></div>
<div class="ttc" id="atest1_8txt_html_ac5da9a7d803e6b43276f443ae05a6f53"><div class="ttname"><a href="test1_8txt.html#ac5da9a7d803e6b43276f443ae05a6f53">memory</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the memory</div><div class="ttdef"><b>Definition:</b> test1.txt:1554</div></div>
<div class="ttc" id="atest1_8txt_html_a71c342c3dbbaf549fe1f9a3563819228"><div class="ttname"><a href="test1_8txt.html#a71c342c3dbbaf549fe1f9a3563819228">JOB</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ JOB</div><div class="ttdef"><b>Definition:</b> test1.txt:2016</div></div>
<div class="ttc" id="atest1_8txt_html_a949adfecd0b38d27971050e9a8dd8872"><div class="ttname"><a href="test1_8txt.html#a949adfecd0b38d27971050e9a8dd8872">Piper</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S Piper</div><div class="ttdef"><b>Definition:</b> test1.txt:2107</div></div>
<div class="ttc" id="atest1_8txt_html_a246e29540014c8569d5817c74e3ab425"><div class="ttname"><a href="test1_8txt.html#a246e29540014c8569d5817c74e3ab425">t</a></div><div class="ttdeci">1/10 long z, t=1/10 chop(8) long, t=1/10 long z, t=1/10 The following Fortran subprograms illustrate more details of FLOP and CHOP. The first subprogram is a simplified example of a system-dependent function used within MAT88 itself. The common variable FLP is essentially the first component of the variable FLOP. The common variable CHP is initially zero, but it is set to p by the statement CHOP(p). To shorten the DATA statement, we assume there are only 6 hexadecimal digits. We also assume an extension of Fortran that allows .AND. to be used as a binary operation between two real variables. REAL FUNCTION FLOP(X) REAL X INTEGER FLP, CHP COMMON FLP, CHP REAL MASK(5) DATA MASK/ZFFFFFFF0, ZFFFFFF00, ZFFFFF000, ZFFFF0000, ZFFF00000/FLP=FLP+1 IF(CHP .EQ. 0) FLOP=X IF(CHP .GE. 1 .AND. CHP .LE. 5) FLOP=X .AND. MASK(CHP) IF(CHP .GE. 6) FLOP=0.0 END REAL FUNCTION FLOP The following subroutine illustrates a typical use of the previous function within MAT88. It is a simplified version of the Basic Linear Algebra Subprogram that adds a scalar multiple of one vector to another. We assume here that the vectors are stored with a memory increment of one. SUBROUTINE SAXPY(N, TR, TI, XR, XI, YR, YI) REAL TR, TI, XR(N), XI(N), YR(N), YI(N), FLOP IF(N .LE. 0) RETURN IF(TR .EQ. 0.0 .AND. TI .EQ. 0.0) RETURN DO I=1, N YR(I)=FLOP(YR(I)+TR *XR(I) - TI *XI(I)) YI(I)=YI(I)+TR *XI(I)+TI *XR(I) IF(YI(I) .NE. 0.0D0) YI(I)=FLOP(YI(I)) enddo END SUBROUTINE SAXPY The saxpy operation is perhaps the most fundamental operation within LINPACK. It is used in the computation of the LU, the QR and the SVD factorizations, and in several other places. We see that adding a multiple of one vector with n components to another uses n flops if the vectors are real and between n and 2 *n flops if the vectors have nonzero imaginary components. The permanent MAT88 variable EPS is reset by the statement CHOP(p). Its new value is usually the smallest inverse power of two that satisfies the Fortran logical test FLOP(1.0+EPS) .GT. 1.0 However, if EPS had been directly reset to a larger value, the old value is retained. 13. COMMUNICATING WITH OTHER PROGRAMS There are four different ways MAT88 can be used in conjunction with other programs:-- USER, -- EXEC, -- SAVE and LOAD, -- MATZ, CALL and QUIT . Let us illustrate each of these by the following simple example. n=6 for i=1:n, for j=1:n, a(i, j)=abs(i-j) t</div><div class="ttdef"><b>Definition:</b> test1.txt:1914</div></div>
<div class="ttc" id="atest1_8txt_html_a1ec3453ffd71b3cba339c0d95f0947d0"><div class="ttname"><a href="test1_8txt.html#a1ec3453ffd71b3cba339c0d95f0947d0">LDA</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ LDA</div><div class="ttdef"><b>Definition:</b> test1.txt:2016</div></div>
<div class="ttc" id="amold_8f90_html_a8a173341e9b9688b2a786e471c480a11"><div class="ttname"><a href="mold_8f90.html#a8a173341e9b9688b2a786e471c480a11">htribk</a></div><div class="ttdeci">subroutine htribk(NM, N, AR, AI, TAU, M, ZR, ZI)</div><div class="ttdef"><b>Definition:</b> mold.f90:5152</div></div>
<div class="ttc" id="atest1_8txt_html_a2d270951613ab71339a804dd5bd39b54"><div class="ttname"><a href="test1_8txt.html#a2d270951613ab71339a804dd5bd39b54">RAND</a></div><div class="ttdeci">RAND(n) *RAND(n)</div></div>
<div class="ttc" id="atest1_8txt_html_a6a54b1fb39b570ed947ba9bff09da1ee"><div class="ttname"><a href="test1_8txt.html#a6a54b1fb39b570ed947ba9bff09da1ee">n</a></div><div class="ttdeci">n</div><div class="ttdef"><b>Definition:</b> test1.txt:436</div></div>
<div class="ttc" id="anamespacem__matrix_html_a4a9314d4683998ad107da1df15f92477"><div class="ttname"><a href="namespacem__matrix.html#a4a9314d4683998ad107da1df15f92477">m_matrix::stki</a></div><div class="ttdeci">doubleprecision, dimension(bigmem) stki</div><div class="ttdef"><b>Definition:</b> mmm.f90:81</div></div>
<div class="ttc" id="amold_8f90_html_a9bbeeb28d89022ddb43927cf6638c6e3"><div class="ttname"><a href="mold_8f90.html#a9bbeeb28d89022ddb43927cf6638c6e3">factor</a></div><div class="ttdeci">subroutine factor</div><div class="ttdef"><b>Definition:</b> mold.f90:677</div></div>
<div class="ttc" id="atest1_8txt_html_af63eb132e3fe388bd8604fa9aab1cebb"><div class="ttname"><a href="test1_8txt.html#af63eb132e3fe388bd8604fa9aab1cebb">RANK</a></div><div class="ttdeci">for the reduced row echelon is of some interest in theoretical linear although it has little computational value It is included in MAT88 for pedagogical reasons The algorithm is essentially Gauss Jordan elimination with detection of negligible columns applied to rectangular matrices There are three separate places in MAT88 where the rank of a matrix is implicitly in A B for non square and in the pseudoinverse the rank of A is the number of nonzero rows The elimination algorithm used for RREF is the fastest of the three rank determining but it is the least sophisticated numerically and the least reliable With A the algorithm is essentially that used by example subroutine SQRST in chapter of the LINPACK guide With the algorithm is based on the singular value decomposition and is described in chapter of the LINPACK guide The SVD algorithm is the most time but the most reliable and is therefore also used for RANK(A). The uniformly distributed random numbers in RAND are obtained from the machine-independent random number generator URAND described in[9]. It is possible to switch to normally distributed random numbers</div></div>
<div class="ttc" id="atest1_8txt_html_a5d0fe932a92f1e17ab646ec9b8a8b062"><div class="ttname"><a href="test1_8txt.html#a5d0fe932a92f1e17ab646ec9b8a8b062">imag</a></div><div class="ttdeci">if imag(d(1))=0</div></div>
<div class="ttc" id="atest1_8txt_html_ad3a46ad317f8826946f3c9a3ea39acc7"><div class="ttname"><a href="test1_8txt.html#ad3a46ad317f8826946f3c9a3ea39acc7">B</a></div><div class="ttdeci">&lt; 4 2 0 &gt; x B</div><div class="ttdef"><b>Definition:</b> test1.txt:235</div></div>
<div class="ttc" id="atest1_8txt_html_a4425845f68bdae4e6edb174d5fffae8a"><div class="ttname"><a href="test1_8txt.html#a4425845f68bdae4e6edb174d5fffae8a">h</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for h</div><div class="ttdef"><b>Definition:</b> test1.txt:413</div></div>
<div class="ttc" id="atest1_8txt_html_ab3a173bc1345c26521ef491ca265b383"><div class="ttname"><a href="test1_8txt.html#ab3a173bc1345c26521ef491ca265b383">Matrix</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a Matrix</div><div class="ttdef"><b>Definition:</b> test1.txt:2122</div></div>
<div class="ttc" id="atest1_8txt_html_a4602821dafb9f6eeb17c6c1a12f02d2c"><div class="ttname"><a href="test1_8txt.html#a4602821dafb9f6eeb17c6c1a12f02d2c">than</a></div><div class="ttdeci">is a by matrix The semicolon ends the first row Vectors and matrices can be used inside&lt; &gt; brackets&lt; A B;C &gt; is allowed if the number of rows of A equals the number of rows of B and the number of columns of A plus the number of columns of B equals the number of columns of C This rule generalizes in a hopefully obvious way to allow fairly complicated constructions thereby removing it from the list of current variables For the use of&lt; and &gt; on the left of see SVD and so on In WHILE and IF&lt;&gt; means less than or greater than</div><div class="ttdef"><b>Definition:</b> test1.txt:2227</div></div>
<div class="ttc" id="amold_8f90_html_a4db0cd147eea703aa27c121fa80acae4"><div class="ttname"><a href="mold_8f90.html#a4db0cd147eea703aa27c121fa80acae4">matfn3</a></div><div class="ttdeci">subroutine matfn3</div><div class="ttdef"><b>Definition:</b> mold.f90:1830</div></div>
<div class="ttc" id="atest1_8txt_html_adf15e440746ece7a840eb50f7d80089b"><div class="ttname"><a href="test1_8txt.html#adf15e440746ece7a840eb50f7d80089b">Ac</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal evaluated at the i th boundary point A right hand side with m components is also generated In this the elements of the right hand side are either zero or one The coefficients are then found by solving the overdetermined set of equations Ac</div><div class="ttdef"><b>Definition:</b> test1.txt:883</div></div>
<div class="ttc" id="amold_8f90_html_a7a953fc0014129dd416edec92ec0cf5f"><div class="ttname"><a href="mold_8f90.html#a7a953fc0014129dd416edec92ec0cf5f">files</a></div><div class="ttdeci">subroutine files(LUNIT, INAME)</div><div class="ttdef"><b>Definition:</b> mold.f90:913</div></div>
<div class="ttc" id="atest1_8txt_html_a449d2d99f971c07e935bb02ca5fd76ac"><div class="ttname"><a href="test1_8txt.html#a449d2d99f971c07e935bb02ca5fd76ac">format</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output format</div><div class="ttdef"><b>Definition:</b> test1.txt:466</div></div>
<div class="ttc" id="amold_8f90_html_ab98982d15ac38d859f31422493baf045"><div class="ttname"><a href="mold_8f90.html#ab98982d15ac38d859f31422493baf045">matfn4</a></div><div class="ttdeci">subroutine matfn4</div><div class="ttdef"><b>Definition:</b> mold.f90:2081</div></div>
<div class="ttc" id="anamespacem__matrix_html_abda0814f8ebd1a8ccbd956b410fd89c5"><div class="ttname"><a href="namespacem__matrix.html#abda0814f8ebd1a8ccbd956b410fd89c5">m_matrix::mat_wset</a></div><div class="ttdeci">subroutine mat_wset(n, xr, xi, yr, yi, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1231</div></div>
<div class="ttc" id="atest1_8txt_html_adc246d5c455a98075a5aaa48b4c95041"><div class="ttname"><a href="test1_8txt.html#adc246d5c455a98075a5aaa48b4c95041">SIN</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more more efficient methods for finding polynomial but this approach has the crucial advantage that it does not require very much additional code The elementary functions SIN</div><div class="ttdef"><b>Definition:</b> test1.txt:1654</div></div>
<div class="ttc" id="amold_8f90_html_aae9af92dfaeab6d3a48ae1e8ba8289b6"><div class="ttname"><a href="mold_8f90.html#aae9af92dfaeab6d3a48ae1e8ba8289b6">base</a></div><div class="ttdeci">subroutine base(X, B, EPS, S, N)</div><div class="ttdef"><b>Definition:</b> mold.f90:7181</div></div>
<div class="ttc" id="atest1_8txt_html_adb75752900fb7a64f1751a738ab7d0ea"><div class="ttname"><a href="test1_8txt.html#adb75752900fb7a64f1751a738ab7d0ea">ROWS</a></div><div class="ttdeci">&lt; 4 2 0 &gt; x since they can easily be added to the system ROWS</div><div class="ttdef"><b>Definition:</b> test1.txt:340</div></div>
<div class="ttc" id="atest1_8txt_html_a87f6540bdacc78d66aa258ba9cb8419a"><div class="ttname"><a href="test1_8txt.html#a87f6540bdacc78d66aa258ba9cb8419a">matrix</a></div><div class="ttdeci">T we display the perturbed matrix</div><div class="ttdef"><b>Definition:</b> test1.txt:1207</div></div>
<div class="ttc" id="atest1_8txt_html_ae3f2fc4b0fc3d12de2247183bb2f25ae"><div class="ttname"><a href="test1_8txt.html#ae3f2fc4b0fc3d12de2247183bb2f25ae">Manual</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Manual</div><div class="ttdef"><b>Definition:</b> test1.txt:2107</div></div>
<div class="ttc" id="ammm_8f90_html_aeec5fe0816d5eac1e69c04124e731e7d"><div class="ttname"><a href="mmm_8f90.html#aeec5fe0816d5eac1e69c04124e731e7d">ml_wasum</a></div><div class="ttdeci">doubleprecision function ml_wasum(N, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11675</div></div>
<div class="ttc" id="ammm_8f90_html_a33764f04f25af3abd4dff9d6c638f061"><div class="ttname"><a href="mmm_8f90.html#a33764f04f25af3abd4dff9d6c638f061">ml_expr</a></div><div class="ttdeci">subroutine ml_expr()</div><div class="ttdef"><b>Definition:</b> mmm.f90:5922</div></div>
<div class="ttc" id="anamespacem__matrix_html_a35eccf74eb3300405d0af6056a8da6fd"><div class="ttname"><a href="namespacem__matrix.html#a35eccf74eb3300405d0af6056a8da6fd">m_matrix::mat_str2buf</a></div><div class="ttdeci">subroutine mat_str2buf(string, buf, lrecl)</div><div class="ttdef"><b>Definition:</b> mmm.f90:620</div></div>
<div class="ttc" id="atest1_8txt_html_a544fa1233ba0eeae50e8302c9f8aa4df"><div class="ttname"><a href="test1_8txt.html#a544fa1233ba0eeae50e8302c9f8aa4df">Mexico</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean University of New Mexico</div><div class="ttdef"><b>Definition:</b> test1.txt:2129</div></div>
<div class="ttc" id="atest1_8txt_html_a33a2f6da525db47d5165df1263ea383c"><div class="ttname"><a href="test1_8txt.html#a33a2f6da525db47d5165df1263ea383c">b</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean University of New Computer Science technical submitted for APPENDIX INTRO Welcome to MAT88 HELP Sections Available Topics Documentation help NEWS what Syntax&lt; &gt; semi * b</div><div class="ttdef"><b>Definition:</b> test1.txt:2173</div></div>
<div class="ttc" id="amold_8f90_html_aa19f3ed8bda73a1d7089e0599d0670d3"><div class="ttname"><a href="mold_8f90.html#aa19f3ed8bda73a1d7089e0599d0670d3">wasum</a></div><div class="ttdeci">double precision function wasum(N, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mold.f90:7396</div></div>
<div class="ttc" id="atest1_8txt_html_ac96b96742620adb301595bc5046518e8"><div class="ttname"><a href="test1_8txt.html#ac96b96742620adb301595bc5046518e8">norm</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean University of New Computer Science technical submitted for APPENDIX INTRO Welcome to MAT88 HELP Sections Available Topics Documentation help NEWS what Syntax&lt; &gt; semi norm(A-V *D/V) help \</div></div>
<div class="ttc" id="atest1_8txt_html_af105eb2315d2a94fe1ffe3ce801ff395"><div class="ttname"><a href="test1_8txt.html#af105eb2315d2a94fe1ffe3ce801ff395">system</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal evaluated at the i th boundary point A right hand side with m components is also generated In this the elements of the right hand side are either zero or one The coefficients are then found by solving the overdetermined set of equations the approximate solution is defined everywhere on the domain It is then possible to compute the effective conductivity sigma In a very simple formula n j the following program is first stored in the computer file system</div><div class="ttdef"><b>Definition:</b> test1.txt:897</div></div>
<div class="ttc" id="atest1_8txt_html_a6a3074d3ca1987916de7c1f6e03bac23"><div class="ttname"><a href="test1_8txt.html#a6a3074d3ca1987916de7c1f6e03bac23">Smith</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T Smith</div><div class="ttdef"><b>Definition:</b> test1.txt:2097</div></div>
<div class="ttc" id="anamespacem__matrix_html_a842ac2b684d2d55ad407031d490f3b70"><div class="ttname"><a href="namespacem__matrix.html#a842ac2b684d2d55ad407031d490f3b70">m_matrix::mat88</a></div><div class="ttdeci">subroutine, public mat88(init, string0)</div><div class="ttdef"><b>Definition:</b> mmm.f90:201</div></div>
<div class="ttc" id="atest1_8txt_html_a2c72e03c36d3b0194ad969878493b142"><div class="ttname"><a href="test1_8txt.html#a2c72e03c36d3b0194ad969878493b142">QR</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC QR(A) - CQRDC</div></div>
<div class="ttc" id="atest1_8txt_html_acdeb7bd9eb6d6d2877635569da7ae712"><div class="ttname"><a href="test1_8txt.html#acdeb7bd9eb6d6d2877635569da7ae712">Moreover</a></div><div class="ttdeci">which produces the eigenvalues of B and Moreover</div><div class="ttdef"><b>Definition:</b> test1.txt:1013</div></div>
<div class="ttc" id="atest1_8txt_html_aca1d7611cdbea048de957fcb0fb4ea3c"><div class="ttname"><a href="test1_8txt.html#aca1d7611cdbea048de957fcb0fb4ea3c">abs</a></div><div class="ttdeci">E The IF clause allows conditional execution of statements The general form is IF expr relop ELSE statement The first group of statements are executed if the relation is true and the second group are executed if the relation is false The ELSE and the statements following it may be omitted For if abs(i-j)</div></div>
<div class="ttc" id="amold_8f90_html_a020fad45f6fea64dd15f03de52412ea2"><div class="ttname"><a href="mold_8f90.html#a020fad45f6fea64dd15f03de52412ea2">formz</a></div><div class="ttdeci">subroutine formz(LUNIT, X, Y)</div><div class="ttdef"><b>Definition:</b> mold.f90:1046</div></div>
<div class="ttc" id="anamespacem__matrix_html_abfbe8e5cad04bad68185a783daaed20f"><div class="ttname"><a href="namespacem__matrix.html#abfbe8e5cad04bad68185a783daaed20f">m_matrix::mstk</a></div><div class="ttdeci">integer, dimension(48) mstk</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="atest1_8txt_html_aa66e73fe13a8b2b2c95e514691e96b77"><div class="ttname"><a href="test1_8txt.html#aa66e73fe13a8b2b2c95e514691e96b77">LOG</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more more efficient methods for finding polynomial but this approach has the crucial advantage that it does not require very much additional code The elementary functions LOG</div><div class="ttdef"><b>Definition:</b> test1.txt:1654</div></div>
<div class="ttc" id="atest1_8txt_html_ab6ccafdf0aeaca8f2554ef0549adef41"><div class="ttname"><a href="test1_8txt.html#ab6ccafdf0aeaca8f2554ef0549adef41">Hall</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice Hall</div><div class="ttdef"><b>Definition:</b> test1.txt:2115</div></div>
<div class="ttc" id="atest1_8txt_html_ac83e89a2ff6814a50f192c1059337720"><div class="ttname"><a href="test1_8txt.html#ac83e89a2ff6814a50f192c1059337720">eigenvectors</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for&lt; h, cos(pi *h)&gt; prints a table of cosines&lt; X, D &gt; for A *v displays eigenvectors</div><div class="ttdef"><b>Definition:</b> test1.txt:419</div></div>
<div class="ttc" id="atest1_8txt_html_a1ba13147a5ec144da8a76d7f280de760"><div class="ttname"><a href="test1_8txt.html#a1ba13147a5ec144da8a76d7f280de760">place</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in place</div><div class="ttdef"><b>Definition:</b> test1.txt:1554</div></div>
<div class="ttc" id="atest1_8txt_html_ab2b4c3636ed16da5803c7c9e12f43ced"><div class="ttname"><a href="test1_8txt.html#ab2b4c3636ed16da5803c7c9e12f43ced">So</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff So</div><div class="ttdef"><b>Definition:</b> test1.txt:1047</div></div>
<div class="ttc" id="amold_8f90_html_ada23385ef8a89f31d1e7cc016012c2ff"><div class="ttname"><a href="mold_8f90.html#ada23385ef8a89f31d1e7cc016012c2ff">term</a></div><div class="ttdeci">subroutine term</div><div class="ttdef"><b>Definition:</b> mold.f90:4208</div></div>
<div class="ttc" id="atest1_8txt_html_ae2fdc33bcd49731e36913fa7258b0dc8"><div class="ttname"><a href="test1_8txt.html#ae2fdc33bcd49731e36913fa7258b0dc8">are</a></div><div class="ttdeci">which produces the eigenvalues of B are</div><div class="ttdef"><b>Definition:</b> test1.txt:1013</div></div>
<div class="ttc" id="atest1_8txt_html_ae174389deb2d86d8b14b20e0d1b010ca"><div class="ttname"><a href="test1_8txt.html#ae174389deb2d86d8b14b20e0d1b010ca">symmetric</a></div><div class="ttdeci">which produces the eigenvalues of B and since B is not symmetric</div><div class="ttdef"><b>Definition:</b> test1.txt:1014</div></div>
<div class="ttc" id="atest1_8txt_html_a1d1735e45aea7d2eb800147c41031098"><div class="ttname"><a href="test1_8txt.html#a1d1735e45aea7d2eb800147c41031098">language</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the language</div><div class="ttdef"><b>Definition:</b> test1.txt:1251</div></div>
<div class="ttc" id="atest1_8txt_html_ac18e49485653b2a6fb341dc08c108af4"><div class="ttname"><a href="test1_8txt.html#ac18e49485653b2a6fb341dc08c108af4">flop</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal evaluated at the i th boundary point A right hand side with m components is also generated In this the elements of the right hand side are either zero or one The coefficients are then found by solving the overdetermined set of equations the approximate solution is defined everywhere on the domain It is then possible to compute the effective conductivity sigma In a very simple formula n j the following program is first stored in the computer file say under the name PDE rho n m flop</div><div class="ttdef"><b>Definition:</b> test1.txt:906</div></div>
<div class="ttc" id="ammm_8f90_html_a2bbb312146a2be04769a5f42f2cc4633"><div class="ttname"><a href="mmm_8f90.html#a2bbb312146a2be04769a5f42f2cc4633">ml_matfn1</a></div><div class="ttdeci">subroutine ml_matfn1()</div><div class="ttdef"><b>Definition:</b> mmm.f90:6525</div></div>
<div class="ttc" id="atest1_8txt_html_a3c5c107b2b8ad3dd4a7196afeff03175"><div class="ttname"><a href="test1_8txt.html#a3c5c107b2b8ad3dd4a7196afeff03175">FLOP</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except FLOP</div><div class="ttdef"><b>Definition:</b> test1.txt:472</div></div>
<div class="ttc" id="amold_8f90_html_aa5e258dc2ea6cdd5d2b74a867dc4bf96"><div class="ttname"><a href="mold_8f90.html#aa5e258dc2ea6cdd5d2b74a867dc4bf96">ml_dfloat</a></div><div class="ttdeci">double precision function ml_dfloat(I)</div><div class="ttdef"><b>Definition:</b> mold.f90:7723</div></div>
<div class="ttc" id="ammm_8f90_html_acf3d643298f036d2ec84023be8c9478f"><div class="ttname"><a href="mmm_8f90.html#acf3d643298f036d2ec84023be8c9478f">mat_parse</a></div><div class="ttdeci">subroutine mat_parse(INIT)</div><div class="ttdef"><b>Definition:</b> mmm.f90:5110</div></div>
<div class="ttc" id="atest1_8txt_html_a4d930d019be5faa57dde81afc4ad296e"><div class="ttname"><a href="test1_8txt.html#a4d930d019be5faa57dde81afc4ad296e">RCOND</a></div><div class="ttdeci">X *D X This is essentially method number out of the dubious possibilities described in[8] It is dubious because it doesn t always work The matrix of eigenvectors X can be arbitrarily badly conditioned and all accuracy lost in the computation of X *D X A warning message is printed if RCOND(X) is very small</div></div>
<div class="ttc" id="amold_8f90_html_a18f85a30df1b6dc6ba8fab4e6d2e1518"><div class="ttname"><a href="mold_8f90.html#a18f85a30df1b6dc6ba8fab4e6d2e1518">wsign</a></div><div class="ttdeci">subroutine wsign(XR, XI, YR, YI, ZR, ZI)</div><div class="ttdef"><b>Definition:</b> mold.f90:7320</div></div>
<div class="ttc" id="atest1_8txt_html_a1fd406685cbdee605d0a7bebed56fdb0"><div class="ttname"><a href="test1_8txt.html#a1fd406685cbdee605d0a7bebed56fdb0">F</a></div><div class="ttdeci">F</div><div class="ttdef"><b>Definition:</b> test1.txt:436</div></div>
<div class="ttc" id="amold_8f90_html_a88fc8be8f1702eb32fe9f6ad8e5675b5"><div class="ttname"><a href="mold_8f90.html#a88fc8be8f1702eb32fe9f6ad8e5675b5">wscal</a></div><div class="ttdeci">subroutine wscal(N, SR, SI, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mold.f90:7442</div></div>
<div class="ttc" id="amold_8f90_html_aed06c1d855d3ce64d7db1496c5ae673a"><div class="ttname"><a href="mold_8f90.html#aed06c1d855d3ce64d7db1496c5ae673a">wdotcr</a></div><div class="ttdeci">double precision function wdotcr(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7510</div></div>
<div class="ttc" id="anamespacem__matrix_html_af40f275d65f0cef94c8687d7c08d248e"><div class="ttname"><a href="namespacem__matrix.html#af40f275d65f0cef94c8687d7c08d248e">m_matrix::mat_funs</a></div><div class="ttdeci">subroutine mat_funs(id)</div><div class="ttdef"><b>Definition:</b> mmm.f90:993</div></div>
<div class="ttc" id="atest1_8txt_html_af665980481c66cfefaa0be993cdae7f3"><div class="ttname"><a href="test1_8txt.html#af665980481c66cfefaa0be993cdae7f3">TEXT</a></div><div class="ttdeci">TEXT</div><div class="ttdef"><b>Definition:</b> test1.txt:453</div></div>
<div class="ttc" id="atest1_8txt_html_a4626554aee0564362d52929f770837c4"><div class="ttname"><a href="test1_8txt.html#a4626554aee0564362d52929f770837c4">k</a></div><div class="ttdeci">for for k</div><div class="ttdef"><b>Definition:</b> test1.txt:925</div></div>
<div class="ttc" id="atest1_8txt_html_a1bf1fcaf1160916fb1329a5fc3a5c663"><div class="ttname"><a href="test1_8txt.html#a1bf1fcaf1160916fb1329a5fc3a5c663">Stewart</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W Stewart</div><div class="ttdef"><b>Definition:</b> test1.txt:2093</div></div>
<div class="ttc" id="anamespacem__matrix_html_a6f243f3dd4df99998b39562078c3fca2"><div class="ttname"><a href="namespacem__matrix.html#a6f243f3dd4df99998b39562078c3fca2">m_matrix::mat_print</a></div><div class="ttdeci">subroutine mat_print(ID, K)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1394</div></div>
<div class="ttc" id="atest1_8txt_html_aed003dcb4f2b42106defff92bdfceca3"><div class="ttname"><a href="test1_8txt.html#aed003dcb4f2b42106defff92bdfceca3">Review</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM Review</div><div class="ttdef"><b>Definition:</b> test1.txt:2122</div></div>
<div class="ttc" id="amold_8f90_html_ad2aaf1b57a93704deea8c793f8c0bc04"><div class="ttname"><a href="mold_8f90.html#ad2aaf1b57a93704deea8c793f8c0bc04">error</a></div><div class="ttdeci">subroutine error(N)</div><div class="ttdef"><b>Definition:</b> mold.f90:446</div></div>
<div class="ttc" id="atest1_8txt_html_ac85e1322e210cd3e55055a318bee02d8"><div class="ttname"><a href="test1_8txt.html#ac85e1322e210cd3e55055a318bee02d8">as</a></div><div class="ttdeci">semi comma quote&lt;[less 51 &gt; great a z a z letters it will execute the edited if you had entered a line such as</div><div class="ttdef"><b>Definition:</b> test1.txt:3069</div></div>
<div class="ttc" id="ammm_8f90_html_a28b61f1560d8a697b452ded189b3a6e7"><div class="ttname"><a href="mmm_8f90.html#a28b61f1560d8a697b452ded189b3a6e7">ml_wpofa</a></div><div class="ttdeci">subroutine ml_wpofa(AR, AI, LDA, N, INFO)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9232</div></div>
<div class="ttc" id="atest1_8txt_html_ab915b59342d7609c0979d7d5764a0009"><div class="ttname"><a href="test1_8txt.html#ab915b59342d7609c0979d7d5764a0009">DET</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI DET(A) - CGECO</div></div>
<div class="ttc" id="amold_8f90_html_a52c3dbb372ff2086a5ae3fc477b4000e"><div class="ttname"><a href="mold_8f90.html#a52c3dbb372ff2086a5ae3fc477b4000e">stack1</a></div><div class="ttdeci">subroutine stack1(OP)</div><div class="ttdef"><b>Definition:</b> mold.f90:3584</div></div>
<div class="ttc" id="anamespacem__matrix_html_ae609ddab43244373ab9cfd76786b7518"><div class="ttname"><a href="namespacem__matrix.html#ae609ddab43244373ab9cfd76786b7518">m_matrix::mat_getch</a></div><div class="ttdeci">subroutine mat_getch()</div><div class="ttdef"><b>Definition:</b> mmm.f90:1086</div></div>
<div class="ttc" id="ammm_8f90_html_a52508a439ee05d140905bad8ece55211"><div class="ttname"><a href="mmm_8f90.html#a52508a439ee05d140905bad8ece55211">ml_getlin</a></div><div class="ttdeci">subroutine ml_getlin()</div><div class="ttdef"><b>Definition:</b> mmm.f90:6262</div></div>
<div class="ttc" id="atest1_8txt_html_aeaa87295020e1111fdb763522930f934"><div class="ttname"><a href="test1_8txt.html#aeaa87295020e1111fdb763522930f934">M</a></div><div class="ttdeci">M</div><div class="ttdef"><b>Definition:</b> test1.txt:1021</div></div>
<div class="ttc" id="anamespacem__matrix_html_ae8a13cda66ac0c391845f63f90b881d2"><div class="ttname"><a href="namespacem__matrix.html#ae8a13cda66ac0c391845f63f90b881d2">m_matrix::ialf</a></div><div class="ttdeci">integer, parameter ialf</div><div class="ttdef"><b>Definition:</b> mmm.f90:80</div></div>
<div class="ttc" id="anamespacem__matrix_html_abaec2067bfb39e3e03265dded9fc5217"><div class="ttname"><a href="namespacem__matrix.html#abaec2067bfb39e3e03265dded9fc5217">m_matrix::mat_wsqrt</a></div><div class="ttdeci">subroutine mat_wsqrt(xr, xi, yr, yi)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1636</div></div>
<div class="ttc" id="anamespacem__matrix_html_a59f41f208a67a0646fab14590cf6e176"><div class="ttname"><a href="namespacem__matrix.html#a59f41f208a67a0646fab14590cf6e176">m_matrix::case</a></div><div class="ttdeci">integer case</div><div class="ttdef"><b>Definition:</b> mmm.f90:83</div></div>
<div class="ttc" id="atest1_8txt_html_af130bf7fe0efabc76dcf9b2c7008846a"><div class="ttname"><a href="test1_8txt.html#af130bf7fe0efabc76dcf9b2c7008846a">CGECO</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGECO</div><div class="ttdef"><b>Definition:</b> test1.txt:1576</div></div>
<div class="ttc" id="atest1_8txt_html_a352951c06b9686651e25162d794210a4"><div class="ttname"><a href="test1_8txt.html#a352951c06b9686651e25162d794210a4">program</a></div><div class="ttdeci">as well as a flow chart of the mat88 program</div><div class="ttdef"><b>Definition:</b> test1.txt:1247</div></div>
<div class="ttc" id="amold_8f90_html_ad449dcb586436c3166e521f140868235"><div class="ttname"><a href="mold_8f90.html#ad449dcb586436c3166e521f140868235">getch</a></div><div class="ttdeci">subroutine getch</div><div class="ttdef"><b>Definition:</b> mold.f90:1131</div></div>
<div class="ttc" id="atest1_8txt_html_a892c970f69320643c327265e26f6ede1"><div class="ttname"><a href="test1_8txt.html#a892c970f69320643c327265e26f6ede1">TERM</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the TERM</div><div class="ttdef"><b>Definition:</b> test1.txt:1251</div></div>
<div class="ttc" id="amold_8f90_html_afeb342642959a74d4fa81ebbc8d2f9c8"><div class="ttname"><a href="mold_8f90.html#afeb342642959a74d4fa81ebbc8d2f9c8">rref</a></div><div class="ttdeci">subroutine rref(AR, AI, LDA, M, N, EPS)</div><div class="ttdef"><b>Definition:</b> mold.f90:4947</div></div>
<div class="ttc" id="atest1_8txt_html_a97607d1b57ca47c9c7fdb29a25fad589"><div class="ttname"><a href="test1_8txt.html#a97607d1b57ca47c9c7fdb29a25fad589">operations</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various operations</div><div class="ttdef"><b>Definition:</b> test1.txt:460</div></div>
<div class="ttc" id="anamespacem__matrix_html_aec61107087d12549478ad8583cd92563"><div class="ttname"><a href="namespacem__matrix.html#aec61107087d12549478ad8583cd92563">m_matrix::fun</a></div><div class="ttdeci">integer fun</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="atest1_8txt_html_a0544c3fe466e421738dae463968b70ba"><div class="ttname"><a href="test1_8txt.html#a0544c3fe466e421738dae463968b70ba">else</a></div><div class="ttdeci">else</div><div class="ttdef"><b>Definition:</b> test1.txt:1198</div></div>
<div class="ttc" id="atest1_8txt_html_a3691308f2a4c2f6983f2880d32e29c84"><div class="ttname"><a href="test1_8txt.html#a3691308f2a4c2f6983f2880d32e29c84">s</a></div><div class="ttdeci">s</div><div class="ttdef"><b>Definition:</b> test1.txt:1195</div></div>
<div class="ttc" id="atest1_8txt_html_a5b22cd4aece979ac7d4cf8f4e3f9716b"><div class="ttname"><a href="test1_8txt.html#a5b22cd4aece979ac7d4cf8f4e3f9716b">STATEMENT</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the STATEMENT</div><div class="ttdef"><b>Definition:</b> test1.txt:1251</div></div>
<div class="ttc" id="amold_8f90_html_ac631082cee54f1a313728d8ecc8d50a4"><div class="ttname"><a href="mold_8f90.html#ac631082cee54f1a313728d8ecc8d50a4">wnrm2</a></div><div class="ttdeci">double precision function wnrm2(N, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mold.f90:7380</div></div>
<div class="ttc" id="amold_8f90_html_add4a5a29f03b9409108e5ac80185bb9e"><div class="ttname"><a href="mold_8f90.html#add4a5a29f03b9409108e5ac80185bb9e">wqrdc</a></div><div class="ttdeci">subroutine wqrdc(XR, XI, LDX, N, P, QRAUXR, QRAUXI, JPVT, WORKR, WORKI, JOB)</div><div class="ttdef"><b>Definition:</b> mold.f90:6541</div></div>
<div class="ttc" id="atest1_8txt_html_abe46cc1febfd259e117a41f0f5076b19"><div class="ttname"><a href="test1_8txt.html#abe46cc1febfd259e117a41f0f5076b19">echo</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no echo</div><div class="ttdef"><b>Definition:</b> test1.txt:2855</div></div>
<div class="ttc" id="atest1_8txt_html_ab7c073ef1b4f845be815eaab20c1e93e"><div class="ttname"><a href="test1_8txt.html#ab7c073ef1b4f845be815eaab20c1e93e">FLOPS</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc X saves only X See FILE The variables may be retrieved later by then REAL or DOUBLEPRECISION NMAX IMG DO N M M enddo The formats used are system dependent The following are typical See SUBROUTINE ML_SAVLOD in your implementation of MAT88 the user is asked whether or not to suppress printing until the next input Initially the limit is often hexadecimal short See LONG diary DIARY( 'file') causes a copy of all subsequent terminal input and most of the resulting output to be written on the file. DIARY(0) turns it off. See FILE. disp DISPLAY(X) prints X in a compact format. If a base is specified the values are printed as numeric values in the specified base. disp(0 FLOPS(1) will be printed whenever a statement is terminated by an extra comma. For example</div></div>
<div class="ttc" id="atest1_8txt_html_a7fa3434e865bb9ba2c248c40b6a4faa2"><div class="ttname"><a href="test1_8txt.html#a7fa3434e865bb9ba2c248c40b6a4faa2">original</a></div><div class="ttdeci">T we display the perturbed which is obviously close to the original</div><div class="ttdef"><b>Definition:</b> test1.txt:1208</div></div>
<div class="ttc" id="atest1_8txt_html_a41e09a121a9a12762c73144ae1e566a9"><div class="ttname"><a href="test1_8txt.html#a41e09a121a9a12762c73144ae1e566a9">algorithms</a></div><div class="ttdeci">for the reduced row echelon is of some interest in theoretical linear although it has little computational value It is included in MAT88 for pedagogical reasons The algorithm is essentially Gauss Jordan elimination with detection of negligible columns applied to rectangular matrices There are three separate places in MAT88 where the rank of a matrix is implicitly in A B for non square and in the pseudoinverse the rank of A is the number of nonzero rows The elimination algorithm used for RREF is the fastest of the three rank determining algorithms</div><div class="ttdef"><b>Definition:</b> test1.txt:1706</div></div>
<div class="ttc" id="atest1_8txt_html_afaea1e281b4ef9b7e3eb17b24f710754"><div class="ttname"><a href="test1_8txt.html#afaea1e281b4ef9b7e3eb17b24f710754">Verlag</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer Verlag</div><div class="ttdef"><b>Definition:</b> test1.txt:2100</div></div>
<div class="ttc" id="anamespacem__matrix_html_a9fe2d4dd61c820168cd3c4fd3ce2d406"><div class="ttname"><a href="namespacem__matrix.html#a9fe2d4dd61c820168cd3c4fd3ce2d406">m_matrix::mat_err</a></div><div class="ttdeci">subroutine mat_err(n)</div><div class="ttdef"><b>Definition:</b> mmm.f90:318</div></div>
<div class="ttc" id="ammm_8f90_html_a8c923a1a046464dab7ab65cc41a7cafb"><div class="ttname"><a href="mmm_8f90.html#a8c923a1a046464dab7ab65cc41a7cafb">ml_stack2</a></div><div class="ttdeci">subroutine ml_stack2(OP)</div><div class="ttdef"><b>Definition:</b> mmm.f90:7943</div></div>
<div class="ttc" id="atest1_8txt_html_a069b65bbd09d82ae86a692ef1d3ee529"><div class="ttname"><a href="test1_8txt.html#a069b65bbd09d82ae86a692ef1d3ee529">eig</a></div><div class="ttdeci">C the first eigenvalue has the largest sensitivity We now proceed to show that A is close to a matrix with a double eigenvalue The direction of the required perturbation is given by we bracket the point where two eigenvalues of a perturbed A coalesce and then become complex eig(A+.4 *E)</div></div>
<div class="ttc" id="atest1_8txt_html_a83355996f09f56a051f33844a294e5f1"><div class="ttname"><a href="test1_8txt.html#a83355996f09f56a051f33844a294e5f1">Physics</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied Physics</div><div class="ttdef"><b>Definition:</b> test1.txt:2119</div></div>
<div class="ttc" id="ammm_8f90_html_a7df88b2785a6d26e0964f5f9d9ef2fcd"><div class="ttname"><a href="mmm_8f90.html#a7df88b2785a6d26e0964f5f9d9ef2fcd">ml_wgedi</a></div><div class="ttdeci">subroutine ml_wgedi(AR, AI, LDA, N, IPVT, DETR, DETI, WORKR, WORKI, JOB)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9082</div></div>
<div class="ttc" id="amold_8f90_html_ac6ea312c6ffca4158b9d75be9941ad44"><div class="ttname"><a href="mold_8f90.html#ac6ea312c6ffca4158b9d75be9941ad44">wswap</a></div><div class="ttdeci">subroutine wswap(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7578</div></div>
<div class="ttc" id="amold_8f90_html_adfb205ac7e901e6bed95673a788b28ae"><div class="ttname"><a href="mold_8f90.html#adfb205ac7e901e6bed95673a788b28ae">wqrsl</a></div><div class="ttdeci">subroutine wqrsl(XR, XI, LDX, N, K, QRAUXR, QRAUXI, YR, YI, QYR, QYI, QTYR, QTYI, BR, BI, RSDR, RSDI, XBR, XBI, JOB, INFO)</div><div class="ttdef"><b>Definition:</b> mold.f90:6776</div></div>
<div class="ttc" id="aGPF_8txt_html_ab7d04b0f5f4ce2b442d411f74dac2e19"><div class="ttname"><a href="GPF_8txt.html#ab7d04b0f5f4ce2b442d411f74dac2e19">location</a></div><div class="ttdeci">returns its location(LICENSE:PD) 1081 makpat(3m_match) -[M_MATCH] make pattern from arg(from)</div></div>
<div class="ttc" id="atest1_8txt_html_a2a4f9be161b0cefe12f78a77d2523e9f"><div class="ttname"><a href="test1_8txt.html#a2a4f9be161b0cefe12f78a77d2523e9f">Algebra</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Algebra</div><div class="ttdef"><b>Definition:</b> test1.txt:2111</div></div>
<div class="ttc" id="anamespacem__matrix_html_abd05ea033cfab3a182ca6632f38dfb62"><div class="ttname"><a href="namespacem__matrix.html#abd05ea033cfab3a182ca6632f38dfb62">m_matrix::ptz</a></div><div class="ttdeci">integer ptz</div><div class="ttdef"><b>Definition:</b> mmm.f90:84</div></div>
<div class="ttc" id="anamespacem__matrix_html_a8e987cc1ce819a82fa179f8da90117eb"><div class="ttname"><a href="namespacem__matrix.html#a8e987cc1ce819a82fa179f8da90117eb">m_matrix::buf</a></div><div class="ttdeci">integer, dimension(1024) buf</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="atest1_8txt_html_a8e121f5ce8b3ea2ed7111d397c2e3ba1"><div class="ttname"><a href="test1_8txt.html#a8e121f5ce8b3ea2ed7111d397c2e3ba1">prompts</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and prompts</div><div class="ttdef"><b>Definition:</b> test1.txt:2859</div></div>
<div class="ttc" id="atest1_8txt_html_aee357ecbd07a3326ddc392b2ccc10f07"><div class="ttname"><a href="test1_8txt.html#aee357ecbd07a3326ddc392b2ccc10f07">EXPRESSION</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the EXPRESSION</div><div class="ttdef"><b>Definition:</b> test1.txt:1251</div></div>
<div class="ttc" id="amold_8f90_html_a372f240b74e10461d81e59fc27b5ea2a"><div class="ttname"><a href="mold_8f90.html#a372f240b74e10461d81e59fc27b5ea2a">rat</a></div><div class="ttdeci">subroutine rat(X, LEN, MAXD, A, B, D)</div><div class="ttdef"><b>Definition:</b> mold.f90:3501</div></div>
<div class="ttc" id="atest1_8txt_html_a40eab2bd454e9f761f2d13dffa13fb19"><div class="ttname"><a href="test1_8txt.html#a40eab2bd454e9f761f2d13dffa13fb19">by</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions by</div><div class="ttdef"><b>Definition:</b> test1.txt:1536</div></div>
<div class="ttc" id="atest1_8txt_html_ab08a39236f6e02e56cce7d36c5d35c13"><div class="ttname"><a href="test1_8txt.html#ab08a39236f6e02e56cce7d36c5d35c13">Garbow</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Garbow</div><div class="ttdef"><b>Definition:</b> test1.txt:2097</div></div>
<div class="ttc" id="atest1_8txt_html_a35025cf4860faecf5c8a7a24cfa62aed"><div class="ttname"><a href="test1_8txt.html#a35025cf4860faecf5c8a7a24cfa62aed">Mathematics</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied Mathematics</div><div class="ttdef"><b>Definition:</b> test1.txt:2095</div></div>
<div class="ttc" id="atest1_8txt_html_ae0323a9039add2978bf5b49550572c7c"><div class="ttname"><a href="test1_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a></div><div class="ttdeci">x short c</div><div class="ttdef"><b>Definition:</b> test1.txt:211</div></div>
<div class="ttc" id="anamespacem__matrix_html_af774805ad7ba7c918f50b97d54bb56eb"><div class="ttname"><a href="namespacem__matrix.html#af774805ad7ba7c918f50b97d54bb56eb">m_matrix::mat_flop</a></div><div class="ttdeci">doubleprecision function mat_flop(x)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1798</div></div>
<div class="ttc" id="anamespacem__matrix_html_a0a78a34f88cc83c1775339a929642b8a"><div class="ttname"><a href="namespacem__matrix.html#a0a78a34f88cc83c1775339a929642b8a">m_matrix::mat_eqid</a></div><div class="ttdeci">logical function mat_eqid(x, y)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1841</div></div>
<div class="ttc" id="atest1_8txt_html_a732e5473fee9bf5afa842843990cab00"><div class="ttname"><a href="test1_8txt.html#a732e5473fee9bf5afa842843990cab00">S</a></div><div class="ttdeci">S+X(I) *Y(I) or Y(I)=Y(I)+T *X(I) In other words, it consists of one floating point multiplication, together with one floating point addition and the associated indexing and storage reference operations. MAT88 will print the number of flops required for a particular statement when the statement is terminated by an extra comma. For example, the line n=20 S</div><div class="ttdef"><b>Definition:</b> test1.txt:1759</div></div>
<div class="ttc" id="amold_8f90_html_aeed89bed19dc9211a2f727e9985d455b"><div class="ttname"><a href="mold_8f90.html#aeed89bed19dc9211a2f727e9985d455b">print</a></div><div class="ttdeci">subroutine print(ID, K)</div><div class="ttdef"><b>Definition:</b> mold.f90:3303</div></div>
<div class="ttc" id="atest1_8txt_html_a8cd8674b5311ce7ac9a155c6da3c6cec"><div class="ttname"><a href="test1_8txt.html#a8cd8674b5311ce7ac9a155c6da3c6cec">diag</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of which are the are so far from being orthonormal is our first indication that the eigenvalues are sensitive To see this we display more figures of the computed eigenvalues diag(D) ANS</div></div>
<div class="ttc" id="anamespacem__matrix_html_ad55325f7cf84b899398367e9917dcb1e"><div class="ttname"><a href="namespacem__matrix.html#ad55325f7cf84b899398367e9917dcb1e">m_matrix::mat_wdiv</a></div><div class="ttdeci">subroutine mat_wdiv(ar, ai, br, bi, cr, ci)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1198</div></div>
<div class="ttc" id="atest1_8txt_html_ae437ff9d995d7a49216cdf8294a3e0a7"><div class="ttname"><a href="test1_8txt.html#ae437ff9d995d7a49216cdf8294a3e0a7">Extension</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Extension</div><div class="ttdef"><b>Definition:</b> test1.txt:2103</div></div>
<div class="ttc" id="amold_8f90_html_a3ede1f30e05e92d965dfa893ec52d05c"><div class="ttname"><a href="mold_8f90.html#a3ede1f30e05e92d965dfa893ec52d05c">wcopy</a></div><div class="ttdeci">subroutine wcopy(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7547</div></div>
<div class="ttc" id="ammm_8f90_html_a0d0f0891593c3f83ead1ba37d95d9135"><div class="ttname"><a href="mmm_8f90.html#a0d0f0891593c3f83ead1ba37d95d9135">ml_stackp</a></div><div class="ttdeci">subroutine ml_stackp(ID)</div><div class="ttdef"><b>Definition:</b> mmm.f90:8339</div></div>
<div class="ttc" id="ammm_8f90_html_ad03f3c06b033412fda1d185bae49dcb2"><div class="ttname"><a href="mmm_8f90.html#ad03f3c06b033412fda1d185bae49dcb2">ml_savlod</a></div><div class="ttdeci">subroutine ml_savlod(LSAVE, ID, M, N, IMG, JOB, XREAL, XIMAG)</div><div class="ttdef"><b>Definition:</b> mmm.f90:7841</div></div>
<div class="ttc" id="atest1_8txt_html_ad1662dc9ea62f1ee5b678d64fc1a0978"><div class="ttname"><a href="test1_8txt.html#ad1662dc9ea62f1ee5b678d64fc1a0978">THAN</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THAN</div><div class="ttdef"><b>Definition:</b> test1.txt:2024</div></div>
<div class="ttc" id="atest1_8txt_html_ab4a3112c11f40636a76f2bcc29d7cd3f"><div class="ttname"><a href="test1_8txt.html#ab4a3112c11f40636a76f2bcc29d7cd3f">matrices</a></div><div class="ttdeci">or as the last statement on the line HELP FLPS gives more details flps More detail on FLOPS It is not feasible to count absolutely all floating point but most of the important ones are counted Each multiply and add in a real vector operation such as a dot product or a saxpy counts one flop Each multiply and add in a complex vector operation counts two flops Other subtractions and multiplications count one flop each if the result is real and two flops if it is not Real divisions count one and complex divisions count two Elementary functions count one if real and two if complex Some examples If A and B are real N by N matrices</div><div class="ttdef"><b>Definition:</b> test1.txt:3009</div></div>
<div class="ttc" id="atest1_8txt_html_acba771aabe3d94d33404f0944d1ef540"><div class="ttname"><a href="test1_8txt.html#acba771aabe3d94d33404f0944d1ef540">Science</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer Science</div><div class="ttdef"><b>Definition:</b> test1.txt:2099</div></div>
<div class="ttc" id="ammm_8f90_html_ace4b9c618bf9ede79dc1b335ad2a713a"><div class="ttname"><a href="mmm_8f90.html#ace4b9c618bf9ede79dc1b335ad2a713a">ml_comqr3</a></div><div class="ttdeci">subroutine ml_comqr3(nm, n, low, igh, ortr, orti, hr, hi, wr, wi, zr, zi, ierr, job)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9817</div></div>
<div class="ttc" id="atest1_8txt_html_ada0caa322adce49c0ec353ed4e6621e1"><div class="ttname"><a href="test1_8txt.html#ada0caa322adce49c0ec353ed4e6621e1">frequently</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More frequently</div><div class="ttdef"><b>Definition:</b> test1.txt:489</div></div>
<div class="ttc" id="atest1_8txt_html_a20643379f048e8b7e7849a7cf575ac89"><div class="ttname"><a href="test1_8txt.html#a20643379f048e8b7e7849a7cf575ac89">SHORT</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT</div><div class="ttdef"><b>Definition:</b> test1.txt:465</div></div>
<div class="ttc" id="anamespacem__matrix_html_acdb0d6b9b1d3c9644e021c7b95591156"><div class="ttname"><a href="namespacem__matrix.html#acdb0d6b9b1d3c9644e021c7b95591156">m_matrix::mat_matfn6</a></div><div class="ttdeci">subroutine mat_matfn6()</div><div class="ttdef"><b>Definition:</b> mmm.f90:685</div></div>
<div class="ttc" id="anamespacem__matrix_html_aac92d55bfdde32ff9945dd4976d6a123"><div class="ttname"><a href="namespacem__matrix.html#aac92d55bfdde32ff9945dd4976d6a123">m_matrix::mat_putid</a></div><div class="ttdeci">subroutine mat_putid(x, y)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1057</div></div>
<div class="ttc" id="atest1_8txt_html_a2abbe4edf4ac16c700da1b1fddfb16ad"><div class="ttname"><a href="test1_8txt.html#a2abbe4edf4ac16c700da1b1fddfb16ad">computer</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of which are the are so far from being orthonormal is our first indication that the eigenvalues are sensitive To see this we display more figures of the computed eigenvalues on this computer</div><div class="ttdef"><b>Definition:</b> test1.txt:1090</div></div>
<div class="ttc" id="anamespacem__matrix_html_af5cad12a9536ed7357d849cc6c7016be"><div class="ttname"><a href="namespacem__matrix.html#af5cad12a9536ed7357d849cc6c7016be">m_matrix::nstk</a></div><div class="ttdeci">integer, dimension(48) nstk</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="amold_8f90_html_ac6de085b6f6d5032e54fd84dba99c574"><div class="ttname"><a href="mold_8f90.html#ac6de085b6f6d5032e54fd84dba99c574">wdiv</a></div><div class="ttdeci">subroutine wdiv(AR, AI, BR, BI, CR, CI)</div><div class="ttdef"><b>Definition:</b> mold.f90:7301</div></div>
<div class="ttc" id="atest1_8txt_html_a2b0908574c71adccd2d88688117d1c04"><div class="ttname"><a href="test1_8txt.html#a2b0908574c71adccd2d88688117d1c04">a</a></div><div class="ttdeci">a</div><div class="ttdef"><b>Definition:</b> test1.txt:5</div></div>
<div class="ttc" id="anamespacem__matrix_html_ae108c650e068ad3d013dff2cd9c23b7c"><div class="ttname"><a href="namespacem__matrix.html#ae108c650e068ad3d013dff2cd9c23b7c">m_matrix::ml_formz</a></div><div class="ttdeci">subroutine ml_formz(lunit, x, y)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1682</div></div>
<div class="ttc" id="atest1_8txt_html_a8e3694f0ad1f8275a630e1fb056e1e4e"><div class="ttname"><a href="test1_8txt.html#a8e3694f0ad1f8275a630e1fb056e1e4e">Laboratory</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific Laboratory</div><div class="ttdef"><b>Definition:</b> test1.txt:2088</div></div>
<div class="ttc" id="ammm_8f90_html_a4e5e76a9889c497d7ddd0f1a1a2e18cc"><div class="ttname"><a href="mmm_8f90.html#a4e5e76a9889c497d7ddd0f1a1a2e18cc">ml_wnrm2</a></div><div class="ttdeci">doubleprecision function ml_wnrm2(N, XR, XI, INCX)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11657</div></div>
<div class="ttc" id="anamespacem__matrix_html_acd528a97c4714dd082145f67e0fa0fbc"><div class="ttname"><a href="namespacem__matrix.html#acd528a97c4714dd082145f67e0fa0fbc">m_matrix::flp</a></div><div class="ttdeci">integer, dimension(2) flp</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="amold_8f90_html_a78a478bbf1d448da261b5a7e14653361"><div class="ttname"><a href="mold_8f90.html#a78a478bbf1d448da261b5a7e14653361">wgedi</a></div><div class="ttdeci">subroutine wgedi(AR, AI, LDA, N, IPVT, DETR, DETI, WORKR, WORKI, JOB)</div><div class="ttdef"><b>Definition:</b> mold.f90:4772</div></div>
<div class="ttc" id="atest1_8txt_html_a38e6d74dbec5d98dd45386bba314f0b6"><div class="ttname"><a href="test1_8txt.html#a38e6d74dbec5d98dd45386bba314f0b6">terminal</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the terminal</div><div class="ttdef"><b>Definition:</b> test1.txt:2821</div></div>
<div class="ttc" id="atest1_8txt_html_a49b681fbfb2eed36f24b739332104881"><div class="ttname"><a href="test1_8txt.html#a49b681fbfb2eed36f24b739332104881">subroutines</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square HTRIBK if A is Hermitian COMQR2 if A is not Hermitian this was not an extensive change It also facilitated implementation of the FLOP and CHOP features which count and optionally truncate each floating point operation The EISPACK subroutine COMQR2 was modified to allow access to the Schur triangular ordinarily just an intermediate result IMTQL2 was modified to make computation of the eigenvectors optional Both subroutines were modified to eliminate the machine dependent accuracy parameter and all the EISPACK subroutines were changed to include FLOP and CHOP The algorithms employed for the POLY and ROOTS functions illustrate an interesting aspect of the modern approach to eigenvalue computation which of the eigenvalues of A But both POLY and ROOTS use EISPACK eigenvalues subroutines</div><div class="ttdef"><b>Definition:</b> test1.txt:1605</div></div>
<div class="ttc" id="atest1_8txt_html_a0cadd9872f757284113de2075eebf2f1"><div class="ttname"><a href="test1_8txt.html#a0cadd9872f757284113de2075eebf2f1">plan</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to plan</div><div class="ttdef"><b>Definition:</b> test1.txt:1993</div></div>
<div class="ttc" id="ammm_8f90_html_a1eda1c5de1a5be8afafc9832df907961"><div class="ttname"><a href="mmm_8f90.html#a1eda1c5de1a5be8afafc9832df907961">ml_watan</a></div><div class="ttdeci">subroutine ml_watan(xr, xi, yr, yi)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11463</div></div>
<div class="ttc" id="atest1_8txt_html_a0a890a7b5e140ce2ce94502357b159cf"><div class="ttname"><a href="test1_8txt.html#a0a890a7b5e140ce2ce94502357b159cf">Fortran</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple except that MAT88 is programmed in Fortran</div><div class="ttdef"><b>Definition:</b> test1.txt:1421</div></div>
<div class="ttc" id="atest1_8txt_html_a8f5ce5a28ca8ea470507802ff2d0214f"><div class="ttname"><a href="test1_8txt.html#a8f5ce5a28ca8ea470507802ff2d0214f">report</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean University of New Computer Science technical report</div><div class="ttdef"><b>Definition:</b> test1.txt:2130</div></div>
<div class="ttc" id="atest1_8txt_html_a7ee4abe2dceee16ed21aa30d16352713"><div class="ttname"><a href="test1_8txt.html#a7ee4abe2dceee16ed21aa30d16352713">statements</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following statements</div><div class="ttdef"><b>Definition:</b> test1.txt:1991</div></div>
<div class="ttc" id="atest1_8txt_html_a81a6880416ed81de652fd0cd1992ab06"><div class="ttname"><a href="test1_8txt.html#a81a6880416ed81de652fd0cd1992ab06">K</a></div><div class="ttdeci">A T N DO N K</div><div class="ttdef"><b>Definition:</b> test1.txt:1928</div></div>
<div class="ttc" id="atest1_8txt_html_abbac44297f1e0d20465021e196fda3a2"><div class="ttname"><a href="test1_8txt.html#abbac44297f1e0d20465021e196fda3a2">product</a></div><div class="ttdeci">C This recursion is easily derived by expanding the product(z - z(1)) *(z - z(2)) *... *(z-z(n)) . It is possible to prove that POLY(A) produces the coefficients in the characteristic polynomial of a matrix within roundoff error of A. This is true even if the eigenvalues of A are badly conditioned. The traditional algorithms for obtaining the characteristic polynomial which do not use the eigenvalues do not have such satisfactory numerical properties. If C is a vector with n+1 components</div></div>
<div class="ttc" id="amold_8f90_html_ad1042b1ab8e4ff7b1da7bc24f4880ea1"><div class="ttname"><a href="mold_8f90.html#ad1042b1ab8e4ff7b1da7bc24f4880ea1">wdotui</a></div><div class="ttdeci">double precision function wdotui(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7491</div></div>
<div class="ttc" id="anamespacem__matrix_html_adbd4dbfd80d9650cb9061700c82a9243"><div class="ttname"><a href="namespacem__matrix.html#adbd4dbfd80d9650cb9061700c82a9243">m_matrix::ran</a></div><div class="ttdeci">integer, dimension(2) ran</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="atest1_8txt_html_a44041718ce9e6aacd16c76a9ce3d8832"><div class="ttname"><a href="test1_8txt.html#a44041718ce9e6aacd16c76a9ce3d8832">variables</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all variables</div><div class="ttdef"><b>Definition:</b> test1.txt:472</div></div>
<div class="ttc" id="atest1_8txt_html_aa2f0c2424656e37c8769bdf9482d0af5"><div class="ttname"><a href="test1_8txt.html#aa2f0c2424656e37c8769bdf9482d0af5">EIG</a></div><div class="ttdeci">is a by matrix The semicolon ends the first row Vectors and matrices can be used inside&lt; &gt; brackets&lt; A B;C &gt; is allowed if the number of rows of A equals the number of rows of B and the number of columns of A plus the number of columns of B equals the number of columns of C This rule generalizes in a hopefully obvious way to allow fairly complicated constructions thereby removing it from the list of current variables For the use of&lt; and &gt; on the left of see EIG</div><div class="ttdef"><b>Definition:</b> test1.txt:2224</div></div>
<div class="ttc" id="amold_8f90_html_a9449ad9804e63ca22a997f20f30c39a8"><div class="ttname"><a href="mold_8f90.html#a9449ad9804e63ca22a997f20f30c39a8">matfn1</a></div><div class="ttdeci">subroutine matfn1</div><div class="ttdef"><b>Definition:</b> mold.f90:1324</div></div>
<div class="ttc" id="atest1_8txt_html_ac52c248b1fa324464828f5882fdbac9d"><div class="ttname"><a href="test1_8txt.html#ac52c248b1fa324464828f5882fdbac9d">form</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square HTRIBK if A is Hermitian COMQR2 if A is not Hermitian this was not an extensive change It also facilitated implementation of the FLOP and CHOP features which count and optionally truncate each floating point operation The EISPACK subroutine COMQR2 was modified to allow access to the Schur triangular form</div><div class="ttdef"><b>Definition:</b> test1.txt:1594</div></div>
<div class="ttc" id="ammm_8f90_html_a46e12019664b02eb781edb696193d83e"><div class="ttname"><a href="mmm_8f90.html#a46e12019664b02eb781edb696193d83e">ml_htribk</a></div><div class="ttdeci">subroutine ml_htribk(NM, N, AR, AI, TAU, M, ZR, ZI)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9415</div></div>
<div class="ttc" id="amold_8f90_html_afd887c53285535b170bf9e688227c485"><div class="ttname"><a href="mold_8f90.html#afd887c53285535b170bf9e688227c485">wdotur</a></div><div class="ttdeci">double precision function wdotur(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7473</div></div>
<div class="ttc" id="ammm_8f90_html_a54e98b1c562e809460ad22b8a361accb"><div class="ttname"><a href="mmm_8f90.html#a54e98b1c562e809460ad22b8a361accb">ml_xchar</a></div><div class="ttdeci">subroutine ml_xchar(BUF, K)</div><div class="ttdef"><b>Definition:</b> mmm.f90:6376</div></div>
<div class="ttc" id="atest1_8txt_html_aec13d5a39c6fdcec828d2d910ee17ec6"><div class="ttname"><a href="test1_8txt.html#aec13d5a39c6fdcec828d2d910ee17ec6">ORTH</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL ORTH(A) - CQRDC</div></div>
<div class="ttc" id="atest1_8txt_html_a64d67d86a913aaff4ec9179ac843e747"><div class="ttname"><a href="test1_8txt.html#a64d67d86a913aaff4ec9179ac843e747">Bunch</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R Bunch</div><div class="ttdef"><b>Definition:</b> test1.txt:2093</div></div>
<div class="ttc" id="atest1_8txt_html_abdd170aac281dd6883c27d5cf5aa05e9"><div class="ttname"><a href="test1_8txt.html#abdd170aac281dd6883c27d5cf5aa05e9">Moler</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Moler</div><div class="ttdef"><b>Definition:</b> test1.txt:2098</div></div>
<div class="ttc" id="ammm_8f90_html_a3b70ce86b06f12449457c9f0b9b22d74"><div class="ttname"><a href="mmm_8f90.html#a3b70ce86b06f12449457c9f0b9b22d74">ml_factor</a></div><div class="ttdeci">subroutine ml_factor()</div><div class="ttdef"><b>Definition:</b> mmm.f90:6001</div></div>
<div class="ttc" id="atest1_8txt_html_a2056b74828e598cfffe009254c073eab"><div class="ttname"><a href="test1_8txt.html#a2056b74828e598cfffe009254c073eab">CLAUSE</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the CLAUSE</div><div class="ttdef"><b>Definition:</b> test1.txt:1251</div></div>
<div class="ttc" id="ammm_8f90_html_a19acaf121966efac67816ec89985d702"><div class="ttname"><a href="mmm_8f90.html#a19acaf121966efac67816ec89985d702">ml_matfn5</a></div><div class="ttdeci">subroutine ml_matfn5()</div><div class="ttdef"><b>Definition:</b> mmm.f90:7484</div></div>
<div class="ttc" id="atest1_8txt_html_a9f04eb7371e84208802ab0f994fc4c26"><div class="ttname"><a href="test1_8txt.html#a9f04eb7371e84208802ab0f994fc4c26">expr</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for&lt; h, cos(pi *h)&gt; prints a table of cosines&lt; X, D &gt; for A *v displays one at a time The WHILE clause allows statements to be repeated an indefinite number of times The general form is WHILE expr relop expr</div><div class="ttdef"><b>Definition:</b> test1.txt:424</div></div>
<div class="ttc" id="atest1_8txt_html_aa32fc5e36a19ef8decdfdc1caf8e6f75"><div class="ttname"><a href="test1_8txt.html#aa32fc5e36a19ef8decdfdc1caf8e6f75">r</a></div><div class="ttdeci">C the first eigenvalue has the largest sensitivity We now proceed to show that A is close to a matrix with a double eigenvalue The direction of the required perturbation is given by we bracket the point where two eigenvalues of a perturbed A coalesce and then become complex a bisecting driven by the imaginary part of one of the finds the point where two eigenvalues are nearly equal r</div><div class="ttdef"><b>Definition:</b> test1.txt:1195</div></div>
<div class="ttc" id="ammm_8f90_html_a9666a6c4dc67601ddea8ac6e7c6fcfca"><div class="ttname"><a href="mmm_8f90.html#a9666a6c4dc67601ddea8ac6e7c6fcfca">ml_rrotg</a></div><div class="ttdeci">subroutine ml_rrotg(DA, DB, C, S)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11544</div></div>
<div class="ttc" id="atest1_8txt_html_a794701c711ad26f76bbc7ec4a8b299de"><div class="ttname"><a href="test1_8txt.html#a794701c711ad26f76bbc7ec4a8b299de">FORMAT</a></div><div class="ttdeci">Then the MAT88 statements N DO N N FORMAT('A ', 2I4) DO J</div></div>
<div class="ttc" id="amold_8f90_html_a93a01732286c6817ca1a41aaa6c61409"><div class="ttname"><a href="mold_8f90.html#a93a01732286c6817ca1a41aaa6c61409">matlab</a></div><div class="ttdeci">subroutine matlab(INIT)</div><div class="ttdef"><b>Definition:</b> mold.f90:2828</div></div>
<div class="ttc" id="anamespacem__matrix_html_ac1866e27ea39d770da394b0a13659658"><div class="ttname"><a href="namespacem__matrix.html#ac1866e27ea39d770da394b0a13659658">m_matrix::psize</a></div><div class="ttdeci">integer psize</div><div class="ttdef"><b>Definition:</b> mmm.f90:84</div></div>
<div class="ttc" id="atest1_8txt_html_a6c8a49d5d30f0f5f9583a3417de3a97e"><div class="ttname"><a href="test1_8txt.html#a6c8a49d5d30f0f5f9583a3417de3a97e">fact</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal evaluated at the i th boundary point A right hand side with m components is also generated In this the elements of the right hand side are either zero or one The coefficients are then found by solving the overdetermined set of equations the approximate solution is defined everywhere on the domain It is then possible to compute the effective conductivity sigma In fact</div><div class="ttdef"><b>Definition:</b> test1.txt:889</div></div>
<div class="ttc" id="anamespacem__matrix_html_ac15765848439f57280785c0f3f9ee844"><div class="ttname"><a href="namespacem__matrix.html#ac15765848439f57280785c0f3f9ee844">m_matrix::alflq</a></div><div class="ttdeci">integer alflq</div><div class="ttdef"><b>Definition:</b> mmm.f90:83</div></div>
<div class="ttc" id="atest1_8txt_html_a9c06e556fce3af9a2c29c2eb836a6c30"><div class="ttname"><a href="test1_8txt.html#a9c06e556fce3af9a2c29c2eb836a6c30">plot</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be prompts and pauses This is useful for demonstrations on video terminals If there will be echos and but no pauses This is the the default if the exec command is not followed by a semicolon i e the text in the file may contain EXEC of another file EXEC s may also be driven by FOR and WHILE loops load change the READs to WRITEs in the code given under SAVE print LONG etc See FILE doc X saves only X See FILE The variables may be retrieved later by then REAL or DOUBLEPRECISION NMAX IMG DO N M M enddo The formats used are system dependent The following are typical See SUBROUTINE ML_SAVLOD in your implementation of MAT88 the user is asked whether or not to suppress printing until the next input Initially the limit is often hexadecimal short See LONG diary DIARY( 'file') causes a copy of all subsequent terminal input and most of the resulting output to be written on the file. DIARY(0) turns it off. See FILE. disp DISPLAY(X) prints X in a compact format. If a base is specified the values are printed as numeric values in the specified base. disp(0 plot(t.*cos(t), t.*sin(t)) opts</div></div>
<div class="ttc" id="atest1_8txt_html_ac9b787ad27f1717580f52f313235594d"><div class="ttname"><a href="test1_8txt.html#ac9b787ad27f1717580f52f313235594d">command</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple except that MAT88 is programmed in which does not have recursion The interrelation of the primary subroutines is shown in the following diagram MAIN MAT88 CLAUSE PARSE EXPR TERM FACTOR STACK1 STACK2 STACKG STACKP PRINT COMAND CGECO CGEFA MATFN1 CGESL CGEDI CPOFA IMTQL2 HTRIDI MATFN2 HTRIBK CORTH COMQR3 MATFN3 CSVDC CQRDC MATFN4 CQRSL FILES MATFN5 SAVLOD Subroutine PARSE controls the interpretation of each statement It calls subroutines that process the various syntactic quantities such as command</div><div class="ttdef"><b>Definition:</b> test1.txt:1476</div></div>
<div class="ttc" id="ammm_8f90_html_a3c5283e0543eeb71ca60d8cfd4a919a2"><div class="ttname"><a href="mmm_8f90.html#a3c5283e0543eeb71ca60d8cfd4a919a2">ml_corth</a></div><div class="ttdeci">subroutine ml_corth(NM, N, LOW, IGH, AR, AI, ORTR, ORTI)</div><div class="ttdef"><b>Definition:</b> mmm.f90:9680</div></div>
<div class="ttc" id="atest1_8txt_html_aa01141da9a3967665463aca35fdae176"><div class="ttname"><a href="test1_8txt.html#aa01141da9a3967665463aca35fdae176">bottom</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the bottom</div><div class="ttdef"><b>Definition:</b> test1.txt:1545</div></div>
<div class="ttc" id="ammm_8f90_html_a12b6e51dd14f7ec3d00d146f832e7224"><div class="ttname"><a href="mmm_8f90.html#a12b6e51dd14f7ec3d00d146f832e7224">ml_wdotui</a></div><div class="ttdeci">doubleprecision function ml_wdotui(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11692</div></div>
<div class="ttc" id="amold_8f90_html_a25a4a1bea5502a92a3936e84f576fc01"><div class="ttname"><a href="mold_8f90.html#a25a4a1bea5502a92a3936e84f576fc01">funs</a></div><div class="ttdeci">subroutine funs(ID)</div><div class="ttdef"><b>Definition:</b> mold.f90:1057</div></div>
<div class="ttc" id="atest1_8txt_html_a251c1da2ff52dc297ac959a76bc53bba"><div class="ttname"><a href="test1_8txt.html#a251c1da2ff52dc297ac959a76bc53bba">NORM</a></div><div class="ttdeci">while NORM(E+F-E, 1) &gt; 0</div></div>
<div class="ttc" id="ammm_8f90_html_a1d7904441060ebc3f8422c24d81ef393"><div class="ttname"><a href="mmm_8f90.html#a1d7904441060ebc3f8422c24d81ef393">ml_wsign</a></div><div class="ttdeci">subroutine ml_wsign(xr, xi, yr, yi, zr, zi)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11450</div></div>
<div class="ttc" id="atest1_8txt_html_ab3cd915d758008bd19d0f2428fbb354a"><div class="ttname"><a href="test1_8txt.html#ab3cd915d758008bd19d0f2428fbb354a">m</a></div><div class="ttdeci">m</div><div class="ttdef"><b>Definition:</b> test1.txt:946</div></div>
<div class="ttc" id="anamespacem__matrix_html_abb76cf81ccf2f029765bfa278d2c343b"><div class="ttname"><a href="namespacem__matrix.html#abb76cf81ccf2f029765bfa278d2c343b">m_matrix::mat_make_help</a></div><div class="ttdeci">subroutine mat_make_help(io)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1890</div></div>
<div class="ttc" id="amold_8f90_html_a4e90b0a8043dc9d3d8ad47304cfdf34f"><div class="ttname"><a href="mold_8f90.html#a4e90b0a8043dc9d3d8ad47304cfdf34f">stack2</a></div><div class="ttdeci">subroutine stack2(OP)</div><div class="ttdef"><b>Definition:</b> mold.f90:3633</div></div>
<div class="ttc" id="atest1_8txt_html_a4ee8ada2d434ec40e53a218a580f955d"><div class="ttname"><a href="test1_8txt.html#a4ee8ada2d434ec40e53a218a580f955d">ID</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION ID</div><div class="ttdef"><b>Definition:</b> test1.txt:2001</div></div>
<div class="ttc" id="anamespacem__matrix_html_a335fb5343e6fb0f97e7ce05670539e01"><div class="ttname"><a href="namespacem__matrix.html#a335fb5343e6fb0f97e7ce05670539e01">m_matrix::pstk</a></div><div class="ttdeci">integer, dimension(32) pstk</div><div class="ttdef"><b>Definition:</b> mmm.f90:84</div></div>
<div class="ttc" id="atest1_8txt_html_adad056c2bb85ae600a648f168a00c7cf"><div class="ttname"><a href="test1_8txt.html#adad056c2bb85ae600a648f168a00c7cf">Klema</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C Klema</div><div class="ttdef"><b>Definition:</b> test1.txt:2098</div></div>
<div class="ttc" id="atest1_8txt_html_a98c7ccada846190eeea79403addb09be"><div class="ttname"><a href="test1_8txt.html#a98c7ccada846190eeea79403addb09be">Y</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of which are the are so far from being orthonormal is our first indication that the eigenvalues are sensitive To see this we display more figures of the computed eigenvalues on this the last five significant figures are contaminated by roundoff error A somewhat superficial explanation of this is provided by this condition number is affected by scaling it is now apparent that the three eigenvectors are nearly parallel More detailed information on the sensitivity of the individual eigenvalues involves the left eigenvectors Y</div><div class="ttdef"><b>Definition:</b> test1.txt:1127</div></div>
<div class="ttc" id="atest1_8txt_html_a0c54dd1075148c39364d8fae09980027"><div class="ttname"><a href="test1_8txt.html#a0c54dd1075148c39364d8fae09980027">CHAR</a></div><div class="ttdeci">or as the last statement on the line HELP FLPS gives more details flps More detail on FLOPS It is not feasible to count absolutely all floating point but most of the important ones are counted Each multiply and add in a real vector operation such as a dot product or a saxpy counts one flop Each multiply and add in a complex vector operation counts two flops Other subtractions and multiplications count one flop each if the result is real and two flops if it is not Real divisions count one and complex divisions count two Elementary functions count one if real and two if complex Some examples If A and B are real N by N then A B counts N A *B counts N A **counts *N CHAR(45) replaces backslash. CHAR(-K) replaces the alternate character number K. By default the character set is</div><div class="ttdef"><b>Definition:</b> test1.txt:3020</div></div>
<div class="ttc" id="amold_8f90_html_a52810aacda059c78b95d16bf14cf77bf"><div class="ttname"><a href="mold_8f90.html#a52810aacda059c78b95d16bf14cf77bf">getlin</a></div><div class="ttdeci">subroutine getlin</div><div class="ttdef"><b>Definition:</b> mold.f90:1147</div></div>
<div class="ttc" id="atest1_8txt_html_a7e45abf6b2f55a8ecfcfacc622fc9e83"><div class="ttname"><a href="test1_8txt.html#a7e45abf6b2f55a8ecfcfacc622fc9e83">Loan</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Loan</div><div class="ttdef"><b>Definition:</b> test1.txt:2119</div></div>
<div class="ttc" id="atest1_8txt_html_a5eb0356c0e9c6a8b400f47161bcd3188"><div class="ttname"><a href="test1_8txt.html#a5eb0356c0e9c6a8b400f47161bcd3188">executed</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is executed</div><div class="ttdef"><b>Definition:</b> test1.txt:1986</div></div>
<div class="ttc" id="ammm_8f90_html_ad61b0fd6726bfa0cb4af7cfebac67049"><div class="ttname"><a href="mmm_8f90.html#ad61b0fd6726bfa0cb4af7cfebac67049">ml_2chars</a></div><div class="ttdeci">subroutine ml_2chars(DINTS, M, ICOUNT, IROW, STRING)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11754</div></div>
<div class="ttc" id="amold_8f90_html_aa93249471aeafd9cb9365b44a5144f80"><div class="ttname"><a href="mold_8f90.html#aa93249471aeafd9cb9365b44a5144f80">wpofa</a></div><div class="ttdeci">subroutine wpofa(AR, AI, LDA, N, INFO)</div><div class="ttdef"><b>Definition:</b> mold.f90:4922</div></div>
<div class="ttc" id="atest1_8txt_html_af5dbe12a379dc99358be93328d0ce5d3"><div class="ttname"><a href="test1_8txt.html#af5dbe12a379dc99358be93328d0ce5d3">Chicago</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing Chicago</div><div class="ttdef"><b>Definition:</b> test1.txt:2108</div></div>
<div class="ttc" id="atest1_8txt_html_a33490e7b05e6a070b48a4e54a62a784b"><div class="ttname"><a href="test1_8txt.html#a33490e7b05e6a070b48a4e54a62a784b">LU</a></div><div class="ttdeci">is a by matrix The semicolon ends the first row Vectors and matrices can be used inside&lt; &gt; brackets&lt; A B;C &gt; is allowed if the number of rows of A equals the number of rows of B and the number of columns of A plus the number of columns of B equals the number of columns of C This rule generalizes in a hopefully obvious way to allow fairly complicated constructions thereby removing it from the list of current variables For the use of&lt; and &gt; on the left of see LU</div><div class="ttdef"><b>Definition:</b> test1.txt:2224</div></div>
<div class="ttc" id="amold_8f90_html_ae4d47fd9e32f333a108634c006dc9e72"><div class="ttname"><a href="mold_8f90.html#ae4d47fd9e32f333a108634c006dc9e72">corth</a></div><div class="ttdeci">subroutine corth(NM, N, LOW, IGH, AR, AI, ORTR, ORTI)</div><div class="ttdef"><b>Definition:</b> mold.f90:5409</div></div>
<div class="ttc" id="ammm_8f90_html_ab36595f8e370b9dd2ea1b0a3205adc58"><div class="ttname"><a href="mmm_8f90.html#ab36595f8e370b9dd2ea1b0a3205adc58">bigmat</a></div><div class="ttdeci">program bigmat</div><div class="ttdef"><b>Definition:</b> mmm.f90:11787</div></div>
<div class="ttc" id="amold_8f90_html_ad79d31df31d07578686d28b596af5b14"><div class="ttname"><a href="mold_8f90.html#ad79d31df31d07578686d28b596af5b14">prompt</a></div><div class="ttdeci">subroutine prompt(PAUSE)</div><div class="ttdef"><b>Definition:</b> mold.f90:3460</div></div>
<div class="ttc" id="ammm_8f90_html_ae5fa08bedfac1fb603e2a47f0257a6c7"><div class="ttname"><a href="mmm_8f90.html#ae5fa08bedfac1fb603e2a47f0257a6c7">ml_wdotcr</a></div><div class="ttdeci">doubleprecision function ml_wdotcr(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11713</div></div>
<div class="ttc" id="anamespacem__matrix_html_a344577eeda3566680cce805365e8c7c0"><div class="ttname"><a href="namespacem__matrix.html#a344577eeda3566680cce805365e8c7c0">m_matrix::mat_hilber</a></div><div class="ttdeci">subroutine mat_hilber(a, lda, n)</div><div class="ttdef"><b>Definition:</b> mmm.f90:653</div></div>
<div class="ttc" id="ammm_8f90_html_ac8e781fa9c2a3c84070268197eeb5892"><div class="ttname"><a href="mmm_8f90.html#ac8e781fa9c2a3c84070268197eeb5892">ml_magic</a></div><div class="ttdeci">subroutine ml_magic(a, lda, n)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11355</div></div>
<div class="ttc" id="anamespacem__matrix_html_a349f6acb6860576f366637d558624a0c"><div class="ttname"><a href="namespacem__matrix.html#a349f6acb6860576f366637d558624a0c">m_matrix::vsize</a></div><div class="ttdeci">integer vsize</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="anamespacem__matrix_html_a9a88107f61c6effcd44027c713f46da3"><div class="ttname"><a href="namespacem__matrix.html#a9a88107f61c6effcd44027c713f46da3">m_matrix::mat_wswap</a></div><div class="ttdeci">subroutine mat_wswap(n, xr, xi, incx, yr, yi, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1317</div></div>
<div class="ttc" id="atest1_8txt_html_a6bcb3e27afc22552106ea23d58ae10ab"><div class="ttname"><a href="test1_8txt.html#a6bcb3e27afc22552106ea23d58ae10ab">equal</a></div><div class="ttdeci">is a by matrix The semicolon ends the first row Vectors and matrices can be used inside&lt; &gt; brackets&lt; A B;C &gt; is allowed if the number of rows of A equals the number of rows of B and the number of columns of A plus the number of columns of B equals the number of columns of C This rule generalizes in a hopefully obvious way to allow fairly complicated constructions thereby removing it from the list of current variables For the use of&lt; and &gt; on the left of see SVD and so on In WHILE and IF&lt;&gt; means less than or greater i e not equal</div><div class="ttdef"><b>Definition:</b> test1.txt:2227</div></div>
<div class="ttc" id="amold_8f90_html_a96f27f991d7b251ec8af04de5756357c"><div class="ttname"><a href="mold_8f90.html#a96f27f991d7b251ec8af04de5756357c">rswap</a></div><div class="ttdeci">subroutine rswap(N, X, INCX, Y, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7615</div></div>
<div class="ttc" id="atest1_8txt_html_afb358f48b1646c750fb9da6c6585be2b"><div class="ttname"><a href="test1_8txt.html#afb358f48b1646c750fb9da6c6585be2b">end</a></div><div class="ttdeci">end</div><div class="ttdef"><b>Definition:</b> test1.txt:408</div></div>
<div class="ttc" id="amold_8f90_html_a041758cb65364406f12139e1a3493461"><div class="ttname"><a href="mold_8f90.html#a041758cb65364406f12139e1a3493461">plot</a></div><div class="ttdeci">subroutine plot(LUNIT, X, Y, N, P, K)</div><div class="ttdef"><b>Definition:</b> mold.f90:3255</div></div>
<div class="ttc" id="atest1_8txt_html_a8cf2b044d733a109a156d7b7617b371b"><div class="ttname"><a href="test1_8txt.html#a8cf2b044d733a109a156d7b7617b371b">sums</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean sums</div><div class="ttdef"><b>Definition:</b> test1.txt:2129</div></div>
<div class="ttc" id="ammm_8f90_html_a7e5483a42eb9d8f1ff5eb3f00ba54a0a"><div class="ttname"><a href="mmm_8f90.html#a7e5483a42eb9d8f1ff5eb3f00ba54a0a">ml_rrot</a></div><div class="ttdeci">subroutine ml_rrot(N, DX, INCX, DY, INCY, C, S)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11521</div></div>
<div class="ttc" id="anamespacem__matrix_html_a34ad265b124a3461a7fc9beafac416ea"><div class="ttname"><a href="namespacem__matrix.html#a34ad265b124a3461a7fc9beafac416ea">m_matrix::mat_getval</a></div><div class="ttdeci">subroutine mat_getval(s)</div><div class="ttdef"><b>Definition:</b> mmm.f90:1071</div></div>
<div class="ttc" id="atest1_8txt_html_a2857bbd4b5d07a07f178c59b854d9c80"><div class="ttname"><a href="test1_8txt.html#a2857bbd4b5d07a07f178c59b854d9c80">the</a></div><div class="ttdeci">is a by matrix The semicolon ends the first row Vectors and matrices can be used inside&lt; &gt; brackets&lt; A B;C &gt; is allowed if the number of rows of A equals the number of rows of B and the number of columns of A plus the number of columns of B equals the number of columns of C This rule generalizes in a hopefully obvious way to allow fairly complicated constructions thereby removing it from the list of current variables For the use of&lt; and &gt; on the left of the</div><div class="ttdef"><b>Definition:</b> test1.txt:2223</div></div>
<div class="ttc" id="atest1_8txt_html_aa0b7cb0a04f82e3a2c0e877a33e0192f"><div class="ttname"><a href="test1_8txt.html#aa0b7cb0a04f82e3a2c0e877a33e0192f">j</a></div><div class="ttdeci">for j</div><div class="ttdef"><b>Definition:</b> test1.txt:52</div></div>
<div class="ttc" id="ammm_8f90_html_abae292ee41c57c87c562688ddad3479f"><div class="ttname"><a href="mmm_8f90.html#abae292ee41c57c87c562688ddad3479f">matx_waxpy</a></div><div class="ttdeci">subroutine matx_waxpy(n, sr, si, xr, xi, incx, yr, yi, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:5077</div></div>
<div class="ttc" id="atest1_8txt_html_a83ee87d9fb5380cdcff33e8b9ea44ccf"><div class="ttname"><a href="test1_8txt.html#a83ee87d9fb5380cdcff33e8b9ea44ccf">Computation</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic Computation</div><div class="ttdef"><b>Definition:</b> test1.txt:2111</div></div>
<div class="ttc" id="atest1_8txt_html_ac3184a4056593db0d92e28fe3684dc31"><div class="ttname"><a href="test1_8txt.html#ac3184a4056593db0d92e28fe3684dc31">results</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal evaluated at the i th boundary point A right hand side with m components is also generated In this the elements of the right hand side are either zero or one The coefficients are then found by solving the overdetermined set of equations the approximate solution is defined everywhere on the domain It is then possible to compute the effective conductivity sigma In a very simple formula results</div><div class="ttdef"><b>Definition:</b> test1.txt:890</div></div>
<div class="ttc" id="atest1_8txt_html_aecbe895893c5818a261aae64393479dc"><div class="ttname"><a href="test1_8txt.html#aecbe895893c5818a261aae64393479dc">Structures</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Structures</div><div class="ttdef"><b>Definition:</b> test1.txt:2114</div></div>
<div class="ttc" id="atest1_8txt_html_ad6ef64fb9b12015a107b9ed4c99aac5b"><div class="ttname"><a href="test1_8txt.html#ad6ef64fb9b12015a107b9ed4c99aac5b">it</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert it</div><div class="ttdef"><b>Definition:</b> test1.txt:1994</div></div>
<div class="ttc" id="atest1_8txt_html_a1aabac6d068eef6a7bad3fdf50a05cc8"><div class="ttname"><a href="test1_8txt.html#a1aabac6d068eef6a7bad3fdf50a05cc8">d</a></div><div class="ttdeci">d</div><div class="ttdef"><b>Definition:</b> test1.txt:1197</div></div>
<div class="ttc" id="atest1_8txt_html_a33bd2c689b67587221a6744e31e669e8"><div class="ttname"><a href="test1_8txt.html#a33bd2c689b67587221a6744e31e669e8">PINV</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC PINV(A, eps) - CSVDC RANK(A</div></div>
<div class="ttc" id="amold_8f90_html_ad04a22bf5e4e668f042a98604c7ba78c"><div class="ttname"><a href="mold_8f90.html#ad04a22bf5e4e668f042a98604c7ba78c">edit</a></div><div class="ttdeci">subroutine edit(BUF, N)</div><div class="ttdef"><b>Definition:</b> mold.f90:436</div></div>
<div class="ttc" id="atest1_8txt_html_a85881ef5260acd9683f1822c1df634b3"><div class="ttname"><a href="test1_8txt.html#a85881ef5260acd9683f1822c1df634b3">IMTQL2</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square IMTQL2</div><div class="ttdef"><b>Definition:</b> test1.txt:1578</div></div>
<div class="ttc" id="anamespacem__matrix_html_af7ce1a4faf3e347923370373e5de7029"><div class="ttname"><a href="namespacem__matrix.html#af7ce1a4faf3e347923370373e5de7029">m_matrix::lct</a></div><div class="ttdeci">integer, dimension(4) lct</div><div class="ttdef"><b>Definition:</b> mmm.f90:85</div></div>
<div class="ttc" id="atest1_8txt_html_a04bcf943628e7989fd28b4227f13cf61"><div class="ttname"><a href="test1_8txt.html#a04bcf943628e7989fd28b4227f13cf61">SCHUR</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square HTRIBK if A is Hermitian COMQR2 if A is not Hermitian SCHUR(A) - same as EIG. HESS(A) - same as EIG. Minor modifications were made to all these subroutines. The LINPACK routines were changed to replace the Fortran complex arithmetic with explicit references to real and imaginary parts. Since most of the floating point arithmetic is concentrated in a few low-level subroutines which perform vector operations(the Basic Linear Algebra Subprograms)</div></div>
<div class="ttc" id="atest1_8txt_html_ae930ef95331bdb8588448799268c712e"><div class="ttname"><a href="test1_8txt.html#ae930ef95331bdb8588448799268c712e">publication</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean University of New Computer Science technical submitted for publication</div><div class="ttdef"><b>Definition:</b> test1.txt:2131</div></div>
<div class="ttc" id="amold_8f90_html_a0bfdc54d7dbe4e38918b501cd87ada81"><div class="ttname"><a href="mold_8f90.html#a0bfdc54d7dbe4e38918b501cd87ada81">htridi</a></div><div class="ttdeci">subroutine htridi(NM, N, AR, AI, D, E, E2, TAU)</div><div class="ttdef"><b>Definition:</b> mold.f90:4998</div></div>
<div class="ttc" id="atest1_8txt_html_a0bc651ef7626a7868da4cbfdbe70f96f"><div class="ttname"><a href="test1_8txt.html#a0bc651ef7626a7868da4cbfdbe70f96f">long</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are and They happen to be computed in another order by the EISPACK subroutines The fact that the columns of which are the are so far from being orthonormal is our first indication that the eigenvalues are sensitive To see this we display more figures of the computed eigenvalues long</div><div class="ttdef"><b>Definition:</b> test1.txt:1082</div></div>
<div class="ttc" id="ammm_8f90_html_aee6d660c6e701a034cfd8489a32569c9"><div class="ttname"><a href="mmm_8f90.html#aee6d660c6e701a034cfd8489a32569c9">ml_matfn4</a></div><div class="ttdeci">subroutine ml_matfn4()</div><div class="ttdef"><b>Definition:</b> mmm.f90:7298</div></div>
<div class="ttc" id="atest1_8txt_html_ac3b4bd07c3d59237c7575ae1c248dfb7"><div class="ttname"><a href="test1_8txt.html#ac3b4bd07c3d59237c7575ae1c248dfb7">Reinsch</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Reinsch</div><div class="ttdef"><b>Definition:</b> test1.txt:2110</div></div>
<div class="ttc" id="amold_8f90_html_a8cf1ca1390a06dd4155795700c06135c"><div class="ttname"><a href="mold_8f90.html#a8cf1ca1390a06dd4155795700c06135c">matfn6</a></div><div class="ttdeci">subroutine matfn6</div><div class="ttdef"><b>Definition:</b> mold.f90:2558</div></div>
<div class="ttc" id="atest1_8txt_html_ab482938e076e67a7ccac675254b1184b"><div class="ttname"><a href="test1_8txt.html#ab482938e076e67a7ccac675254b1184b">Dongarra</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J Dongarra</div><div class="ttdef"><b>Definition:</b> test1.txt:2093</div></div>
<div class="ttc" id="atest1_8txt_html_a97a3da51b53542297b551ea7855945ee"><div class="ttname"><a href="test1_8txt.html#a97a3da51b53542297b551ea7855945ee">modify</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or modify</div><div class="ttdef"><b>Definition:</b> test1.txt:1983</div></div>
<div class="ttc" id="anamespacem__matrix_html_acc17dd1374592d6c8e39e77db5edf25a"><div class="ttname"><a href="namespacem__matrix.html#acc17dd1374592d6c8e39e77db5edf25a">m_matrix::chra</a></div><div class="ttdeci">integer chra</div><div class="ttdef"><b>Definition:</b> mmm.f90:86</div></div>
<div class="ttc" id="atest1_8txt_html_a2d8e85fb77ff1d1ea742f96a57fc3bd0"><div class="ttname"><a href="test1_8txt.html#a2d8e85fb77ff1d1ea742f96a57fc3bd0">echos</a></div><div class="ttdeci">E exit Causes termination of a FOR or WHILE loop If not in a terminates execution of MAT88 Also see QUIT quit From the causes return to the operating system or other program which invoked MAT88 From inside an causes return to the invoking or to the and PRINT functions access files The file parameter takes different forms for different operating systems On most file may be a string of up to characters in quotes For file may be a positive integer k less than which will be used as a FORTRAN logical unit number Some systems then automatically access a file with a name like FORT k or FORk DAT Other systems require a file with a name like FT0kF001 to be assigne to unit k before MAT88 is executed Check your installation for details The filename must be composed of recognized characters See CHAR Also see QUIT and EXIT exec the input is echoed If the MAT88 prompt is printed If MAT88 pauses before each prompt and waits for a null line to continue If there is no prompt or pause This is the default if the exec command is followed by a semicolon If there will be echos</div><div class="ttdef"><b>Definition:</b> test1.txt:2857</div></div>
<div class="ttc" id="atest1_8txt_html_ae66d623fffa8c1c9e52e6d57255e471b"><div class="ttname"><a href="test1_8txt.html#ae66d623fffa8c1c9e52e6d57255e471b">v</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for&lt; h, cos(pi *h)&gt; prints a table of cosines&lt; X, D &gt; for v</div><div class="ttdef"><b>Definition:</b> test1.txt:417</div></div>
<div class="ttc" id="atest1_8txt_html_a7e49824cb77f559a9822c14a618aa69c"><div class="ttname"><a href="test1_8txt.html#a7e49824cb77f559a9822c14a618aa69c">meaningful</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very meaningful</div><div class="ttdef"><b>Definition:</b> test1.txt:488</div></div>
<div class="ttc" id="anamespacem__matrix_html_a1efe66cf5505fcb346248b633ad69fa1"><div class="ttname"><a href="namespacem__matrix.html#a1efe66cf5505fcb346248b633ad69fa1">m_matrix::idstk</a></div><div class="ttdeci">integer, dimension(4, 48) idstk</div><div class="ttdef"><b>Definition:</b> mmm.f90:82</div></div>
<div class="ttc" id="atest1_8txt_html_ab51cd29909e4fcfd3ade3a94fbee5d45"><div class="ttname"><a href="test1_8txt.html#ab51cd29909e4fcfd3ade3a94fbee5d45">statement</a></div><div class="ttdeci">A changes all but the outer edge of the lower triangle and then prints the final matrix for&lt; h, cos(pi *h)&gt; prints a table of cosines&lt; X, D &gt; for A *v displays one at a time The WHILE clause allows statements to be repeated an indefinite number of times The general form is WHILE expr relop statement</div><div class="ttdef"><b>Definition:</b> test1.txt:424</div></div>
<div class="ttc" id="atest1_8txt_html_a5e3b1529a2a02cc88b4f5ccf1efb79fe"><div class="ttname"><a href="test1_8txt.html#a5e3b1529a2a02cc88b4f5ccf1efb79fe">M_88</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL M_88(0,'') N</div></div>
<div class="ttc" id="atest1_8txt_html_afa84babc0819b952c94a51d4446cf2f0"><div class="ttname"><a href="test1_8txt.html#afa84babc0819b952c94a51d4446cf2f0">Sachs</a></div><div class="ttdeci">solve for the coefficients and compute the conductivity The operation count is roughly proportional to m *n **The results obtained for sigma as a function of rho by this approach are essentially the same as those obtained by the finite difference technique of Keller and Sachs</div><div class="ttdef"><b>Definition:</b> test1.txt:994</div></div>
<div class="ttc" id="atest1_8txt_html_ac3f1ddb181dc52c6f4e5eb67c1e9eaad"><div class="ttname"><a href="test1_8txt.html#ac3f1ddb181dc52c6f4e5eb67c1e9eaad">arrays</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple except that MAT88 is programmed in which does not have recursion The interrelation of the primary subroutines is shown in the following diagram MAIN MAT88 CLAUSE PARSE EXPR TERM FACTOR STACK1 STACK2 STACKG STACKP PRINT COMAND CGECO CGEFA MATFN1 CGESL CGEDI CPOFA IMTQL2 HTRIDI MATFN2 HTRIBK CORTH COMQR3 MATFN3 CSVDC CQRDC MATFN4 CQRSL FILES MATFN5 SAVLOD Subroutine PARSE controls the interpretation of each statement It calls subroutines that process the various syntactic quantities such as term and factor A fairly simple program stack mechanism allows these subroutines to recursively call each other along the lines allowed by the syntax diagrams The four STACK subroutines manage the variable memory and perform elementary such as matrix addition and transposition The four subroutines MATFN1 though MATFN4 are called whenever serious matrix computations are required They are interface routines which call the various LINPACK and EISPACK subroutines MATFN5 primarily handles the file access tasks Two large real arrays</div><div class="ttdef"><b>Definition:</b> test1.txt:1488</div></div>
<div class="ttc" id="atest1_8txt_html_abc1de55a1ded540ae925d455d78d4573"><div class="ttname"><a href="test1_8txt.html#abc1de55a1ded540ae925d455d78d4573">sigma</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement though seldom very to use such strings in matrix operations More the text is used as a special argument to various functions X prints X on a file say contains the source text for a MAT88 statement or then the construction T&lt; causes T to be executed or evaluated. For example T='2 *A+3';S='B=&gt; T&lt;+5' A=4;&gt; S&lt; produces B=16. Some other examples are given under MACRO in the appendix. This facility is useful for fairly short statements and expressions. More complicated MAT88 &quot;programs&quot; should use the EXEC facility. The operations which access external files cannot be handled in a completely machine-independent manner by portable Fortran code. It is necessary for each particular installation to provide a subroutine which associates external text files with Fortran logical unit numbers.6. CENSUS EXAMPLE Our first extended example involves predicting the population of the United States in 1980 using extrapolation of various fits to the census data from 1900 through 1970. There are eight observations, so we begin with the MAT88 statement n=8 The values of the dependent variable, the population in millions, can be entered with y=&lt; 75.995 91.972 105.711 123.203 ... 131.669 150.697 179.323 203.212 &gt;' In order to produce a reasonably scaled matrix, the independent variable, time, is transformed from the interval[1900, 1970] to[-1.00, 0.75]. This can be accomplished directly with t=-1.0:0.25:0.75 or in a fancier, but perhaps clearer, way with t=1900:10:1970;t=(t - 1940 *ones(t))/40 Either of these is equivalent to t=&lt;-1 -.75 -.50 -.25 0 .25 .50 .75 &gt; The interpolating polynomial of degree n-1 involves an Vandermonde matrix of order n with elements that might be generated by for i=1:n, for j=1:n, a(i, j)=t(i) **(j-1);However, this results in an error caused by 0 **0 when i=5 and j=1 . The preferable approach is A=ones(n, n);for i=1:n, for j=2:n, a(i, j)=t(i) *a(i, j-1);Now the statement cond(A) produces the output ANS=1.1819E+03 which indicates that transformation of the time variable has resulted in a reasonably well conditioned matrix. The statement c=A\y results in C=131.6690 41.0406 103.5396 262.4535 -326.0658 -662.0814 341.9022 533.6373 These are the coefficients in the interpolating polynomial n-1 c+c t+...+c t 1 2 n Our transformation of the time variable has resulted in t=1 corresponding to the year 1980. Consequently, the extrapolated population is simply the sum of the coefficients. This can be computed by p=sum(c) The result is P=426.0950 which indicates a 1980 population of over 426 million. Clearly, using the seventh degree interpolating polynomial to extrapolate even a fairly short distance beyond the end of the data interval is not a good idea. The coefficients in least squares fits by polynomials of lower degree can be computed using fewer than n columns of the matrix. for k=1:n, c=A(:, 1:k)\y, p=sum(c) would produce the coefficients of these fits, as well as the resulting extrapolated population. If we do not want to print all the coefficients, we can simply generate a small table of populations predicted by polynomials of degrees zero through seven. We also compute the maximum deviation between the fitted and observed values. for k=1:n, X=A(:, 1:k);c=X\y;... d(k)=k-1;p(k)=sum(c);e(k)=norm(X *c-y, 'inf');&lt; d, p, e &gt; The resulting output is 0 132.7227 70.4892 1 211.5101 9.8079 2 227.7744 5.0354 3 241.9574 3.8941 4 234.2814 4.0643 5 189.7310 2.5066 6 118.3025 1.6741 7 426.0950 0.0000 The zeroth degree fit, 132.7 million, is the result of fitting a constant to the data and is simply the average. The results obtained with polynomials of degree one through four all appear reasonable. The maximum deviation of the degree four fit is slightly greater than the degree three, even though the sum of the squares of the deviations is less. The coefficients of the highest powers in the fits of degree five and six turn out to be negative and the predicted populations of less than 200 million are probably unrealistic. The hopefully absurd prediction of the interpolating polynomial concludes the table. We wish to emphasize that roundoff errors are not significant here. Nearly identical results would be obtained on other computers, or with other algorithms. The results simply indicate the difficulties associated with extrapolation of polynomial fits of even modest degree. A stabilized fit by a seventh degree polynomial can be obtained using the pseudoinverse, but it requires a fairly delicate choice of a tolerance. The statement s=svd(A) produces the singular values S=3.4594 2.2121 1.0915 0.4879 0.1759 0.0617 0.0134 0.0029 We see that the last three singular values are less than 0.1, consequently, A can be approximately by a matrix of rank five with an error less than 0.1 . The Moore-Penrose pseudoinverse of this rank five matrix is obtained from the singular value decomposition with the following statements c=pinv(A, 0.1) *y, p=sum(c), e=norm(a *c-y, 'inf') The output is C=134.7972 67.5055 23.5523 9.2834 3.0174 2.6503 -2.8808 3.2467 P=241.1720 E=3.9469 The resulting seventh degree polynomial has coefficients which are much smaller than those of the interpolating polynomial given earlier. The predicted population and the maximum deviation are reasonable. Any choice of the tolerance between the fifth and sixth singular values would produce the same results, but choices outside this range result in pseudoinverses of different rank and do not work as well. The one term exponential approximation y(t)=k exp(pt) can be transformed into a linear approximation by taking logarithms. log(y(t))=log k+pt=c+c t 1 2 The following segment makes use of the fact that a function of a vector is the function applied to the individual components. X=A(:, 1:2);c=X\log(y) p=exp(sum(c)) e=norm(exp(X *c) -y, 'inf') The resulting output is C=4.9083 0.5407 P=232.5134 E=4.9141 The predicted population and maximum deviation appear satisfactory and indicate that the exponential model is a reasonable one to consider. As a curiousity, we return to the degree six polynomial. Since the coefficient of the high order term is negative and the value of the polynomial at t=1 is positive, it must have a root at some value of t greater than one. The statements X=A(:, 1:7);c=X\y;c=c(7:-1:1);z=roots(c) produce Z=1.1023- 0.0000 *i 0.3021+0.7293 *i -0.8790+0.6536 *i -1.2939- 0.0000 *i -0.8790- 0.6536 *i 0.3021- 0.7293 *i There is only one real, positive root. The corresponding time on the original scale is 1940+40 *real(z(1))=1984.091 We conclude that the United States population should become zero early in February of 1984.7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE Our second extended example is a boundary value problem for Laplace 's equation. The underlying physical problem involves the conductivity of a medium with cylindrical inclusions and is considered by Keller and Sachs[7]. Find a function u(x, y) satisfying Laplace 's equation u+u=0 xx yy The domain is a unit square with a quarter circle of radius rho removed from one corner. There are Neumann conditions on the top and bottom edges and Dirichlet conditions on the remainder of the boundary. u=0 n -------------|.|.|.|. u=1|.|.|. u=0||||||||u=1||||||------------------------ u=0 n The effective conductivity of an medium is then given by the integral along the left edge, 1 sigma=integral u(0, y) dy 0 n It is of interest to study the relation between the radius rho and the conductivity sigma. In particular, as rho approaches one, sigma becomes infinite. Keller and Sachs use a finite difference approximation. The following technique makes use of the fact that the equation is actually Laplace 's equation and leads to a much smaller matrix problem to solve. Consider an approximate solution of the form n 2j-1 u=sum c r cos(2j-1) t j=1 j where r, t are polar coordinates(t is theta). The coefficients are to be determined. For any set of coefficients, this function already satisfies the differential equation because the basis functions are harmonic;it satisfies the normal derivative boundary condition on the bottom edge of the domain because we used cos t in preference to sin t ;and it satisfies the boundary condition on the left edge of the domain because we use only odd multiples of t . The computational task is to find coefficients so that the boundary conditions on the remaining edges are satisfied as well as possible. To accomplish this, pick m points(r, t) on the remaining edges. It is desirable to have m &gt; n and in practice we usually choose m to be two or three times as large as n Typical values of n are or and of m are to An m by n matrix A is generated The j element is the j th basis or its normal evaluated at the i th boundary point A right hand side with m components is also generated In this the elements of the right hand side are either zero or one The coefficients are then found by solving the overdetermined set of equations the approximate solution is defined everywhere on the domain It is then possible to compute the effective conductivity sigma In a very simple formula n j sigma</div><div class="ttdef"><b>Definition:</b> test1.txt:893</div></div>
<div class="ttc" id="anamespacem__matrix_html"><div class="ttname"><a href="namespacem__matrix.html">m_matrix</a></div><div class="ttdef"><b>Definition:</b> mmm.f90:1</div></div>
<div class="ttc" id="atest1_8txt_html_a6147ba73976fbe7eb9a28c7c80c7c752"><div class="ttname"><a href="test1_8txt.html#a6147ba73976fbe7eb9a28c7c80c7c752">A</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands SHORT LONG E and LONG Z alter the output but do not alter the precision of the computations or the internal storage The WHO and WHAT commands provide information about the functions and variables that are currently defined The CLEAR command erases all except RAND and EYE The statement A</div><div class="ttdef"><b>Definition:</b> test1.txt:473</div></div>
<div class="ttc" id="atest1_8txt_html_a98888794f2f2be8301cc4c0faad48f31"><div class="ttname"><a href="test1_8txt.html#a98888794f2f2be8301cc4c0faad48f31">Department</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX CALL N DO N the call to then waits for input The command quit sends control back to our example program The matrix A is generated by the program and sent to the stack by the first call to MATZ The call to put the result on the stack and go back to our program The second call to MATZ will retrieve X By the this matrix X is interesting Take a look at where it is being supported by the National Science Foundation Additional work has been done during visits to Stanford Linear Accelerator Argonne National Laboratory and Los Alamos Scientific where support has been provided by NSF and the Department of Energy REFERENCES[1] J J J R C B Moler and G W LINPACK Users Society for Industrial and Applied B T J M J J B S Y V C C B Matrix Eigensystem Routines EISPACK Lecture Notes in Computer second Springer B S J M J J C B Matrix Eigensystem Routines EISPACK Guide Lecture Notes in Computer Springer S Cohen and S SPEAKEASY III Reference Speakeasy Computing J H Wilkinson and C Handbook for Automatic volume Linear Springer Niklaus Algorithms Data Prentice H B Keller and D Calculations of the Conductivity of a Medium Containing Cylindrical J Applied C B Moler and C F Van Nineteen Dubious Ways to Compute the Exponential of a SIAM G E M A Malcolm and C B Computer Methods for Mathematical Prentice C B Moler and D R Replacing square roots by Pythagorean University of New Computer Science Department</div><div class="ttdef"><b>Definition:</b> test1.txt:2130</div></div>
<div class="ttc" id="atest1_8txt_html_a19a12944ce8e0fa189b3c1925e324518"><div class="ttname"><a href="test1_8txt.html#a19a12944ce8e0fa189b3c1925e324518">roots</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more more efficient methods for finding polynomial roots</div><div class="ttdef"><b>Definition:</b> test1.txt:1651</div></div>
<div class="ttc" id="atest1_8txt_html_a7a076662b7e84a2fa7ba1e6199ae1952"><div class="ttname"><a href="test1_8txt.html#a7a076662b7e84a2fa7ba1e6199ae1952">printed</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is printed</div><div class="ttdef"><b>Definition:</b> test1.txt:1546</div></div>
<div class="ttc" id="atest1_8txt_html_a71bce84a4cc397d00878bcbdd0ff6ffa"><div class="ttname"><a href="test1_8txt.html#a71bce84a4cc397d00878bcbdd0ff6ffa">LONG</a></div><div class="ttdeci">FILES AND MACROS MAT88 has several commands which control the output format and the overall execution of the system The HELP command allows on line access to short portions of text describing various functions and special characters The entire HELP document is reproduced in an appendix Results are usually printed in a scaled fixed point format that shows or significant figures The commands LONG</div><div class="ttdef"><b>Definition:</b> test1.txt:465</div></div>
<div class="ttc" id="atest1_8txt_html_a12cabef38d4d6e0c1f262db98f8a35f4"><div class="ttname"><a href="test1_8txt.html#a12cabef38d4d6e0c1f262db98f8a35f4">SQRT</a></div><div class="ttdeci">It is possible to prove that the results produced are the exact eigenvalues of a matrix within roundoff error of the companion matrix but this does not mean that they are the exact roots of a polynomial with coefficients within roundoff error of those in C There are more more efficient methods for finding polynomial but this approach has the crucial advantage that it does not require very much additional code The elementary functions SQRT</div><div class="ttdef"><b>Definition:</b> test1.txt:1654</div></div>
<div class="ttc" id="atest1_8txt_html_a6b97d9ca3f436840f7a2ca0cd09b74a1"><div class="ttname"><a href="test1_8txt.html#a6b97d9ca3f436840f7a2ca0cd09b74a1">INV</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions INV(A) - CGECO</div></div>
<div class="ttc" id="ammm_8f90_html_af143642a819cceb1dba69ae322c43fdc"><div class="ttname"><a href="mmm_8f90.html#af143642a819cceb1dba69ae322c43fdc">ml_comand</a></div><div class="ttdeci">subroutine ml_comand(id)</div><div class="ttdef"><b>Definition:</b> mmm.f90:5639</div></div>
<div class="ttc" id="ammm_8f90_html_a3037a6673d337dc32522c485e16913ba"><div class="ttname"><a href="mmm_8f90.html#a3037a6673d337dc32522c485e16913ba">ml_urand</a></div><div class="ttdeci">doubleprecision function ml_urand(IY)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11593</div></div>
<div class="ttc" id="atest1_8txt_html_a6beaf7fa34e582333829af6d06cc0dea"><div class="ttname"><a href="test1_8txt.html#a6beaf7fa34e582333829af6d06cc0dea">IDA</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IDA</div><div class="ttdef"><b>Definition:</b> test1.txt:2016</div></div>
<div class="ttc" id="atest1_8txt_html_a484ecf74e30e0ca388203af147e59920"><div class="ttname"><a href="test1_8txt.html#a484ecf74e30e0ca388203af147e59920">IDX</a></div><div class="ttdeci">Then the MAT88 statements N DO N N N N enddo or MAT88 subroutine SAVLOD After this program is enter MAT88 and give the following X If all goes according to this will read the matrix A from the file invert store the inverse in X and then write the matrix X on the file X The following program can then access X PROGRAM MAINX DOUBLEPRECISION N N M ENDDO but which is not used by MAT88 itself The preample of MATZ IERR INTEGER IERR DOUBLEPRECISION STORED IN AN ARRAY WITH ! LEADING DIMENSION LDA ! IDA IS THE NAME OF A ! IF IDA IS AN INTEGER K LESS THEN THE NAME IS A K FORMAT STACKP AND ERROR The preample of subroutine MAT88 NONZERO FOR SUBSEQUENT ENTRIES To do our write the following IDX(4) DATA LDA/10/DATA IDA/'A'</div></div>
<div class="ttc" id="atest1_8txt_html_ade3819bf3b3e0fd29e1b0074f4990c96"><div class="ttname"><a href="test1_8txt.html#ade3819bf3b3e0fd29e1b0074f4990c96">also</a></div><div class="ttdeci">the elements of A would be exact integers if there were no roundoff is our test matrix We can now forget how it was generated and analyze its eigenvalues&lt; X, D &gt; its eigenvalues are also</div><div class="ttdef"><b>Definition:</b> test1.txt:1061</div></div>
<div class="ttc" id="atest1_8txt_html_a928b1496cc8cb78ed463c9959d654a53"><div class="ttname"><a href="test1_8txt.html#a928b1496cc8cb78ed463c9959d654a53">FACTOR</a></div><div class="ttdeci">as well as a flow chart of the mat88 is provided by the syntax diagrams or syntax graphs of wirth[6] There are eleven non terminal symbols in the FACTOR</div><div class="ttdef"><b>Definition:</b> test1.txt:1252</div></div>
<div class="ttc" id="atest1_8txt_html_a210480115a11b94b08648cec1c99db0a"><div class="ttname"><a href="test1_8txt.html#a210480115a11b94b08648cec1c99db0a">names</a></div><div class="ttdeci">&lt; &gt; QUOTE LINE STATEMENT CLAUSE EXPR COMMAND EXPR&lt; &gt;&lt; ;&lt;-|||--------||---------||-&lt;,&lt;-|STATEMENT|-&gt;&lt;----||--&gt;&lt;---||||||||||--&lt;,&lt;---|||||||------------&gt; EXPR&lt; &gt; FACTOR **FACTOR TEXT NUMBER INT INT E INT INT DIGIT NAME&lt; LETTER&lt;--|||------&gt; LETTER&lt; DIGIT&lt;--|COMMAND|--&gt; NAME NAME CHAR TEXT LETTER DIGIT CHAR THE PARSER INTERPRETER The structure of the parser interpreter is similar to that of Wirth s compiler[6] for his simple except that MAT88 is programmed in which does not have recursion The interrelation of the primary subroutines is shown in the following diagram MAIN MAT88 CLAUSE PARSE EXPR TERM FACTOR STACK1 STACK2 STACKG STACKP PRINT COMAND CGECO CGEFA MATFN1 CGESL CGEDI CPOFA IMTQL2 HTRIDI MATFN2 HTRIBK CORTH COMQR3 MATFN3 CSVDC CQRDC MATFN4 CQRSL FILES MATFN5 SAVLOD Subroutine PARSE controls the interpretation of each statement It calls subroutines that process the various syntactic quantities such as term and factor A fairly simple program stack mechanism allows these subroutines to recursively call each other along the lines allowed by the syntax diagrams The four STACK subroutines manage the variable memory and perform elementary such as matrix addition and transposition The four subroutines MATFN1 though MATFN4 are called whenever serious matrix computations are required They are interface routines which call the various LINPACK and EISPACK subroutines MATFN5 primarily handles the file access tasks Two large real STKR and are used to store all the matrices Four integer arrays are used to store the names</div><div class="ttdef"><b>Definition:</b> test1.txt:1489</div></div>
<div class="ttc" id="ammm_8f90_html_a260b8b5d6b04b91bf2b589eb6a54c02a"><div class="ttname"><a href="mmm_8f90.html#a260b8b5d6b04b91bf2b589eb6a54c02a">ml_rset</a></div><div class="ttdeci">subroutine ml_rset(n, dx, dy, incy)</div><div class="ttdef"><b>Definition:</b> mmm.f90:11486</div></div>
<div class="ttc" id="atest1_8txt_html_a01189851d712b9987cc1902d9aed2008"><div class="ttname"><a href="test1_8txt.html#a01189851d712b9987cc1902d9aed2008">CORTH</a></div><div class="ttdeci">RAND and occupy the last four positions of the variable stacks RAND has dimensions but whenever its value is a random number generator is used instead EYE has dimensions by to indicate that the actual dimensions must be determined later by context The two saved variables have dimensions by and by and so take up a total of locations Subsequent statements involving A and x will result in temporary copies being made in the top of the stack for use in the actual calculations Whenever the top of the stack reaches the a message indicating memory has been exceeded is but the current variables are not affected This modular structure makes it possible to implement MAT88 on a system with a limited amount of memory The object code for the MATFN s and the LINPACK EISPACK subroutines is rarely needed Although it is not many Fortran operating systems provide some overlay mechanism so that this code is brought into the main memory only when required The which occupy a relatively small portion of the remain in while the subroutines which process them are loaded a few at a time THE NUMERICAL ALGORITHMS The algorithms underlying the basic MAT88 functions are described in the LINPACK and EISPACK guides[1-3] The following list gives the subroutines used by these functions CGEDI CGEDI CSVDC eps CSVDC CQRSL CSQSL A B and B A CGESL if A is square CQRSL if A is not square HTRIBK if A is Hermitian CORTH</div><div class="ttdef"><b>Definition:</b> test1.txt:1579</div></div>
<div class="ttc" id="amold_8f90_html_a6f73f9351f3ecaa3cd975d2ae0bf08cb"><div class="ttname"><a href="mold_8f90.html#a6f73f9351f3ecaa3cd975d2ae0bf08cb">wdotci</a></div><div class="ttdeci">double precision function wdotci(N, XR, XI, INCX, YR, YI, INCY)</div><div class="ttdef"><b>Definition:</b> mold.f90:7528</div></div>
<div class="ttc" id="atest1_8txt_html_a31e09e18f466cbf0e108d295d847143f"><div class="ttname"><a href="test1_8txt.html#a31e09e18f466cbf0e108d295d847143f">th</a></div><div class="ttdeci">for th(i)</div></div>
<div class="ttc" id="amold_8f90_html_a4feae87113559886a49a530247142151"><div class="ttname"><a href="mold_8f90.html#a4feae87113559886a49a530247142151">matfn5</a></div><div class="ttdeci">subroutine matfn5</div><div class="ttdef"><b>Definition:</b> mold.f90:2267</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
