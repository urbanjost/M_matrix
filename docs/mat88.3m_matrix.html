<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="https://github.com/urbanjost/M_matrix">[UP]</a></h5>
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>mat88 (3m_matrix)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>MAT88</B>(3f) - [M_matrix] initialize and/or pass commands to matrix
laboratory interpreter
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>Options</A><BR>
<A HREF=#4>Example</A><BR>
</BLOCKQUOTE>
<A name=5>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<P>
<B>subroutine</B> <B>MAT88</B>(init,cmd)
<P>
<PRE>
   integer,intent(in),optional :: init
   character(len=*),intent(in),optional :: cmd
      or
   character(len=*),intent(in),optional :: cmd(:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<B>MAT88</B>(3f) is modeled on <B>MATLAB</B>(3f) (MATrix LABoratory), a FORTRAN
package developed by Argonne National Laboratories for in-house use.
It provides comprehensive vector and tensor operations in a package
which may be programmed, either through a macro language or through
execution of script files.
<P>
<B>MAT88</B>(3f) is reentrant and recursive. Functions supported include (but
are not by any means limited to) sin, cos, tan, arcfunctions, upper
triangular, lower triangular, determinants, matrix multiplication,
identity, Hilbert matrices, eigenvalues and eigenvectors, matrix
roots and products, inversion and so on and so forth.
<P>
The HELP command describes using the interpreter.
</BLOCKQUOTE>
<A name=3>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>INIT</B> </TD><TD valign=bottom>
indicate size of scratch space to allocate
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>CMD</B> </TD><TD valign=bottom>
MAT88 <B>command</B>(s) to perform. May be CHARACTER scalar or vector
</TD></TR>
<TR></TR></TABLE>INIT and CMD cannot be combined on a single call.
<P>
The first should be an initialization declaring the number of
doubleprecision values to allocate for the combined scratch and
variable storage area. This is a required initial command. It may be
repeated. A size of zero will deallocate any allocated storage.
<P>
If no parameters or a blank string is supplied interactive mode
is entered.
<P>
If a CMD is passed and no initialization call was made the scratch space
will be allocated to 200000.
</BLOCKQUOTE>
<A name=4>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
<P>
Sample program
<P>
<PRE>
      program demo_MAT88
      use M_matrix, only : mat88
<P>
         write(*,&#146;(a)&#146;)&#146;optionally initialize scratch area size&#146;
         call MAT88(20000)
<P>
         write(*,&#146;(a)&#146;)&#146;do some commands&#146;
         call MAT88([character(len=256) :: &
         & &#146;semi;                         &#146;,&
         & &#146;semi;                         &#146;,&
         & &#146;a=magic(4),b=-a               &#146;,&
         & &#146;a+b;a;b                       &#146;,&
         & &#146;display("That is all Folks")  &#146;])
<P>
         write(*,&#146;(a)&#146;)&#146;do a single command&#146;
         call MAT88(&#146;who&#146;)
<P>
         write(*,&#146;(a)&#146;)&#146;enter interactive mode&#146;
         call MAT88()
<P>
         write(*,&#146;(a)&#146;)&#146;ending program&#146;
</PRE>
end program demo_MAT88
<P>
Example 2:
<P>
<PRE>
   program bigmat
   use M_matrix, only : mat88
      ! pass strings to MAT88 but do not enter interactive mode
      call mat88(20000)                  ! initialize silently
      call mat88( &#146;a=[1 2 3 4; 5 6 7 8]&#146;)
      call mat88( [character(len=80) :: &
       & &#146;semi;lines(9999)                                      &#146;,&
       & &#146;// create a magic square and add 100 to all the values&#146;,&
       & &#146;A=magic(4),&lt;X,Y&gt;=size(A)                              &#146;,&
       & &#146;B=A+ones(X,Y)*100                                     &#146;,&
       & &#146;// save all current values to a file                  &#146;,&
       & &#146;save("sample.mat")                                    &#146;,&
       & &#146;// clear all user values                              &#146;,&
       & &#146;clear                                                 &#146;,&
       & &#146;// show variable names, load values from file         &#146;,&
       & &#146;                                                      &#146;,&
       & &#146;who;load("sample.mat");who                            &#146;])
   end program bigmat
<P>
</PRE>
Sample program with custom user function
<P>
<PRE>
      program sample_user
      use M_matrix, only : mat88
         call MAT88(20000)
         call MAT88(&#146; &#146;)
      end program
<P>
      !-------------------------------------------------------------
      SUBROUTINE mat88_user(A,M,N,S,T)  ! sample mat88_user routine
      ! Allows personal  Fortran  subroutines  to  be  linked  into
      ! MAT88. The subroutine should have the heading
      !
      !               SUBROUTINE mat88_user(A,M,N,S,T)
      !               DOUBLEPRECISION A(M,N),S,T
      !
      ! The MAT88 statement Y = USER(X,s,t) results in a call to
      ! the subroutine with a copy of the matrix X stored in the
      ! argument A, its column and row dimensions in M and N,
      ! and the scalar parameters S and T stored in S and T.
      ! If S and T are omitted, they are set to 0.0. After
      ! the return, A is stored in Y. The dimensions M and
      ! N may be reset within the subroutine. The statement Y =
      ! USER(K) results in a call with M = 1, N = 1 and A(1,1) =
      ! FLOAT(K). After the subroutine has been written, it must
      ! be compiled and linked to the MAT88 object code within the
      ! local operating system.
      !
      integer M,N
      DOUBLEPRECISION A(M,N),S,T
      !
      if(s.eq.0.and.t.eq.0)then
         ! print statistics for matrix, for example
         write(*,*)&#146;m=&#146;,m
         write(*,*)&#146;n=&#146;,n
         write(*,*)&#146;s=&#146;,s
         write(*,*)&#146;t=&#146;,t
<P>
         DO i10 = 1, M
            write(*,*)(a(i10,i20),i20=1,n)
         enddo
      else  ! a(i,j)=a(i,j)*s+t  in a linear fashion
         DO i30 = 1, M
            DO i40 = 1, N
               a(i30,i40)=a(i30,i40)*S+T
            enddo
         enddo
      endif
      END SUBROUTINE mat88_user
<P>
      ! end program sample_user
<P>
</PRE>
</BLOCKQUOTE>
Example inputs
<P>
<PRE>
    :avg:
<P>
    for i = 2:2:n, for j = 2:2:n, t = (a(i-1,j-1)+a(i-1,j)+a(i,j-1)+a(i,j))/4; &#46;&#46;&#46;
    a(i-1,j-1) = t; a(i,j-1) = t; a(i-1,j) = t; a(i,j) = t;
<P>
    :cdiv:
<P>
    // ======================================================
    // cdiv
    a=sqrt(random(8))
    ar = real(a); ai = imag(a); br = real(b); bi = imag(b);
    p = bi/br;
    t = (ai - p*ar)/(br + p*bi);
    cr = p*t + ar/br;
    ci = t;
    p2 = br/bi;
    t2 = (ai + p2*ar)/(bi + p2*br);
    ci2 = p2*t2 - ar/bi;
    cr2 = t2;
    s = abs(br) + abs(bi);
    ars = ar/s;
    ais = ai/s;
    brs = br/s;
    bis = bi/s;
    s = brs**2 + bis**2;
    cr3 = (ars*brs + ais*bis)/s;
    ci3 = (ais*brs - ars*bis)/s;
    [cr ci; cr2 ci2; cr3 ci3]
    // ======================================================
<P>
    :exp:
<P>
    t = 0*x + eye; s = 0*eye(x); n = 1;
    while abs(s+t-s) &gt; 0, s = s+t, t = x*t/n, n = n + 1
<P>
    :four:
     n
     pi = 4*atan(1);
     i = sqrt(-1);
     w = exp(2*pi*i/n);
     F = [];
     for k = 1:n, for j = 1:n, F(k,j) = w**((j-1)*(k-1));
     F = F/sqrt(n);
     alpha = r*pi;
     rho = exp(i*alpha);
     S = log(rho*F)/i - alpha*eye;
     serr = norm(imag(S),1);
     S = real(S);
     serr = serr + norm(S-S&#146;,1)
     S = (S + S&#146;)/2;
     ferr = norm(F-exp(i*S),1)
<P>
     :gs:
     for k = 1:n, for j = 1:k-1, d = x(k,:)*x(j,:)&#146;; x(k,:) = x(k,:) - d*x(j,:); &#46;&#46;&#46;
     end, s = norm(x(k,:)), x(k,:) = x(k,:)/s;
<P>
     :jacobi:
     [n, n] = size(A);
     X = eye(n);
     anorm = norm(A,&#146;fro&#146;);
     cnt = 1;
     while cnt &gt; 0, &#46;&#46;&#46;
       cnt = 0; &#46;&#46;&#46;
       for p = 1:n-1, &#46;&#46;&#46;
         for q = p+1:n, &#46;&#46;&#46;
           if anorm + abs(a(p,q)) &gt; anorm, &#46;&#46;&#46;
             cnt = cnt + 1; &#46;&#46;&#46;
             exec(&#146;jacstep&#146;); &#46;&#46;&#46;
           end, &#46;&#46;&#46;
         end, &#46;&#46;&#46;
       end, &#46;&#46;&#46;
       display(rat(A)), &#46;&#46;&#46;
     end
<P>
     :jacstep:
<P>
     d = (a(q,q)-a(p,p))*0.5/a(p,q);
     t = 1/(abs(d)+sqrt(d*d+1));
     if d &lt; 0, t = -t; end;
     c = 1/sqrt(1+t*t);  s = t*c;
     R = eye(n); r(p,p)=c; r(q,q)=c; r(p,q)=s; r(q,p)=-s;
     X = X*R;
     A = R&#146;*A*R;
<P>
     :kron:
<P>
     //  C = Kronecker product of A and B
     [m, n] = size(A);
     for i = 1:m, &#46;&#46;&#46;
        ci = a(i,1)*B; &#46;&#46;&#46;
        for j = 2:n, ci = [ci a(i,j)*B]; end &#46;&#46;&#46;
        if i = 1, C = ci; else, C = [C; ci];
<P>
     :lanczos:
<P>
     [n,n] = size(A);
     q1 = rand(n,1);
     ort
     alpha = []; beta = [];
     q = q1/norm(q1); r = A*q(:,1);
     for j = 1:n, exec(&#146;lanstep&#146;,0);
<P>
     :lanstep:
<P>
     alpha(j) = q(:,j)&#146;*r;
     r = r - alpha(j)*q(:,j);
     if ort &lt;&gt; 0, for k = 1:j-1, r = r - r&#146;*q(:,k)*q(:,k);
     beta(j) = norm(r);
     q(:,j+1) = r/beta(j);
     r = A*q(:,j+1) - beta(j)*q(:,j);
     if j &gt; 1, T = diag(beta(1:j-1),1); T = diag(alpha) + T + T&#146;; eig(T)
<P>
     :mgs:
<P>
     for k = 1:n, s = norm(x(k,:)), x(k,:) = x(k,:)/s; &#46;&#46;&#46;
        for j = k+1:n, d = x(j,:)*x(k,:)&#146;; x(j,:) = x(j,:) - d*x(k,:);
<P>
     :net:
<P>
     C = [
     1   2   15  .   .   .
     2   1   3   .   .   .
     3   2   4   11  .   .
     4   3   5   .   .   .
     5   4   6   7   .   .
     6   5   8   .   .   .
     7   5   9   30  .   .
     8   6   9   10  11  .
     9   7   8   30  .   .
     10  8   12  30  31  34
     11  3   8   12  13  .
     12  10  11  34  36  .
     13  11  14  .   .   .
     14  13  15  16  38  .
     15  1   14  .   .   .
     16  14  17  20  35  37
     17  16  18  .   .   .
     18  17  19  .   .   .
     19  18  20  .   .   .
     20  16  19  21  .   .
     21  20  22  .   .   .
     22  21  23  .   .   .
     23  22  24  35  .   .
     24  23  25  39  .   .
     25  24  .   .   .   .
     26  27  33  39  .   .
     27  26  32  .   .   .
     28  29  32  .   .   .
     29  28  30  .   .   .
     30  7   9   10  29  .
     31  10  32  .   .   .
     32  27  28  31  34  .
     33  26  34  .   .   .
     34  10  12  32  33  35
     35  16  23  34  36  .
     36  12  35  38  .   .
     37  16  38  .   .   .
     38  14  36  37  .   .
     39  24  26  .   .   .
     ];
     [n, m] = size(C);
     A = 0*ones(n,n);
     for i=1:n, for j=2:m, k=c(i,j); if k&gt;0, a(i,k)=1;
     check = norm(A-A&#146;,1), if check &gt; 0, quit
     [X,D] = eig(A+eye);
     D = diag(D);  D = D(n:-1:1)
     X = X(:,n:-1:1);
     [x(:,1)/sum(x(:,1)) x(:,2) x(:,3) x(:,19)]
<P>
     :pascal:
<P>
     //Generate next Pascal matrix
     [k,k] = size(L);
     k = k + 1;
     L(k,1:k) = [L(k-1,:) 0] + [0 L(k-1,:)];
<P>
     :pdq:
<P>
     alpha = []; beta = 0; q = []; p = p(:,1)/norm(p(:,1));
     t = A&#146;*p(:,1);
     alpha(1) = norm(t);
     q(:,1) = t/alpha(1);
     X = p(:,1)*(alpha(1)*q(:,1))&#146;
     e(1) = norm(A-X,1)
     for j = 2:r, exec(&#146;pdqstep&#146;,ip); &#46;&#46;&#46;
        X = X + p(:,j)*(alpha(j)*q(:,j)+beta(j)*q(:,j-1))&#146;, &#46;&#46;&#46;
        e(j) = norm(A-X,1)
<P>
     :pdqstep:
<P>
     t = A*q(:,j-1) - alpha(j-1)*p(:,j-1);
        if ort&gt;0, for i = 1:j-1, t = t - t&#146;*p(:,i)*p(:,i);
     beta(j) = norm(t);
     p(:,j) = t/beta(j);
     t = A&#146;*p(:,j) - beta(j)*q(:,j-1);
        if ort&gt;0, for i = 1:j-1, t = t - t&#146;*q(:,i)*q(:,i);
     alpha(j) = norm(t);
     q(:,j) = t/alpha(j);
<P>
     :pop:
<P>
     y = [ 75.995   91.972  105.711  123.203   &#46;&#46;&#46;
          131.669  150.697  179.323  203.212]&#146;
     t = [ 1900:10:1970 ]&#146;
     t = (t - 1940*ones(t))/40;   [t y]
     n = 8;  A(:,1) = ones(t);  for j = 2:n, A(:,j) = t .* A(:,j-1);
</PRE>
<A name=>

    <H4>&nbsp; &nbsp; A</H4>
</A>
<BLOCKQUOTE>
c = A\y
<P>
:qr:
<P>
scale = <B>s</B>(m);
sm = <B>s</B>(m)/scale; smm1 = <B>s</B>(m-1)/scale; emm1 = <B>e</B>(m-1)/scale;
sl = <B>s</B>(l)/scale; el = <B>e</B>(l)/scale;
b = ((smm1 + sm)*(smm1 - sm) + emm1**2)/2;
c = (sm*emm1)**2;
shift = <B>sqrt</B>(b**2+c); if b &lt; 0, shift = <B>-shift</B>;
shift = <B>c/</B>(b + shift)
f = (sl + sm)*(sl-sm) - shift
g = sl*el
for k = l: m-1, <B>exec</B>(&#146;qrstep&#146;,ip)
<B>e</B>(m-1) = f
<P>
:qrstep:
<P>
<B>exec</B>(&#146;rot&#146;);
if k &lt;&gt; l, <B>e</B>(k-1) = f
f = cs*<B>s</B>(k) + sn*<B>e</B>(k)
<B>e</B>(k) = cs*<B>e</B>(k) - sn*<B>s</B>(k)
g = sn*<B>s</B>(k+1)
<B>s</B>(k+1) = cs*<B>s</B>(k+1)
<B>exec</B>(&#146;rot&#146;);
<B>s</B>(k) = f
f = cs*<B>e</B>(k) + sn*<B>s</B>(k+1)
<B>s</B>(k+1) = <B>-sn</B>*<B>e</B>(k) + cs*<B>s</B>(k+1)
g = sn*<B>e</B>(k+1)
<B>e</B>(k+1) = cs*<B>e</B>(k+1)
<P>
:rho:
<P>
//Conductivity example.
//Parameters ---
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: //Conductivity example.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>rho</B> </TD><TD valign=bottom>
//radius of cylindrical inclusion
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>n</B> </TD><TD valign=bottom>
//number of terms in solution
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>m</B> </TD><TD valign=bottom>
//number of boundary points
//initialize operation counter
flop = [0 0];
//initialize variables
</TD></TR>
<TR valign=top><TD colspan=2>
<B>m1 = </B><B>round</B>(m/3); </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
//number of points on each straight edge
</TD></TR>
<TR valign=top><TD colspan=2>
<B>m2 = m - m1;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
//number of points with Dirichlet conditions
pi = 4*<B>4*atan</B>(1);
//generate points in Cartesian coordinates
//right hand edge
for i = 1:m1, <B>x</B>(i) = 1; <B>y</B>(i) = (1-rho)*(i-1)/(m1-1);
//top edge
for i = m2+1:m, <B>x</B>(i) = (1-rho)*(m-i)/(m-m2-1); <B>y</B>(i) = 1;
//circular edge
for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); &#46;&#46;&#46;
<TABLE width=100% cellpadding=3><!-- tsb: //number of points with Dirichlet conditions
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B></B><B>x</B>(i) = 1-rho*sin(t); </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<B>y</B>(i) = 1-rho*cos(t);
//convert to polar coordinates
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>for i = 1:m-1, </B><B>th</B>(i) = <B>atan</B>(<B>y</B>(i)/<B>x</B>(i)); </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
&#46;&#46;&#46;
<B>r</B>(i) = <B>sqrt</B>(<B>x</B>(i)**2+<B>y</B>(i)**2);
</TD></TR>
<TR valign=top><TD colspan=2>
<B></B><B>th</B>(m) = pi/2; </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<B>r</B>(m) = 1;
//generate matrix
//Dirichlet conditions
for i = 1:m2, for j = 1:n, k = 2*j-1; &#46;&#46;&#46;
<B>a</B>(i,j) = <B>r</B>(i)**k*cos(k*<B>th</B>(i));
//Neumann conditions
for i = m2+1:m, for j = 1:n, k = 2*j-1; &#46;&#46;&#46;
<B>a</B>(i,j) = k*<B>r</B>(i)**(k-1)*sin((k-1)*<B>th</B>(i));
//generate right hand side
for i = 1:m2, <B>b</B>(i) = 1;
for i = m2+1:m, <B>b</B>(i) = 0;
//solve for coefficients
c = A$b
//compute effective conductivity
<B>c</B>(2:2:n) = -<B>c</B>(2:2:n)
sigma = <B>sum</B>(c)
//output total operation count
ops = <B>flop</B>(2)
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
:rogers.exec:
<TABLE cellpadding=3><!-- tsb: :rogers.exec:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B></B><B>exec</B>(&#146;d.boug&#146;); </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// reads data
</TD></TR>
<TR valign=top><TD colspan=2>
<B>[g,k] = </B><B>size</B>(p); </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// p is matrix of gene frequencies
</TD></TR>
<TR valign=top><TD colspan=2>
<B>wv = ncen/</B><B>sum</B>(ncen); </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// ncen contains population sizes
</TD></TR>
<TR valign=top><TD colspan=2>
<B>pbar = wv*p;</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// weighted average of p
</TD></TR>
<TR valign=top><TD colspan=2>
<B>p = p - </B><B>ones</B>(g,1)*pbar; </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// deviations from mean
</TD></TR>
<TR valign=top><TD colspan=2>
<B>p = </B><B>sqrt</B>(diag(wv)) * p; </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// weight rows of p by sqrt of pop size
h = <B>diag</B>(pbar); h = h*(eye-h); // diagonal contains binomial variance: p*(1-p)
</TD></TR>
<TR valign=top><TD colspan=2>
<B>r = p*</B><B>p*inv</B>(h)*p&#146;/k; </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
// normalized covariance matrix
<B>eig</B>(r)&#146;
</TD></TR>
<TR><TD colspan=2>
:rosser:
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>A</B> </TD><TD valign=bottom>
= [
<TABLE width=100% cellpadding=3><!-- tsb: = [
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
611.
</TD><TD>
196. <B>-192</B>. 407. <B>-8</B>. <B>-52</B>. <B>-49</B>. 29.
</TD></TR>
<TR valign=top><TD width=4%>
196.
</TD><TD>
899. 113. <B>-192</B>. <B>-71</B>. <B>-43</B>. <B>-8</B>. <B>-44</B>.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=4% nowrap>
<B></B><B>-192</B>. </TD><TD valign=bottom>
113.  899.  196.   61.   49.    8.   52.
<TABLE width=100% cellpadding=3><!-- tsb: 113.  899.  196.   61.   49.    8.   52.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
407.
</TD><TD>
<B>-192</B>. 196. 611. 8. 44. 59. <B>-23</B>.
<TABLE width=100% cellpadding=3><!-- tsb: <B>-192</B>. 196. 611. 8. 44. 59. <B>-23</B>.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B><B>-8</B>. </TD><TD valign=bottom>
<B>-71</B>.   61.    8.  411. <B>-599</B>.  208.  208.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B><B>-52</B>. </TD><TD valign=bottom>
<B>-43</B>.   49.   44. <B>-599</B>.  411.  208.  208.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B><B>-49</B>. </TD><TD valign=bottom>
<B>-8</B>.    8.   59.  208.  208.   99. <B>-911</B>.
<TABLE width=100% cellpadding=3><!-- tsb: <B>-8</B>.    8.   59.  208.  208.   99. <B>-911</B>.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
29.
</TD><TD>
<B>-44</B>. 52. <B>-23</B>. 208. 208. <B>-911</B>. 99. ];
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
:rot:
</TD></TR>
<TR><TD colspan=2>
// subexec <B>rot</B>(f,g,cs,sn)
rho = g; if <B>abs</B>(f) &gt; <B>abs</B>(g), rho = f;
cs = 1.0; sn = 0.0; z = 1.0;
r = <B>norm</B>([f g]); if rho &lt; 0, r = <B>-r</B>; r
if r &lt;&gt; 0.0, cs = f/r
if r &lt;&gt; 0.0, sn = g/r
if <B>abs</B>(f) &gt; <B>abs</B>(g), z = sn;
if <B>abs</B>(g) &gt;= <B>abs</B>(f), if cs &lt;&gt; 0, z = 1/cs;
f = r;
g = z;
</TD></TR>
<TR><TD colspan=2>
:rqi:
</TD></TR>
<TR><TD colspan=2>
rho = (x&#146;*A*x)
x = (A-rho*eye)\x;
x = <B>x/norm</B>(x)
</TD></TR>
<TR><TD colspan=2>
:setup:
</TD></TR>
<TR><TD colspan=2>
<B>diary</B>(&#146;xxx&#146;)
!tail <B>-f</B> xxx &gt; /dev/tty1 &
!tail <B>-f</B> xxx &gt; /dev/tty2 &
</TD></TR>
<TR><TD colspan=2>
:sigma:
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RHO = .5</B> </TD></TR><TR valign=top><TD width=4%>&nbsp;</TD><TD>
M = 20  N = 10   SIGMA =  1.488934271883534
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RHO = .5</B> </TD></TR><TR valign=top><TD width=4%>&nbsp;</TD><TD>
M = 40  N = 20   SIGMA =  1.488920312974229
</TD></TR>
<TR valign=top><TD colspan=2>
<B>RHO = .5</B> </TD></TR><TR valign=top><TD width=4%>&nbsp;</TD><TD>
M = 60  N = 30   SIGMA =  1.488920697912116
</TD></TR>
<TR><TD colspan=2>
:strut.mat:
</TD></TR>
<TR><TD colspan=2>
// Structure problem, Forsythe, Malcolm and Moler, p. 62
</TD></TR>
<TR valign=top><TD width=4% nowrap>
<B>s =</B> </TD><TD valign=bottom>
<B>sqrt</B>(2)/2;
A = [
</TD></TR>
<TR valign=top><TD width=4% nowrap>
<B></B><B>-s</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=4% nowrap>
<B></B><B>-s</B> </TD><TD valign=bottom>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>. </B><B>-1</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
b = [
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>.</B> </TD><TD valign=bottom>
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
:test1:
</TD></TR>
<TR><TD colspan=2>
// -----------------------------------------------------------------
// start a new log file
sh rm <B>-fv</B> log.txt
<B>diary</B>(&#146;log.txt&#146;)
// -----------------------------------------------------------------
titles=[&#146;GNP deflator&#146;
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>&#146;GNP</B> </TD><TD valign=bottom>
<BR>.Unemployment&#146; 
<BR>.Armed Force &#146;
</TD></TR>
<TR valign=top><TD colspan=2>
<B>&#146;Population</B> <!-- Consumed .TP -->
<BR>
<B>&#146;Year</B> <!-- Consumed .TP -->
<BR>
<B>&#146;Employment</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
data = &#46;&#46;&#46;
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>[ 83.0</B> </TD><TD valign=bottom>
234.289  235.6  159.0  107.608  1947  60.323
<TABLE width=100% cellpadding=3><!-- tsb: 234.289  235.6  159.0  107.608  1947  60.323
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>88.5</B> </TD><TD valign=bottom>
259.426  232.5  145.6  108.632  1948  61.122
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>88.2</B> </TD><TD valign=bottom>
258.054  368.2  161.6  109.773  1949  60.171
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>89.5</B> </TD><TD valign=bottom>
284.599  335.1  165.0  110.929  1950  61.187
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>96.2</B> </TD><TD valign=bottom>
328.975  209.9  309.9  112.075  1951  63.221
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>98.1</B> </TD><TD valign=bottom>
346.999  193.2  359.4  113.270  1952  63.639
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>99.0</B> </TD><TD valign=bottom>
365.385  187.0  354.7  115.094  1953  64.989
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>100.0</B> </TD><TD valign=bottom>
363.112  357.8  335.0  116.219  1954  63.761
<TABLE width=100% cellpadding=3><!-- tsb: 363.112  357.8  335.0  116.219  1954  63.761
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B>101.2</B> </TD><TD valign=bottom>
397.469  290.4  304.8  117.388  1955  66.019
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>104.6</B> </TD><TD valign=bottom>
419.180  282.2  285.7  118.734  1956  67.857
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>108.4</B> </TD><TD valign=bottom>
442.769  293.6  279.8  120.445  1957  68.169
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>110.8</B> </TD><TD valign=bottom>
444.546  468.1  263.7  121.950  1958  66.513
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>112.6</B> </TD><TD valign=bottom>
482.704  381.3  255.2  123.366  1959  68.655
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>114.2</B> </TD><TD valign=bottom>
502.601  393.1  251.4  125.368  1960  69.564
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>115.7</B> </TD><TD valign=bottom>
518.173  480.6  257.2  127.852  1961  69.331
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>116.9</B> </TD><TD valign=bottom>
554.894  400.7  282.7  130.081  1962  70.551];
short
X = data;
[n,p] = <B>size</B>(X)
mu = <B>ones</B>(1,n)*X/n
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>X = X - </B><B>ones</B>(n,1)*mu; </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
X = <B>X/diag</B>(<B>sqrt</B>(<B>diag</B>(X&#146;*X)))
corr = X&#146;*X
y = <B>data</B>(:,p); X = <B>[ones</B>(y) <B>data</B>(:,1:p-1)];
long e
beta = X\y
expected = [ &#46;&#46;&#46;
<B>-3.482258634594421D</B>+03
1.506187227124484D-02
<B>-3.581917929257409D-02</B>
<B>-2.020229803816908D-02</B>
<B>-1.033226867173703D-02</B>
<B>-5.110410565317738D-02</B>
1.829151464612817D+00
]
<B>display</B>(&#146;EXPE and BETA should be the same&#146;)
</TD></TR>
<TR><TD colspan=2>
:tryall:
</TD></TR>
<TR><TD colspan=2>
<B>diary</B>(&#146;log.txt&#146;)
<B>a=magic</B>(8)
n=3
<B>exec</B>(&#146;avg&#146;)
<B>b=random</B>(8,8)
<B>exec</B>(&#146;cdiv&#146;)
<B>exec</B>(&#146;exp&#146;)
<B>exec</B>(&#146;four&#146;)
<B>exec</B>(&#146;gs&#146;)
<B>exec</B>(&#146;jacobi&#146;)
// jacstep
<B>exec</B>(&#146;kron&#146;)
<B>exec</B>(&#146;lanczos&#146;)
// lanstep
<B>exec</B>(&#146;longley&#146;)
<B>exec</B>(&#146;mgs&#146;)
<B>exec</B>(&#146;net&#146;)
<B>exec</B>(&#146;pascal&#146;)
<B>exec</B>(&#146;pdq&#146;)
// pdqstep
<B>exec</B>(&#146;pop&#146;)
<B>exec</B>(&#146;qr&#146;)
// qrstep
<B>exec</B>(&#146;rho&#146;)
<B>exec</B>(&#146;rosser&#146;)
// rot
<B>exec</B>(&#146;rqi&#146;)
<B>exec</B>(&#146;setup&#146;)
<B>exec</B>(&#146;sigma&#146;)
<B>exec</B>(&#146;strut.mat&#146;)
<B>exec</B>(&#146;w5&#146;)
<B>exec</B>(&#146;rogers.exec
<B>exec</B>(&#146;rogers.load
</TD></TR>
<TR><TD colspan=2>
:w5:
</TD></TR>
<TR><TD colspan=2>
w5 = [
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=4%>
1.
</TD><TD>
1. 0. 0. 0.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=4% nowrap>
<B></B><B>-10</B>. </TD><TD valign=bottom>
1.      1.      0.      0.
<TABLE width=100% cellpadding=3><!-- tsb: 1.      1.      0.      0.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
40.
</TD><TD>
0. 1. 1. 0.
</TD></TR>
<TR></TR></TABLE><!-- .IP 205. 4 -->
</TD></TR>
<TR></TR></TABLE><TABLE cellpadding=3>
<TR valign=top><TD width=4%>
205.
</TD><TD>
0. 0. 1. 1.
<TABLE width=100% cellpadding=3><!-- tsb: 0. 0. 1. 1.
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=4%>
024.
</TD><TD>
0. 0. 0. <B>-4</B>.
]
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>mat88 (3m_matrix)</TD> <TD align=right width=33%><I>May 08, 2021</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from e082233e-8c89-4f01-96ad-b55193cd5e99 using man macros.</FONT>
<br><br><center><img src="images/mat88.gif"></center>
</div>
</div>
</body>
</HTML>
