$BLOCK COMMENT -file matz.3.man
NAME
      matz(3f) - [M_matrix] reads or writes in internal stack
 
SYNOPSIS
    subroutine matz(ar,ai,lda,m,n,name,job)

      double precision ar(lda,*),ai(lda,*)
      integer lda,m,n
      character*(*) name
      integer :: ,job

DESCRIPTION

   Routine to be called by user programs to transfer matrices
   to and from the MAT88 interpreter.

OPTIONS

   ar,ai   working array of size N*LDA. Contains the A matrix
           If A is real ai is null. 
           A is an M x N matrix, stored in an array with leading
           dimension LDA.
   lda     number of rows in the calling program
   name    character string; name of the mat88 variable.
   job     specify type and direction of matrix transfer
           
            job= 0  mat88   -> fortran , real matrix
            job= 1  fortran -> mat88   , real matrix
            job=10  mat88   -> fortran , complex matrix
            job=11  fortran -> mat88   , complex matrix

$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
subroutine matz(ar,ai,lda,m,n,name,job)
use M_matrix, only :  mat88
use M_matrix, only :  ml_stackg
use M_matrix, only :  mat_stackp
use M_matrix, only :  mat_err
integer               :: lda
double precision ar(lda,*),ai(lda,*)
integer,intent(inout) :: m,n
character(len=*)      :: name
integer               :: job
 
!include 'stack.h'
integer,parameter     :: nsiz=4
integer               :: iadr,sadr
integer               :: il,it,l,l4,lec,srhs,id(nsiz)
!
   iadr(l)=l+l-1
   sadr(l)=(l/2)+1
!
   it=0
   if(job.ge.10) it=1
   lec=job-10*it
!
   lon=0
   lon1=len(name)
   do i=1,lon1
      if(name(i:i).eq.char(0)) exit
      lon=lon+1
   enddo
   if((lon1.gt.0).and.(lon1.lt.lon)) then
      ln=lon1
   else
      ln=lon
   endif
   ln=min(nlgh,ln)
   call str2buf(id,name(1:ln),4)
   srhs=rhs
   rhs=0
!
   if(lec.ge.1) goto 10
!
! read   : from mat88 stack -> fortran variable ar
! -------
!
   fin=-1
   call ml_stackg(id)
   if (err .gt. 0) return
   if (fin .eq. 0) then
      call putid(ids(1,pt+1),id)
      call mat_err(4)
      return
   endif
   il=iadr(lstk(fin))
   if(istk(il).ne.1.or.istk(il+3).ne.it) call mat_err(44)
   if(err.gt.0) return
   m=istk(il+1)
   n=istk(il+2)
   l=sadr(il+4)
   call dmcopy(stk(l),m,ar,lda,m,n)
   if(it.eq.1) call dmcopy(stk(l+m*n),m,ai,lda,m,n)
   goto 99
!
! write   : fortran -> mat88
! --------
!
10 continue
   if(top+2.ge.bot) then
      call mat_err(18)
      return
   endif
   top=top+1
   il=iadr(lstk(top))
   l=sadr(il+4)
   err=l+m*n*(it+1)-lstk(bot)
   if(err.gt.0) then
      call mat_err(17)
      return
   endif
   istk(il)=1
   istk(il+1)=m
   istk(il+2)=n
   istk(il+3)=it
!
   call dmcopy(ar,lda,stk(l),m,m,n)
   if(it.eq.1) call dmcopy(ai,lda,stk(l+m*n),m,m,n)
   lstk(top+1)=l+m*n*(it+1)
   l4=lct(4)
   lct(4)=-1
   call mat_stackp(id,0)
   lct(4)=l4
   if(err.gt.0) return
   goto 99
!
99 continue
   rhs=srhs
end subroutine matz
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
program demo_matz
doubleprecision a(10,10),x(10,10)
integer ida(4),idx(4)
integer :: lda=10
data ida/'a',' ',' ',' '/, idx/'x',' ',' ',' '/
   call m_88(0,'')
   n = 6
   do j = 1, n
      do i = 1, n
         a(i,j) = iabs(i-j)
      enddo
   enddo
   call matz(a,lda,n,n,ida,1)
   !!if (ierr .ne. 0) goto ...
   call mat88(1,'')
   call matz(x,lda,n,n,idx,0)
   !!if (ierr .ne. 0) goto ...

!   When this program is executed, the call to MAT88(0) produces the
!   MAT88 greeting, then waits for input. The command
!            quit
!   sends control back to our example program. The matrix A is
!   generated by the program and sent to the stack by the first call
!   to MATZ. The call to MAT88(1) produces the MAT88(1) prompt. Then
!   the statements
!            X = inv(A)
!            quit
!
!   will invert our matrix, put the result on the stack and go back
!   to our program. The second call to MATZ will retrieve X.

!   By the way, this matrix X is interesting. Take a look at
!   round(2*(n-1)*X).
end program demo_matz
