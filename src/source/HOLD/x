40c40,48
<    Changes per John S. Urban:
---
>    Changes per John S. Urban: see change log and git(1) history
> Originally based on a routine called MATLAB, although heavily modified
> since. The original stated ...
> 
>    MATLAB stands for MATrix LABoratory.  It is a FORTRAN package developed
>    by Argonne National Laboratories for in-house use.  It provides
>    comprehensive vector and tensor operations in a package which may be
>    programmed, either through a macro language or through execution of
>    script files.
42,69c50,54
<    Converted to do most I/O via journal() so can be used with my codes
<    more easily. Also allow additional comment indicator (# in column 1)
<    so can read back in trail files made by DIARY command.
< 
<    Added command history editor command ";"
< 
<    Made call to system shell with SH command
< 
<    Made case-sensitive
< 
<    Made it take directives from string on routine call
< 
<    Allow longer filenames
< 
<    Partly converted program away from use of HOLLERITH towards use of ADE
<    or maybe even character variables (enough to be able to use GNU g95
<    compiler, anyway). Might have to change the way I make a letter
<    "hollerith" on non little-endian non-32bit platforms.
< 
<    changed RETURN command to QUIT
< 
<    built-in help document
< 
<    Sample compile commands:
< 
<       g77 --no-backslash matrix.f90
<       g95 matrix.f90
<       gfortran -fno-range-check matrix.f90
---
>    Matlab is reentrant and recursive.  Functions supported include (but
>    are not by any means limited to) sin, cos, tan, arcfunctions, upper
>    triangular, lower triangular, determinants, matrix multiplication,
>    identity, Hilbert matrices, eigenvalues and eigenvectors, matrix
>    roots and products, inversion and so on and so forth.
70a56,77
>    The file available on the bulletin board as Matlab.arc contains an
>    Amiga-ized executable copy of MATLAB and the online help file, as
>    well as this intro.
> 
>    If you want the source code (over 300K) and a manual, or if your
>    bulletin board only has this message and not the package, send $5.00
>    and a 3.5" disk to:
> 
>                               Jim Locker
>                               4443 N. Hyland Ave.
>                               Dayton, OH 45424
> 
>    The package is public domain, but of course postage and reproduction
>    cost money.  Believe me, this package is a bargain at the price.
>    Please feel free to distribute the package.
> 
>    The source was taken off a VAX 11/780. It ran without modification
>    (except the file handler and some minor error handling) on an Amiga
>    1000 using ABSoft Fortran v2.2.  It will run in 512K environment.
>    I have seen it on IBM mainframes and IBM PCs.
> ================================================================================
>    Changes per John S. Urban: see change log and git(1) history
72a80
> $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
73a82
> use,intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
75c84
< integer,parameter :: BIGMEM=200005
---
> !private
76a86,88
> public mat88_get
> public mat88_put
> public test_suite_M_matrix
79,89c91,186
< character(len=1024),save :: STRINGQ
< integer,save             :: ISTRINGQ
< integer,save             :: INITQ
< !==================================================================================================================================!
< INTEGER,PARAMETER        :: IALF=78
< DOUBLEPRECISION          :: STKR(BIGMEM),STKI(BIGMEM)
< INTEGER                  :: IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
< INTEGER                  :: ALFA(IALF),ALFB(IALF),alflq,CASE
< INTEGER                  :: IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
< INTEGER                  :: DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,RTE,WTE,FE
< INTEGER                  :: SYM,SYN(4),BUF(1024),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
---
> character(len=1024),save :: G_STRING
> integer,save             :: G_ISTRING
> integer,save             :: G_INIT
> !==================================================================================================================================!
> integer                  :: G_DEBUG_LEVEL       ! select which debug messages to display. zero (0) is off
> logical                  :: G_FILE_OPEN_ERROR   ! flag whether file open error occurred or not
> integer,parameter        :: G_eol=99
> integer                  :: G_LINECOUNT(4)      ! [1] lines displayed since count started
>                                                 ! [2] line limit before warning (ie. page length+1)
>                                                 ! [3]
>                                                 ! [4]
> integer                  :: G_ERR, G_FMT, G_LIN(1024), G_LPT(6), G_HIO, G_RIO, G_RTE, G_WTE
> integer                  :: G_SYM, G_BUF(1024), G_CHRA, G_FLOP_COUNTER(2), G_FUN, G_LHS, G_RHS, G_RAN(2)
> integer                  :: G_FIN
> 
> !==================================================================================================================================!
> integer,parameter        :: G_MAX_NUMBER_OF_NAMES=480
> integer,parameter        :: G_MAX_NAME_LENGTH=32  ! <WARNING> just began changing this to a constant
> integer                  :: G_IDS(G_MAX_NAME_LENGTH,32)
> integer                  :: G_PSTK(32), G_RSTK(32), G_PSIZE, G_PT, G_PTZ
> integer,parameter        :: G_PAD(*)=[36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36]
> integer                  :: G_SYN(G_MAX_NAME_LENGTH)
> integer                  :: G_IDSTK(G_MAX_NAME_LENGTH, G_MAX_NUMBER_OF_NAMES)
> integer                  :: G_LSTK(G_MAX_NUMBER_OF_NAMES)
> integer                  :: G_MSTK(G_MAX_NUMBER_OF_NAMES)
> integer                  :: G_NSTK(G_MAX_NUMBER_OF_NAMES)
> integer                  :: G_BOT, G_TOP
> integer                  :: G_VSIZE
> !   Two large real arrays, G_STKR and G_STKI (for real and imaginary parts), are used to store all
> !   the matrices. Four integer arrays (G_IDSTK, G_MSTK, G_NSTK, G_LSTK) are used to store the names,
> !   the row and column dimensions, and the pointers into the real
> !   stacks. The following diagram illustrates this storage scheme.
> !
> !    TOP        IDSTK     MSTK NSTK LSTK               STKR      STKI
> !     --      -- -- -- --   --   --   --              --------   --------
> !    |  |--->|  |  |  |  | |  | |  | |  |----------->|        | |        |
> !     --      -- -- -- --   --   --   --              --------   --------
> !            |  |  |  |  | |  | |  | |  |            |        | |        |
> !             -- -- -- --   --   --   --              --------   --------
> !                  .         .    .    .                  .          .
> !                  .         .    .    .                  .          .
> !                  .         .    .    .                  .          .
> !             -- -- -- --   --   --   --              --------   --------
> !    BOT     |  |  |  |  | |  | |  | |  |            |        | |        |
> !     --      -- -- -- --   --   --   --              --------   --------
> !    |  |--->| X|  |  |  | | 2| | 1| |  |----------->|  3.14  | |  0.00  |
> !     --      -- -- -- --   --   --   --              --------   --------
> !            | A|  |  |  | | 2| | 2| |  |---------   |  0.00  | |  1.00  |
> !             -- -- -- --   --   --   --          \   --------   --------
> !            | E| P| S|  | | 1| | 1| |  |-------   ->| 11.00  | |  0.00  |
> !             -- -- -- --   --   --   --        \     --------   --------
> !            | F| L| O| P| | 1| | 2| |  |------  \   | 21.00  | |  0.00  |
> !             -- -- -- --   --   --   --       \  \   --------   --------
> !            | E| Y| E|  | |-1| |-1| |  |---    \ |  | 12.00  | |  0.00  |
> !             -- -- -- --   --   --   --    \   | |   --------   --------
> !            | R| A| N| D| | 1| | 1| |  |-   \  | |  | 22.00  | |  0.00  |
> !             -- -- -- --   --   --   --  \  |  \ \   --------   --------
> !                                         |  \   \ ->| 1.E-15 | |  0.00  |
> !                                         \   \   \   --------   --------
> !                                          \   \   ->|  0.00  | |  0.00  |
> !                                           \   \     --------   --------
> !                                            \   \   |  0.00  | |  0.00  |
> !                                             \   \   --------   --------
> !                                              \   ->|  1.00  | |  0.00  |
> !                                               \     --------   --------
> !                                                --->| URAND  | |  0.00  |
> !                                                     --------   --------
> !
> !   The top portion of the stack is used for temporary variables
> !   and the bottom portion for saved variables. The figure shows the
> !   situation after the line
> !
> !      A = <11,12; 21,22>,  x = <3.14, sqrt(-1)>'
> !
> !   has been processed. The four permanent names, EPS, FLOP, RAND
> !   and EYE, occupy the last four positions of the variable stacks.
> !   RAND has dimensions 1 by 1, but whenever its value is requested,
> !   a random number generator is used instead. EYE has dimensions -1
> !   by -1 to indicate that the actual dimensions must be determined
> !   later by context. The two saved variables have dimensions 2 by 2
> !   and 2 by 1 and so take up a total of 6 locations.
> !
> !   Subsequent statements involving A and x will result in
> !   temporary copies being made in the top of the stack for use in
> !   the actual calculations. Whenever the top of the stack reaches
> !   the bottom, a message indicating memory has been exceeded is
> !   printed, but the current variables are not affected.
> !
> !   This modular structure makes it possible to implement MAT88
> !   on a system with a limited amount of memory. The object code for
> !   the MATFN's and the LINPACK-EISPACK subroutines is rarely needed.
> !   Although it is not standard, many Fortran operating systems
> !   provide some overlay mechanism so that this code is brought into
> !   the main memory only when required. The variables, which occupy
> !   a relatively small portion of the memory, remain in place, while
> !   the subroutines which process them are loaded a few at a time.
91,93c188,189
< !                                       0---------1---------2---------3---------4--------- 5---------6---------7-------
< !                                       01234567890123456789012345678901234567890123456789 0123456789012345678901234567
< character(len=ialf),parameter ::  CH_A='0123456789abcdefghijklmnopqrstuvwxyz ();:+-*/\=.,''<>ABCDEFGHIJKLMNOPQRSTUVWXYZ'
---
> integer,parameter        :: G_BIGMEM=200005
> doubleprecision          :: G_STKR(G_BIGMEM), G_STKI(G_BIGMEM)
95,96c191,192
< ! ALTERNATE CHARACTER SET
< !                                       0---------1---------2---------3---------4---------5---------6---------7-------
---
> integer,parameter        :: G_CHARSET_SIZE=78      ! number of characters in character set
> ! CHARACTER SET                                    0---------1---------2---------3---------4---------5---------6---------7-------
98,100c194,204
< character(len=ialf),parameter ::  CH_B='0123456789abcdefghijklmnopqrstuvwxyz {};|+-*/$=@,"[]ABCDEFGHIJKLMNOPQRSTUVWXYZ'
< !==================================================================================================================================!
< integer,parameter :: eol=99
---
> character(len=G_CHARSET_SIZE),parameter ::  G_DEFINE_CHARSET=&
>                                                  &"0123456789abcdefghijklmnopqrstuvwxyz ();:+-*/\=.,'<>ABCDEFGHIJKLMNOPQRSTUVWXYZ"
> 
> ! ALTERNATE CHARACTER SET                          0---------1---------2---------3---------4---------5---------6---------7-------
> !                                                  012345678901234567890123456789012345678901234567890123456789012345678901234567
> character(len=G_CHARSET_SIZE),parameter ::  G_DEFINE_ALT_CHARSET=&
>                                                  &'0123456789abcdefghijklmnopqrstuvwxyz {};|+-*/$=@,"[]ABCDEFGHIJKLMNOPQRSTUVWXYZ'
> 
> integer                  :: G_CHARSET(G_CHARSET_SIZE)  ! G_DEFINE_CHARSET converted to "Hollerith" values
> integer                  :: G_ALT_CHARSET(G_CHARSET_SIZE)  ! G_DEFINE_ALT_CHARSET converted to "Hollerith" values
> 
105c209,210
< $BLOCK COMMENT -file mat88.3m_matrix.man
---
> $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> $COMMENT -file mat88.3m_matrix.man
108a214
> 
112c218
<    character(len=*),intent(in) :: cmd)
---
>    character(len=*),intent(in) :: cmd
131,133c237,239
<             0 For ordinary first entry with reads from stdin
<            -1 negative for silent initialization (ignores CMD)
<             1 positive for subsequent entries, enter command mode
---
>             0  initial entry. with reads from stdin
>            -1  for silent initialization (ignores CMD)
>             1  perform CMD, and enter command mode, subsequently
135c241
<             2 subsequent entry , return after doing CMD
---
>             2  return after doing CMD
138a245
> 
197c304,708
< $BLOCK
---
> 
>  Example inputs
> avg:for i = 2:2:n, for j = 2:2:n, t = (a(i-1,j-1)+a(i-1,j)+a(i,j-1)+a(i,j))/4; ...
>      avg:   a(i-1,j-1) = t; a(i,j-1) = t; a(i-1,j) = t; a(i,j) = t;
> 
>      cdiv:// ======================================================
>      cdiv:// cdiv
>      cdiv:a=sqrt(random(8)
>      cdiv:   ar = real(a); ai = imag(a); br = real(b); bi = imag(b);
>      cdiv:   p = bi/br;
>      cdiv:   t = (ai - p*ar)/(br + p*bi);
>      cdiv:   cr = p*t + ar/br;
>      cdiv:   ci = t;
>      cdiv:   p2 = br/bi;
>      cdiv:   t2 = (ai + p2*ar)/(bi + p2*br);
>      cdiv:   ci2 = p2*t2 - ar/bi;
>      cdiv:   cr2 = t2;
>      cdiv:   s = abs(br) + abs(bi);
>      cdiv:   ars = ar/s;
>      cdiv:   ais = ai/s;
>      cdiv:   brs = br/s;
>      cdiv:   bis = bi/s;
>      cdiv:   s = brs**2 + bis**2;
>      cdiv:   cr3 = (ars*brs + ais*bis)/s;
>      cdiv:   ci3 = (ais*brs - ars*bis)/s;
>      cdiv:   <cr ci; cr2 ci2; cr3 ci3>
>      cdiv:// ======================================================
> 
>      exp:t = 0*x + eye; s = 0*eye(x); n = 1;
>      exp:while abs(s+t-s) > 0, s = s+t, t = x*t/n, n = n + 1
> 
>      four:n
>      four:pi = 4*atan(1);
>      four:i = sqrt(-1);
>      four:w = exp(2*pi*i/n);
>      four:F = <>;
>      four:for k = 1:n, for j = 1:n, F(k,j) = w**((j-1)*(k-1));
>      four:F = F/sqrt(n);
>      four:G_CHARSET = r*pi;
>      four:rho = exp(i*G_CHARSET);
>      four:S = log(rho*F)/i - G_CHARSET*EYE;
>      four:serr = norm(imag(S),1);
>      four:S = real(S);
>      four:serr = serr + norm(S-S',1)
>      four:S = (S + S')/2;
>      four:ferr = norm(F-exp(i*S),1)
> 
>      gs:for k = 1:n, for j = 1:k-1, d = x(k,:)*x(j,:)'; x(k,:) = x(k,:) - d*x(j,:); ...
>      gs:   end, s = norm(x(k,:)), x(k,:) = x(k,:)/s;
> 
>      jacobi:<n, n> = size(A);
>      jacobi:X = eye(n);
>      jacobi:anorm = norm(A,'fro');
>      jacobi:cnt = 1;
>      jacobi:while cnt > 0,...
>      jacobi:  cnt = 0;...
>      jacobi:  for p = 1:n-1,...
>      jacobi:    for q = p+1:n,...
>      jacobi:      if anorm + abs(a(p,q)) > anorm,...
>      jacobi:        cnt = cnt + 1;...
>      jacobi:        exec('jacstep');...
>      jacobi:      end,...
>      jacobi:    end,...
>      jacobi:  end,...
>      jacobi:  display(rat(A)),...
>      jacobi:end
> 
>      jacstep:        d = (a(q,q)-a(p,p))*0.5/a(p,q);
>      jacstep:        t = 1/(abs(d)+sqrt(d*d+1));
>      jacstep:        if d < 0, t = -t; end;
>      jacstep:        c = 1/sqrt(1+t*t);  s = t*c;
>      jacstep:        R = eye(n); r(p,p)=c; r(q,q)=c; r(p,q)=s; r(q,p)=-s;
>      jacstep:        X = X*R;
>      jacstep:        A = R'*A*R;
> 
>      kron://  C = Kronecker product of A and B
>      kron:<m, n> = size(A);
>      kron:for i = 1:m, ...
>      kron:   ci = a(i,1)*B; ...
>      kron:   for j = 2:n, ci = <ci a(i,j)*B>; end ...
>      kron:   if i = 1, C = ci; else, C = <C; ci>;
> 
>      lanczos:<n,n> = size(A);
>      lanczos:q1 = rand(n,1);
>      lanczos:ort
>      lanczos:G_CHARSET = <>; beta = <>;
>      lanczos:q = q1/norm(q1); r = A*q(:,1);
>      lanczos:for j = 1:n, exec('lanstep',0);
> 
>      lanstep:G_CHARSET(j) = q(:,j)'*r;
>      lanstep:r = r - G_CHARSET(j)*q(:,j);
>      lanstep:if ort <> 0, for k = 1:j-1, r = r - r'*q(:,k)*q(:,k);
>      lanstep:beta(j) = norm(r);
>      lanstep:q(:,j+1) = r/beta(j);
>      lanstep:r = A*q(:,j+1) - beta(j)*q(:,j);
>      lanstep:if j > 1, T = diag(beta(1:j-1),1); T = diag(G_CHARSET) + T + T'; eig(T)
> 
>      mgs:for k = 1:n, s = norm(x(k,:)), x(k,:) = x(k,:)/s; ...
>      mgs:   for j = k+1:n, d = x(j,:)*x(k,:)'; x(j,:) = x(j,:) - d*x(k,:);
> 
>      net:C = <
>      net:1   2   15  .   .   .
>      net:2   1   3   .   .   .
>      net:3   2   4   11  .   .
>      net:4   3   5   .   .   .
>      net:5   4   6   7   .   .
>      net:6   5   8   .   .   .
>      net:7   5   9   30  .   .
>      net:8   6   9   10  11  .
>      net:9   7   8   30  .   .
>      net:10  8   12  30  31  34
>      net:11  3   8   12  13  .
>      net:12  10  11  34  36  .
>      net:13  11  14  .   .   .
>      net:14  13  15  16  38  .
>      net:15  1   14  .   .   .
>      net:16  14  17  20  35  37
>      net:17  16  18  .   .   .
>      net:18  17  19  .   .   .
>      net:19  18  20  .   .   .
>      net:20  16  19  21  .   .
>      net:21  20  22  .   .   .
>      net:22  21  23  .   .   .
>      net:23  22  24  35  .   .
>      net:24  23  25  39  .   .
>      net:25  24  .   .   .   .
>      net:26  27  33  39  .   .
>      net:27  26  32  .   .   .
>      net:28  29  32  .   .   .
>      net:29  28  30  .   .   .
>      net:30  7   9   10  29  .
>      net:31  10  32  .   .   .
>      net:32  27  28  31  34  .
>      net:33  26  34  .   .   .
>      net:34  10  12  32  33  35
>      net:35  16  23  34  36  .
>      net:36  12  35  38  .   .
>      net:37  16  38  .   .   .
>      net:38  14  36  37  .   .
>      net:39  24  26  .   .   .
>      net:>;
>      net:<n, m> = size(C);
>      net:A = 0*ones(n,n);
>      net:for i=1:n, for j=2:m, k=c(i,j); if k>0, a(i,k)=1;
>      net:check = norm(A-A',1), if check > 0, quit
>      net:<X,D> = eig(A+eye);
>      net:D = diag(D);  D = D(n:-1:1)
>      net:X = X(:,n:-1:1);
>      net:<x(:,1)/sum(x(:,1)) x(:,2) x(:,3) x(:,19)>
> 
>      pascal://Generate next Pascal matrix
>      pascal:<k,k> = size(L);
>      pascal:k = k + 1;
>      pascal:L(k,1:k) = <L(k-1,:) 0> + <0 L(k-1,:)>;
> 
>      pdq:G_CHARSET = <>; beta = 0; q = <>; p = p(:,1)/norm(p(:,1));
>      pdq:t = A'*p(:,1);
>      pdq:G_CHARSET(1) = norm(t);
>      pdq:q(:,1) = t/G_CHARSET(1);
>      pdq:X = p(:,1)*(G_CHARSET(1)*q(:,1))'
>      pdq:e(1) = norm(A-X,1)
>      pdq:for j = 2:r, exec('pdqstep',ip); ...
>      pdq:   X = X + p(:,j)*(G_CHARSET(j)*q(:,j)+beta(j)*q(:,j-1))', ...
>      pdq:   e(j) = norm(A-X,1)
> 
>      pdqstep:t = A*q(:,j-1) - G_CHARSET(j-1)*p(:,j-1);
>      pdqstep:   if ort>0, for i = 1:j-1, t = t - t'*p(:,i)*p(:,i);
>      pdqstep:beta(j) = norm(t);
>      pdqstep:p(:,j) = t/beta(j);
>      pdqstep:t = A'*p(:,j) - beta(j)*q(:,j-1);
>      pdqstep:   if ort>0, for i = 1:j-1, t = t - t'*q(:,i)*q(:,i);
>      pdqstep:G_CHARSET(j) = norm(t);
>      pdqstep:q(:,j) = t/G_CHARSET(j);
> 
>      pop:y = < 75.995   91.972  105.711  123.203   ...
>      pop:     131.669  150.697  179.323  203.212>'
>      pop:t = < 1900:10:1970 >'
>      pop:t = (t - 1940*ones(t))/40;   <t y>
>      pop:n = 8;  A(:,1) = ones(t);  for j = 2:n, A(:,j) = t .* A(:,j-1);
>      pop:A
>      pop:c = A\y
> 
>      qr:scale = s(m);
>      qr:sm = s(m)/scale; smm1 = s(m-1)/scale; emm1 = e(m-1)/scale;
>      qr:sl = s(l)/scale; el = e(l)/scale;
>      qr:b = ((smm1 + sm)*(smm1 - sm) + emm1**2)/2;
>      qr:c = (sm*emm1)**2;
>      qr:shift = sqrt(b**2+c); if b < 0, shift = -shift;
>      qr:shift = c/(b + shift)
>      qr:f = (sl + sm)*(sl-sm) - shift
>      qr:g = sl*el
>      qr:for k = l: m-1, exec('qrstep',ip)
>      qr:e(m-1) = f
> 
>      qrstep:exec('rot');
>      qrstep:if k <> l, e(k-1) = f
>      qrstep:f = cs*s(k) + sn*e(k)
>      qrstep:e(k) = cs*e(k) - sn*s(k)
>      qrstep:g = sn*s(k+1)
>      qrstep:s(k+1) = cs*s(k+1)
>      qrstep:exec('rot');
>      qrstep:s(k) = f
>      qrstep:f = cs*e(k) + sn*s(k+1)
>      qrstep:s(k+1) = -sn*e(k) + cs*s(k+1)
>      qrstep:g = sn*e(k+1)
>      qrstep:e(k+1) = cs*e(k+1)
> 
>      rho://Conductivity example.
>      rho://Parameters ---
>      rho:   rho       //radius of cylindrical inclusion
>      rho:   n         //number of terms in solution
>      rho:   m         //number of boundary points
>      rho://initialize operation counter
>      rho:   flop = <0 0>;
>      rho://initialize variables
>      rho:   m1 = round(m/3);   //number of points on each straight edge
>      rho:   m2 = m - m1;       //number of points with Dirichlet conditions
>      rho:   pi = 4*atan(1);
>      rho://generate points in Cartesian coordinates
>      rho:   //right hand edge
>      rho:   for i = 1:m1, x(i) = 1; y(i) = (1-rho)*(i-1)/(m1-1);
>      rho:   //top edge
>      rho:   for i = m2+1:m, x(i) = (1-rho)*(m-i)/(m-m2-1); y(i) = 1;
>      rho:   //circular edge
>      rho:   for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); ...
>      rho:      x(i) = 1-rho*sin(t);  y(i) = 1-rho*cos(t);
>      rho://convert to polar coordinates
>      rho:   for i = 1:m-1, th(i) = atan(y(i)/x(i));  ...
>      rho:      r(i) = sqrt(x(i)**2+y(i)**2);
>      rho:   th(m) = pi/2;  r(m) = 1;
>      rho://generate matrix
>      rho:   //Dirichlet conditions
>      rho:   for i = 1:m2, for j = 1:n, k = 2*j-1; ...
>      rho:      a(i,j) = r(i)**k*cos(k*th(i));
>      rho:   //Neumann conditions
>      rho:   for i = m2+1:m, for j = 1:n, k = 2*j-1; ...
>      rho:      a(i,j) = k*r(i)**(k-1)*sin((k-1)*th(i));
>      rho://generate right hand side
>      rho:   for i = 1:m2, b(i) = 1;
>      rho:   for i = m2+1:m, b(i) = 0;
>      rho://solve for coefficients
>      rho:   c = A$b
>      rho://compute effective conductivity
>      rho:   c(2:2:n) = -c(2:2:n)
>      rho:   sigma = sum(c)
>      rho://output total operation count
>      rho:   ops = flop(2)
> 
>      rogers.exec:exec('d.boug');                        // reads data
>      rogers.exec:<g,k> = size(p);               // p is matrix of gene frequencies
>      rogers.exec:wv = ncen/sum(ncen);           // ncen contains population sizes
>      rogers.exec:pbar = wv*p;                   // weighted average of p
>      rogers.exec:p = p - ones(g,1)*pbar;        // deviations from mean
>      rogers.exec:p = sqrt(diag(wv)) * p;        // weight rows of p by sqrt of pop size
>      rogers.exec:h = diag(pbar); h = h*(eye-h); // diagonal contains binomial variance: p*(1-p)
>      rogers.exec:r = p*inv(h)*p'/k;             // normalized covariance matrix
>      rogers.exec:eig(r)'
> 
>      rosser:A  = <
>      rosser:  611.  196. -192.  407.   -8.  -52.  -49.   29.
>      rosser:  196.  899.  113. -192.  -71.  -43.   -8.  -44.
>      rosser: -192.  113.  899.  196.   61.   49.    8.   52.
>      rosser:  407. -192.  196.  611.    8.   44.   59.  -23.
>      rosser:   -8.  -71.   61.    8.  411. -599.  208.  208.
>      rosser:  -52.  -43.   49.   44. -599.  411.  208.  208.
>      rosser:  -49.   -8.    8.   59.  208.  208.   99. -911.
>      rosser:   29.  -44.   52.  -23.  208.  208. -911.   99.  >;
> 
>      rot:// subexec rot(f,g,cs,sn)
>      rot:      rho = g; if abs(f) > abs(g), rho = f;
>      rot:      cs = 1.0; sn = 0.0; z = 1.0;
>      rot:      r = norm(<f g>); if rho < 0, r = -r; r
>      rot:      if r <> 0.0, cs = f/r
>      rot:      if r <> 0.0, sn = g/r
>      rot:      if abs(f) > abs(g), z = sn;
>      rot:      if abs(g) >= abs(f), if cs <> 0, z = 1/cs;
>      rot:      f = r;
>      rot:      g = z;
> 
>      rqi:rho = (x'*A*x)
>      rqi:x = (A-rho*eye)\x;
>      rqi:x = x/norm(x)
> 
>      setup:diary('xxx')
>      setup:!tail -f xxx > /dev/tty1 &
>      setup:!tail -f xxx > /dev/tty2 &
> 
>      sigma:RHO = .5  M = 20  N = 10   SIGMA =  1.488934271883534
>      sigma:RHO = .5  M = 40  N = 20   SIGMA =  1.488920312974229
>      sigma:RHO = .5  M = 60  N = 30   SIGMA =  1.488920697912116
> 
>      strut.mat:// Structure problem, Forsythe, Malcolm and Moler, p. 62
>      strut.mat:s =  sqrt(2)/2;
>      strut.mat:A = <
>      strut.mat:-s  .  .  1  s   .  .  .  .  .  .  .  .  .  .  .  .
>      strut.mat:-s  . -1  . -s   .  .  .  .  .  .  .  .  .  .  .  .
>      strut.mat: . -1  .  .  .   1  .  .  .  .  .  .  .  .  .  .  .
>      strut.mat: .  .  1  .  .   .  .  .  .  .  .  .  .  .  .  .  .
>      strut.mat: .  .  . -1  .   .  .  1  .  .  .  .  .  .  .  .  .
>      strut.mat: .  .  .  .  .   . -1  .  .  .  .  .  .  .  .  .  .
>      strut.mat: .  .  .  . -s -1  .  .  s  1  .  .  .   .  .  .  .
>      strut.mat: .  .  .  .  s   .  1  .  s  .  .  .  .  .  .  .  .
>      strut.mat: .  .  .  .  .   .  . -1 -s  .  .  1  s  .  .  .  .
>      strut.mat: .  .  .  .  .   .  .  . -s  . -1  . -s  .  .  .  .
>      strut.mat: .  .  .  .  .   .  .  .  . -1  .  .  .  1  .  .  .
>      strut.mat: .  .  .  .  .   .  .  .  .  .  1  .  .  .  .  .  .
>      strut.mat: .  .  .  .  .   .  .  .  .  .  . -1  .  .  .  s  .
>      strut.mat: .  .  .  .  .   .  .  .  .  .  .  .  .  . -1 -s  .
>      strut.mat: .  .  .  .  .   .  .  .  .  .  .  . -s -1  .  .  1
>      strut.mat: .  .  .  .  .   .  .  .  .  .  .  .  s  .  1  .  .
>      strut.mat: .  .  .  .  .   .  .  .  .  .  .  .  .  .  . -s -1>;
>      strut.mat:b = <
>      strut.mat: .  .  . 10  .   .  . 15  .  .  .  .  .  .  . 10  .>';
> 
>      test1:// -----------------------------------------------------------------
>      test1:// start a new log file
>      test1:sh rm -fv log.txt
>      test1:diary('log.txt')
>      test1:// -----------------------------------------------------------------
>      test1:titles=<'GNP deflator'
>      test1: 'GNP         '
>      test1: 'Unemployment'
>      test1: 'Armed Force '
>      test1: 'Population  '
>      test1: 'Year        '
>      test1: 'Employment  '>;
>      test1:data = ...
>      test1:< 83.0  234.289  235.6  159.0  107.608  1947  60.323
>      test1:  88.5  259.426  232.5  145.6  108.632  1948  61.122
>      test1:  88.2  258.054  368.2  161.6  109.773  1949  60.171
>      test1:  89.5  284.599  335.1  165.0  110.929  1950  61.187
>      test1:  96.2  328.975  209.9  309.9  112.075  1951  63.221
>      test1:  98.1  346.999  193.2  359.4  113.270  1952  63.639
>      test1:  99.0  365.385  187.0  354.7  115.094  1953  64.989
>      test1: 100.0  363.112  357.8  335.0  116.219  1954  63.761
>      test1: 101.2  397.469  290.4  304.8  117.388  1955  66.019
>      test1: 104.6  419.180  282.2  285.7  118.734  1956  67.857
>      test1: 108.4  442.769  293.6  279.8  120.445  1957  68.169
>      test1: 110.8  444.546  468.1  263.7  121.950  1958  66.513
>      test1: 112.6  482.704  381.3  255.2  123.366  1959  68.655
>      test1: 114.2  502.601  393.1  251.4  125.368  1960  69.564
>      test1: 115.7  518.173  480.6  257.2  127.852  1961  69.331
>      test1: 116.9  554.894  400.7  282.7  130.081  1962  70.551>;
>      test1:short
>      test1:X = data;
>      test1:<n,p> = size(X)
>      test1:mu = ones(1,n)*X/n
>      test1:X = X - ones(n,1)*mu;  X = X/diag(sqrt(diag(X'*X)))
>      test1:corr = X'*X
>      test1:y = data(:,p); X = <ones(y) data(:,1:p-1)>;
>      test1:long e
>      test1:beta = X\y
>      test1:expected = < ...
>      test1:   -3.482258634594421D+03
>      test1:    1.506187227124484D-02
>      test1:   -3.581917929257409D-02
>      test1:   -2.020229803816908D-02
>      test1:   -1.033226867173703D-02
>      test1:   -5.110410565317738D-02
>      test1:    1.829151464612817D+00
>      test1:>
>      test1:disp('EXPE and BETA should be the same')
> 
>      tryall:diary('log.txt')
>      tryall:a=magic(8)
>      tryall:n=3
>      tryall:exec('avg')
>      tryall:b=random(8,8)
>      tryall:exec('cdiv')
>      tryall:exec('exp')
>      tryall:exec('four')
>      tryall:exec('gs')
>      tryall:exec('jacobi')
>      tryall:// jacstep
>      tryall:exec('kron')
>      tryall:exec('lanczos')
>      tryall:// lanstep
>      tryall:exec('longley')
>      tryall:exec('mgs')
>      tryall:exec('net')
>      tryall:exec('pascal')
>      tryall:exec('pdq')
>      tryall:// pdqstep
>      tryall:exec('pop')
>      tryall:exec('qr')
>      tryall:// qrstep
>      tryall:exec('rho')
>      tryall:exec('rosser')
>      tryall:// rot
>      tryall:exec('rqi')
>      tryall:exec('setup')
>      tryall:exec('sigma')
>      tryall:exec('strut.mat')
>      tryall:exec('w5')
>      tryall:exec('rogers.exec
>      tryall:exec('rogers.load
> 
>      w5:w5    = <
>      w5:          1.          1.          0.          0.          0.
>      w5:        -10.          1.          1.          0.          0.
>      w5:         40.          0.          1.          1.          0.
>      w5:       -205.          0.          0.          1.          1.
>      w5:       1024.          0.          0.          0.         -4.
>      w5:         >
> $END
201c712
< $@(#) M_matrix::mat88(3f): initialize and/or pass commands to matrix laboratory interpreter
---
> ! ident_1="@(#)M_matrix::mat88(3f): initialize and/or pass commands to matrix laboratory interpreter"
207,210c718,721
< integer,save                :: EPS(4)=   [14,25,28,36]
< integer,save                :: FLOPS(4)= [15,21,24,25]
< integer,save                :: EYE(4)=   [14,34,14,36]
< integer,save                :: RAND(4)=  [27,10,23,13]
---
> integer,save                :: EPS(G_MAX_NAME_LENGTH)=   [14,25,28,36,G_PAD(:)]
> integer,save                :: FLOPS(G_MAX_NAME_LENGTH)= [15,21,24,25,G_PAD(:)]
> integer,save                :: EYE(G_MAX_NAME_LENGTH)=   [14,34,14,36,G_PAD(:)]
> integer,save                :: RAND(G_MAX_NAME_LENGTH)=  [27,10,23,13,G_PAD(:)]
226c737
<       STRINGQ=STRING0
---
>    G_STRING=STRING0
228,231c739,742
<       ISTRINGQ=len_trim(STRING0(1:ISTRING0))
<       IF(ISTRINGQ.LE.0.AND.INIT.EQ.2)THEN
<          STRINGQ='quit'
<          ISTRINGQ=4
---
>    G_ISTRING=len_trim(STRING0(1:ISTRING0))
>    IF(G_ISTRING.LE.0.AND.INIT.EQ.2)THEN
>       G_STRING='quit'
>       G_ISTRING=4
233c744
<       INITQ=INIT
---
>    G_INIT=INIT
235,240c746,751
<       IF (INIT .NE. 0 .and. INIT .ne. -1) GOTO 90     ! already initialized
<       RTE = 5                                         ! unit number for terminal input
<       CALL mat_files(RTE,BUF)
<       RIO = RTE                                       ! current file to read commands from
<       WTE = 6                                         ! unit number for terminal  output
<       CALL mat_files(WTE,BUF)
---
>    IF (INIT .eq. 0 .or. INIT .eq. -1) then              ! initialize the routine
>       G_RTE = STDIN                                     ! unit number for terminal input
>       CALL mat_files(G_RTE,G_BUF)
>       G_RIO = G_RTE                                     ! current file to read commands from
>       G_WTE = STDOUT                                    ! unit number for terminal output
>       CALL mat_files(G_WTE,G_BUF)
243,244c754
<          call journal('  < M A T 8 8 >')
<          call journal(' based on MATLAB Version of 05/25/82')
---
>          call journal('< MAT88 > modeled on the MATLAB version of 05/25/82')
247,254c757,761
<       HIO = 11                                        ! UNIT NUMBER FOR HELP FILE
<       CALL mat_files(HIO,BUF)                         ! open HELP FILE
<       RAN(1) = 0                                      ! RANDOM NUMBER SEED
<       LCT(2) = 25                                     ! INITIAL LINE LIMIT
< 
<       alflq = IALF
<       CASE = 0
< !     CASE = 1 for file names in lower case
---
>       G_HIO = 11                                        ! UNIT NUMBER FOR HELP FILE
>       CALL mat_files(G_HIO,G_BUF)                       ! open HELP FILE
>       G_RAN(1) = 0                                      ! RANDOM NUMBER SEED
>       G_LINECOUNT(2) = 25                               ! INITIAL LINE LIMIT
> 
256,257c763,764
<       call mat_str2buf(ch_a,alfa,alflq) ! convert string to hollerith
<       call mat_str2buf(ch_b,alfb,alflq) ! convert string to hollerith
---
>       call mat_str2buf(G_DEFINE_CHARSET,G_CHARSET,G_CHARSET_SIZE)         ! convert string to hollerith
>       call mat_str2buf(G_DEFINE_ALT_CHARSET,G_ALT_CHARSET,G_CHARSET_SIZE) ! convert string to hollerith
260,268c767,774
<       VSIZE = BIGMEM
<       LSIZE = 48
<       PSIZE = 32
<       BOT = LSIZE-3
<       CALL mat_wset(5,0.0D0,0.0D0,STKR(VSIZE-4),STKI(VSIZE-4),1)
<       CALL mat_putid(IDSTK(1,LSIZE-3),EPS)
<       LSTK(LSIZE-3) = VSIZE-4
<       MSTK(LSIZE-3) = 1
<       NSTK(LSIZE-3) = 1
---
>       G_VSIZE = G_BIGMEM
>       G_PSIZE = 32
>       G_BOT = G_MAX_NUMBER_OF_NAMES-3
>       CALL mat_wset(5,0.0D0,0.0D0,G_STKR(G_VSIZE-4),G_STKI(G_VSIZE-4),1)
>       CALL mat_putid(G_IDSTK(1,G_MAX_NUMBER_OF_NAMES-3),EPS)
>       G_LSTK(G_MAX_NUMBER_OF_NAMES-3) = G_VSIZE-4
>       G_MSTK(G_MAX_NUMBER_OF_NAMES-3) = 1
>       G_NSTK(G_MAX_NUMBER_OF_NAMES-3) = 1
271c777
<    30 continue
---
>       SET_ST: do
274,275c780,783
<       IF (T .GT. 1.0D0) GOTO 30
<       STKR(VSIZE-4) = 2.0D0*S
---
>          IF (T .le. 1.0D0) exit
>       enddo SET_ST
> 
>       G_STKR(G_VSIZE-4) = 2.0D0*S
277,297c785,805
<       CALL mat_putid(IDSTK(1,LSIZE-2),FLOPS)
<       LSTK(LSIZE-2) = VSIZE-3
<       MSTK(LSIZE-2) = 1
<       NSTK(LSIZE-2) = 2
<       CALL mat_putid(IDSTK(1,LSIZE-1), EYE)
<       LSTK(LSIZE-1) = VSIZE-1
<       MSTK(LSIZE-1) = -1
<       NSTK(LSIZE-1) = -1
<       STKR(VSIZE-1) = 1.0D0
<       CALL mat_putid(IDSTK(1,LSIZE), RAND)
<       LSTK(LSIZE) = VSIZE
<       MSTK(LSIZE) = 1
<       NSTK(LSIZE) = 1
<       FMT = 1
<       FLP(1) = 0
<       FLP(2) = 0
<       DDT = 0
<       RAN(2) = 0
<       PTZ = 0
<       PT = PTZ
<       ERR = 0
---
>       CALL mat_putid(G_IDSTK(1,G_MAX_NUMBER_OF_NAMES-2),FLOPS)
>       G_LSTK(G_MAX_NUMBER_OF_NAMES-2) = G_VSIZE-3
>       G_MSTK(G_MAX_NUMBER_OF_NAMES-2) = 1
>       G_NSTK(G_MAX_NUMBER_OF_NAMES-2) = 2
>       CALL mat_putid(G_IDSTK(1,G_MAX_NUMBER_OF_NAMES-1), EYE)
>       G_LSTK(G_MAX_NUMBER_OF_NAMES-1) = G_VSIZE-1
>       G_MSTK(G_MAX_NUMBER_OF_NAMES-1) = -1
>       G_NSTK(G_MAX_NUMBER_OF_NAMES-1) = -1
>       G_STKR(G_VSIZE-1) = 1.0D0
>       CALL mat_putid(G_IDSTK(1,G_MAX_NUMBER_OF_NAMES), RAND)
>       G_LSTK(G_MAX_NUMBER_OF_NAMES) = G_VSIZE
>       G_MSTK(G_MAX_NUMBER_OF_NAMES) = 1
>       G_NSTK(G_MAX_NUMBER_OF_NAMES) = 1
>       G_FMT = 1
>       G_FLOP_COUNTER(1) = 0
>       G_FLOP_COUNTER(2) = 0
>       G_DEBUG_LEVEL = 0
>       G_RAN(2) = 0
>       G_PTZ = 0
>       G_PT = G_PTZ
>       G_ERR = 0
299,301c807,809
< !
< 90    continue
<       INFINITE : do
---
>    endif
> 
>    PARSE_LINE : do
303c811
<          select case(fun)
---
>       select case(G_fun)
311c819
<          case(99); exit INFINITE
---
>       case(99); exit PARSE_LINE
314c822
<       enddo INFINITE
---
>    enddo PARSE_LINE
320a829,831
> 
> ! ident_2="@(#)m_matrix::mat_err(3fp): given error number, write associated error message"
> 
322,326c833,834
< integer,parameter         :: linelen=255
< character(len=linelen)    :: blh
< character(len=linelen)    :: msg
< character(len=linelen+20) :: mline
< integer                   :: iend
---
> 
> integer              :: i
329,330d836
< integer                   :: i
< integer                   :: i9400
332a839
> character(len=255)   :: msg
334,337d840
<    blh(1:linelen)='        '
< !
<    k = lpt(2) - lpt(1)
<    if (k .lt. 1) k = 1
339,341c842,844
<     case(1); msg='IMPROPER MULTIPLE ASSIGNMENT'
<     case(2); msg='IMPROPER FACTOR'
<     case(3); msg='EXPECT RIGHT PARENTHESIS'
---
>     case(1);  msg='Improper multiple assignment'
>     case(2);  msg='Improper factor'
>     case(3);  msg='Expected right parenthesis'
344,353c847,856
<       DO I9400 = 1, 4
<          KK = IDS(I9400,PT+1)
<          BUF(I9400) = ALFA(KK+1)
<       enddo
<       call mat_buf2str(msg,buf,4)
<       msg='UNDEFINED VARIABLE: '//msg(1:4)
< !.......................................................................
<     case(5); msg='COLUMN LENGTHS DO NOT MATCH'
<     case(6); msg='ROW LENGTHS DO NOT MATCH'
<     case(7); msg='TEXT TOO LONG'
---
>       DO I = 1, G_MAX_NAME_LENGTH             ! extract variable name into buffer
>          KK = G_IDS(I,G_PT+1)
>          G_BUF(I) = G_CHARSET(KK+1)
>       enddo
>       call mat_buf2str(msg,G_buf,G_MAX_NAME_LENGTH)           ! convert buffer to string
>       msg='Undefined variable: '//msg(1:G_MAX_NAME_LENGTH)
> !.......................................................................
>     case(5);  msg='Column lengths do not match'
>     case(6);  msg='Row lengths do not match'
>     case(7);  msg='Text too long'
361,362c864,865
<     case(15); msg='IMPROPER ASSIGNMENT TO SUBMATRIX'
<     case(16); msg='IMPROPER COMMAND'
---
>     case(15); msg='Improper assignment to submatrix'
>     case(16); msg='Improper command'
365,375c868,876
<       LB = VSIZE - LSTK(BOT) + 1
<       LT = ERR + LSTK(BOT)
<       call journal(' TOO MUCH MEMORY REQUIRED')
<       WRITE(MLINE,'(1X,I7,'' VARIABLES,'',I7,'' TEMPORARIES,'',I7,'' AVAILABLE.'')') LB,LT,VSIZE
<       call journal(MLINE)
<       GOTO 999
< !.......................................................................
<     case(18); msg='TOO MANY NAMES'
<     case(19); msg='MATRIX IS SINGULAR TO WORKING PRECISION'
<     case(20); msg='MATRIX MUST BE SQUARE'
<     case(21); msg='SUBSCRIPT OUT OF RANGE'
---
>       lb = G_VSIZE - G_LSTK(G_BOT) + 1
>       lt = g_err + G_LSTK(G_BOT)
>       call journal(' Too much memory required')
>       write(msg,'(1X,I7,'' Variables,'',I7,'' Temporaries,'',I7,'' Available.'')') lb,lt,G_VSIZE
> !.......................................................................
>     case(18); msg='Too many names'
>     case(19); msg='Matrix is singular to working precision'
>     case(20); msg='Matrix must be square'
>     case(21); msg='Subscript out of range'
378,381c879,880
<       WRITE(MLINE,122) (RSTK(I),I=1,PT)
< 122   FORMAT(1X,'RECURSION DIFFICULTIES',10I4)
<       call journal(mline)
<       GOTO 999
---
>       write(msg,122) (G_RSTK(I),I=1,G_PT)
> 122   format(1X,'Recursion difficulties',10I4)
383,400c882,899
<     case(23); msg='ONLY 1, 2 OR INF NORM OF MATRIX'
<     case(24); msg='NO CONVERGENCE'
<     case(25); msg='CAN NOT USE FUNCTION NAME AS VARIABLE'
<     case(26); msg='TOO COMPLICATED (STACK OVERFLOW)'
<     case(27); msg='DIVISION BY ZERO IS A NO-NO'
<     case(28); msg='EMPTY MACRO'
<     case(29); msg='NOT POSITIVE DEFINITE'
<     case(30); msg='IMPROPER EXPONENT'
<     case(31); msg='IMPROPER STRING'
<     case(32); msg='SINGULARITY OF LOG OR ATAN'
<     case(33); msg='TOO MANY COLONS'
<     case(34); msg='IMPROPER FOR CLAUSE'
<     case(35); msg='IMPROPER WHILE OR IF CLAUSE'
<     case(36); msg='ARGUMENT OUT OF RANGE'
<     case(37); msg='IMPROPER MACRO'
<     case(38); msg='IMPROPER FILE NAME'
<     case(39); msg='INCORRECT NUMBER OF ARGUMENTS'
<     case(40); msg='EXPECT STATEMENT TERMINATOR'
---
>     case(23); msg='Only 1, 2 or INF norm of matrix'
>     case(24); msg='No convergence'
>     case(25); msg='Can not use function name as variable'
>     case(26); msg='Too complicated (STACK OVERFLOW)'
>     case(27); msg='Division by zero is a NO-NO'
>     case(28); msg='Empty macro'
>     case(29); msg='Not positive definite'
>     case(30); msg='Improper exponent'
>     case(31); msg='Improper string'
>     case(32); msg='Singularity of LOG or ATAN'
>     case(33); msg='Too many colons'
>     case(34); msg='Improper FOR clause'
>     case(35); msg='Improper WHILE or IF clause'
>     case(36); msg='Argument out of range'
>     case(37); msg='Improper MACRO'
>     case(38); msg='Improper file name'
>     case(39); msg='Incorrect number of arguments'
>     case(40); msg='Expecting statement terminator'
403,404c902
<     call journal('sc','*mat_err* unknown error code =',n)
<     goto 999
---
>        write(msg,'("*mat_err* internal error: unknown error code =",i0)')n
407a906,907
>    k = max(1,G_LPT(2) - G_LPT(1)) ! number of spaces to shift arrow by
>    call journal(' '//repeat(' ',k)//'/\--ERROR:'//msg)
409,422c909
<    iend=max(1,len_trim(msg))
< 
<    if(k+iend.lt.len(mline))then
<       write(mline,'(1x,a,''/^--ERROR:'',a)') blh(1:k),msg(1:iend)
<       call journal(mline)
<    else
<       WRITE(mline,'(1x,a,''/^--ERROR:'')') blh(1:k)
<       call journal(mline)
<       call journal(msg)
<    endif
<    goto 999
< !.......................................................................
< 999 continue
<    err = n
---
>    G_err = n
427c914
< subroutine mat_files(lunit,iname)
---
> subroutine mat_files(lunit,iname,status)
433c920
<    ! if LUNIT is -11 and HIO .ne. 0 , rewind the help file
---
>    ! if LUNIT is -11 and G_HIO .ne. 0 , rewind the help file
436c923
< !     INAME = FILE NAME, 1 character per word
---
> integer                      :: iname(256) ! INAME = FILE NAME, 1 character per word
438d924
< integer                      :: iname(256)
440a927,928
> character(len=*),optional    :: status
> character(len=20)            :: status_local
442,443c930,934
< integer                      :: itemp
< integer                      :: itemp1
---
> if(present(status))then
>    status_local=status
> else
>    status_local='UNKNOWN'
> endif
446c937
<    if (ddt .eq. 1) then
---
>    if (G_DEBUG_LEVEL .eq. 1) then
453c944
<    fe=0
---
>    G_FILE_OPEN_ERROR=.false.
470,471c961
<          itemp1=max(1,len_trim(temp1))
<          open(11,file=temp1(:itemp1),status='old',iostat=ios)       ! open help file
---
>          open(11,file=temp1,status='old',iostat=ios)                 ! open help file
473,475c963,964
<             call journal('HELP IS NOT AVAILABLE ON FILE ...')
<             call journal(temp1(1:itemp1))
<             HIO = 0
---
>             call journal('HELP IS NOT AVAILABLE ON FILE ...'//temp1)
>             G_HIO = 0
481c970
<       if( lunit .eq. -11 .and. hio .ne. 0)then                       ! SPECIAL CASE FOR HELP FILE
---
>       if( lunit .eq. -11 .and. G_HIO .ne. 0)then                     ! SPECIAL CASE FOR HELP FILE
491,493c980
<       itemp=len_trim(name)
<       !call journal('filename='//name(:itemp)
<       open(unit=lunit,file=name(:itemp),status='unknown',iostat=ios) ! open a file
---
>       open(unit=lunit,file=name,status=status_local,iostat=ios)      ! open a file
495,498c982,986
<          call journal('*mat_files* OPEN FILE FAILED')
<          call journal(name(1:len_trim(name)))
<          fe=1                                                        ! set the I/O to terminal I/O
<          rio=rte                                                     ! set current file to read input lines from/to RTE
---
>          call journal('OPEN failed on file '//name)
>          G_FILE_OPEN_ERROR=.true.                                    ! set the flag a file error occurred
>          G_RIO=G_RTE                                                 ! set current file to read input lines from/to G_RTE
>       else
>          G_FILE_OPEN_ERROR=.false.                                   ! set the flag a file error did not occurr
507c995
< $@(#) m_matrix::mat_getsym(3fp): get a symbol
---
> ! ident_3="@(#)m_matrix::mat_getsym(3fp): get a symbol"
509c997
< character(len=80) ::  mline
---
> character(len=80) :: message
516,518c1004,1006
< integer,save :: BLANK=36
< integer,save :: Z=35
< integer,save :: DOT=47
---
> integer,parameter :: BLANK=36
> integer,parameter :: Z=35
> integer,parameter :: DOT=47
523,524c1011,1012
< integer,save :: PLUS=41
< integer,save :: MINUS=42
---
> integer,parameter :: PLUS=41
> integer,parameter :: MINUS=42
527,529c1015,1017
< integer,save :: STAR=43
< integer,save :: SLASH=44
< integer,save :: BSLASH=45
---
> integer,parameter :: STAR=43
> integer,parameter :: SLASH=44
> integer,parameter :: BSLASH=45
537c1025
<       if (chra .ne. blank) exit INFINITE
---
>       if (G_chra .ne. blank) exit INFINITE
541,544c1029,1032
<    lpt(2) = lpt(3)
<    lpt(3) = lpt(4)
<    if (chra .le. 9) goto 50                                 ! numeric character (0-9)
<    if (chra .le. z.or.(chra.ge.a2.and.chra.le.z2)) goto 30  ! alphameric (A-Z OR a-z)
---
>    G_LPT(2) = G_LPT(3)
>    G_LPT(3) = G_LPT(4)
>    if (G_chra .le. 9) goto 50                                     ! numeric character (0-9)
>    if (G_chra .le. z.or.(G_chra.ge.a2.and.G_chra.le.z2)) goto 30  ! alphameric (A-Z OR a-z)
547,548c1035,1036
<    ss = sym
<    sym = chra
---
>    ss = G_sym
>    G_sym = G_chra
550c1038
<    if (sym .ne. dot) goto 90
---
>    if (G_sym .ne. dot) goto 90
554,555c1042,1043
<    if (chra .le. 9) goto 55  ! a number character
<    if (chra.eq.star.or.chra.eq.slash.or.chra.eq.bslash) goto 90
---
>    if (G_chra .le. 9) goto 55  ! a number character
>    if (G_chra.eq.star.or.G_chra.eq.slash.or.G_chra.eq.bslash) goto 90
561,562c1049,1050
<    sym = name
<    syn(1) = chra
---
>    G_sym = name
>    G_syn(1) = G_chra
567,568c1055,1056
<    if (chra .ge. a2.and.chra.le.z2) goto  44! alternate case letter
<    if (chra .gt. z) goto 45  ! a control character not alphanumeric and not special like eol
---
>    if (G_chra .ge. a2.and.G_chra.le.z2) goto  44! alternate case letter
>    if (G_chra .gt. z) goto 45  ! a control character not alphanumeric and not special like eol
570c1058
<    if (chcnt .le. 4) syn(chcnt) = chra
---
>    if (chcnt .le. G_MAX_NAME_LENGTH) G_syn(chcnt) = G_chra
573,575c1061,1063
<    if (chcnt .gt. 4) goto 47
<    do i = chcnt, 4
<       syn(i) = blank
---
>    if (chcnt .gt. G_MAX_NAME_LENGTH) goto 47
>    do i = chcnt, G_MAX_NAME_LENGTH
>       G_syn(i) = blank
583c1071
<    if (chra .ne. dot) goto 60
---
>    if (G_chra .ne. dot) goto 60
586c1074
<    chcnt = lpt(4)
---
>    chcnt = G_LPT(4)
588,589c1076,1077
<    chcnt = lpt(4) - chcnt
<    if (chra .eq. eol) chcnt = chcnt+1
---
>    chcnt = G_LPT(4) - chcnt
>    if (G_chra .eq. G_eol) chcnt = chcnt+1
592c1080
<    if (chra.ne.d .and. chra.ne.e .and. chra.ne.d_up .and. chra.ne.e_up ) goto 70
---
>    if (G_chra.ne.d .and. G_chra.ne.e .and. G_chra.ne.d_up .and. G_chra.ne.e_up ) goto 70
594c1082
<    sign = chra
---
>    sign = G_chra
600,601c1088,1089
<    stki(vsize) = mat_flop(syv)
<    sym = num
---
>    G_STKI(G_VSIZE) = mat_flop(syv)
>    G_sym = num
604c1092
<    if (chra .ne. blank) goto 99
---
>    if (G_chra .ne. blank) goto 99
608,616c1096,1104
<    if (ddt .ne. 1) return
<    if (sym.gt.name .and. sym.lt.alflq) then
<       call journal(char(alfa(sym+1)))
<    endif
<    if (sym .ge. alflq) call journal('eol')
<    if (sym .eq. name) call mat_prntid(syn,1)
<    if (sym .eq. num) then
<       write(mline,'(1x,g8.2)') syv
<       call journal(mline)
---
>    if (G_DEBUG_LEVEL .ne. 1) return
>    if (G_sym.gt.name .and. G_sym.lt.G_CHARSET_SIZE) then
>       call journal(char(G_CHARSET(G_sym+1)))
>    endif
>    if (G_sym .ge. G_CHARSET_SIZE) call journal('eol')
>    if (G_sym .eq. name) call mat_prntid(G_syn,1)
>    if (G_sym .eq. num) then
>       write(message,'(1x,g8.2)') syv
>       call journal(message)
624c1112
< $@(#) M_matrix::mat_str2buf(3fp) :: convert string to hollerith
---
> ! ident_4="@(#)M_matrix::mat_str2buf(3fp) :: convert string to hollerith"
629d1116
< integer,intent(out)         :: buf(lrecl)
631c1118,1119
< integer                     :: i10
---
> integer,intent(out)         :: buf(:)
> integer                     :: i
633,634c1121,1123
<    do i10=1,lrecl
<       buf(i10)=ichar(string(i10:i10))+538976304-48
---
>    buf=ichar(' ')+538976304-48
>    do i=1,min(lrecl,len_trim(string),size(buf))
>       buf(i)=ichar(string(i:i))+538976304-48
641c1130,1133
< subroutine mat_buf2str(string,buf,lrecl) ! convert string to hollerith
---
> subroutine mat_buf2str(string,buf,lrecl)
> 
> ! ident_5="@(#)M_matrix::mat_buf2string(3fp) :: convert hollerith to string"
> 
643c1135
< integer,intent(in)           :: buf(lrecl)
---
> integer,intent(in)           :: buf(:)
645c1137,1138
< integer                      :: i10
---
> integer                      :: i
> integer                      :: ilen
647,649c1140,1142
<    do i10=1,lrecl
<       if(buf(i10).eq.0)exit
<       string(i10:i10)=char(buf(i10)-538976304+48)
---
>    ilen=len(string)
>    do i=1,min(lrecl,ilen,size(buf))
>       string(i:i)=char(buf(i)-538976304+48)
657c1150,1157
< $@(#) M_matrix::ml_hilbr(3fp): generate inverse hilbert matrix
---
> ! ident_6="@(#)M_matrix::ml_hilbr(3fp): generate doubleprecision inverse hilbert matrix"
> !
> ! References:
> ! Forsythe, G. E. and C. B. Moler. Computer Solution of Linear Algebraic Systems. Englewood Cliffs, NJ: Prentice-Hall, 1967.
> 
> integer,intent(in)          :: lda
> integer,intent(in)          :: n
> doubleprecision,intent(out) :: a(lda,n)
659,661d1158
< integer         :: lda
< integer         :: n
< doubleprecision :: a(lda,n)
668c1165
<    p = dfloat(n)
---
>    p = dble(n)
671,673c1168,1170
<       if (i.ne.1) p = (dfloat(n-i+1)*p*dfloat(n+i-1))/dfloat(i-1)**2
<       r = p*p
<       a(i,i) = r/dfloat(2*i-1)
---
>       if (i.ne.1) p = (dble(n-i+1) * p * dble(n+i-1)) / dble(i-1)**2
>       r = p * p
>       a(i,i) = r / dble(2*i-1)
675c1172
<       ip1 = i+1
---
>       ip1 = i + 1
677,678c1174,1175
<          r = (-1)*(dfloat(n-j+1)*r*(n+j-1))/dfloat(j-1)**2
<          a(i,j) = r/dfloat(i+j-1)
---
>          r = (-1) * (dble(n-j+1) * r * (n+j-1)) / dble(j-1)**2
>          a(i,j) = r/ dble(i+j-1)
689c1186
< $@(#) M_matrix::mat_matfn6(3f):evaluate utility functions
---
> ! ident_7="@(#)M_matrix::mat_matfn6(3f):evaluate utility functions"
712,716c1209,1214
< integer,save      :: semi=39
< integer,save      :: unifor(4) =[30,23,18,15]
< integer,save      :: normal(4) =[23,24,27,22]
< integer,save      :: seed(4)   =[28,14,14,13]
< integer           :: id(4)
---
> integer,parameter :: semi=39
> INTEGER,parameter :: BLANK=36
> integer,save      :: unifor(G_MAX_NAME_LENGTH) =[30,23,18,15,G_PAD(:)]
> integer,save      :: normal(G_MAX_NAME_LENGTH) =[23,24,27,22,G_PAD(:)]
> integer,save      :: seed(G_MAX_NAME_LENGTH)   =[28,14,14,13,G_PAD(:)]
> integer           :: id(G_MAX_NAME_LENGTH)
718c1216
< character(len=80) :: mline
---
> character(len=80) :: message
720,721c1218,1219
<       IF (DDT .EQ. 1) call journal('sc','*MATFN6* ',FIN)
< !     FUNCTIONS/FIN
---
>       IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc','*MATFN6* ',G_FIN)
> !     FUNCTIONS/G_FIN
724,727c1222,1225
<       L = LSTK(TOP)
<       M = MSTK(TOP)
<       N = NSTK(TOP)
<       FUN6: select case(fin)
---
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)
>       N = G_NSTK(G_TOP)
>       FUN6: select case(G_fin)
731,736c1229,1234
<       IF (RHS .NE. 2) CALL mat_err(39)
<       IF (ERR .GT. 0) RETURN
<       TOP = TOP - 1
<       L = LSTK(TOP)
<       MA = MSTK(TOP)
<       NA = NSTK(TOP)
---
>       IF (G_RHS .NE. 2) CALL mat_err(39)
>       IF (G_ERR .GT. 0) RETURN
>       G_TOP = G_TOP - 1
>       L = G_LSTK(G_TOP)
>       MA = G_MSTK(G_TOP)
>       NA = G_NSTK(G_TOP)
739,741c1237,1239
<       ERR = LB + M*N - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
---
>       G_ERR = LB + M*N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
743c1241
<       CALL mat_wcopy(MA*NA+M*N,STKR(L),STKI(L),1,STKR(LA),STKI(LA),1)
---
>       CALL mat_wcopy(MA*NA+M*N,G_STKR(L),G_STKI(L),1,G_STKR(LA),G_STKI(LA),1)
749c1247
<             CALL mat_wcopy(M,STKR(LJ),STKI(LJ),1,STKR(L),STKI(L),1)
---
>             CALL mat_wcopy(M,G_STKR(LJ),G_STKI(LJ),1,G_STKR(L),G_STKI(L),1)
754,757c1252,1255
<               IF (FIN .EQ. 11) CALL mat_wmul(STKR(LS),STKI(LS),STKR(L),STKI(L),STKR(L),STKI(L))
<               IF (FIN .EQ. 12) CALL mat_wdiv(STKR(LS),STKI(LS),STKR(L),STKI(L),STKR(L),STKI(L))
<               IF (FIN .EQ. 13) CALL mat_wdiv(STKR(L),STKI(L),STKR(LS),STKI(LS),STKR(L),STKI(L))
<               IF (ERR .GT. 0) RETURN
---
>               IF (G_FIN .EQ. 11) CALL mat_wmul(G_STKR(LS),G_STKI(LS),G_STKR(L),G_STKI(L),G_STKR(L),G_STKI(L))
>               IF (G_FIN .EQ. 12) CALL mat_wdiv(G_STKR(LS),G_STKI(LS),G_STKR(L),G_STKI(L),G_STKR(L),G_STKI(L))
>               IF (G_FIN .EQ. 13) CALL mat_wdiv(G_STKR(L),G_STKI(L),G_STKR(LS),G_STKI(LS),G_STKR(L),G_STKI(L))
>               IF (G_ERR .GT. 0) RETURN
763,764c1261,1262
<       MSTK(TOP) = M*MA
<       NSTK(TOP) = N*NA
---
>       G_MSTK(G_TOP) = M*MA
>       G_NSTK(G_TOP) = N*NA
773,776c1271,1274
<       FLP(2) = IDINT(STKR(L))
<       IF (SYM .NE. SEMI) then
<          WRITE(mline,'(''CHOP '',I2,'' PLACES.'')') FLP(2)
<          call journal(mline)
---
>       G_FLOP_COUNTER(2) = int(G_STKR(L))
>       IF (G_SYM .NE. SEMI) then
>          WRITE(message,'(''CHOP '',I2,'' PLACES.'')') G_FLOP_COUNTER(2)
>          call journal(message)
784,786c1282,1284
<       T = STKR(VSIZE-4)
<       IF (T.LT.EPS .OR. T.EQ.EPS0) STKR(VSIZE-4) = EPS
<       MSTK(TOP) = 0
---
>       T = G_STKR(G_VSIZE-4)
>       IF (T.LT.EPS .OR. T.EQ.EPS0) G_STKR(G_VSIZE-4) = EPS
>       G_MSTK(G_TOP) = 0
794,795c1292,1293
<          SR = mat_flop(SR+STKR(LS))
<          SI = mat_flop(SI+STKI(LS))
---
>          SR = mat_flop(SR+G_STKR(LS))
>          SI = mat_flop(SI+G_STKI(LS))
797,800c1295,1298
<       STKR(L) = SR
<       STKI(L) = SI
<       MSTK(TOP) = 1
<       NSTK(TOP) = 1
---
>       G_STKR(L) = SR
>       G_STKI(L) = SI
>       G_MSTK(G_TOP) = 1
>       G_NSTK(G_TOP) = 1
808c1306
<          CALL mat_wmul(STKR(LS),STKI(LS),SR,SI,SR,SI)
---
>          CALL mat_wmul(G_STKR(LS),G_STKI(LS),SR,SI,SR,SI)
810,813c1308,1311
<       STKR(L) = SR
<       STKI(L) = SI
<       MSTK(TOP) = 1
<       NSTK(TOP) = 1
---
>       G_STKR(L) = SR
>       G_STKI(L) = SI
>       G_MSTK(G_TOP) = 1
>       G_NSTK(G_TOP) = 1
818,824c1316,1322
<       IF (RHS .LT. 2) GOTO 72
<       IF (RHS .LT. 3) GOTO 71
<       T = STKR(L)
<       TOP = TOP-1
<       L = LSTK(TOP)
<       M = MSTK(TOP)
<       N = NSTK(TOP)
---
>       IF (G_RHS .LT. 2) GOTO 72
>       IF (G_RHS .LT. 3) GOTO 71
>       T = G_STKR(L)
>       G_TOP = G_TOP-1
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)
>       N = G_NSTK(G_TOP)
826,830c1324,1328
<       S = STKR(L)
<       TOP = TOP-1
<       L = LSTK(TOP)
<       M = MSTK(TOP)
<       N = NSTK(TOP)
---
>       S = G_STKR(L)
>       G_TOP = G_TOP-1
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)
>       N = G_NSTK(G_TOP)
832,835c1330,1333
<       CALL mat88_user(STKR(L),M,N,S,T)
<       CALL mat_rset(M*N,0.0D0,STKI(L),1)
<       MSTK(TOP) = M
<       NSTK(TOP) = N
---
>       CALL mat88_user(G_STKR(L),M,N,S,T)
>       CALL mat_rset(M*N,0.0D0,G_STKI(L),1)
>       G_MSTK(G_TOP) = M
>       G_NSTK(G_TOP) = N
838c1336
<       N = MAX0(IDINT(STKR(L)),0)
---
>       N = MAX0(int(G_STKR(L)),0)
840,843c1338,1341
<       IF (N .GT. 0) CALL mat_magic(STKR(L),N,N)
<       CALL mat_rset(N*N,0.0D0,STKI(L),1)
<       MSTK(TOP) = N
<       NSTK(TOP) = N
---
>       IF (N .GT. 0) CALL mat_magic(G_STKR(L),N,N)
>       CALL mat_rset(N*N,0.0D0,G_STKI(L),1)
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = N
846,857c1344,1355
<       STKR(L) = M
<       STKR(L+1) = N
<       STKI(L) = 0.0D0
<       STKI(L+1) = 0.0D0
<       MSTK(TOP) = 1
<       NSTK(TOP) = 2
<       IF (LHS .EQ. 1) exit FUN6
<       NSTK(TOP) = 1
<       TOP = TOP + 1
<       LSTK(TOP) = L+1
<       MSTK(TOP) = 1
<       NSTK(TOP) = 1
---
>       G_STKR(L) = M
>       G_STKR(L+1) = N
>       G_STKI(L) = 0.0D0
>       G_STKI(L+1) = 0.0D0
>       G_MSTK(G_TOP) = 1
>       G_NSTK(G_TOP) = 2
>       IF (G_LHS .EQ. 1) exit FUN6
>       G_NSTK(G_TOP) = 1
>       G_TOP = G_TOP + 1
>       G_LSTK(G_TOP) = L+1
>       G_MSTK(G_TOP) = 1
>       G_NSTK(G_TOP) = 1
861,868c1359,1366
<       IF (RHS .NE. 2) GOTO 81
<          K = IDINT(STKR(L))
<          TOP = TOP-1
<          L = LSTK(TOP)
<          M = MSTK(TOP)
<          N = NSTK(TOP)
<    81 continue
<       IF (FIN .GE. 14) GOTO 85
---
>       IF (G_RHS .EQ. 2) then
>          K = int(G_STKR(L))
>          G_TOP = G_TOP-1
>          L = G_LSTK(G_TOP)
>          M = G_MSTK(G_TOP)
>          N = G_NSTK(G_TOP)
>       endif
>       IF (G_FIN .GE. 14) GOTO 85
872,873c1370,1371
<       MSTK(TOP) = MAX0(MN,0)
<       NSTK(TOP) = 1
---
>       G_MSTK(G_TOP) = MAX0(MN,0)
>       G_NSTK(G_TOP) = 1
879,880c1377,1378
<          STKR(LL) = STKR(LS)
<          STKI(LL) = STKI(LS)
---
>          G_STKR(LL) = G_STKR(LS)
>          G_STKI(LL) = G_STKI(LS)
886,890c1384,1388
<       ERR = L+N*N - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       MSTK(TOP) = N
<       NSTK(TOP) = N
---
>       G_ERR = L+N*N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = N
900,903c1398,1401
<             IF (J-I .EQ. K) SR = STKR(LS)
<             IF (J-I .EQ. K) SI = STKI(LS)
<             STKR(LL) = SR
<             STKI(LL) = SI
---
>             IF (J-I .EQ. K) SR = G_STKR(LS)
>             IF (J-I .EQ. K) SI = G_STKI(LS)
>             G_STKR(LL) = SR
>             G_STKI(LL) = SI
912,916c1410,1418
<          IF (FIN .EQ. 14) LL = J - K - 1
<          IF (FIN .EQ. 14) LS = LD - LL
<          IF (FIN .EQ. 15) LL = M - J + K
<          IF (FIN .EQ. 15) LS = LD + 1
<          IF (LL .GT. 0) CALL mat_wset(LL,0.0D0,0.0D0,STKR(LS),STKI(LS),1)
---
>          select case(G_FIN)
>          case(14)
>                   LL = J - K - 1
>                   LS = LD - LL
>          case(15)
>                   LL = M - J + K
>                   LS = LD + 1
>          end select
>          IF (LL .GT. 0) CALL mat_wset(LL,0.0D0,0.0D0,G_STKR(LS),G_STKI(LS),1)
920,928c1422,1432
<       IF (M.GT.1 .OR. RHS.EQ.0) GOTO 94
<       IF (RHS .NE. 2) GOTO 91
<         NN = IDINT(STKR(L))
<         TOP = TOP-1
<         L = LSTK(TOP)
<         N = NSTK(TOP)
<    91 continue
<       IF (FIN.NE.7 .OR. N.LT.4) GOTO 93
<       DO I = 1, 4
---
>       IF (M.GT.1 .OR. G_RHS.EQ.0) GOTO 94
>       IF (G_RHS .eq. 2) then
>          NN = int(G_STKR(L))
>          G_TOP = G_TOP-1
>          L = G_LSTK(G_TOP)
>          N = G_NSTK(G_TOP)
>       endif
> 
>       IF (G_FIN.EQ.7.and.N.lt.G_MAX_NAME_LENGTH)then    ! a call to RAND might be RAND('UNIFORM'|'SEED'|'NORMAL')
>          ID=BLANK
>          DO I = 1, MIN(G_MAX_NAME_LENGTH,N)  ! in case it is one of these words store it in the ID array to test if it matches
930c1434
<         ID(I) = IDINT(STKR(LS))
---
>             ID(I) = int(G_STKR(LS))
932,934c1436,1448
<       IF (mat_eqid(ID,UNIFOR).OR.mat_eqid(ID,NORMAL)) GOTO 97
<       IF (mat_eqid(ID,SEED)) GOTO 98
<    93 continue
---
>          IF (mat_eqid(ID,UNIFOR).OR.mat_eqid(ID,NORMAL))then ! SWITCH UNIFORM AND NORMAL (if a matrix just happens to match, a bug)
>             G_RAN(2) = ID(1) - UNIFOR(1)
>             G_MSTK(G_TOP) = 0
>             exit FUN6
>          elseif (mat_eqid(ID,SEED)) then ! COMMAND::SEED    ! if a matrix just happens to match, a bug)
>             IF (G_RHS .EQ. 2) G_RAN(1) = NN
>             G_STKR(L) = G_RAN(1)
>             G_MSTK(G_TOP) = 1
>             IF (G_RHS .EQ. 2) G_MSTK(G_TOP) = 0
>             G_NSTK(G_TOP) = 1
>             exit FUN6
>          endif
>       endif
936,943c1450,1457
<       M = MAX0(IDINT(STKR(L)),0)
<       IF (RHS .EQ. 2) N = MAX0(NN,0)
<       IF (RHS .NE. 2) N = M
<       ERR = L+M*N - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       MSTK(TOP) = M
<       NSTK(TOP) = N
---
>       M = MAX0(int(G_STKR(L)),0)
>       IF (G_RHS .EQ. 2) N = MAX0(NN,0)
>       IF (G_RHS .NE. 2) N = M
>       G_ERR = L+M*N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       G_MSTK(G_TOP) = M
>       G_NSTK(G_TOP) = N
949,956c1463,1470
<            STKR(LL) = 0.0D0
<            STKI(LL) = 0.0D0
<            IF(I.EQ.J .OR. FIN.EQ.8) STKR(LL) = 1.0D0
<            IF(FIN.EQ.7 .AND. RAN(2).EQ.0)STKR(LL)=mat_flop(mat_urand(RAN(1)))
<            IF(FIN.NE.7 .OR. RAN(2).EQ.0) cycle
<       95      continue
<               SR = 2.0D0*mat_urand(RAN(1))-1.0D0
<               SI = 2.0D0*mat_urand(RAN(1))-1.0D0
---
>            G_STKR(LL) = 0.0D0
>            G_STKI(LL) = 0.0D0
>            IF(I.EQ.J .OR. G_FIN.EQ.8) G_STKR(LL) = 1.0D0
>            IF(G_FIN.EQ.7 .AND. G_RAN(2).EQ.0)G_STKR(LL)=mat_flop(mat_urand(G_RAN(1)))
>            IF(G_FIN.NE.7 .OR. G_RAN(2).EQ.0) cycle
>            do
>               SR = 2.0D0*mat_urand(G_RAN(1))-1.0D0
>               SI = 2.0D0*mat_urand(G_RAN(1))-1.0D0
958,959c1472,1474
<               IF (T .GT. 1.0D0) GOTO 95
<            STKR(LL) = mat_flop(SR*DSQRT((-(2.0D0*DLOG(T)))/T))
---
>               IF (T .LE. 1.0D0) exit
>            enddo
>            G_STKR(LL) = mat_flop(SR*DSQRT((-(2.0D0*DLOG(T)))/T))
962,975d1476
<       exit FUN6
< !-----------------------------------------------------------------------------------------------------------------------------------
< !     SWITCH UNIFORM AND NORMAL
<    97 continue
<       RAN(2) = ID(1) - UNIFOR(1)
<       MSTK(TOP) = 0
<       exit FUN6
< !-----------------------------------------------------------------------------------------------------------------------------------
<    98 continue ! COMMAND::SEED
<       IF (RHS .EQ. 2) RAN(1) = NN
<       STKR(L) = RAN(1)
<       MSTK(TOP) = 1
<       IF (RHS .EQ. 2) MSTK(TOP) = 0
<       NSTK(TOP) = 1
985c1486
< $@(#) M_matrix::ml_funcs(3fp):scan function list
---
> ! ident_8="@(#)M_matrix::ml_funcs(3fp):scan function list"
987,1022c1488,1493
< integer,intent(in) :: id(4)
< integer,parameter  :: funl=58                      ! number of functions
< integer,save       :: funn(4,funl)                 ! names of functions encoded
< integer,save       :: funp(funl)                   ! calling codes corresponding to the function names
< integer            :: k
< !
< !    function names per letter position
<    data funn/                                              &
<    &  10,11,28,36, 10,29,10,23, 11,10,28,14, 12,17,10,27,  & !    1   ABS   ATAN  BASE  CHAR
<    &  12,17,24,21, 12,17,24,25, 12,24,23,13, 12,24,23,19,  & !    2   CHOL  CHOP  COND  CONJ
<    &  12,24,28,36, 13,14,29,36, 13,18,10,16, 13,18,10,27,  & !    3   COS   DET   DIAG  DIAR
<    &  13,18,28,25, 14,18,16,36, 14,25,28,36, 14,33,14,12,  & !    4   DISP  EIG   EPS   EXEC
<    &  14,33,25,36, 14,34,14,36, 15,21,24,25, 17,14,28,28,  & !    5   EXP   EYE   FLOP  HESS
<    &  17,18,21,11, 18,22,10,16, 18,23,31,36, 20,27,24,23,  & !    6   HILB  IMAG  INV   KRON
<    &  21,18,23,14, 21,24,10,13, 21,24,16,36, 21,30,36,36,  & !    7   LINE  LOAD  LOG   LU
<    &  22,10,16,18, 23,24,27,22, 24,23,14,28, 24,27,29,17,  & !    8   MAGIC NORM  ONES  ORTH
<    &  25,18,23,31, 25,21,24,29, 25,24,21,34, 25,27,18,23,  & !    9   PINV  PLOT  POLY  PRINT
<    &  25,27,24,13, 26,27,36,36, 27,10,23,13, 27,10,23,20,  & !    10  PROD  QR    RAND  RANK
<    &  27,10,29,36, 27,12,24,23, 27,14,10,21, 27,24,24,29,  & !    11  RAT   RCOND REAL  ROOT
<    &  27,24,30,23, 27,27,14,15, 28,10,31,14, 28,12,17,30,  & !    12  ROUND RREF  SAVE  SCHUR
<    &  28,18,23,36, 28,18,35,14, 28,26,27,29, 28,30,22,36,  & !    13  SIN   SIZE  SQRT  SUM
<    &  28,31,13,36, 29,27,18,21, 29,27,18,30, 30,28,14,27,  & !    14  SVD   TRIL  TRIU  USER
<    &  13,14,11,30, 13,24,12,36 /                             !    15  DEBUG DOC
< !
< !    determine what to call for each name.
< !     o first digit indicates which routine to call (SUBROUTINE ML_MATFN[1-6])
< !     o remaining digits indicate nth number in computed goto in called routine
< !
<    data funp/                                              &
<    &  221,203,507,509, 106,609,303,225, 202,102,602,505,   &
<    &  506,211,000,501, 204,606,000,213, 105,224,101,611,   &
<    &  508,503,206,104, 601,304,608,402, 302,510,214,504,   &
<    &  604,401,607,305, 511,103,223,215, 222,107,502,212,   &
<    &  201,610,205,603, 301,614,615,605, 512,513 /
< !
< !  print function names and return
---
> integer,intent(in)               :: id(G_MAX_NAME_LENGTH)
> integer                          :: selector
> character(len=G_MAX_NAME_LENGTH) :: name
> integer                          :: i
> 
>    !  print function names and return
1024c1495,1513
<       call mat_prntid(funn,funl)
---
>       call journal('sc', ' FUNCTIONS:                                                     ')
>       call journal('sc', ' abs    atan  base  char   chol  chop  cond   conj   cos   debug')
>       call journal('sc', ' det    diag  diar  disp   doc   eig   eps    exec   exp   eye')
>       call journal('sc', ' flop   hess  hilb  imag   inv   kron  line   load   log   lu')
>       call journal('sc', ' magic  norm  ones  orth   pinv  plot  poly   print  prod  qr')
>       call journal('sc', ' rand   rank  rat   rcond  real  root  round  rref   save  schur')
>       call journal('sc', ' sin    size  sqrt  sum    svd   tril  triu   user')
>       call journal('sc', ' COMMANDS:                                                     ')
>       return
>    endif
> 
>    name=''
>    do i=1,size(id)
>       if(id(i).le.0)exit
>       if(id(i).lt.len(G_DEFINE_CHARSET))then
>          name(i:i)=G_DEFINE_CHARSET(id(i)+1:id(i)+1)
>       else
>          call journal('sc',' function name contains unacceptable characters:',name,'...')
>          G_fin = 0
1027,1030d1515
< !
< !  find FUNP value for given function name
<    do k = 1, funl
<       if (mat_eqid(id,funn(1,k))) goto 20
1032,1033c1517,1581
< !  function name was not found
<    fin = 0
---
>    !
>    !  find value for given function name to determine what to call for each name.
>    !     o first digit indicates which routine to call (SUBROUTINE ML_MATFN[1-6])
>    !     o remaining digits indicate nth number in computed goto in called routine
>    select case(name)
>    case('abs');             selector=221  !  calling  codes  corresponding  to  the  function  names
>    case('atan');            selector=203
>    case('base');            selector=507
>    case('char');            selector=509
>    case('chol');            selector=106
>    case('chop');            selector=609
>    case('cond');            selector=303
>    case('conj');            selector=225
>    case('cos');             selector=202
>    case('debug');           selector=512
>    case('det');             selector=102
>    case('diag');            selector=602
>    case('diar');            selector=505
>    case('disp');            selector=506
>    case('doc');             selector=513
>    case('eig');             selector=211
>    case('eps');             selector=000
>    case('exec');            selector=501
>    case('exp');             selector=204
>    case('eye');             selector=606
>    case('flop');            selector=000
>    case('hess');            selector=213
>    case('hilb','hilbert');  selector=105
>    case('imag');            selector=224
>    case('inv');             selector=101
>    case('kron');            selector=611
>    case('line');            selector=508
>    case('load');            selector=503
>    case('log');             selector=206
>    case('lu');              selector=104
>    case('magic');           selector=601
>    case('norm');            selector=304
>    case('ones');            selector=608
>    case('orth');            selector=402
>    case('pinv');            selector=302
>    case('plot');            selector=510
>    case('poly');            selector=214
>    case('print');           selector=504
>    case('prod');            selector=604
>    case('qr');              selector=401
>    case('rand');            selector=607
>    case('rank');            selector=305
>    case('rat');             selector=511
>    case('rcond');           selector=103
>    case('real');            selector=223
>    case('root');            selector=215
>    case('round');           selector=222
>    case('rref');            selector=107
>    case('save');            selector=502
>    case('schur');           selector=212
>    case('sin');             selector=201
>    case('size');            selector=610
>    case('sqrt');            selector=205
>    case('sum');             selector=603
>    case('svd');             selector=301
>    case('tril');            selector=614
>    case('triu');            selector=615
>    case('user');            selector=605
>    case default !  function name was not found
>       G_fin = 0
1035c1583
< !  found name so great FIN and FUN value from corresponding FUNP code
---
>    end select
1037,1039c1585,1588
< 20 continue
<    fin = mod(funp(k),100) ! which routine to call (SUBROUTINE ML_MATFN[1-6])
<    fun = funp(k)/100      ! which case to select in called procedure
---
> !  found name so get G_FIN and G_FUN value from corresponding code
> 
>    G_fin = mod(selector,100) ! which routine to call (SUBROUTINE ML_MATFN[1-6])
>    G_fun = selector/100      ! which case to select in called procedure
1041,1042c1590,1591
<    if (rhs.eq.0 .and. funp(k).eq.606) fin = 0
<    if (rhs.eq.0 .and. funp(k).eq.607) fin = 0
---
>    if (G_rhs.eq.0 .and. selector.eq.606) G_fin = 0
>    if (G_rhs.eq.0 .and. selector.eq.607) G_fin = 0
1049c1598
< $@(#) M_matrix::mat_putid(3fp): store a name
---
> ! ident_9="@(#)M_matrix::mat_putid(3fp): store a name"
1051,1052c1600,1601
< integer,intent(out) :: x(4)
< integer,intent(in)  :: y(4)
---
> integer,intent(out) :: x(G_MAX_NAME_LENGTH)
> integer,intent(in)  :: y(G_MAX_NAME_LENGTH)
1054c1603
<       do i = 1, 4
---
>       do i = 1, G_MAX_NAME_LENGTH
1063c1612
< $@(#) M_matrix::mat_getval(3fp): form numerical value
---
> ! ident_10="@(#)M_matrix::mat_getval(3fp): form numerical value"
1068,1069c1617,1618
<          if (chra .gt. 9) exit INFINITE
<          s = 10.0d0*s + dble(chra)
---
>          if (G_chra .gt. 9) exit INFINITE
>          s = 10.0d0*s + dble(G_chra)
1078c1627
< $@(#) M_matrix::mat_getch(3f): get next character from input line
---
> ! ident_11="@(#)M_matrix::mat_getch(3f): get next character from input line"
1082,1084c1631,1633
<    l = lpt(4)
<    chra = lin(l)
<    if (chra .ne. eol) lpt(4) = l + 1
---
>    l = G_LPT(4)
>    G_chra = G_LIN(l)
>    if (G_chra .ne. G_eol) G_LPT(4) = l + 1
1126c1675
< $@(#) M_matrix::mat_appnum(3fp): subroutine returns a string given a prefix string and a real value
---
> ! ident_12="@(#)M_matrix::mat_appnum(3fp): subroutine returns a string given a prefix string and a real value"
1159,1166c1708,1715
< subroutine mat_wcopy(n,xr,xi,incx,yr,yi,incy)
< integer         :: n
< doubleprecision :: xr(*)
< doubleprecision :: xi(*)
< integer         :: incx
< doubleprecision :: yr(*)
< doubleprecision :: yi(*)
< integer         :: incy
---
> subroutine mat_wcopy(number_of_values,xr,xi,incx,yr,yi,incy)
> integer,intent(in)          :: number_of_values
> doubleprecision,intent(in)  :: xr(*)
> doubleprecision,intent(in)  :: xi(*)
> integer,intent(in)          :: incx
> doubleprecision,intent(out) :: yr(*)
> doubleprecision,intent(out) :: yi(*)
> integer,intent(in)          :: incy
1171c1720
<    if (n .gt. 0) then
---
>    if (number_of_values .gt. 0) then
1174,1176c1723,1725
<       if (incx.lt.0) ix = (-n+1)*incx + 1
<       if (incy.lt.0) iy = (-n+1)*incy + 1
<       do i = 1, n
---
>       if (incx.lt.0) ix = (-number_of_values+1)*incx + 1
>       if (incy.lt.0) iy = (-number_of_values+1)*incy + 1
>       do i = 1, number_of_values
1189c1738
< $@(#) M_matrix::mat_wdiv(3fp): c = a/b
---
> ! ident_13="@(#)M_matrix::mat_wdiv(3fp): c = a/b"
1250c1799
< $@(#) M_matrix::mat_base(3fp): store base b representation of x in s(1:n)
---
> ! ident_14="@(#)M_matrix::mat_base(3fp): store base b representation of x in s(1:n)"
1285,1286c1834,1835
<       j = idint(x)
<       s(l) = dfloat(j)
---
>       j = int(x)
>       s(l) = dble(j)
1292c1841
<    t = dabs(dfloat(k))
---
>    t = dabs(dble(k))
1294c1843
<    if (t .ge. b) n = n + idint(dlog(t)/dlog(b))
---
>    if (t .ge. b) n = n + int(dlog(t)/dlog(b))
1297,1298c1846,1847
<    j = idint(dmod(t,b))
<    s(l) = dfloat(j)
---
>    j = int(dmod(t,b))
>    s(l) = dble(j)
1354c1903
<    if (ddt .eq. 25) then
---
>    if (G_DEBUG_LEVEL .eq. 25) then
1369c1918
<          if (ddt .eq. 25) then
---
>          if (G_DEBUG_LEVEL .eq. 25) then
1382c1931
< SUBROUTINE mat_print(ID,K)
---
> subroutine mat_print(ID,K)
1384c1933
< $@(#) M_matrix::mat_print(3fp): primary output routine
---
> ! ident_15="@(#)M_matrix::mat_print(3fp): primary output routine"
1386c1935
< integer           :: id(4)
---
> integer           :: id(G_MAX_NAME_LENGTH)
1389c1938
< character(len=81) :: mline
---
> character(len=81) :: message
1416a1966
> integer           :: itype
1420c1970
< ! FMT   1       2       3       4       5
---
> ! G_FMT   1       2       3       4       5
1425c1975
<    IF (LCT(1) .LT. 0) GOTO 99
---
>    if (G_LINECOUNT(1) .lt. 0) goto 99
1427,1454c1977,2005
<    L = LSTK(K)
<    M = MSTK(K)
<    N = NSTK(K)
<    MN = M*N
<    TYP = 1
<    S = 0.0D0
<    DO I = 1, MN
<       LS = L+I-1
<       TR = STKR(LS)
<       TI = STKI(LS)
<       S = DMAX1(S,DABS(TR),DABS(TI))
<       IF (mat_round(TR) .NE. TR) TYP = MAX0(2,TYP)
<       IF (TI .NE. 0.0D0) TYP = 3
<    enddo
<    IF (S .NE. 0.0D0) S = DLOG10(S)
<    KS = IDINT(S)
<    IF (-2 .LE. KS .AND. KS .LE. 1) KS = 0
<    IF (KS .EQ. 2 .AND. FMT .EQ. 1 .AND. TYP .EQ. 2) KS = 0
< 
<    F=0                          ! initialize to bad value
<    IF (TYP .EQ. 1 )THEN         ! if output type is integer
<       IF( KS .LE. 2 )THEN
<          F = 1
<       ELSE
<          F = 2
<       ENDIF
<    ENDIF
<    IF (TYP .EQ. 1 .AND. KS .GT. 9) TYP = 2  !change type from integer to real
---
>    l = G_LSTK(k)
>    m = G_MSTK(k)
>    n = G_NSTK(k)
>    mn = m*n
>    typ = 1
>    s = 0.0d0
>    itype=-9999
>    do i = 1, mn
>       ls = l+i-1
>       tr = G_STKR(ls)
>       ti = G_STKI(ls)
>       s = dmax1(s,dabs(tr),dabs(ti))
>       if (mat_round(tr) .ne. tr) typ = max0(2,typ)
>       if (ti .ne. 0.0d0) typ = 3
>    enddo
>    if (s .ne. 0.0d0) s = dlog10(s)
>    ks = int(s)
>    if (-2 .le. ks .and. ks .le. 1) ks = 0
>    if (ks .eq. 2 .and. G_FMT .eq. 1 .and. typ .eq. 2) ks = 0
> 
>    f=0                          ! initialize to bad value
>    if (typ .eq. 1 )then         ! if output type is integer
>       if( ks .le. 2 )then
>          f = 1
>       else
>          f = 2
>       endif
>    endif
>    if (typ .eq. 1 .and. ks .gt. 9) typ = 2  !change type from integer to real
1456,1457c2007,2008
<    IF (TYP .EQ. 2) F = FMT + 2   ! if type is real
<    IF (TYP .EQ. 3) F = FMT + 6   ! if type is complex
---
>    if (typ .eq. 2) f = G_FMT + 2   ! if type is real
>    if (typ .eq. 3) f = G_FMT + 6   ! if type is complex
1463c2014
<    IF (MN.EQ.1 .AND. KS.NE.0 .AND. FMT.LT.3 .AND. TYP.NE.1) F = F+2
---
>    if (mn.eq.1 .and. ks.ne.0 .and. G_FMT.lt.3 .and. typ.ne.1) f = f+2
1465c2016
<    IF (FMT .EQ. 5) F = 11
---
>    if (G_FMT .eq. 5) f = 11
1467,1468c2018,2019
<    JINC = FNL(F)
<    F = FNO(F)
---
>    jinc = fnl(f)
>    f = fno(f)
1470,1472c2021,2023
<    S = 1.0D0
<    IF (F.EQ.21 .OR. F.EQ.22 .OR. F.EQ.31 .OR. F.EQ.32) S = 10.0D0**KS
<    LS = ((N-1)/JINC+1)*M + 2
---
>    s = 1.0d0
>    if (f.eq.21 .or. f.eq.22 .or. f.eq.31 .or. f.eq.32) s = 10.0D0**ks
>    ls = ((n-1)/jinc+1)*m + 2
1474,1475c2025,2026
<    IF (LCT(1) + LS .LE. LCT(2)) GOTO 20
<    LCT(1) = 0
---
>    IF (G_LINECOUNT(1) + LS .gt. G_LINECOUNT(2)) then
>       G_LINECOUNT(1) = 0
1477,1479c2028,2029
<    WRITE(mline,43) LS
< 43 FORMAT(' AT LEAST ',I5,' MORE LINES.','  ENTER BLANK LINE TO CONTINUE OUTPUT.')
<    call journal(mline)
---
>       WRITE(message, "(' AT LEAST ',I5,' MORE LINES.','  ENTER BLANK LINE TO CONTINUE OUTPUT.')") LS
>       call journal(message)
1481c2031
<    READ(RTE,'(a1)',END=19) LS_CHAR  ! read response to pause from standard input
---
>       READ(G_RTE,'(a1)',END=19) LS_CHAR  ! read response to pause from standard input
1483c2033
<    LCT(1) = -1
---
>       G_LINECOUNT(1) = -1
1485,1487c2035,2038
< 19 CONTINUE
<    CALL mat_files(-RTE,BUF)
< 20 CONTINUE
---
>    19 continue
>       CALL mat_files(-G_RTE,G_BUF)
>    endif
>    20 continue
1490,1495c2041,2046
<    CALL mat_prntid(ID,-1)
<    LCT(1) = LCT(1)+2
<    IF (S .NE. 1.0D0)then
<       WRITE(mline,'(''  '',1PD9.1,2H *)') S
<       if(wte.eq.6)then
<          call journal(mline)
---
>    call mat_prntid(ID,-1)
>    G_LINECOUNT(1) = G_LINECOUNT(1)+2
>    if (s .ne. 1.0d0)then
>       write(message,'(''  '',1PD9.1," *")') s
>       if(G_WTE.eq.STDOUT)then
>          call journal(message)
1497c2048
<          write(wte,'(a)')mline(1:80)
---
>          write(G_WTE,'(a)')message(1:80)
1500,1505c2051,2056
<    DO 80 J1 = 1, N, JINC
<       J2 = MIN0(N, J1+JINC-1)
<       IF (N .GT. JINC)then
<          WRITE(mline,'(''     COLUMNS'',I6,'' THRU'',I6)') J1,J2
<          if(wte.eq.6)then
<             call journal(mline)
---
>    do j1 = 1, n, jinc
>       j2 = min0(n, j1+jinc-1)
>       if (n .gt. jinc)then
>          write(message,'(''     COLUMNS'',I6,'' THRU'',I6)') j1,j2
>          if(G_WTE.eq.STDOUT)then
>             call journal(message)
1507,1508c2058
<             write(wte,'(a)')mline(1:80)
<          endif
---
>             write(G_WTE,'(a)')message(1:80)
1510,1524d2059
<       DO 70 I = 1, M
<          JM = J2-J1+1
<          DO J = 1, JM
<             LS = L+I-1+(J+J1-2)*M
<             PR(J) = STKR(LS)/S
<             PI(J) = DABS(STKI(LS)/S)
<             SIG(J) = ALFA(PLUS+1)
<             IF (STKI(LS) .LT. 0.0D0) SIG(J) = ALFA(MINUS+1)
<          enddo
<          goto(11,12)F-10
<          goto(21,22,23,24)F-20
<          goto(31,32,33,34)F-30
<          IF (F .EQ. -1) THEN
<             CALL mat_formz(WTE,STKR(LS),STKI(LS))
<             goto 71
1525a2061,2116
>       do i = 1, m
>          jm = j2-j1+1
>          do j = 1, jm
>             ls = l+i-1+(j+j1-2)*m
>             pr(j) = G_STKR(ls)/s
>             pi(j) = dabs(G_STKI(ls)/s)
>             sig(j) = G_CHARSET(plus+1)
>             if (G_STKI(ls) .lt. 0.0d0) sig(j) = G_CHARSET(minus+1)
>          enddo
> 
>          select case(F)
>          case(11)
>             form='(1X,12F6.0)'          ! integer
>             istep=12
>             itype= 777
>          case(12)
>             form='(1X,6F12.0)'          ! integer
>             istep=6
>             itype= 777
>          case(21)
>             form='(1X,F9.4,7F10.4)'     ! 8 numbers
>             istep=8
>             itype= 999
>          case(22)
>             form='(1X,F19.15,3F20.15)'  ! 4 numbers
>             istep=4
>             itype= 999
>          case(23)
>             form='(1X,1P6D13.4)'        ! 6 numbers
>             istep=6
>             itype= 999
>          case(24)
>             form='(1X,1P3D24.15)'       ! 3 numbers
>             istep=3
>             itype= 999
>          case(31)
>             form='(1X,4(F9.4,1X,A1,F7.4,''i''))'                       ! 4x3
>             istep=12
>             itype= 888
>          case(32)
>             form='(1X,F19.15,A1,F18.15,''i'',F20.15,A1,F18.15,''i'')'  ! 6
>             istep=6
>             itype= 888
>          case(33)
>             form='(1X,3(1PD13.4,1X,A1,1PD10.4,''i''))'                 ! 9
>             istep=9
>             itype= 888
>          case(34)
>             form='(1X,1PD24.15,1X,A1,1PD21.15,''i'')'                  ! 3
>             istep=3
>             itype= 888
>          case(-1)
>             call mat_formz(G_WTE,G_STKR(ls),G_STKI(ls))
>             istep=-1
>             itype=-1
>          case default
1528,1573c2119,2130
< !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
< 11       CONTINUE
<          FORM='(1X,12F6.0)'  ! integer
<          ISTEP=12
<          goto 716
< 12       CONTINUE
<          FORM='(1X,6F12.0)'  ! integer
<          ISTEP=6
<          goto 716
< 
< 716      CONTINUE
<          J3=1
< 7161     CONTINUE
<          WRITE(mline,FORM)(PR(J),J=J3,MIN(J3+ISTEP-1,JM))
<          if(wte.eq.6)then
<             call journal(mline)
<          else
<             write(wte,'(a)')mline(1:80)
<          endif
<          J3=J3+ISTEP
<          if(J3.le.JM)goto 7161
<          GOTO 71
< !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
< 21       CONTINUE
<          FORM='(1X,F9.4,7F10.4)'  ! 8 numbers
<          ISTEP=8
<          goto 714
< 22       CONTINUE
<          FORM='(1X,F19.15,3F20.15)'  ! 4 numbers
<          ISTEP=4
<          goto 714
< 23       CONTINUE
<          FORM='(1X,1P6D13.4)'   ! 6 numbers
<          ISTEP=6
<          goto 714
< 24       CONTINUE
<          FORM='(1X,1P3D24.15)'  ! 3 numbers
<          ISTEP=3
<          GOTO 714
< 
< 714      CONTINUE
<          J3=1
< 7141     CONTINUE
<          WRITE(mline,FORM)(PR(J),J=J3,MIN(J3+ISTEP,JM))
<          if(wte.eq.6)then
<             call journal(mline)
---
>          end select
> 
>          ! print data based on type
>          if(itype.gt.0)then
>             do j3=1,jm,istep
>                select case(itype)
>                case(777); write(message,form)(pr(j),j=j3,min(j3+istep-1,jm))
>                case(999); write(message,form)(pr(j),j=j3,min(j3+istep,jm))
>                case(888); write(message,form)(pr(j),sig(j),pi(j),j=j3,min(j3+istep-1,jm))
>                end select
>                if(G_WTE.eq.STDOUT)then
>                   call journal(message)
1575c2132
<             write(wte,'(a)')mline(1:80)
---
>                   write(G_WTE,'(a)')message(1:80)
1577,1604c2134
<          J3=J3+ISTEP
<          if(J3.le.JM)goto 7141
<          goto 71
< !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
< 31       CONTINUE
<          FORM='(1X,4(F9.4,1X,A1,F7.4,''i''))'  ! 4x3
<          ISTEP=12
<          goto 718
< 32       CONTINUE
<          FORM='(1X,F19.15,A1,F18.15,''i'',F20.15,A1,F18.15,''i'')'  ! 6
<          ISTEP=6
<          goto 718
< 33       CONTINUE
<          FORM='(1X,3(1PD13.4,1X,A1,1PD10.4,''i''))'  ! 9
<          ISTEP=9
<          goto 718
< 34       CONTINUE
<          FORM='(1X,1PD24.15,1X,A1,1PD21.15,''i'')'  ! 3
<          ISTEP=3
< 
< 718      CONTINUE
<          J3=1
< 7181     CONTINUE
<          WRITE(mline,form)(PR(J),SIG(J),PI(J),J=J3,MIN(J3+ISTEP-1,JM))
<          if(wte.eq.6)then
<             call journal(mline)
<          else
<             write(wte,'(a)')mline(1:80)
---
>             enddo
1606,1619c2136,2144
<          J3=J3+ISTEP
<          if(J3.le.JM)goto 7181
<          goto 71
< !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
< 71       CONTINUE
<          LCT(1) = LCT(1)+1
< 70    CONTINUE
< 80 CONTINUE
<    GOTO 99
< !.......................................................................
< 99 CONTINUE
<    if(wte.ne.6)flush(unit=wte,iostat=ios)
< !
< END SUBROUTINE mat_print
---
> 
>          G_LINECOUNT(1) = G_LINECOUNT(1)+1
>       enddo
>    enddo
> 
> 99 continue
>    if(G_WTE.ne.STDOUT)flush(unit=G_WTE,iostat=ios)
> 
> end subroutine mat_print
1625c2150
< $@(#) M_matrix::mat_wsqrt(3fp): y = sqrt(x) with yr .ge. 0.0 and sign(yi) .eq. sign(xi)
---
> ! ident_16="@(#)M_matrix::mat_wsqrt(3fp): y = sqrt(x) with yr .ge. 0.0 and sign(yi) .eq. sign(xi)"
1627,1630c2152,2155
< doubleprecision :: xr
< doubleprecision :: xi
< doubleprecision :: yr
< doubleprecision :: yi
---
> doubleprecision,intent(in)  :: xr
> doubleprecision,intent(in)  :: xi
> doubleprecision,intent(out) :: yr
> doubleprecision,intent(out) :: yi
1650c2175
< $@(#) M_matrix::mat_wlog(3fp): y = log(x)
---
> ! ident_17="@(#)M_matrix::mat_wlog(3fp): y = log(x)"
1671c2196
< $@(#) M_matrix::mat_formz: system dependent routine to print with z format
---
> ! ident_18="@(#)M_matrix::mat_formz: system dependent routine to print with z format"
1692c2217
< $@(#) issue interactive prompt with optional pause
---
> ! ident_19="@(#)issue interactive prompt with optional pause"
1698,1701c2223,2226
<    if(wte.le.0)then
<       call journal('*mat_prompt* internal error: wte <= 0')
<    elseif(rte.lt.0)then
<       call journal('*mat_prompt* internal error: rte <= 0')
---
>    if(G_WTE.le.0)then
>       call journal('*mat_prompt* internal error: G_WTE <= 0')
>    elseif(G_RTE.lt.0)then
>       call journal('*mat_prompt* internal error: G_RTE <= 0')
1704,1705c2229,2230
<       if(wte.eq.6)then
<          WRITE(WTE,'(''<>'')',advance='no')   ! write prompt to interactive input
---
>       if(G_WTE.eq.STDOUT)then
>          WRITE(G_WTE,'(''<>'')',advance='no')   ! write prompt to interactive input
1707c2232
<       if (pause .eq. 1) read(rte,'(a1)') dummy
---
>       if (pause .eq. 1) read(G_RTE,'(a1)') dummy
1716c2241
< $@(#) M_matrix::mat_magic(3fp): Algorithms for magic squares
---
> ! ident_20="@(#)M_matrix::mat_magic(3fp): Algorithms for magic squares"
1718c2243
< !        Algorithims taken from
---
> !        Algorithms taken from
1723d2247
< doubleprecision :: a(lda,n)
1724a2249
> doubleprecision :: a(lda,n)
1759c2284
<       if(idint(a(i1,j1)).eq.0) goto 30
---
>       if(int(a(i1,j1)).eq.0) goto 30
1856c2381
<    tol = eps*dfloat(2*max0(m,n))*tol
---
>    tol = eps*dble(2*max0(m,n))*tol
1907,1909c2432,2434
< integer         :: n
< doubleprecision :: sr
< doubleprecision :: si
---
> integer,intent(in)         :: n
> doubleprecision,intent(in) :: sr
> doubleprecision,intent(in) :: si
1928c2453
< $@(#) mat_wmul(3fp) - [M_matrix] c = a*b
---
> ! ident_21="@(#)M_matrix::mat_wmul(3fp) c = a*b"
1930,1935c2455,2460
< doubleprecision :: ar
< doubleprecision :: ai
< doubleprecision :: br
< doubleprecision :: bi
< doubleprecision :: cr
< doubleprecision :: ci
---
> doubleprecision,intent(in)  :: ar
> doubleprecision,intent(in)  :: ai
> doubleprecision,intent(in)  :: br
> doubleprecision,intent(in)  :: bi
> doubleprecision,intent(out) :: cr
> doubleprecision,intent(out) :: ci
1948c2473
< $@(#) M_matrix::mat_stack1(3f): Unary Operations
---
> ! ident_22="@(#)M_matrix::mat_stack1(3f): Unary Operations"
1961,1964c2486,2489
<    IF (DDT .EQ. 1) call journal('sc','mat_stack1 ',OP)
<    L = LSTK(TOP)
<    M = MSTK(TOP)
<    N = NSTK(TOP)
---
>    IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc','mat_stack1 ',OP)
>    L = G_LSTK(G_TOP)
>    M = G_MSTK(G_TOP)
>    N = G_NSTK(G_TOP)
1968c2493
<       CALL mat_wrscal(MN,-1.0D0,STKR(L),STKI(L),1)
---
>       CALL mat_wrscal(MN,-1.0D0,G_STKR(L),G_STKI(L),1)
1971,1978c2496,2503
<       ERR = LL+MN - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       CALL mat_wcopy(MN,STKR(L),STKI(L),1,STKR(LL),STKI(LL),1)
<       M = NSTK(TOP)
<       N = MSTK(TOP)
<       MSTK(TOP) = M
<       NSTK(TOP) = N
---
>       G_ERR = LL+MN - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       CALL mat_wcopy(MN,G_STKR(L),G_STKI(L),1,G_STKR(LL),G_STKI(LL),1)
>       M = G_NSTK(G_TOP)
>       N = G_MSTK(G_TOP)
>       G_MSTK(G_TOP) = M
>       G_NSTK(G_TOP) = N
1983,1984c2508,2509
<             STKR(LL) = STKR(LS)
<             STKI(LL) = -STKI(LS)
---
>             G_STKR(LL) = G_STKR(LS)
>             G_STKI(LL) = -G_STKI(LS)
1994c2519
< $@(#) M_matrix::mat_rrot(3f): Applies a plane rotation.
---
> ! ident_23="@(#)M_matrix::mat_rrot(3f): Applies a plane rotation."
2028c2553
< $@(#) M_matrix::mat_rset(3f): copies a scalar, dx, to a scalar, dy.
---
> ! ident_24="@(#)M_matrix::mat_rset(3f): copies a scalar, dx, to a scalar, dy."
2050c2575
< $@(#) M_matrix::mat_prntid(3fp): print table of variable id names (up to) eight per line
---
> ! ident_25="@(#)M_matrix::mat_prntid(3fp): print table of variable id names (up to) eight per line"
2052c2577
< !     ID     IS ARRAY OF 4-CHARACTER IDS TO PRINT
---
> !     ID     IS ARRAY OF G_MAX_NAME_LENGTH CHARACTER IDS TO PRINT
2056c2581
< integer :: id(4,*)
---
> integer :: id(G_MAX_NAME_LENGTH,*)
2060c2585
< integer             :: linebuf(256)    ! scratch buffer for building up line
---
> integer             :: linebuf(8*G_MAX_NAME_LENGTH+2*8+1)    ! scratch buffer for building up line
2062,2063c2587,2588
< integer,parameter   ::  ade_blank=32
< integer,parameter   ::  ade_equal=61
---
> integer,parameter   ::  hollerith_blank=ichar(' ')+538976304-48
> integer,parameter   ::  hollerith_equal=ichar('=')+538976304-48
2069c2594
<       linebuf(1)=ade_blank                ! put a space at beginning of line
---
>       linebuf(1)=hollerith_blank          ! put a space at beginning of line
2072c2597
<          do i = 1, 4                      !    copy one name into buffer
---
>          do i = 1, G_MAX_NAME_LENGTH        !    copy one name into buffer
2074,2075c2599,2600
<             linebuf(l) = alfa(k)
<             l = l+1                       ! increment pointer into output
---
>             linebuf(l) = G_CHARSET(k)
>             if(linebuf(l).ne.hollerith_blank)l = l+1   ! increment pointer into output
2077,2078c2602,2603
<          linebuf(l+0)=ade_blank           ! put two space between names
<          linebuf(l+1)=ade_blank
---
>          linebuf(l+0)=hollerith_blank           ! put two space between names
>          linebuf(l+1)=hollerith_blank
2082c2607
<          linebuf(l) = ade_equal           ! put value for equal sign into buffer
---
>          linebuf(l) = hollerith_equal     ! put value for equal sign into buffer
2088c2613
<       if(wte.eq.6)then
---
>       if(G_WTE.eq.STDOUT)then
2091c2616
<          write(wte,'(a)')mline(1:80)      ! print the line
---
>          write(G_WTE,'(a)')mline(1:80)      ! print the line
2101c2626
< subroutine mat_stackp(id)
---
> subroutine MAT_STACK_PUT(id)
2103c2628
< $@(#) M_matrix::mat_stackp(3fp): put variables into storage
---
> ! ident_26="@(#)M_matrix::MAT_STACK_PUT(3fp): put variables into storage"
2105c2630
< integer             :: id(4)
---
> integer             :: id(G_MAX_NAME_LENGTH)
2135c2660
<    if (ddt .eq. 1) then
---
>    if (G_DEBUG_LEVEL .eq. 1) then
2140,2141c2665,2668
<    if (top .le. 0) call mat_err(1)
<    if (err .gt. 0) return
---
>    if (G_top .le. 0) then
>       call mat_err(1)
>       return
>    endif
2144,2145c2671,2678
<    if (fin .ne. 0) call mat_err(25)
<    if (err .gt. 0) return
---
>    if (G_fin .ne. 0) then
>       call mat_err(25)
>       return
>    endif
> 
>    m = G_MSTK(G_top)
>    n = G_NSTK(G_top)
>    if (m .gt. 0) l = G_LSTK(G_top)
2147,2151c2680,2683
<    m = mstk(top)
<    n = nstk(top)
<    if (m .gt. 0) l = lstk(top)
<    if (m .lt. 0) call mat_err(14)
<    if (err .gt. 0) return
---
>    if (m .lt. 0) then
>       call mat_err(14)
>       return
>    endif
2163,2164c2695,2696
<    call mat_putid(idstk(1,bot-1),id)
<    k = lsize+1
---
>    call mat_putid(G_IDSTK(1,G_BOT-1),id)
>    k = G_MAX_NUMBER_OF_NAMES+1
2167,2171c2699,2703
<    if (.not.mat_eqid(idstk(1,k),id)) goto 05
<    if (k .eq. bot-1) goto 30
<    lk = lstk(k)
<    mk = mstk(k)
<    nk = nstk(k)
---
>    if (.not.mat_eqid(G_IDSTK(1,k),id)) goto 05
>    if (k .eq. G_BOT-1) goto 30
>    lk = G_LSTK(k)
>    mk = G_MSTK(k)
>    nk = G_NSTK(k)
2173,2175c2705,2707
<    if (rhs .eq. 0) goto 20
<    if (rhs .gt. 2) call mat_err(15)
<    if (err .gt. 0) return
---
>    if (G_rhs .eq. 0) goto 20
>    if (G_rhs .gt. 2) call mat_err(15)
>    if (G_err .gt. 0) return
2179,2182c2711,2714
<    err = lt + mnk - lstk(bot)
<    if (err .gt. 0) call mat_err(17)
<    if (err .gt. 0) return
<    call mat_wcopy(mnk,stkr(lk),stki(lk),1,stkr(lt),stki(lt),1)
---
>    G_err = lt + mnk - G_LSTK(G_BOT)
>    if (G_err .gt. 0) call mat_err(17)
>    if (G_err .gt. 0) return
>    call mat_wcopy(mnk,G_stkr(lk),G_STKI(lk),1,G_stkr(lt),G_STKI(lt),1)
2186,2188c2718,2720
<    if (rhs.eq.0 .and. mn.eq.mnk) goto 40
<    if (k .ge. lsize-3) call mat_err(13)
<    if (err .gt. 0) return
---
>    if (G_rhs.eq.0 .and. mn.eq.mnk) goto 40
>    if (k .ge. G_MAX_NUMBER_OF_NAMES-3) call mat_err(13)
>    if (G_err .gt. 0) return
2191,2192c2723,2724
<    if (k .eq. bot) goto 25
<    ls = lstk(bot)
---
>    if (k .eq. G_BOT) goto 25
>    ls = G_LSTK(G_BOT)
2194c2726
<    call mat_wcopy(lk-ls,stkr(ls),stki(ls),-1,stkr(ll),stki(ll),-1)
---
>    call mat_wcopy(lk-ls,G_stkr(ls),G_STKI(ls),-1,G_stkr(ll),G_STKI(ll),-1)
2196,2201c2728,2733
<    do ib = bot, km1
<       i = bot+km1-ib
<       call mat_putid(idstk(1,i+1),idstk(1,i))
<       mstk(i+1) = mstk(i)
<       nstk(i+1) = nstk(i)
<       lstk(i+1) = lstk(i)+mnk
---
>    do ib = G_BOT, km1
>       i = G_BOT+km1-ib
>       call mat_putid(G_IDSTK(1,i+1),G_IDSTK(1,i))
>       G_MSTK(i+1) = G_MSTK(i)
>       G_NSTK(i+1) = G_NSTK(i)
>       G_LSTK(i+1) = G_LSTK(i)+mnk
2206c2738
<    bot = bot+1
---
>    G_BOT = G_BOT+1
2211,2216c2743,2748
<    if (bot-2 .le. top) call mat_err(18)
<    if (err .gt. 0) return
<    k = bot-1
<    call mat_putid(idstk(1,k), id)
<    if (rhs .eq. 1) goto 50
<    if (rhs .eq. 2) goto 55
---
>    if (G_BOT-2 .le. G_top) call mat_err(18)
>    if (G_err .gt. 0) return
>    k = G_BOT-1
>    call mat_putid(G_IDSTK(1,k), id)
>    if (G_rhs .eq. 1) goto 50
>    if (G_rhs .eq. 2) goto 55
2220,2224c2752,2756
<    if (k .lt. lsize) lstk(k) = lstk(k+1) - mn
<    mstk(k) = m
<    nstk(k) = n
<    lk = lstk(k)
<    call mat_wcopy(mn,stkr(l),stki(l),-1,stkr(lk),stki(lk),-1)
---
>    if (k .lt. G_MAX_NUMBER_OF_NAMES) G_LSTK(k) = G_LSTK(k+1) - mn
>    G_MSTK(k) = m
>    G_NSTK(k) = n
>    lk = G_LSTK(k)
>    call mat_wcopy(mn,G_stkr(l),G_STKI(l),-1,G_stkr(lk),G_STKI(lk),-1)
2229c2761
<    if (mstk(top-1) .lt. 0) goto 59
---
>    if (G_MSTK(G_top-1) .lt. 0) goto 59
2235,2237c2767,2769
<    l1 = lstk(top-1)
<    m1 = mstk(top-1)
<    mn1 = m1*nstk(top-1)
---
>    l1 = G_LSTK(G_top-1)
>    m1 = G_MSTK(G_top-1)
>    mn1 = m1*G_NSTK(G_top-1)
2242,2245c2774,2777
<    if (err .gt. 0) return
<    l2 = lstk(top-1)
<    m2 = mstk(top-1)
<    mn2 = m2*nstk(top-1)
---
>    if (G_err .gt. 0) return
>    l2 = G_LSTK(G_top-1)
>    m2 = G_MSTK(G_top-1)
>    mn2 = m2*G_NSTK(G_top-1)
2251,2254c2783,2786
<    if (mstk(top-1).lt.0 .and. mstk(top-2).lt.0) goto 59
<    l2 = lstk(top-1)
<    m2 = mstk(top-1)
<    mn2 = m2*nstk(top-1)
---
>    if (G_MSTK(G_top-1).lt.0 .and. G_MSTK(G_top-2).lt.0) goto 59
>    l2 = G_LSTK(G_top-1)
>    m2 = G_MSTK(G_top-1)
>    mn2 = m2*G_NSTK(G_top-1)
2256,2258c2788,2790
<    l1 = lstk(top-2)
<    m1 = mstk(top-2)
<    mn1 = m1*nstk(top-2)
---
>    l1 = G_LSTK(G_top-2)
>    m1 = G_MSTK(G_top-2)
>    mn1 = m1*G_NSTK(G_top-2)
2264,2266c2796,2798
<    if (err .gt. 0) return
<    lk = lstk(k)
<    call mat_wcopy(mn,stkr(l),stki(l),-1,stkr(lk),stki(lk),-1)
---
>    if (G_err .gt. 0) return
>    lk = G_LSTK(k)
>    call mat_wcopy(mn,G_stkr(l),G_STKI(l),-1,G_stkr(lk),G_STKI(lk),-1)
2271c2803
<    if (err .gt. 0) return
---
>    if (G_err .gt. 0) return
2276,2277c2808,2809
<       mk = max0(mk,idint(stkr(ls)))
<       ll = min0(ll,idint(stkr(ls)))
---
>       mk = max0(mk,int(G_stkr(ls)))
>       ll = min0(ll,int(G_stkr(ls)))
2284,2285c2816,2817
<       nk = max0(nk,idint(stkr(ls)))
<       ll = min0(ll,idint(stkr(ls)))
---
>       nk = max0(nk,int(G_stkr(ls)))
>       ll = min0(ll,int(G_stkr(ls)))
2290c2822
<    if (err .gt. 0) return
---
>    if (G_err .gt. 0) return
2292,2299c2824,2831
<    lk = lstk(k+1) - mnk
<    err = lt + mt*nt - lk
<    if (err .gt. 0) call mat_err(17)
<    if (err .gt. 0) return
<    lstk(k) = lk
<    mstk(k) = mk
<    nstk(k) = nk
<    call mat_wset(mnk,0.0d0,0.0d0,stkr(lk),stki(lk),1)
---
>    lk = G_LSTK(k+1) - mnk
>    G_err = lt + mt*nt - lk
>    if (G_err .gt. 0) call mat_err(17)
>    if (G_err .gt. 0) return
>    G_LSTK(k) = lk
>    G_MSTK(k) = mk
>    G_NSTK(k) = nk
>    call mat_wset(mnk,0.0d0,0.0d0,G_stkr(lk),G_STKI(lk),1)
2304c2836
<       call mat_wcopy(mt,stkr(ls),stki(ls),-1,stkr(ll),stki(ll),-1)
---
>       call mat_wcopy(mt,G_stkr(ls),G_STKI(ls),-1,G_stkr(ll),G_STKI(ll),-1)
2310c2842
<          if (m1 .gt. 0) li = l1 + idint(stkr(li)) - 1
---
>          if (m1 .gt. 0) li = l1 + int(G_stkr(li)) - 1
2312c2844
<          if (m2 .gt. 0) lj = l2 + idint(stkr(lj)) - 1
---
>          if (m2 .gt. 0) lj = l2 + int(G_stkr(lj)) - 1
2315,2316c2847,2848
<          stkr(ll) = stkr(ls)
<          stki(ll) = stki(ls)
---
>          G_stkr(ll) = G_stkr(ls)
>          G_STKI(ll) = G_STKI(ls)
2323,2325c2855,2857
<    if (sym.ne.semi .and. lct(3).eq.0) call mat_print(id,k)
<    if (sym.eq.semi .and. lct(3).eq.1) call mat_print(id,k)
<    if (k .eq. bot-1) bot = bot-1
---
>    if (G_sym.ne.semi .and. G_LINECOUNT(3).eq.0) call mat_print(id,k)
>    if (G_sym.eq.semi .and. G_LINECOUNT(3).eq.1) call mat_print(id,k)
>    if (k .eq. G_BOT-1) G_BOT = G_BOT-1
2327,2329c2859,2861
<    if (m .ne. 0) top = top - 1 - rhs
<    if (m .eq. 0) top = top - 1
< end subroutine mat_stackp
---
>    if (m .ne. 0) G_top = G_top - 1 - G_rhs
>    if (m .eq. 0) G_top = G_top - 1
> end subroutine MAT_STACK_PUT
2373c2905
< $@(#) M_matrix::mat_watan(3fp): y = atan(x) = (i/2)*log((i+x)/(i-x))
---
> ! ident_27="@(#)M_matrix::mat_watan(3fp): y = atan(x) = (i/2)*log((i+x)/(i-x))"
2400c2932
< $@(#) M_matrix::mat_rrotg(3fp): construct Givens plane rotation.
---
> ! ident_28="@(#)M_matrix::mat_rrotg(3fp): construct Givens plane rotation."
2429c2961
< $@(#) M_matrix::mat_wsign(3fp): if y .ne. 0, z = x*y/abs(y); if y .eq. 0, z = x
---
> ! ident_29="@(#)M_matrix::mat_wsign(3fp): if y .ne. 0, z = x*y/abs(y)"
2451c2983
< integer            :: ID(4)
---
> integer            :: ID(G_MAX_NAME_LENGTH)
2462,2464c2994,2996
< integer,parameter  :: ANS(4) =[10,23,28,36]
< integer,parameter  :: ENND(4)=[14,23,13,36]
< integer,parameter  :: ELSE(4)=[14,21,28,14]
---
> integer,parameter  :: ANS(G_MAX_NAME_LENGTH) =[10,23,28,36,G_PAD(:)]
> integer,parameter  :: ENND(G_MAX_NAME_LENGTH)=[14,23,13,36,G_PAD(:)]
> integer,parameter  :: ELSE(G_MAX_NAME_LENGTH)=[14,21,28,14,G_PAD(:)]
2479,2482c3011,3014
<       IF (ERR .GT. 0) PTZ = 0
<       IF (ERR.LE.0 .AND. PT.GT.PTZ) R = RSTK(PT)
<       IF (DDT .EQ. 1) THEN
<          WRITE(MLINE,'('' PARSE'',4I4)') PT,R,PTZ,ERR
---
>       IF (G_ERR .GT. 0) G_PTZ = 0
>       IF (G_ERR.LE.0 .AND. G_PT.GT.G_PTZ) R = G_RSTK(G_PT)
>       IF (G_DEBUG_LEVEL .EQ. 1) THEN
>          WRITE(MLINE,'('' PARSE'',4I4)') G_PT,R,G_PTZ,G_ERR
2487,2493c3019,3025
<       SYM = EOL
<       TOP = 0
<       IF (RIO .NE. RTE) CALL mat_files(-RIO,BUF)
<       RIO = RTE
<       LCT(3) = 0
<       LCT(4) = 2
<       LPT(1) = 1
---
>       G_SYM = G_EOL
>       G_TOP = 0
>       IF (G_RIO .NE. G_RTE) CALL mat_files(-G_RIO,G_BUF)
>       G_RIO = G_RTE
>       G_LINECOUNT(3) = 0
>       G_LINECOUNT(4) = 2
>       G_LPT(1) = 1
2495,2498c3027,3030
<       IF (SYM.EQ.EOL.AND.MOD(LCT(4)/2,2).EQ.1) CALL mat_prompt(LCT(4)/4)
<       IF (SYM .EQ. EOL) CALL mat_getlin()
<       ERR = 0
<       PT = PTZ
---
>       IF (G_SYM.EQ.G_EOL.AND.MOD(G_LINECOUNT(4)/2,2).EQ.1) CALL mat_prompt(G_LINECOUNT(4)/4)
>       IF (G_SYM .EQ. G_EOL) CALL mat_getlin()
>       G_ERR = 0
>       G_PT = G_PTZ
2501c3033
<       IF (DDT .EQ. 1) THEN
---
>       IF (G_DEBUG_LEVEL .EQ. 1) THEN
2503,2504c3035,3036
<          CALL mat_appnum(REAL(PT),MLINE,ILEN,IERR)
<          CALL mat_appnum(REAL(TOP),MLINE,ILEN,IERR)
---
>          CALL mat_appnum(REAL(G_PT),MLINE,ILEN,IERR)
>          CALL mat_appnum(REAL(G_TOP),MLINE,ILEN,IERR)
2507c3039
<       LHS = 1
---
>       G_LHS = 1
2510,2515c3042,3047
<       IF (SYM.EQ.COLON .AND. CHRA.EQ.EOL) DDT = 1-DDT
<       IF (SYM .EQ. COLON) CALL mat_getsym()
<       IF (SYM.EQ.SEMI .OR. SYM.EQ.COMMA .OR. SYM.EQ.EOL) GOTO 80
<       IF (SYM .EQ. NAME) GOTO 20
<       IF (SYM .EQ. LESS) GOTO 40
<       IF (SYM .EQ. GREAT) GOTO 45
---
>       IF (G_SYM.EQ.COLON .AND. G_CHRA.EQ.G_EOL) G_DEBUG_LEVEL = 1-G_DEBUG_LEVEL
>       IF (G_SYM .EQ. COLON) CALL mat_getsym()
>       IF (G_SYM.EQ.SEMI .OR. G_SYM.EQ.COMMA .OR. G_SYM.EQ.G_EOL) GOTO 80
>       IF (G_SYM .EQ. NAME) GOTO 20
>       IF (G_SYM .EQ. LESS) GOTO 40
>       IF (G_SYM .EQ. GREAT) GOTO 45
2520,2525c3052,3057
<       CALL mat_comand(SYN)
<       IF (ERR .GT. 0) GOTO 01
<       IF (FUN .EQ. 99) GOTO 95
<       IF (FIN .EQ. -15) GOTO 80
<       IF (FIN .LT. 0) GOTO 91
<       IF (FIN .GT. 0) GOTO 70
---
>       CALL mat_comand(G_SYN)
>       IF (G_ERR .GT. 0) GOTO 01
>       IF (G_FUN .EQ. 99) GOTO 95
>       IF (G_FIN .EQ. -15) GOTO 80
>       IF (G_FIN .LT. 0) GOTO 91
>       IF (G_FIN .GT. 0) GOTO 70
2527,2529c3059,3061
<       RHS = 0
<       CALL mat_funs(SYN)
<       IF (FIN .NE. 0) GOTO 50
---
>       G_RHS = 0
>       CALL mat_funs(G_SYN)
>       IF (G_FIN .NE. 0) GOTO 50
2531,2533c3063,3065
<       IF (CHRA.EQ.SEMI .OR. CHRA.EQ.COMMA .OR. CHRA.EQ.EOL) CALL mat_putid(ID,SYN)
<       IF (CHRA .EQ. EQUAL) GOTO 25
<       IF (CHRA .EQ. LPAREN) GOTO 30
---
>       IF (G_CHRA.EQ.SEMI .OR. G_CHRA.EQ.COMMA .OR. G_CHRA.EQ.G_EOL) CALL mat_putid(ID,G_SYN)
>       IF (G_CHRA .EQ. EQUAL) GOTO 25
>       IF (G_CHRA .EQ. LPAREN) GOTO 30
2538c3070
<       CALL mat_putid(ID,SYN)
---
>       CALL mat_putid(ID,G_SYN)
2545,2546c3077,3078
<       LPT(5) = LPT(4)
<       CALL mat_putid(ID,SYN)
---
>       G_LPT(5) = G_LPT(4)
>       CALL mat_putid(ID,G_SYN)
2551,2554c3083,3086
<       PT = PT+1
<       CALL mat_putid(IDS(1,PT), ID)
<       PSTK(PT) = EXCNT
<       RSTK(PT) = 1
---
>       G_PT = G_PT+1
>       CALL mat_putid(G_IDS(1,G_PT), ID)
>       G_PSTK(G_PT) = EXCNT
>       G_RSTK(G_PT) = 1
2559,2567c3091,3099
<       CALL mat_putid(ID,IDS(1,PT))
<       EXCNT = PSTK(PT)
<       PT = PT-1
<       IF (SYM .EQ. COMMA) GOTO 32
<       IF (SYM .NE. RPAREN) CALL mat_err(3)
<       IF (ERR .GT. 0) GOTO 01
<       IF (ERR .GT. 0) RETURN
<       IF (SYM .EQ. RPAREN) CALL mat_getsym()
<       IF (SYM .EQ. EQUAL) GOTO 50
---
>       CALL mat_putid(ID,G_IDS(1,G_PT))
>       EXCNT = G_PSTK(G_PT)
>       G_PT = G_PT-1
>       IF (G_SYM .EQ. COMMA) GOTO 32
>       IF (G_SYM .NE. RPAREN) CALL mat_err(3)
>       IF (G_ERR .GT. 0) GOTO 01
>       IF (G_ERR .GT. 0) RETURN
>       IF (G_SYM .EQ. RPAREN) CALL mat_getsym()
>       IF (G_SYM .EQ. EQUAL) GOTO 50
2569,2573c3101,3105
<       TOP = TOP - EXCNT
<       LPT(4) = LPT(5)
<       CHRA = LPAREN
<       SYM = NAME
<       CALL mat_putid(SYN,ID)
---
>       G_TOP = G_TOP - EXCNT
>       G_LPT(4) = G_LPT(5)
>       G_CHRA = LPAREN
>       G_SYM = NAME
>       CALL mat_putid(G_SYN,ID)
2580,2581c3112,3113
<       LPT(5) = LPT(4)
<       PTS = PT
---
>       G_LPT(5) = G_LPT(4)
>       PTS = G_PT
2584,2585c3116,3117
<       IF (SYM .NE. NAME) GOTO 43
<       CALL mat_putid(ID,SYN)
---
>       IF (G_SYM .NE. NAME) GOTO 43
>       CALL mat_putid(ID,G_SYN)
2587,2592c3119,3124
<       IF (SYM .EQ. GREAT) GOTO 42
<       IF (SYM .EQ. COMMA) CALL mat_getsym()
<       PT = PT+1
<       LHS = LHS+1
<       PSTK(PT) = 0
<       CALL mat_putid(IDS(1,PT),ID)
---
>       IF (G_SYM .EQ. GREAT) GOTO 42
>       IF (G_SYM .EQ. COMMA) CALL mat_getsym()
>       G_PT = G_PT+1
>       G_LHS = G_LHS+1
>       G_PSTK(G_PT) = 0
>       CALL mat_putid(G_IDS(1,G_PT),ID)
2596c3128
<       IF (SYM .EQ. EQUAL) GOTO 50
---
>       IF (G_SYM .EQ. EQUAL) GOTO 50
2598,2603c3130,3135
<       LPT(4) = LPT(5)
<       PT = PTS
<       LHS = 1
<       SYM = LESS
<       CHRA = LPT(4)-1
<       CHRA = LIN(CHRA)
---
>       G_LPT(4) = G_LPT(5)
>       G_PT = PTS
>       G_LHS = 1
>       G_SYM = LESS
>       G_CHRA = G_LPT(4)-1
>       G_CHRA = G_LIN(G_CHRA)
2610c3142
<       IF (DDT .EQ. 1) THEN
---
>       IF (G_DEBUG_LEVEL .EQ. 1) THEN
2612,2613c3144,3145
<          CALL mat_appnum(REAL(PT),MLINE,ILEN,IERR)
<          CALL mat_appnum(REAL(TOP),MLINE,ILEN,IERR)
---
>          CALL mat_appnum(REAL(G_PT),MLINE,ILEN,IERR)
>          CALL mat_appnum(REAL(G_TOP),MLINE,ILEN,IERR)
2615,2618c3147,3150
<       IF (SYM.EQ.LESS .AND. CHRA.EQ.EOL) CALL mat_err(28)
<       IF (ERR .GT. 0) GOTO 01
<       PT = PT+1
<       RSTK(PT) = 20
---
>       IF (G_SYM.EQ.LESS .AND. G_CHRA.EQ.G_EOL) CALL mat_err(28)
>       IF (G_ERR .GT. 0) GOTO 01
>       G_PT = G_PT+1
>       G_RSTK(G_PT) = 20
2623,2631c3155,3163
<       PT = PT-1
<       IF (SYM.NE.LESS .AND. SYM.NE.EOL) CALL mat_err(37)
<       IF (ERR .GT. 0) GOTO 01
<       IF (SYM .EQ. LESS) CALL mat_getsym()
<       K = LPT(6)
<       LIN(K+1) = LPT(1)
<       LIN(K+2) = LPT(2)
<       LIN(K+3) = LPT(6)
<       LPT(1) = K + 4
---
>       G_PT = G_PT-1
>       IF (G_SYM.NE.LESS .AND. G_SYM.NE.G_EOL) CALL mat_err(37)
>       IF (G_ERR .GT. 0) GOTO 01
>       IF (G_SYM .EQ. LESS) CALL mat_getsym()
>       K = G_LPT(6)
>       G_LIN(K+1) = G_LPT(1)
>       G_LIN(K+2) = G_LPT(2)
>       G_LIN(K+3) = G_LPT(6)
>       G_LPT(1) = K + 4
2633,2635c3165,3167
<       K = LPT(1)
<       L = LSTK(TOP)
<       N = MSTK(TOP)*NSTK(TOP)
---
>       K = G_LPT(1)
>       L = G_LSTK(G_TOP)
>       N = G_MSTK(G_TOP)*G_NSTK(G_TOP)
2638,2640c3170,3172
<          LIN(K) = IDINT(STKR(LS))
<          IF (LIN(K).LT.0 .OR. LIN(K).GE.IALF) CALL mat_err(37)
<          IF (ERR .GT. 0) RETURN
---
>          G_LIN(K) = int(G_STKR(LS))
>          IF (G_LIN(K).LT.0 .OR. G_LIN(K).GE.G_CHARSET_SIZE) CALL mat_err(37)
>          IF (G_ERR .GT. 0) RETURN
2648,2658c3180,3190
<       TOP = TOP-1
<       LIN(K) = EOL
<       LPT(6) = K
<       LPT(4) = LPT(1)
<       LPT(3) = 0
<       LPT(2) = 0
<       LCT(1) = 0
<       CHRA = BLANK
<       PT = PT+1
<       PSTK(PT) = LPT(1)
<       RSTK(PT) = 21
---
>       G_TOP = G_TOP-1
>       G_LIN(K) = G_EOL
>       G_LPT(6) = K
>       G_LPT(4) = G_LPT(1)
>       G_LPT(3) = 0
>       G_LPT(2) = 0
>       G_LINECOUNT(1) = 0
>       G_CHRA = BLANK
>       G_PT = G_PT+1
>       G_PSTK(G_PT) = G_LPT(1)
>       G_RSTK(G_PT) = 21
2663,2665c3195,3197
<       PT = PT-1
<       IF (DDT .EQ. 1)then
<          WRITE(mline,'('' MACEND '',2I4)') PT,TOP
---
>       G_PT = G_PT-1
>       IF (G_DEBUG_LEVEL .EQ. 1)then
>          WRITE(mline,'('' MACEND '',2I4)') G_PT,G_TOP
2668,2672c3200,3204
<       K = LPT(1) - 4
<       LPT(1) = LIN(K+1)
<       LPT(4) = LIN(K+2)
<       LPT(6) = LIN(K+3)
<       CHRA = BLANK
---
>       K = G_LPT(1) - 4
>       G_LPT(1) = G_LIN(K+1)
>       G_LPT(4) = G_LIN(K+2)
>       G_LPT(6) = G_LIN(K+3)
>       G_CHRA = BLANK
2678,2682c3210,3214
<       IF (SYM .EQ. EQUAL) CALL mat_getsym()
<       PT = PT+1
<       CALL mat_putid(IDS(1,PT),ID)
<       PSTK(PT) = EXCNT
<       RSTK(PT) = 2
---
>       IF (G_SYM .EQ. EQUAL) CALL mat_getsym()
>       G_PT = G_PT+1
>       CALL mat_putid(G_IDS(1,G_PT),ID)
>       G_PSTK(G_PT) = EXCNT
>       G_RSTK(G_PT) = 2
2686,2688c3218,3220
<       IF (SYM.EQ.SEMI .OR. SYM.EQ.COMMA .OR. SYM.EQ.EOL) GOTO 60
<       IF (SYM.EQ.NAME .AND. mat_eqid(SYN,ELSE)) GOTO 60
<       IF (SYM.EQ.NAME .AND. mat_eqid(SYN,ENND)) GOTO 60
---
>       IF (G_SYM.EQ.SEMI .OR. G_SYM.EQ.COMMA .OR. G_SYM.EQ.G_EOL) GOTO 60
>       IF (G_SYM.EQ.NAME .AND. mat_eqid(G_SYN,ELSE)) GOTO 60
>       IF (G_SYM.EQ.NAME .AND. mat_eqid(G_SYN,ENND)) GOTO 60
2690c3222
<       IF (ERR .GT. 0) GOTO 01
---
>       IF (G_ERR .GT. 0) GOTO 01
2694,2699c3226,3231
<       RHS = PSTK(PT)
<       CALL mat_stackp(IDS(1,PT))
<       IF (ERR .GT. 0) GOTO 01
<       PT = PT-1
<       LHS = LHS-1
<       IF (LHS .GT. 0) GOTO 60
---
>       G_RHS = G_PSTK(G_PT)
>       CALL MAT_STACK_PUT(G_IDS(1,G_PT))
>       IF (G_ERR .GT. 0) GOTO 01
>       G_PT = G_PT-1
>       G_LHS = G_LHS-1
>       IF (G_LHS .GT. 0) GOTO 60
2705,2709c3237,3241
<       K = FLP(1)
<       IF (K .NE. 0) STKR(VSIZE-3) = DFLOAT(K)
<       STKR(VSIZE-2) = STKR(VSIZE-2) + DFLOAT(K)
<       FLP(1) = 0
<       IF (.NOT.(CHRA.EQ.COMMA .OR. (SYM.EQ.COMMA .AND. CHRA.EQ.EOL)))GOTO 80
---
>       K = G_FLOP_COUNTER(1)
>       IF (K .NE. 0) G_STKR(G_VSIZE-3) = dble(K)
>       G_STKR(G_VSIZE-2) = G_STKR(G_VSIZE-2) + dble(K)
>       G_FLOP_COUNTER(1) = 0
>       IF (.NOT.(G_CHRA.EQ.COMMA .OR. (G_SYM.EQ.COMMA .AND. G_CHRA.EQ.G_EOL)))GOTO 80
2728c3260
<       FIN = 0
---
>       G_FIN = 0
2731,2734c3263,3266
<       IF (PT .GT. 0) P = PSTK(PT)
<       IF (PT .GT. 0) R = RSTK(PT)
<       IF (DDT .EQ. 1)then
<          WRITE(mline,'('' FINISH'',5I4)') PT,PTZ,P,R,LPT(1)
---
>       IF (G_PT .GT. 0) P = G_PSTK(G_PT)
>       IF (G_PT .GT. 0) R = G_RSTK(G_PT)
>       IF (G_DEBUG_LEVEL .EQ. 1)then
>          WRITE(mline,'('' FINISH'',5I4)') G_PT,G_PTZ,P,R,G_LPT(1)
2737,2739c3269,3271
<       IF (SYM.EQ.COMMA .OR. SYM.EQ.SEMI) GOTO 15
<       IF (R.EQ.21 .AND. P.EQ.LPT(1)) GOTO 49
<       IF (PT .GT. PTZ) GOTO 91
---
>       IF (G_SYM.EQ.COMMA .OR. G_SYM.EQ.SEMI) GOTO 15
>       IF (R.EQ.21 .AND. P.EQ.G_LPT(1)) GOTO 49
>       IF (G_PT .GT. G_PTZ) GOTO 91
2746,2748c3278,3280
<       IF (ERR .GT. 0) GOTO 01
<       IF (PT .LE. PTZ) GOTO 15
<       R = RSTK(PT)
---
>       IF (G_ERR .GT. 0) GOTO 01
>       IF (G_PT .LE. G_PTZ) GOTO 15
>       R = G_RSTK(G_PT)
2754,2755c3286,3287
<       IF (ERR .GT. 0) GOTO 01
<       R = RSTK(PT)
---
>       IF (G_ERR .GT. 0) GOTO 01
>       R = G_RSTK(G_PT)
2760,2761c3292,3293
<       IF (ERR .GT. 0) GOTO 01
<       R = RSTK(PT)
---
>       IF (G_ERR .GT. 0) GOTO 01
>       R = G_RSTK(G_PT)
2766,2767c3298,3299
<       IF (ERR .GT. 0) GOTO 01
<       R = RSTK(PT)
---
>       IF (G_ERR .GT. 0) GOTO 01
>       R = G_RSTK(G_PT)
2773,2774c3305,3306
<       if(TOP.LT.1)then
<          !call journal('*mat_parse* stack emptied',top)
---
>       if(G_TOP.LT.1)then
>          !call journal('*mat_parse* stack emptied',G_top)
2776c3308
<          IF (FIN.GT.0 .AND. MSTK(TOP).LT.0) CALL mat_err(14)
---
>          IF (G_FIN.GT.0 .AND. G_MSTK(G_TOP).LT.0) CALL mat_err(14)
2778c3310
<       IF (ERR .GT. 0) GOTO 01
---
>       IF (G_ERR .GT. 0) GOTO 01
2791,2793c3323,3326
< integer            :: id(4)
< character(len=256) :: mline
< integer            :: h(4)
---
> integer              :: id(G_MAX_NAME_LENGTH)
> integer,parameter    :: lrecl=256
> character(len=lrecl) :: mline
> integer              :: h(G_MAX_NAME_LENGTH)
2795,2796c3328
< integer,save       :: LRECL
< integer            :: cmd(4,17)
---
> integer              :: cmd(G_MAX_NAME_LENGTH,17)
2827,2838c3359,3378
< !       CLEAR ELSE  END   EXIT
< !       FOR   HELP  IF    LONG
< !       QUIT  SEMI
< !       SHORT WHAT  WHILE
< !       WHO   SH    LAFF  SHELL
<       DATA CMD/                                                       &
<      &  12,21,14,10, 14,21,28,14, 14,23,13,36, 14,33,18,29,           &
<      &  15,24,27,36, 17,14,21,25, 18,15,36,36, 21,24,23,16,           &
<      &  26,30,18,29, 28,14,22,18,                                     &
<      &  28,17,24,27, 32,17,10,29, 32,17,18,21,                        &
<      &  32,17,24,36, 28,17,36,36, 21,10,21,10, 28,17,14,21/
<       DATA LRECL/LINELEN/
---
> !.......................................................................
> cmd(:,  1)=[12,21,14,10,G_PAD(:)] ! clear
> cmd(:,  2)=[14,21,28,14,G_PAD(:)] ! else
> cmd(:,  3)=[14,23,13,36,G_PAD(:)] ! end
> cmd(:,  4)=[14,33,18,29,G_PAD(:)] ! exit
> cmd(:,  5)=[15,24,27,36,G_PAD(:)] ! for
> cmd(:,  6)=[17,14,21,25,G_PAD(:)] ! help
> cmd(:,  7)=[18,15,36,36,G_PAD(:)] ! if
> cmd(:,  8)=[21,24,23,16,G_PAD(:)] ! long
> cmd(:,  9)=[26,30,18,29,G_PAD(:)] ! quit
> cmd(:, 10)=[28,14,22,18,G_PAD(:)] ! semi
> cmd(:, 11)=[28,17,24,27,G_PAD(:)] ! short
> cmd(:, 12)=[32,17,10,29,G_PAD(:)] ! what
> cmd(:, 13)=[32,17,18,21,G_PAD(:)] ! while
> cmd(:, 14)=[32,17,24,36,G_PAD(:)] ! who
> cmd(:, 15)=[28,17,36,36,G_PAD(:)] ! sh
> cmd(:, 16)=[21,10,21,10,G_PAD(:)] ! laff
> cmd(:, 17)=[28,17,14,21,G_PAD(:)] ! shell
> !.......................................................................
> FINISHED: block
2840,2841c3380,3381
<       IF (DDT .EQ. 1)call journal('COMAND')
<       FUN = 0
---
>       IF (G_DEBUG_LEVEL .EQ. 1)call journal('MAT_COMAND')
>       G_FUN = 0
2845c3385
<       FIN = 0
---
>       G_FIN = 0
2849,2850c3389,3390
<       IF (CHRA.EQ.COMMA .OR. CHRA.EQ.SEMI .OR. CHRA.EQ.EOL) GOTO 22
<       IF ((CHRA.LE.Z.OR.(CHRA.GE.a_up.AND.CHRA.LE.z_up)) .OR. K.EQ.6)GOTO 22  ! if alphanumeric or K=6
---
>       IF (G_CHRA.EQ.COMMA .OR. G_CHRA.EQ.SEMI .OR. G_CHRA.EQ.G_EOL) GOTO 22
>       IF ((G_CHRA.LE.Z.OR.(G_CHRA.GE.a_up.AND.G_CHRA.LE.z_up)) .OR. K.EQ.6)GOTO 22  ! if alphanumeric or K=6
2855c3395
<       FIN = 1
---
>       G_FIN = 1
2860c3400
<       IF ((CHRA.GE.A.AND.CHRA.LE.Z).or.(CHRA.GE.a_up.AND.CHRA.LE.z_up)) then ! alphameric character
---
>       IF ((G_CHRA.GE.A.AND.G_CHRA.LE.Z).or.(G_CHRA.GE.a_up.AND.G_CHRA.LE.z_up)) then ! alphameric character
2862,2868c3402,3408
<          TOP = TOP+1
<          MSTK(TOP) = 0
<          NSTK(TOP) = 0
<          RHS = 0
<          CALL mat_stackp(SYN)
<          IF (ERR .GT. 0) RETURN
<          FIN = 1
---
>          G_TOP = G_TOP+1
>          G_MSTK(G_TOP) = 0
>          G_NSTK(G_TOP) = 0
>          G_RHS = 0
>          CALL MAT_STACK_PUT(G_SYN)
>          IF (G_ERR .GT. 0) RETURN
>          G_FIN = 1
2870c3410
<          BOT = LSIZE-3
---
>          G_BOT = G_MAX_NUMBER_OF_NAMES-3
2874,2888c3414,3428
<    case(5)   !!   30 continue
<       FIN = -11
<       GOTO 99
<    case(13)  !!   32 continue
<       FIN = -12
<       GOTO 99
<    case(7)   !!   34 continue
<       FIN = -13
<       GOTO 99
<    case(2)   !!   36 continue
<       FIN = -14
<       GOTO 99
<    case(3)   !!   38 continue
<       FIN = -15
<       GOTO 99
---
>    case(5)
>       G_FIN = -11
>       exit FINISHED
>    case(13)
>       G_FIN = -12
>       exit FINISHED
>    case(7)
>       G_FIN = -13
>       exit FINISHED
>    case(2)
>       G_FIN = -14
>       exit FINISHED
>    case(3)
>       G_FIN = -15
>       exit FINISHED
2891,2893c3431,3433
<       IF (PT .GT. PTZ) FIN = -16
<       IF (PT .GT. PTZ) exit COMAND
<       K = IDINT(STKR(VSIZE-2))
---
>       IF (G_PT .GT. G_PTZ) G_FIN = -16
>       IF (G_PT .GT. G_PTZ) exit COMAND
>       K = int(G_STKR(G_VSIZE-2))
2897c3437
<       ii=mat_urand(RAN(1))*9
---
>       ii=mat_urand(G_RAN(1))*9
2910c3450
<       FUN = 99
---
>       G_FUN = 99
2913,2925c3453,3467
<       K = LPT(1) - 7
<       IF (K .LE. 0) FUN = 99
<       IF (K .LE. 0) exit COMAND
<       CALL mat_files(-RIO,BUF)
<       LPT(1) = LIN(K+1)
<       LPT(4) = LIN(K+2)
<       LPT(6) = LIN(K+3)
<       PTZ = LIN(K+4)
<       RIO = LIN(K+5)
<       LCT(4) = LIN(K+6)
<       CHRA = BLANK
<       SYM = COMMA
<       GOTO 99
---
>       K = G_LPT(1) - 7
>       IF (K .LE. 0)then
>          G_FUN = 99
>          exit COMAND
>       endif
>       CALL mat_files(-G_RIO,G_BUF)
>       G_LPT(1) = G_LIN(K+1)
>       G_LPT(4) = G_LIN(K+2)
>       G_LPT(6) = G_LIN(K+3)
>       G_PTZ = G_LIN(K+4)
>       G_RIO = G_LIN(K+5)
>       G_LINECOUNT(4) = G_LIN(K+6)
>       G_CHRA = BLANK
>       G_SYM = COMMA
>       exit FINISHED
2930c3472
<       case(17) ! COMMAND::FOO
---
>       case(17) ! COMMAND::SHELL
2935c3477
<          FMT = 1
---
>          G_FMT = 1
2937c3479
<          FMT = 2
---
>          G_FMT = 2
2939,2942c3481,3484
<       IF (CHRA.EQ.E .OR. CHRA.EQ.D .or. chra.eq.e_up .or. chr.eq.d_up ) FMT = FMT+2
<       IF (CHRA .EQ. Z) FMT = 5
<       IF (CHRA.EQ.E    .OR. CHRA.EQ.D    .OR. CHRA.EQ.Z   ) CALL mat_getsym()
<       IF (CHRA.EQ.E_up .OR. CHRA.EQ.D_up .OR. CHRA.EQ.Z_up) CALL mat_getsym()
---
>       IF (G_CHRA.EQ.E .OR. G_CHRA.EQ.D .or. G_chra.eq.e_up .or. chr.eq.d_up ) G_FMT = G_FMT+2
>       IF (G_CHRA .EQ. Z) G_FMT = 5
>       IF (G_CHRA.EQ.E    .OR. G_CHRA.EQ.D    .OR. G_CHRA.EQ.Z   ) CALL mat_getsym()
>       IF (G_CHRA.EQ.E_up .OR. G_CHRA.EQ.D_up .OR. G_CHRA.EQ.Z_up) CALL mat_getsym()
2945c3487
<       LCT(3) = 1 - LCT(3)
---
>       G_LINECOUNT(3) = 1 - G_LINECOUNT(3)
2949,2952c3491,3494
<       CALL mat_prntid(IDSTK(1,BOT),LSIZE-BOT+1)
<       L = VSIZE-LSTK(BOT)+1
<       WRITE(mline,161) L,VSIZE
<   161 FORMAT(1X,'using ',I7,' out of ',I7,' elements.')
---
>       CALL mat_prntid(G_IDSTK(1,G_BOT),G_MAX_NUMBER_OF_NAMES-G_BOT+1)
>       L = G_VSIZE-G_LSTK(G_BOT)+1
>       WRITE(mline,161) L,G_VSIZE
>   161 format(1X,'using ',I7,' out of ',I7,' elements.')
2958,2959c3500,3501
<       CALL mat_funs(H)
<       CALL mat_prntid(CMD,CMDL-2)
---
>       call mat_funs(H)
>       call mat_prntid(CMD,CMDL-2)
2961a3504
>       ! need to think about this
2963,2964c3506,3508
<       IF (CHRA .eq. EOL )then      ! if next character on stack is end-of-line call interactive shell
<           call execute_command_line('/bin/sh',cmdstat=istat) ! call shell interactively
---
>       call get_environment_variable('SHELL',mline)               ! get command to execute
>       IF (G_CHRA .eq. G_EOL )then                                ! if next character on stack is end-of-line call interactive shell
>          call execute_command_line(mline,cmdstat=istat)          ! call shell interactively
2966,2971c3510
<           call mat_buf2str(mline,buf(4),lrecl)                              ! pass ENTIRE line
<           call execute_command_line(MLINE(:len_trim(mline)),cmdstat=istat)  ! call system shell
<           CALL mat_getlin()                                                  ! start a new line because gave all of this one to shell
<           if(istat.ne.0)then
<              CALL JOURNAL('sc','*SH* RETURN=',ISTAT)
<           endif
---
>          call execute_command_line(mline,cmdstat=istat)          ! call shell interactively
2975c3514,3539
<       IF (CHRA .EQ. EOL) THEN
---
>       call command_help(cmd,cmdl)
> !===================================================================================================================================
>       end select COMAND
> !===================================================================================================================================
>       call mat_getsym()
>    endblock FINISHED
> end subroutine mat_comand
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> subroutine command_help(cmd,cmdl)
> integer,intent(in)   :: cmd(G_MAX_NAME_LENGTH,17)
> integer,intent(in)   :: cmdl
> 
> integer,parameter    :: lrecl=256
> character(len=lrecl) :: mline
> integer              :: h(G_MAX_NAME_LENGTH)
> integer              :: i, j, k, jj
> integer,parameter    :: a=10
> integer,parameter    :: a_up=52
> integer,parameter    :: blank=36
> integer,parameter    :: dot=47
> integer,parameter    :: name=1
> integer              :: ch
> COMMAND : block
>    if (G_CHRA .eq. G_EOL) then
2977a3542
>       call journal(' SAMPLE  (simple samples)')
2979,2982c3544,3547
<          H(1) = 0
<          CALL mat_funs(H)
<          CALL mat_prntid(CMD,CMDL-2)
<          J = BLANK+2
---
>       h(1) = 0
>       call mat_funs(h)
>       call mat_prntid(cmd,cmdl-2)
>       j = blank+2
2984,2985c3549,3550
<          !-------------------------------------------------
<          ! write ALFA(J) to ALFA(a_up-1) one string at a time
---
> 
>       ! write G_CHARSET(J) to G_CHARSET(a_up-1) one string at a time
2989c3554
<             WRITE(MLINE,'(1X,17(A1,1X))')(CHAR(ALFA(I)),I=J,a_up-1)
---
>          write(mline,'(1X,17(A1,1X))')(char(G_CHARSET(I)),i=j,a_up-1)
2993,3007c3558,3570
<          !-------------------------------------------------
<          exit COMAND
<       ENDIF
< !
<       CALL mat_getsym()
<       IF (SYM .NE. NAME) THEN
<          IF (SYM .EQ. 0) SYM = DOT
<          H(1) = ALFA(SYM+1)
<          H(2) = ALFA(BLANK+1)
<          H(3) = ALFA(BLANK+1)
<          H(4) = ALFA(BLANK+1)
<       ELSE
<          DO I = 1, 4
<            CH = SYN(I)
<            H(I) = ALFA(CH+1)
---
> 
>       exit COMMAND
>    endif
> 
>    call mat_getsym()
>    if (G_SYM .ne. NAME) then
>       if (G_SYM .eq. 0) G_SYM = dot
>       h(1) = G_CHARSET(G_SYM+1)
>       h(2:) = G_CHARSET(blank+1)
>    else
>       do i = 1, G_MAX_NAME_LENGTH
>         ch = G_SYN(i)
>         h(i) = G_CHARSET(ch+1)
3009c3572
<       ENDIF
---
>    endif
3011,3016c3574,3579
< 84    CONTINUE
<       IF(HIO .NE. 0) THEN
<          READ(HIO,'(a)',END=89) mline   ! read line from help file
<          call mat_str2buf(mline,buf,lrecl)  ! convert string to ADE array
<          DO I = 1, 4                 ! look for match of 4 chars of topic in first 4 chars
<             IF (H(I) .NE. BUF(I)) GOTO 84
---
> 84 continue
>    if(G_HIO .ne. 0) then
>       read(G_HIO,'(a)',end=89) mline       ! read line from help file
>       call mat_str2buf(mline,G_BUF,lrecl)  ! convert string to ADE array
>       do i = 1, G_MAX_NAME_LENGTH          ! look for match of G_MAX_NAME_LENGTH chars of topic in first G_MAX_NAME_LENGTH chars
>          if (h(i) .ne. G_BUF(I)) goto 84
3019,3020c3582,3584
<    86    CONTINUE
<          !-------------------------------------------------
---
> 
> 86 continue
> 
3022,3031c3586,3592
<          K = LRECL + 1
<    87    CONTINUE
<          K = K - 1
<          IF(K.LE.0) THEN  ! blank line
<             K=1
<          ELSEIF (BUF(K) .EQ. ALFA(BLANK+1)) THEN
<             GOTO 87
<          ENDIF
<          !-------------------------------------------------
<          call mat_buf2str(mline,buf,k)
---
>       do k=lrecl,1,-1
>          if (G_BUF(k) .ne. G_CHARSET(blank+1)) then
>             exit
>          endif
>       enddo
> 
>       call mat_buf2str(mline,G_BUF,k)
3033,3049c3594,3607
<          READ(HIO,'(a)') mline
<          call mat_str2buf(mline,buf,lrecl)
<          IF (BUF(1) .EQ. ALFA(BLANK+1)) GOTO 86
<          CALL mat_files(-HIO,BUF)
<          exit COMAND
<       ENDIF
< !
<    89 CONTINUE
<       call mat_buf2str(mline,h,4)
<       mline=' SORRY, NO HELP ON '//mline(1:4)
<       call journal(mline)
<       CALL mat_files(-HIO,BUF)
< !===================================================================================================================================
<       end select COMAND
<       CALL mat_getsym()
<    99 continue
< end subroutine mat_comand
---
>       read(G_HIO,'(a)') mline
>       call mat_str2buf(mline,G_BUF,lrecl)
>       if (G_BUF(1) .eq. G_CHARSET(blank+1)) goto 86
>       call mat_files(-G_HIO,G_BUF)
>       exit COMMAND
>    endif
> 
> 89 continue
>    call mat_buf2str(mline,h,G_MAX_NAME_LENGTH)
>    call journal('SORRY, No help on '//mline(1:G_MAX_NAME_LENGTH))
>    call mat_files(-G_HIO,G_BUF)
> 
> endblock COMMAND
> end subroutine command_help
3055c3613
< $@(#) M_matrix::mat_plot(3fp): Plot X vs. Y on LPLOT.  If K is nonzero, then P(1),...,P(K) are extra parameters
---
> ! ident_30="@(#)M_matrix::mat_plot(3fp): Plot X vs. Y on LPLOT.  If K is nonzero, then P(1),...,P(K) are extra parameters"
3057a3616
> integer           :: n
3071d3629
< integer           :: n
3122,3123c3680,3681
<       if ((ch.ge.0) .and. (ch.lt.alflq)) then
<          lets(i) = alfa(ch+1)
---
>       if ((ch.ge.0) .and. (ch.lt.G_CHARSET_SIZE)) then
>          lets(i) = G_CHARSET(ch+1)
3139c3697
< $@(#) M_matrix::mat_matfn1(3fp): evaluate functions involving gaussian elimination
---
> ! ident_31="@(#)M_matrix::mat_matfn1(3fp): evaluate functions involving gaussian elimination"
3143,3144c3701,3702
< doubleprecision   :: sr
< doubleprecision   :: si
---
> doubleprecision   :: sr(1)
> doubleprecision   :: si(1)
3172c3730
<    IF (DDT .EQ. 1) call journal('sc','*MATFN1* ', FIN)
---
>    IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc','*MATFN1* ', G_FIN)
3174,3176c3732,3734
<    L = LSTK(TOP)
<    M = MSTK(TOP)
<    N = NSTK(TOP)
---
>    L = G_LSTK(G_TOP)
>    M = G_MSTK(G_TOP)
>    N = G_NSTK(G_TOP)
3178c3736
<    select case(FIN)
---
>    select case(G_FIN)
3181,3183c3739,3741
<       l2 = lstk(top+1)
<       m2 = mstk(top+1)
<       n2 = nstk(top+1)
---
>       l2 = G_LSTK(G_top+1)
>       m2 = G_MSTK(G_top+1)
>       n2 = G_NSTK(G_top+1)
3185c3743
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3188c3746
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3190,3193c3748,3751
<       err = l3+n2 - lstk(bot)
<       if (err .gt. 0) call mat_err(17)
<       if (err .gt. 0) return
<       call ml_wgeco(stkr(l2),stki(l2),m2,n2,buf,rcond,stkr(l3),stki(l3))
---
>       G_err = l3+n2 - G_LSTK(G_BOT)
>       if (G_err .gt. 0) call mat_err(17)
>       if (G_err .gt. 0) return
>       call ml_wgeco(G_stkr(l2),G_STKI(l2),m2,n2,G_buf,rcond,G_stkr(l3),G_STKI(l3))
3195c3753
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3197c3755
<       if (t.eq.1.0d0 .and. fun.ne.21)then
---
>       if (t.eq.1.0d0 .and. G_fun.ne.21)then
3203c3761
<       if (t.eq.1.0d0 .and. fun.eq.21)then
---
>       if (t.eq.1.0d0 .and. G_fun.eq.21)then
3213,3214c3771,3772
<             stkr(ll) = stkr(ls)
<             stki(ll) = -stki(ls)
---
>             G_stkr(ll) = G_stkr(ls)
>             G_STKI(ll) = -G_STKI(ls)
3216c3774
<          call ml_wgesl(stkr(l2),stki(l2),m2,n2,buf,stkr(l3),stki(l3),1)
---
>          call ml_wgesl(G_stkr(l2),G_STKI(l2),m2,n2,G_buf,G_stkr(l3),G_STKI(l3),1)
3220,3221c3778,3779
<             stkr(ll) = stkr(ls)
<             stki(ll) = -stki(ls)
---
>             G_stkr(ll) = G_stkr(ls)
>             G_STKI(ll) = -G_STKI(ls)
3224c3782
<       if (fun .ne. 21) goto 99
---
>       if (G_fun .ne. 21) goto 99
3227,3232c3785,3790
<       sr = mat_wasum(n*n,stkr(l),stkr(l),1)
<       si = mat_wasum(n*n,stki(l),stki(l),1)
<       eps = stkr(vsize-4)
<       t = eps*sr
<       if (ddt .eq. 18)then
<          WRITE(WTE,'('' SR,SI,EPS,T'',1P4D13.4)') SR,SI,EPS,T ! debug 18
---
>       sr(1) = mat_wasum(n*n,G_stkr(l),G_stkr(l),1)
>       si(1) = mat_wasum(n*n,G_STKI(l),G_STKI(l),1)
>       eps = G_stkr(G_VSIZE-4)
>       t = eps*sr(1)
>       if (G_DEBUG_LEVEL .eq. 18)then
>          WRITE(G_WTE,'('' SR,SI,EPS,T'',1P4D13.4)') SR(1),SI(1),EPS,T ! debug 18
3234c3792
<       if (si .le. eps*sr) call mat_rset(n*n,0.0d0,stki(l),1)
---
>       if (si(1) .le. eps*sr(1)) call mat_rset(n*n,0.0d0,G_STKI(l),1)
3238,3239c3796,3797
<       sr = stkr(l)
<       si = stki(l)
---
>       sr(1) = G_stkr(l)
>       si(1) = G_STKI(l)
3242,3244c3800,3802
<       mstk(top) = n
<       nstk(top) = n
<       call mat_wcopy(n*n,stkr(l2),stki(l2),1,stkr(l),stki(l),1)
---
>       G_MSTK(G_top) = n
>       G_NSTK(G_top) = n
>       call mat_wcopy(n*n,G_stkr(l2),G_STKI(l2),1,G_stkr(l),G_STKI(l),1)
3247,3249c3805,3807
<       l2 = lstk(top+1)
<       m2 = mstk(top+1)
<       n2 = nstk(top+1)
---
>       l2 = G_LSTK(G_top+1)
>       m2 = G_MSTK(G_top+1)
>       n2 = G_NSTK(G_top+1)
3251c3809
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3254,3257c3812,3815
<       err = l3+n - lstk(bot)
<       if (err .gt. 0) call mat_err(17)
<       if (err .gt. 0) return
<       call ml_wgeco(stkr(l),stki(l),m,n,buf,rcond,stkr(l3),stki(l3))
---
>       G_err = l3+n - G_LSTK(G_BOT)
>       if (G_err .gt. 0) call mat_err(17)
>       if (G_err .gt. 0) return
>       call ml_wgeco(G_stkr(l),G_STKI(l),m,n,G_buf,rcond,G_stkr(l3),G_STKI(l3))
3259c3817
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3268c3826
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3271c3829
<          call ml_wgesl(stkr(l),stki(l),m,n,buf,stkr(lj),stki(lj),0)
---
>          call ml_wgesl(G_stkr(l),G_STKI(l),m,n,G_buf,G_stkr(lj),G_STKI(lj),0)
3273,3274c3831,3832
<       nstk(top) = n2
<       call mat_wcopy(m2*n2,stkr(l2),stki(l2),1,stkr(l),stki(l),1)
---
>       G_NSTK(G_top) = n2
>       call mat_wcopy(m2*n2,G_stkr(l2),G_STKI(l2),1,G_stkr(l),G_STKI(l),1)
3277,3278c3835,3836
<       sr = stkr(l2)
<       si = stki(l2)
---
>       sr(1) = G_stkr(l2)
>       si(1) = G_STKI(l2)
3282c3840
<    select case(FIN)
---
>    select case(G_FIN)
3286,3287c3844,3845
<       if (err .gt. 0) return
<       if (ddt .eq. 17) goto 32
---
>       if (G_err .gt. 0) return
>       if (G_DEBUG_LEVEL .eq. 17) goto 32
3291,3292c3849,3850
<             t0 = stkr(ls)
<             t1 = mat_flop(1.0d0/(dfloat(i+j-1)))
---
>             t0 = G_stkr(ls)
>             t1 = mat_flop(1.0d0/(dble(i+j-1)))
3296,3298c3854,3856
<       call mat_hilber(stkr(l),n,n)
<       call mat_rset(n*n,0.0d0,stki(l),1)
<       if (fin .lt. 0) call mat_wscal(n*n,sr,si,stkr(l),stki(l),1)
---
>       call mat_hilber(G_stkr(l),n,n)
>       call mat_rset(n*n,0.0d0,G_STKI(l),1)
>       if (G_fin .lt. 0) call mat_wscal(n*n,sr(1),si(1),G_stkr(l),G_STKI(l),1)
3302,3305c3860,3863
<       err = l3+n - lstk(bot)
<       if (err .gt. 0) call mat_err(17)
<       if (err .gt. 0) return
<       call ml_wgeco(stkr(l),stki(l),m,n,buf,rcond,stkr(l3),stki(l3))
---
>       G_err = l3+n - G_LSTK(G_BOT)
>       if (G_err .gt. 0) call mat_err(17)
>       if (G_err .gt. 0) return
>       call ml_wgeco(G_stkr(l),G_STKI(l),m,n,G_buf,rcond,G_stkr(l3),G_STKI(l3))
3307c3865
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3315,3316c3873,3874
<       call ml_wgedi(stkr(l),stki(l),m,n,buf,dtr,dti,stkr(l3),stki(l3),1)
<       if (fin .lt. 0) call mat_wscal(n*n,sr,si,stkr(l),stki(l),1)
---
>       call ml_wgedi(G_stkr(l),G_STKI(l),m,n,G_buf,dtr,dti,G_stkr(l3),G_STKI(l3),1)
>       if (G_fin .lt. 0) call mat_wscal(n*n,sr(1),si(1),G_stkr(l),G_STKI(l),1)
3320,3323c3878,3882
<       if (err .gt. 0) return
<       call ml_wgefa(stkr(l),stki(l),m,n,buf,info)
<       call ml_wgedi(stkr(l),stki(l),m,n,buf,dtr,dti,sr,si,10)
<       k = idint(dtr(2))
---
>       if (G_err .gt. 0) return
>       call ml_wgefa(G_stkr(l),G_STKI(l),m,n,G_buf,info)
>       !SUBROUTINE ML_WGEDI(ar,ai,LDA,N,ipvt,detr,deti,workr,worki,JOB)
>       call ml_wgedi(G_stkr(l),G_STKI(l),m,n,G_buf,dtr,dti,sr(1),si(1),10)
>       k = int(dtr(2))
3330,3333c3889,3892
<       stkr(l) = dtr(1)*10.d0**k
<       stki(l) = dti(1)*10.d0**k
<       mstk(top) = 1
<       nstk(top) = 1
---
>       G_stkr(l) = dtr(1)*10.d0**k
>       G_STKI(l) = dti(1)*10.d0**k
>       G_MSTK(G_top) = 1
>       G_NSTK(G_top) = 1
3345,3350c3904,3909
<       stkr(l) = dtr(1)
<       stki(l) = dti(1)
<       stkr(l+1) = dtr(2)
<       stki(l+1) = 0.0d0
<       mstk(top) = 1
<       nstk(top) = 2
---
>       G_stkr(l) = dtr(1)
>       G_STKI(l) = dti(1)
>       G_stkr(l+1) = dtr(2)
>       G_STKI(l+1) = 0.0d0
>       G_MSTK(G_top) = 1
>       G_NSTK(G_top) = 2
3354c3913
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
3356,3364c3915,3923
<       err = l3+n - lstk(bot)
<       if (err .gt. 0) call mat_err(17)
<       if (err .gt. 0) return
<       call ml_wgeco(stkr(l),stki(l),m,n,buf,rcond,stkr(l3),stki(l3))
<       stkr(l) = rcond
<       stki(l) = 0.0d0
<       mstk(top) = 1
<       nstk(top) = 1
<       if (lhs .ne. 1)then
---
>       G_err = l3+n - G_LSTK(G_BOT)
>       if (G_err .gt. 0) call mat_err(17)
>       if (G_err .gt. 0) return
>       call ml_wgeco(G_stkr(l),G_STKI(l),m,n,G_buf,rcond,G_stkr(l3),G_STKI(l3))
>       G_stkr(l) = rcond
>       G_STKI(l) = 0.0d0
>       G_MSTK(G_top) = 1
>       G_NSTK(G_top) = 1
>       if (G_lhs .ne. 1)then
3366,3370c3925,3929
<          call mat_wcopy(n,stkr(l3),stki(l3),1,stkr(l),stki(l),1)
<          top = top + 1
<          lstk(top) = l
<          mstk(top) = n
<          nstk(top) = 1
---
>          call mat_wcopy(n,G_stkr(l3),G_STKI(l3),1,G_stkr(l),G_STKI(l),1)
>          G_top = G_top + 1
>          G_LSTK(G_top) = l
>          G_MSTK(G_top) = n
>          G_NSTK(G_top) = 1
3375,3377c3934,3936
<       if (err .gt. 0) return
<       call ml_wgefa(stkr(l),stki(l),m,n,buf,info)
<       if (lhs .ne. 2) goto 99
---
>       if (G_err .gt. 0) return
>       call ml_wgefa(G_stkr(l),G_STKI(l),m,n,G_buf,info)
>       if (G_lhs .ne. 2) goto 99
3379,3387c3938,3946
<       if (top+1 .ge. bot) call mat_err(18)
<       if (err .gt. 0) return
<       top = top+1
<       lstk(top) = l + nn
<       mstk(top) = n
<       nstk(top) = n
<       err = l+nn+nn - lstk(bot)
<       if (err .gt. 0) call mat_err(17)
<       if (err .gt. 0) return
---
>       if (G_top+1 .ge. G_BOT) call mat_err(18)
>       if (G_err .gt. 0) return
>       G_top = G_top+1
>       G_LSTK(G_top) = l + nn
>       G_MSTK(G_top) = n
>       G_NSTK(G_top) = n
>       G_err = l+nn+nn - G_LSTK(G_BOT)
>       if (G_err .gt. 0) call mat_err(17)
>       if (G_err .gt. 0) return
3393,3402c3952,3961
<             if (i .le. k) stkr(lu) = stkr(ll)
<             if (i .le. k) stki(lu) = stki(ll)
<             if (i .gt. k) stkr(lu) = 0.0d0
<             if (i .gt. k) stki(lu) = 0.0d0
<             if (i .lt. k) stkr(ll) = 0.0d0
<             if (i .lt. k) stki(ll) = 0.0d0
<             if (i .eq. k) stkr(ll) = 1.0d0
<             if (i .eq. k) stki(ll) = 0.0d0
<             if (i .gt. k) stkr(ll) = -stkr(ll)
<             if (i .gt. k) stki(ll) = -stki(ll)
---
>             if (i .le. k) G_stkr(lu) = G_stkr(ll)
>             if (i .le. k) G_STKI(lu) = G_STKI(ll)
>             if (i .gt. k) G_stkr(lu) = 0.0d0
>             if (i .gt. k) G_STKI(lu) = 0.0d0
>             if (i .lt. k) G_stkr(ll) = 0.0d0
>             if (i .lt. k) G_STKI(ll) = 0.0d0
>             if (i .eq. k) G_stkr(ll) = 1.0d0
>             if (i .eq. k) G_STKI(ll) = 0.0d0
>             if (i .gt. k) G_stkr(ll) = -G_stkr(ll)
>             if (i .gt. k) G_STKI(ll) = -G_STKI(ll)
3404c3963
<          i = buf(k)
---
>          i = G_buf(k)
3408c3967
<          call mat_wswap(n-k+1,stkr(li),stki(li),n,stkr(lk),stki(lk),n)
---
>          call mat_wswap(n-k+1,G_stkr(li),G_STKI(li),n,G_stkr(lk),G_STKI(lk),n)
3412,3417c3971,3976
<       n = idint(stkr(l))
<       mstk(top) = n
<       nstk(top) = n
<       call mat_hilber(stkr(l),n,n)
<       call mat_rset(n*n,0.0d0,stki(l),1)
<       if (fin .lt. 0) call mat_wscal(n*n,sr,si,stkr(l),stki(l),1)
---
>       n = int(G_stkr(l))
>       G_MSTK(G_top) = n
>       G_NSTK(G_top) = n
>       call mat_hilber(G_stkr(l),n,n)
>       call mat_rset(n*n,0.0d0,G_STKI(l),1)
>       if (G_fin .lt. 0) call mat_wscal(n*n,sr(1),si(1),G_stkr(l),G_STKI(l),1)
3421,3424c3980,3983
<       if (err .gt. 0) return
<       call mat_wpofa(stkr(l),stki(l),m,n,err)
<       if (err .ne. 0) call mat_err(29)
<       if (err .gt. 0) return
---
>       if (G_err .gt. 0) return
>       call mat_wpofa(G_stkr(l),G_STKI(l),m,n,G_err)
>       if (G_err .ne. 0) call mat_err(29)
>       if (G_err .gt. 0) return
3427c3986
<          call mat_wset(m-j,0.0d0,0.0d0,stkr(ll),stki(ll),1)
---
>          call mat_wset(m-j,0.0d0,0.0d0,G_stkr(ll),G_STKI(ll),1)
3431,3436c3990,3995
<       if (rhs .ge. 2)then
<          top = top-1
<          l = lstk(top)
<          if (mstk(top) .ne. m) call mat_err(5)
<          if (err .gt. 0) return
<          n = n + nstk(top)
---
>       if (G_rhs .ge. 2)then
>          G_top = G_top-1
>          l = G_LSTK(G_top)
>          if (G_MSTK(G_top) .ne. m) call mat_err(5)
>          if (G_err .gt. 0) return
>          n = n + G_NSTK(G_top)
3438,3439c3997,3998
<       call mat_rref(stkr(l),stki(l),m,m,n,stkr(vsize-4))
<       nstk(top) = n
---
>       call mat_rref(G_stkr(l),G_STKI(l),m,m,n,G_stkr(G_VSIZE-4))
>       G_NSTK(G_top) = n
3470c4029
<       DOUBLEPRECISION TR,TI,SR,SI,POWR,POWI
---
>       DOUBLEPRECISION TR(1),TI(1),SR,SI,POWR,POWI
3473c4032
<       IF (DDT .EQ. 1) call journal('sc','*MATFN2* ', FIN)
---
>       IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc','*MATFN2* ', G_FIN)
3475c4034
< !     FUNCTIONS/FIN
---
> !     FUNCTIONS/G_FIN
3482,3485c4041,4044
<       IF (FIN .NE. 0) GOTO 05
<          L = LSTK(TOP+1)
<          POWR = STKR(L)
<          POWI = STKI(L)
---
>       IF (G_FIN .NE. 0) GOTO 05
>          L = G_LSTK(G_TOP+1)
>          POWR = G_STKR(L)
>          POWI = G_STKI(L)
3487,3494c4046,4053
<       L = LSTK(TOP)
<       M = MSTK(TOP)
<       N = NSTK(TOP)
<       IF (FIN .GE. 11 .AND. FIN .LE. 13) GOTO 10
<       IF (FIN .EQ. 14 .AND. (M.EQ.1 .OR. N.EQ.1)) GOTO 50
<       IF (FIN .EQ. 14) GOTO 10
<       IF (FIN .EQ. 15) GOTO 60
<       IF (FIN .GT. 20) GOTO 40
---
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)
>       N = G_NSTK(G_TOP)
>       IF (G_FIN .GE. 11 .AND. G_FIN .LE. 13) GOTO 10
>       IF (G_FIN .EQ. 14 .AND. (M.EQ.1 .OR. N.EQ.1)) GOTO 50
>       IF (G_FIN .EQ. 14) GOTO 10
>       IF (G_FIN .EQ. 15) GOTO 60
>       IF (G_FIN .GT. 20) GOTO 40
3500,3503c4059,4062
<       IF (ERR .GT. 0) RETURN
<       SCHUR = FIN .EQ. 12
<       HESS = FIN .EQ. 13
<       VECT = LHS.EQ.2 .OR. FIN.LT.10
---
>       IF (G_ERR .GT. 0) RETURN
>       SCHUR = G_FIN .EQ. 12
>       HESS = G_FIN .EQ. 13
>       VECT = G_LHS.EQ.2 .OR. G_FIN.LT.10
3509,3512c4068,4071
<       ERR = LW+N - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       CALL mat_wcopy(NN,STKR(L),STKI(L),1,STKR(L2),STKI(L2),1)
---
>       G_ERR = LW+N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       CALL mat_wcopy(NN,G_STKR(L),G_STKI(L),1,G_STKR(L2),G_STKI(L2),1)
3520c4079
<             HERM = STKR(LL).EQ.STKR(LS) .AND. STKI(LL).EQ.-STKI(LS)
---
>             HERM = G_STKR(LL).EQ.G_STKR(LS) .AND. G_STKI(LL).EQ.-G_STKI(LS)
3526,3528c4085,4087
<       CALL mat_wset(NN,0.0D0,0.0D0,STKR(L),STKI(L),1)
<       CALL mat_wset(N,1.0D0,0.0D0,STKR(L),STKI(L),N+1)
<       CALL mat_wset(N,0.0D0,0.0D0,STKI(LD),STKI(LE),1)
---
>       CALL mat_wset(NN,0.0D0,0.0D0,G_STKR(L),G_STKI(L),1)
>       CALL mat_wset(N,1.0D0,0.0D0,G_STKR(L),G_STKI(L),N+1)
>       CALL mat_wset(N,0.0D0,0.0D0,G_STKI(LD),G_STKI(LE),1)
3531,3535c4090,4094
<       CALL ML_HTRIDI(N,N,STKR(L2),STKI(L2),STKR(LD),STKR(LE),STKR(LE),STKR(LW))
<       IF(.NOT.HESS)CALL ML_IMTQL2(N,N,STKR(LD),STKR(LE),STKR(L),ERR,JOB)
<       IF (ERR .GT. 0) CALL mat_err(24)
<       IF (ERR .GT. 0) RETURN
<       IF (JOB .NE. 0) CALL ML_HTRIBK(N,N,STKR(L2),STKI(L2),STKR(LW),N,STKR(L),STKI(L))
---
>       CALL ML_HTRIDI(N,N,G_STKR(L2),G_STKI(L2),G_STKR(LD),G_STKR(LE),G_STKR(LE),G_STKR(LW))
>       IF(.NOT.HESS)CALL ML_IMTQL2(N,N,G_STKR(LD),G_STKR(LE),G_STKR(L),G_ERR,JOB)
>       IF (G_ERR .GT. 0) CALL mat_err(24)
>       IF (G_ERR .GT. 0) RETURN
>       IF (JOB .NE. 0) CALL ML_HTRIBK(N,N,G_STKR(L2),G_STKI(L2),G_STKR(LW),N,G_STKR(L),G_STKI(L))
3540c4099
<       CALL ML_CORTH(N,N,1,N,STKR(L2),STKI(L2),STKR(LW),STKI(LW))
---
>       CALL ML_CORTH(N,N,1,N,G_STKR(L2),G_STKI(L2),G_STKR(LW),G_STKI(LW))
3546,3548c4105,4107
<       CALL ML_COMQR3(N,N,1,N,STKR(LW),STKI(LW),STKR(L2),STKI(L2), STKR(LD),STKI(LD),STKR(L),STKI(L),ERR,JOB)
<       IF (ERR .GT. 0) CALL mat_err(24)
<       IF (ERR .GT. 0) RETURN
---
>       CALL ML_COMQR3(N,N,1,N,G_STKR(LW),G_STKI(LW),G_STKR(L2),G_STKI(L2), G_STKR(LD),G_STKI(LD),G_STKR(L),G_STKI(L),G_ERR,JOB)
>       IF (G_ERR .GT. 0) CALL mat_err(24)
>       IF (G_ERR .GT. 0) RETURN
3553,3558c4112,4117
<       IF (TOP+1 .GE. BOT) CALL mat_err(18)
<       IF (ERR .GT. 0) RETURN
<       TOP = TOP+1
<       LSTK(TOP) = L2
<       MSTK(TOP) = N
<       NSTK(TOP) = N
---
>       IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)
>       IF (G_ERR .GT. 0) RETURN
>       G_TOP = G_TOP+1
>       G_LSTK(G_TOP) = L2
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = N
3568c4127
<          CALL mat_wset(LL,0.0D0,0.0D0,STKR(LJ),STKI(LJ),1)
---
>          CALL mat_wset(LL,0.0D0,0.0D0,G_STKR(LJ),G_STKI(LJ),1)
3570c4129
<       IF (.NOT.HESS .OR. HERM) CALL mat_wcopy(N,STKR(LD),STKI(LD),1,STKR(L2),STKI(L2),N+1)
---
>       IF (.NOT.HESS .OR. HERM) CALL mat_wcopy(N,G_STKR(LD),G_STKI(LD),1,G_STKR(L2),G_STKI(L2),N+1)
3572c4131
<       IF (HESS .AND. HERM)CALL mat_wcopy(N-1,STKR(LE+1),STKI(LE+1),1,STKR(LL),STKI(LL),N+1)
---
>       IF (HESS .AND. HERM)CALL mat_wcopy(N-1,G_STKR(LE+1),G_STKI(LE+1),1,G_STKR(LL),G_STKI(LL),N+1)
3574,3575c4133,4134
<       IF (HESS .AND. HERM)CALL mat_wcopy(N-1,STKR(LE+1),STKI(LE+1),1,STKR(LL),STKI(LL),N+1)
<       IF (FIN .LT. 10) GOTO 42
---
>       IF (HESS .AND. HERM)CALL mat_wcopy(N-1,G_STKR(LE+1),G_STKI(LE+1),1,G_STKR(LL),G_STKI(LL),N+1)
>       IF (G_FIN .LT. 10) GOTO 42
3577c4136
<       CALL mat_wcopy(NN,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
---
>       CALL mat_wcopy(NN,G_STKR(L2),G_STKI(L2),1,G_STKR(L),G_STKI(L),1)
3582,3584c4141,4143
<       IF (FIN .EQ. 14) GOTO 52
<       CALL mat_wcopy(N,STKR(LD),STKI(LD),1,STKR(L),STKI(L),1)
<       NSTK(TOP) = 1
---
>       IF (G_FIN .EQ. 14) GOTO 52
>       CALL mat_wcopy(N,G_STKR(LD),G_STKI(LD),1,G_STKR(L),G_STKI(L),1)
>       G_NSTK(G_TOP) = 1
3599,3600c4158,4159
<         SR = STKR(LS)
<         SI = STKI(LS)
---
>         SR = G_STKR(LS)
>         SI = G_STKI(LS)
3602c4161
<         IF (FIN .NE. 0) GOTO 45
---
>         IF (G_FIN .eq. 0) then
3605,3625c4164,4200
<           TR = DEXP(SR)*DCOS(SI)
<           TI = DEXP(SR)*DSIN(SI)
<    45   IF (FIN .EQ. 1) TR = DSIN(SR)*DCOSH(SI)
<         IF (FIN .EQ. 1) TI = DCOS(SR)*DSINH(SI)
<         IF (FIN .EQ. 2) TR = DCOS(SR)*DCOSH(SI)
<         IF (FIN .EQ. 2) TI = (-DSIN(SR))*DSINH(SI)
<         IF (FIN .EQ. 3) CALL mat_watan(SR,SI,TR,TI)
<         IF (FIN .EQ. 4) TR = DEXP(SR)*DCOS(SI)
<         IF (FIN .EQ. 4) TI = DEXP(SR)*DSIN(SI)
<         IF (FIN .EQ. 5) CALL mat_wsqrt(SR,SI,TR,TI)
<         IF (FIN .EQ. 6) CALL mat_wlog(SR,SI,TR,TI)
<         IF (FIN .EQ. 21) TR = mat_pythag(SR,SI)
<         IF (FIN .EQ. 22) TR = mat_round(SR)
<         IF (FIN .EQ. 23) TR = SR
<         IF (FIN .EQ. 24) TR = SI
<         IF (FIN .EQ. 25) TR = SR
<         IF (FIN .EQ. 25) TI = -SI
<         IF (ERR .GT. 0) RETURN
<         STKR(LS) = mat_flop(TR)
<         STKI(LS) = 0.0D0
<         IF (TI .NE. 0.0D0) STKI(LS) = mat_flop(TI)
---
>           TR(1) = DEXP(SR)*DCOS(SI)
>           TI(1) = DEXP(SR)*DSIN(SI)
>         endif
> 
>         select case(G_FIN)
>         CASE( 1)
>                  TR(1) = DSIN(SR)*DCOSH(SI)
>                  TI(1) = DCOS(SR)*DSINH(SI)
>         CASE( 2)
>                  TR(1) = DCOS(SR)*DCOSH(SI)
>                  TI(1) = (-DSIN(SR))*DSINH(SI)
>         CASE( 3)
>                  CALL mat_watan(SR,SI,TR(1),TI(1))
>         CASE( 4)
>                  TR(1) = DEXP(SR)*DCOS(SI)
>                  TI(1) = DEXP(SR)*DSIN(SI)
>         CASE( 5)
>                  CALL mat_wsqrt(SR,SI,TR(1),TI(1))
>         CASE( 6)
>                  CALL mat_wlog(SR,SI,TR(1),TI(1))
>         CASE( 21)
>                  TR(1) = mat_pythag(SR,SI)
>         CASE( 22)
>                  TR(1) = mat_round(SR)
>         CASE( 23)
>                  TR(1) = SR
>         CASE( 24)
>                  TR(1) = SI
>         CASE( 25)
>                  TR(1) = SR
>                  TI(1) = -SI
>         end select
> 
>         IF (G_ERR .GT. 0) RETURN
>         G_STKR(LS) = mat_flop(TR(1))
>         G_STKI(LS) = 0.0D0
>         IF (TI(1) .NE. 0.0D0) G_STKI(LS) = mat_flop(TI(1))
3630,3631c4205,4206
<         SR = STKR(LS)
<         SI = STKI(LS)
---
>         SR = G_STKR(LS)
>         SI = G_STKI(LS)
3634,3635c4209,4210
<         CALL mat_wcopy(N,STKR(LS),STKI(LS),1,STKR(LL),STKI(LL),1)
<         CALL mat_wscal(N,SR,SI,STKR(LS),STKI(LS),1)
---
>         CALL mat_wcopy(N,G_STKR(LS),G_STKI(LS),1,G_STKR(LL),G_STKI(LL),1)
>         CALL mat_wscal(N,SR,SI,G_STKR(LS),G_STKI(LS),1)
3638,3640c4213,4215
<       FUN = 21
<       FIN = -1
<       TOP = TOP-1
---
>       G_FUN = 21
>       G_FIN = -1
>       G_TOP = G_TOP-1
3648c4223
<       CALL mat_wcopy(N,STKR(L),STKI(L),1,STKR(LD),STKI(LD),1)
---
>       CALL mat_wcopy(N,G_STKR(L),G_STKI(L),1,G_STKR(LD),G_STKI(LD),1)
3652,3653c4227,4228
<       CALL mat_wset(N+1,0.0D0,0.0D0,STKR(L),STKI(L),1)
<       STKR(L) = 1.0D0
---
>       CALL mat_wset(N+1,0.0D0,0.0D0,G_STKR(L),G_STKI(L),1)
>       G_STKR(L) = 1.0D0
3655c4230
<          CALL matX_waxpy(J,-STKR(LD),-STKI(LD),STKR(L),STKI(L),-1, STKR(L+1),STKI(L+1),-1)
---
>          CALL matX_waxpy(J,-G_STKR(LD),-G_STKI(LD),G_STKR(L),G_STKI(L),-1, G_STKR(L+1),G_STKI(L+1),-1)
3658,3659c4233,4234
<       MSTK(TOP) = N+1
<       NSTK(TOP) = 1
---
>       G_MSTK(G_TOP) = N+1
>       G_NSTK(G_TOP) = 1
3665,3666c4240,4241
<       STKR(LL) = -1.0D0
<       STKI(LL) = 0.0D0
---
>       G_STKR(LL) = -1.0D0
>       G_STKI(LL) = 0.0D0
3671c4246
<       IF (DABS(STKR(L1))+DABS(STKI(L1)) .EQ. 0.0D0) GOTO 61
---
>       IF (DABS(G_STKR(L1))+DABS(G_STKI(L1)) .EQ. 0.0D0) GOTO 61
3676,3679c4251,4254
<       ERR = LW+N - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       CALL mat_wset(N*N+N,0.0D0,0.0D0,STKR(L2),STKI(L2),1)
---
>       G_ERR = LW+N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       CALL mat_wset(N*N+N,0.0D0,0.0D0,G_STKR(L2),G_STKI(L2),1)
3682c4257
<          STKR(LL) = 1.0D0
---
>          G_STKR(LL) = 1.0D0
3685,3686c4260,4261
<          CALL mat_wdiv(-STKR(LS),-STKI(LS),STKR(L1),STKI(L1), STKR(LL),STKI(LL))
<          IF (ERR .GT. 0) RETURN
---
>          CALL mat_wdiv(-G_STKR(LS),-G_STKI(LS),G_STKR(L1),G_STKI(L1), G_STKR(LL),G_STKI(LL))
>          IF (G_ERR .GT. 0) RETURN
3688,3690c4263,4265
<       CALL ML_COMQR3(N,N,1,N,STKR(LW),STKI(LW),STKR(L2),STKI(L2),STKR(L),STKI(L),TR,TI,ERR,0)
<       IF (ERR .GT. 0) CALL mat_err(24)
<       IF (ERR .GT. 0) RETURN
---
>       CALL ML_COMQR3(N,N,1,N,G_STKR(LW),G_STKI(LW),G_STKR(L2),G_STKI(L2),G_STKR(L),G_STKI(L),TR,TI,G_ERR,0)
>       IF (G_ERR .GT. 0) CALL mat_err(24)
>       IF (G_ERR .GT. 0) RETURN
3692,3693c4267,4268
<       MSTK(TOP) = N
<       NSTK(TOP) = 1
---
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = 1
3703c4278
< $@(#) M_matrix::mat_matfn3(3fp): evaluate functions involving singular value decomposition
---
> ! ident_32="@(#)M_matrix::mat_matfn3(3fp): evaluate functions involving singular value decomposition"
3724c4299
< doubleprecision :: p,s,t,tol,eps
---
> doubleprecision :: p,s,t(1,1),tol,eps
3726c4301
<    if (ddt .eq. 1) call journal('sc','*MATFN3* ', FIN)
---
>    if (G_DEBUG_LEVEL .eq. 1) call journal('sc','*MATFN3* ', G_FIN)
3728,3731c4303,4306
<    if (fin.eq.1 .and. rhs.eq.2) top = top-1
<    l = lstk(top)
<    m = mstk(top)
<    n = nstk(top)
---
>    if (G_fin.eq.1 .and. G_rhs.eq.2) G_top = G_top-1
>    l = G_LSTK(G_top)
>    m = G_MSTK(G_top)
>    n = G_NSTK(G_top)
3735c4310
<    FUN3: select case(fin)
---
>    FUN3: select case(G_fin)
3741,3747c4316,4323
<       err = l2+min0(m,n) - lstk(bot)
<       if (err .gt. 0) call mat_err(17)
<       if (err .gt. 0) return
<       call ml_wsvdc(stkr(l),stki(l),m,m,n,stkr(ld),stki(ld),stkr(l1),stki(l1),t,t,1,t,t,1,stkr(l2),stki(l2),0,err)
<       if (err .ne. 0) call mat_err(24)
<       if (err .gt. 0) return
<       s = stkr(ld)
---
>       G_err = l2+min0(m,n) - G_LSTK(G_BOT)
>       if (G_err .gt. 0) call mat_err(17)
>       if (G_err .gt. 0) return
>       call ml_wsvdc(G_stkr(l),G_STKI(l),m,m,n, &
>       & G_stkr(ld),G_STKI(ld),G_stkr(l1),G_STKI(l1),t,t,1,t,t,1,G_stkr(l2),G_STKI(l2),0,G_err)
>       if (G_err .ne. 0) call mat_err(24)
>       if (G_err .gt. 0) return
>       s = G_stkr(ld)
3749,3754c4325,4330
<       t = stkr(ld)
<       if (t .ne. 0.0d0) then
<          stkr(l) = mat_flop(s/t)
<          stki(l) = 0.0d0
<          mstk(top) = 1
<          nstk(top) = 1
---
>       t(1,1) = G_stkr(ld)
>       if (t(1,1) .ne. 0.0d0) then
>          G_stkr(l) = mat_flop(s/t(1,1))
>          G_STKI(l) = 0.0d0
>          G_MSTK(G_top) = 1
>          G_NSTK(G_top) = 1
3757c4333
<          mstk(top) = 0
---
>          G_MSTK(G_top) = 0
3763,3770c4339,4346
<       if (rhs .eq. 2)then
<          fro = idint(stkr(l)).eq.15 .and. mn.gt.1
<          inf = idint(stkr(l)).eq.18 .and. mn.gt.1
<          if (.not. fro) p = stkr(l)
<          top = top-1
<          l = lstk(top)
<          m = mstk(top)
<          n = nstk(top)
---
>       if (G_rhs .eq. 2)then
>          fro = int(G_stkr(l)).eq.15 .and. mn.gt.1
>          inf = int(G_stkr(l)).eq.18 .and. mn.gt.1
>          if (.not. fro) p = G_stkr(l)
>          G_top = G_top-1
>          l = G_LSTK(G_top)
>          m = G_MSTK(G_top)
>          n = G_NSTK(G_top)
3778,3779c4354,4355
<       i = mat_iwamax(mn,stkr(l),stki(l),1) + l - 1
<       s = dabs(stkr(i)) + dabs(stki(i))
---
>       i = mat_iwamax(mn,G_stkr(l),G_STKI(l),1) + l - 1
>       s = dabs(G_stkr(i)) + dabs(G_STKI(i))
3781c4357
<       t = 0.0d0
---
>       t(1,1) = 0.0d0
3784c4360
<          t = mat_flop(t + (mat_pythag(stkr(ls),stki(ls))/s)**p)
---
>          t(1,1) = mat_flop(t(1,1) + (mat_pythag(G_stkr(ls),G_STKI(ls))/s)**p)
3787c4363
<       s = mat_flop(s*t**p)
---
>       s = mat_flop(s*t(1,1)**p)
3790c4366
<       S = mat_wasum(MN,STKR(L),STKI(L),1)
---
>       S = mat_wasum(MN,G_STKR(L),G_STKI(L),1)
3793c4369
<       S = mat_wnrm2(MN,STKR(L),STKI(L),1)
---
>       S = mat_wnrm2(MN,G_STKR(L),G_STKI(L),1)
3799c4375
<       IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) RETURN
3803,3809c4379,4386
<       ERR = L2+MIN0(M,N) - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),0,ERR)
<       IF (ERR .NE. 0) CALL mat_err(24)
<       IF (ERR .GT. 0) RETURN
<       S = STKR(LD)
---
>       G_ERR = L2+MIN0(M,N) - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       call ml_wsvdc(G_stkr(l),G_STKI(l),m,m,n, &
>       & G_stkr(ld),G_STKI(ld),G_stkr(l1),G_STKI(l1),t,t,1,t,t,1,G_stkr(l2),G_STKI(l2),0,G_err)
>       IF (G_ERR .NE. 0) CALL mat_err(24)
>       IF (G_ERR .GT. 0) RETURN
>       S = G_STKR(LD)
3815,3816c4392,4393
<          T = mat_wasum(N,STKR(LI),STKI(LI),M)
<          S = DMAX1(S,T)
---
>          T(1,1) = mat_wasum(N,G_STKR(LI),G_STKI(LI),M)
>          S = DMAX1(S,T(1,1))
3823,3824c4400,4401
<          T = mat_wasum(M,STKR(LJ),STKI(LJ),1)
<          S = DMAX1(S,T)
---
>          T(1,1) = mat_wasum(M,G_STKR(LJ),G_STKI(LJ),1)
>          S = DMAX1(S,T(1,1))
3828,3831c4405,4408
<       STKR(L) = S
<       STKI(L) = 0.0D0
<       MSTK(TOP) = 1
<       NSTK(TOP) = 1
---
>       G_STKR(L) = S
>       G_STKI(L) = 0.0D0
>       G_MSTK(G_TOP) = 1
>       G_NSTK(G_TOP) = 1
3834c4411
<       IF (LHS .EQ. 3)then
---
>       IF (G_LHS .EQ. 3)then
3836c4413
<          IF (RHS .EQ. 2) K = MIN0(M,N)
---
>          IF (G_RHS .EQ. 2) K = MIN0(M,N)
3842,3844c4419,4421
<          ERR = L2+MIN0(M,N) - LSTK(BOT)
<          IF (ERR .GT. 0) CALL mat_err(17)
<          IF (ERR .GT. 0) RETURN
---
>          G_ERR = L2+MIN0(M,N) - G_LSTK(G_BOT)
>          IF (G_ERR .GT. 0) CALL mat_err(17)
>          IF (G_ERR .GT. 0) RETURN
3846,3848c4423,4426
<          IF (RHS .EQ. 2) JOB = 21
<          CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),STKR(LU),STKI(LU),M,STKR(LV),STKI(LV), &
<          &        N,STKR(L2),STKI(L2),JOB,ERR)
---
>          IF (G_RHS .EQ. 2) JOB = 21
>          call ml_wsvdc(G_stkr(l),G_STKI(l),m,m,n, &
>          & G_stkr(ld),G_STKI(ld),G_stkr(l1),G_STKI(l1),G_stkr(lu),G_STKI(lu),m,G_stkr(lv),G_STKI(lv), &
>          & n,G_stkr(l2),G_STKI(l2),job,G_err)
3853,3854c4431,4432
<                IF (I.NE.J) STKR(LL) = 0.0D0
<                STKI(LL) = 0.0D0
---
>                IF (I.NE.J) G_STKR(LL) = 0.0D0
>                G_STKI(LL) = 0.0D0
3856c4434
<                IF (I.EQ.J) STKR(LL) = STKR(LS)
---
>                IF (I.EQ.J) G_STKR(LL) = G_STKR(LS)
3858c4436
<                IF (ERR.NE.0 .AND. I.EQ.J-1) STKR(LL) = STKR(LS)
---
>                IF (G_ERR.NE.0 .AND. I.EQ.J-1) G_STKR(LL) = G_STKR(LS)
3861,3877c4439,4455
<          IF (ERR .NE. 0) CALL mat_err(24)
<          ERR = 0
<          CALL mat_wcopy(M*K+K*N+N*N,STKR(LU),STKI(LU),1,STKR(L),STKI(L),1)
<          MSTK(TOP) = M
<          NSTK(TOP) = K
<          IF (TOP+1 .GE. BOT) CALL mat_err(18)
<          IF (ERR .GT. 0) RETURN
<          TOP = TOP+1
<          LSTK(TOP) = L + M*K
<          MSTK(TOP) = K
<          NSTK(TOP) = N
<          IF (TOP+1 .GE. BOT) CALL mat_err(18)
<          IF (ERR .GT. 0) RETURN
<          TOP = TOP+1
<          LSTK(TOP) = L + M*K + K*N
<          MSTK(TOP) = N
<          NSTK(TOP) = N
---
>          IF (G_ERR .NE. 0) CALL mat_err(24)
>          G_ERR = 0
>          CALL mat_wcopy(M*K+K*N+N*N,G_STKR(LU),G_STKI(LU),1,G_STKR(L),G_STKI(L),1)
>          G_MSTK(G_TOP) = M
>          G_NSTK(G_TOP) = K
>          IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)
>          IF (G_ERR .GT. 0) RETURN
>          G_TOP = G_TOP+1
>          G_LSTK(G_TOP) = L + M*K
>          G_MSTK(G_TOP) = K
>          G_NSTK(G_TOP) = N
>          IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)
>          IF (G_ERR .GT. 0) RETURN
>          G_TOP = G_TOP+1
>          G_LSTK(G_TOP) = L + M*K + K*N
>          G_MSTK(G_TOP) = N
>          G_NSTK(G_TOP) = N
3882,3887c4460,4467
<          ERR = L2+MIN0(M,N) - LSTK(BOT)
<          IF (ERR .GT. 0) CALL mat_err(17)
<          IF (ERR .GT. 0) RETURN
<          CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),0,ERR)
<          IF (ERR .NE. 0) CALL mat_err(24)
<          IF (ERR .GT. 0) RETURN
---
>          G_ERR = L2+MIN0(M,N) - G_LSTK(G_BOT)
>          IF (G_ERR .GT. 0) CALL mat_err(17)
>          IF (G_ERR .GT. 0) RETURN
>          call ml_wsvdc(G_stkr(l),G_STKI(l),m,m,n, &
>          & G_stkr(ld),G_STKI(ld),G_stkr(l1),G_STKI(l1), &
>          & t,t,1,t,t,1,G_stkr(l2),G_STKI(l2),0,G_err)
>          IF (G_ERR .NE. 0) CALL mat_err(24)
>          IF (G_ERR .GT. 0) RETURN
3889,3891c4469,4471
<          CALL mat_wcopy(K,STKR(LD),STKI(LD),1,STKR(L),STKI(L),1)
<          MSTK(TOP) = K
<          NSTK(TOP) = 1
---
>          CALL mat_wcopy(K,G_STKR(LD),G_STKI(LD),1,G_STKR(L),G_STKI(L),1)
>          G_MSTK(G_TOP) = K
>          G_NSTK(G_TOP) = 1
3896,3901c4476,4481
<       IF (RHS .EQ. 2) then
<          TOL = STKR(L)
<          TOP = TOP-1
<          L = LSTK(TOP)
<          M = MSTK(TOP)
<          N = NSTK(TOP)
---
>       IF (G_RHS .EQ. 2) then
>          TOL = G_STKR(L)
>          G_TOP = G_TOP-1
>          L = G_LSTK(G_TOP)
>          M = G_MSTK(G_TOP)
>          N = G_NSTK(G_TOP)
3905c4485
<       IF (FIN .EQ. 5) LD = L + M*N
---
>       IF (G_FIN .EQ. 5) LD = L + M*N
3908c4488
<       IF (FIN .EQ. 5) L1 = LD + N
---
>       IF (G_FIN .EQ. 5) L1 = LD + N
3910,3920c4490,4501
<       ERR = L2+MIN0(M,N) - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       IF (FIN .EQ. 2) JOB = 11
<       IF (FIN .EQ. 5) JOB = 0
<       CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),STKR(LU),STKI(LU),M,STKR(LV),STKI(LV), &
<       &        N,STKR(L2),STKI(L2),JOB,ERR)
<       IF (ERR .NE. 0) CALL mat_err(24)
<       IF (ERR .GT. 0) RETURN
<       EPS = STKR(VSIZE-4)
<       IF (TOL .LT. 0.0D0) TOL = mat_flop(DFLOAT(MAX0(M,N))*EPS*STKR(LD))
---
>       G_ERR = L2+MIN0(M,N) - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       IF (G_FIN .EQ. 2) JOB = 11
>       IF (G_FIN .EQ. 5) JOB = 0
>       CALL ML_WSVDC(G_STKR(L),G_STKI(L),M,M,N, &
>       & G_STKR(LD),G_STKI(LD),G_STKR(L1),G_STKI(L1),G_STKR(LU),G_STKI(LU),M,G_STKR(LV),G_STKI(LV), &
>       &        N,G_STKR(L2),G_STKI(L2),JOB,G_ERR)
>       IF (G_ERR .NE. 0) CALL mat_err(24)
>       IF (G_ERR .GT. 0) RETURN
>       EPS = G_STKR(G_VSIZE-4)
>       IF (TOL .LT. 0.0D0) TOL = mat_flop(dble(MAX0(M,N))*EPS*G_STKR(LD))
3925c4506
<          S = STKR(LS)
---
>          S = G_STKR(LS)
3929c4510
<          IF (FIN .EQ. 2) CALL mat_wrscal(N,1.0D0/S,STKR(LL),STKI(LL),1)
---
>          IF (G_FIN .EQ. 2) CALL mat_wrscal(N,1.0D0/S,G_STKR(LL),G_STKI(LL),1)
3931c4512
<       if (fin .ne. 5) then
---
>       if (G_fin .ne. 5) then
3937,3938c4518,4519
<                stkr(ll) = mat_wdotcr(k,stkr(l2),stki(l2),m,stkr(l1),stki(l1),n)
<                stki(ll) = mat_wdotci(k,stkr(l2),stki(l2),m,stkr(l1),stki(l1),n)
---
>                G_stkr(ll) = mat_wdotcr(k,G_stkr(l2),G_STKI(l2),m,G_stkr(l1),G_STKI(l1),n)
>                G_STKI(ll) = mat_wdotci(k,G_stkr(l2),G_STKI(l2),m,G_stkr(l1),G_STKI(l1),n)
3941,3942c4522,4523
<          mstk(top) = n
<          nstk(top) = m
---
>          G_MSTK(G_top) = n
>          G_NSTK(G_top) = m
3944,3947c4525,4528
<          stkr(l) = dfloat(k)
<          stki(l) = 0.0d0
<          mstk(top) = 1
<          nstk(top) = 1
---
>          G_stkr(l) = dble(k)
>          G_STKI(l) = 0.0d0
>          G_MSTK(G_top) = 1
>          G_NSTK(G_top) = 1
3958c4539
< $@(#) M_matrix::mat_matfn4(3fp): evaluate functions involving qr decomposition (least squares)
---
> ! ident_33="@(#)M_matrix::mat_matfn4(3fp): evaluate functions involving qr decomposition (least squares)"
3978,3979c4559,4560
< character(len=81) ::  mline
< DOUBLEPRECISION   :: T,TOL,EPS
---
> character(len=81) :: message
> DOUBLEPRECISION   :: T(1),TOL,EPS
3982c4563
<       IF (DDT .EQ. 1) call journal('sc','*MATFN4* ', FIN)
---
>       IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc','*MATFN4* ', G_FIN)
3984,3988c4565,4569
<       L = LSTK(TOP)
<       M = MSTK(TOP)
<       N = NSTK(TOP)
<       IF (FIN .EQ. -1) GOTO 10
<       IF (FIN .EQ. -2) GOTO 20
---
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)
>       N = G_NSTK(G_TOP)
>       IF (G_FIN .EQ. -1) GOTO 10
>       IF (G_FIN .EQ. -2) GOTO 20
3993,3996c4574,4577
<       L2 = LSTK(TOP+1)
<       M2 = MSTK(TOP+1)
<       N2 = NSTK(TOP+1)
<       TOP = TOP + 1
---
>       L2 = G_LSTK(G_TOP+1)
>       M2 = G_MSTK(G_TOP+1)
>       N2 = G_NSTK(G_TOP+1)
>       G_TOP = G_TOP + 1
3998c4579
<       IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) RETURN
4000c4581
<       IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) RETURN
4002,4006c4583,4587
<       CALL mat_wcopy(M*N,STKR(L),STKI(L),1,STKR(LL),STKI(LL),1)
<       CALL mat_wcopy(M*N+M2*N2,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
<       LSTK(TOP) = L+M2*N2
<       MSTK(TOP) = M
<       NSTK(TOP) = N
---
>       CALL mat_wcopy(M*N,G_STKR(L),G_STKI(L),1,G_STKR(LL),G_STKI(LL),1)
>       CALL mat_wcopy(M*N+M2*N2,G_STKR(L2),G_STKI(L2),1,G_STKR(L),G_STKI(L),1)
>       G_LSTK(G_TOP) = L+M2*N2
>       G_MSTK(G_TOP) = M
>       G_NSTK(G_TOP) = N
4008,4009c4589,4590
<       IF (ERR .GT. 0) RETURN
<       TOP = TOP - 1
---
>       IF (G_ERR .GT. 0) RETURN
>       G_TOP = G_TOP - 1
4017,4019c4598,4600
<       L2 = LSTK(TOP+1)
<       M2 = MSTK(TOP+1)
<       N2 = NSTK(TOP+1)
---
>       L2 = G_LSTK(G_TOP+1)
>       M2 = G_MSTK(G_TOP+1)
>       N2 = G_NSTK(G_TOP+1)
4023,4027c4604,4608
<         ERR = L2+M*M - LSTK(BOT)
<         IF (ERR .GT. 0) CALL mat_err(17)
<         IF (ERR .GT. 0) RETURN
<         CALL mat_wset(M*M-1,0.0D0,0.0D0,STKR(L2+1),STKI(L2+1),1)
<         CALL mat_wcopy(M,STKR(L2),STKI(L2),0,STKR(L2),STKI(L2),M+1)
---
>         G_ERR = L2+M*M - G_LSTK(G_BOT)
>         IF (G_ERR .GT. 0) CALL mat_err(17)
>         IF (G_ERR .GT. 0) RETURN
>         CALL mat_wset(M*M-1,0.0D0,0.0D0,G_STKR(L2+1),G_STKI(L2+1),1)
>         CALL mat_wcopy(M,G_STKR(L2),G_STKI(L2),0,G_STKR(L2),G_STKI(L2),M+1)
4030c4611
<       IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) RETURN
4033,4035c4614,4616
<       ERR = L4 + N - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
---
>       G_ERR = L4 + N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
4041c4622
<         CALL mat_wcopy(M,STKR(LS),STKI(LS),-1,STKR(LL),STKI(LL),-1)
---
>         CALL mat_wcopy(M,G_STKR(LS),G_STKI(LS),-1,G_STKR(LL),G_STKI(LL),-1)
4045c4626
<         BUF(J) = 0
---
>         G_BUF(J) = 0
4047c4628
<       CALL ML_WQRDC(STKR(L),STKI(L),M,M,N,STKR(L4),STKI(L4),BUF,STKR(L3),STKI(L3),1)
---
>       CALL ML_WQRDC(G_STKR(L),G_STKI(L),M,M,N,G_STKR(L4),G_STKI(L4),G_BUF,G_STKR(L3),G_STKI(L3),1)
4049,4051c4630,4632
<       EPS = STKR(VSIZE-4)
<       T = DABS(STKR(L))+DABS(STKI(L))
<       TOL = mat_flop(DFLOAT(MAX0(M,N))*EPS*T)
---
>       EPS = G_STKR(G_VSIZE-4)
>       T(1) = DABS(G_STKR(L))+DABS(G_STKI(L))
>       TOL = mat_flop(dble(MAX0(M,N))*EPS*T(1))
4055,4056c4636,4637
<         T = DABS(STKR(LS)) + DABS(STKI(LS))
<         IF (T .GT. TOL) K = J
---
>         T(1) = DABS(G_STKR(LS)) + DABS(G_STKI(LS))
>         IF (T(1) .GT. TOL) K = J
4059,4060c4640,4641
<          WRITE(mline,'('' RANK DEFICIENT,  RANK ='',I4,'',  TOL ='',1PD13.4)') K,TOL
<          call journal(mline)
---
>          WRITE(message,'(" RANK DEFICIENT,  RANK =",I4,",  TOL =",1PD13.4)') K,TOL
>          call journal(message)
4065,4066c4646,4647
<         CALL ML_WQRSL(STKR(L),STKI(L),M,M,K,STKR(L4),STKI(L4),STKR(LS),STKI(LS),T,T,STKR(LS),STKI(LS),STKR(LS), &
<        & STKI(LS),T,T,T,T,100,INFO)
---
>         CALL ML_WQRSL(G_STKR(L),G_STKI(L),M,M,K,G_STKR(L4),G_STKI(L4),G_STKR(LS),G_STKI(LS),T,T,G_STKR(LS),G_STKI(LS),G_STKR(LS), &
>        & G_STKI(LS),T,T,T,T,100,INFO)
4068c4649
<         CALL mat_wset(N-K,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
---
>         CALL mat_wset(N-K,0.0D0,0.0D0,G_STKR(LL),G_STKI(LL),1)
4071c4652
<         BUF(J) = -BUF(J)
---
>         G_BUF(J) = -G_BUF(J)
4074,4076c4655,4657
<         IF (BUF(J) .GT. 0) cycle
<         K = -BUF(J)
<         BUF(J) = K
---
>         IF (G_BUF(J) .GT. 0) cycle
>         K = -G_BUF(J)
>         G_BUF(J) = K
4081,4083c4662,4664
<           CALL mat_wswap(N2,STKR(LS),STKI(LS),MN,STKR(LL),STKI(LL),MN)
<           BUF(K) = -BUF(K)
<           K = BUF(K)
---
>           CALL mat_wswap(N2,G_STKR(LS),G_STKI(LS),MN,G_STKR(LL),G_STKI(LL),MN)
>           G_BUF(K) = -G_BUF(K)
>           K = G_BUF(K)
4089c4670
<         CALL mat_wcopy(N,STKR(LS),STKI(LS),1,STKR(LL),STKI(LL),1)
---
>         CALL mat_wcopy(N,G_STKR(LS),G_STKI(LS),1,G_STKR(LL),G_STKI(LL),1)
4091,4094c4672,4675
<       MSTK(TOP) = N
<       NSTK(TOP) = N2
<       IF (FIN .EQ. -1) CALL mat_stack1(QUOTE)
<       IF (ERR .GT. 0) RETURN
---
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = N2
>       IF (G_FIN .EQ. -1) CALL mat_stack1(QUOTE)
>       IF (G_ERR .GT. 0) RETURN
4102c4683
<       IF (LHS.EQ.1 .AND. FIN.EQ.1) LS = L
---
>       IF (G_LHS.EQ.1 .AND. G_FIN.EQ.1) LS = L
4105,4108c4686,4689
<       ERR = L4+MM - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
<       IF (LS.NE.L) CALL mat_wcopy(M*N,STKR(L),STKI(L),1,STKR(LS),STKI(LS),1)
---
>       G_ERR = L4+MM - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) RETURN
>       IF (LS.NE.L) CALL mat_wcopy(M*N,G_STKR(L),G_STKI(L),1,G_STKR(LS),G_STKI(LS),1)
4110c4691
<       IF (LHS.LT.3) JOB = 0
---
>       IF (G_LHS.LT.3) JOB = 0
4112c4693
<         BUF(J) = 0
---
>         G_BUF(J) = 0
4114,4117c4695,4698
<       CALL ML_WQRDC(STKR(LS),STKI(LS),M,M,N,STKR(L4),STKI(L4),BUF,STKR(LE),STKI(LE),JOB)
<       IF (LHS.EQ.1 .AND. FIN.EQ.1) GOTO 99
<       CALL mat_wset(M*M,0.0D0,0.0D0,STKR(L),STKI(L),1)
<       CALL mat_wset(M,1.0D0,0.0D0,STKR(L),STKI(L),M+1)
---
>       CALL ML_WQRDC(G_STKR(LS),G_STKI(LS),M,M,N,G_STKR(L4),G_STKI(L4),G_BUF,G_STKR(LE),G_STKI(LE),JOB)
>       IF (G_LHS.EQ.1 .AND. G_FIN.EQ.1) GOTO 99
>       CALL mat_wset(M*M,0.0D0,0.0D0,G_STKR(L),G_STKI(L),1)
>       CALL mat_wset(M,1.0D0,0.0D0,G_STKR(L),G_STKI(L),M+1)
4120,4121c4701,4702
<         CALL ML_WQRSL(STKR(LS),STKI(LS),M,M,N,STKR(L4),STKI(L4),   &
<      &             STKR(LL),STKI(LL),STKR(LL),STKI(LL),T,T,        &
---
>         CALL ML_WQRSL(G_STKR(LS),G_STKI(LS),M,M,N,G_STKR(L4),G_STKI(L4),   &
>      &             G_STKR(LL),G_STKI(LL),G_STKR(LL),G_STKI(LL),T,T,        &
4124,4125c4705,4706
<       IF (FIN .EQ. 2) GOTO 99
<       NSTK(TOP) = M
---
>       IF (G_FIN .EQ. 2) GOTO 99
>       G_NSTK(G_TOP) = M
4128c4709
<         CALL mat_wset(M-J,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
---
>         CALL mat_wset(M-J,0.0D0,0.0D0,G_STKR(LL),G_STKI(LL),1)
4130,4137c4711,4718
<       IF (TOP+1 .GE. BOT) CALL mat_err(18)
<       IF (ERR .GT. 0) RETURN
<       TOP = TOP+1
<       LSTK(TOP) = LS
<       MSTK(TOP) = M
<       NSTK(TOP) = N
<       IF (LHS .EQ. 2) GOTO 99
<       CALL mat_wset(N*N,0.0D0,0.0D0,STKR(LE),STKI(LE),1)
---
>       IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)
>       IF (G_ERR .GT. 0) RETURN
>       G_TOP = G_TOP+1
>       G_LSTK(G_TOP) = LS
>       G_MSTK(G_TOP) = M
>       G_NSTK(G_TOP) = N
>       IF (G_LHS .EQ. 2) GOTO 99
>       CALL mat_wset(N*N,0.0D0,0.0D0,G_STKR(LE),G_STKI(LE),1)
4139,4140c4720,4721
<         LL = LE+BUF(J)-1+(J-1)*N
<         STKR(LL) = 1.0D0
---
>         LL = LE+G_BUF(J)-1+(J-1)*N
>         G_STKR(LL) = 1.0D0
4142,4147c4723,4728
<       IF (TOP+1 .GE. BOT) CALL mat_err(18)
<       IF (ERR .GT. 0) RETURN
<       TOP = TOP+1
<       LSTK(TOP) = LE
<       MSTK(TOP) = N
<       NSTK(TOP) = N
---
>       IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)
>       IF (G_ERR .GT. 0) RETURN
>       G_TOP = G_TOP+1
>       G_LSTK(G_TOP) = LE
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = N
4157c4738
< $@(#) M_matrix::mat_matfn5(3fp):file handling and other I/O
---
> ! ident_34="@(#)M_matrix::mat_matfn5(3fp):file handling and other I/O"
4166,4171c4747,4748
< integer,save        :: flag=0
< integer,save        :: blank=36
< integer,save        :: plus=41
< integer,save        :: minus=42
< integer,save        :: quote=49
< integer,save        :: semi=39
---
> integer,save        :: flag=0  ! should be saved or set at each call?
> integer,parameter   :: blank=36, plus=41, minus=42, quote=49, semi=39
4175c4752
< integer             :: id(4)
---
> integer             :: id(G_MAX_NAME_LENGTH)
4178c4755
< integer             :: i
---
> integer             :: i, j, k, l, m, n
4180d4756
< integer             :: j
4182,4183d4757
< integer             :: k
< integer             :: l
4192d4765
< integer             :: m
4194c4767
< integer             :: n
---
> logical             :: isfound
4196,4197c4769,4770
<       IF (DDT .EQ. 1) call journal('sc','*MATFN5* ',FIN)
< !     FUNCTIONS/FIN
---
>       IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc','*MATFN5* ',G_FIN)
> !     FUNCTIONS/G_FIN
4200,4202c4773,4775
<       L = LSTK(TOP)
<       M = MSTK(TOP)
<       N = NSTK(TOP)
---
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)
>       N = G_NSTK(G_TOP)
4204c4777
<       select case(fin)
---
>       select case(G_fin)
4207a4781,4783
>          IF (G_SYM .EQ. SEMI)then
>             FLAG = 0
>          else
4209,4215c4785,4791
<          IF (SYM .EQ. SEMI) FLAG = 0
<          IF (RHS .GE. 2) THEN
<             FLAG = IDINT(STKR(L))
<             TOP2 = TOP
<             TOP = TOP-1
<             L = LSTK(TOP)
<             MN = MSTK(TOP)*NSTK(TOP)
---
>          endif
>          IF (G_RHS .GE. 2) THEN            ! if more than one parameter on exec('filename',flag) get value of FLAG
>             FLAG = int(G_STKR(L))
>             TOP2 = G_TOP
>             G_TOP = G_TOP-1
>             L = G_LSTK(G_TOP)
>             MN = G_MSTK(G_TOP)*G_NSTK(G_TOP)
4218c4794,4795
<          IF (MN.EQ.1 .AND. STKR(L).LT.10.0D0) LUN = IDINT(STKR(L))
---
>          IF (MN.EQ.1 .AND. G_STKR(L).LT.10.0D0) LUN = int(G_STKR(L))
> 
4220c4797
<              DO J = 1, 32
---
>              DO J = 1, 255
4222c4799
<                 IF (J .LE. MN) CH = IDINT(STKR(LS))
---
>                 IF (J .LE. MN) CH = int(G_STKR(LS))
4224,4227c4801,4803
<                 IF (CH.LT.0 .OR. CH.GE.alflq) CALL mat_err(38)
<                 IF (ERR .GT. 0) RETURN
<                 IF (CASE .EQ. 0) BUF(J) = ALFA(CH+1)
<                 IF (CASE .EQ. 1) BUF(J) = ALFB(CH+1)
---
>                 IF (CH.LT.0 .OR. CH.GE.G_CHARSET_SIZE) CALL mat_err(38)
>                 IF (G_ERR .GT. 0) RETURN
>                 G_BUF(J) = G_CHARSET(CH+1)
4234c4810
<       FUN5 : select case(fin)
---
>       FUN5 : select case(G_fin)
4237,4240c4813,4815
<       IF (LUN .EQ. 0) THEN
< !     EXEC(0)
<          RIO = RTE
<          ERR = 99
---
>       IF (LUN .EQ. 0) THEN                                  ! EXEC(0)
>          G_RIO = G_RTE
>          G_ERR = 99
4242,4258c4817,4834
<          K = LPT(6)
<          LIN(K+1) = LPT(1)
<          LIN(K+2) = LPT(3)
<          LIN(K+3) = LPT(6)
<          LIN(K+4) = PTZ
<          LIN(K+5) = RIO
<          LIN(K+6) = LCT(4)
<          LPT(1) = K + 7
<          LCT(4) = FLAG
<          PTZ = PT - 4
<          IF (RIO .EQ. RTE) RIO = 12
<          RIO = RIO + 1
<          IF (LUN .GT. 0) RIO = LUN
<          IF (LUN .LT. 0) CALL mat_files(RIO,BUF)
<          IF (FLAG .GE. 4)call journal(' PAUSE MODE. ENTER BLANK LINES.')
<          SYM = EOL
<          MSTK(TOP) = 0
---
>          K = G_LPT(6)
>          G_LIN(K+1) = G_LPT(1)
>          G_LIN(K+2) = G_LPT(3)
>          G_LIN(K+3) = G_LPT(6)
>          G_LIN(K+4) = G_PTZ
>          G_LIN(K+5) = G_RIO
>          G_LIN(K+6) = G_LINECOUNT(4)
>          G_LPT(1) = K + 7
>          G_LINECOUNT(4) = FLAG
>          G_PTZ = G_PT - 4
>          IF (G_RIO .EQ. G_RTE) G_RIO = 12
>          G_RIO = G_RIO + 1
>          IF (LUN .GT. 0) G_RIO = LUN
>          !!call find_exec_file(G_BUF,isfound)
>          IF (LUN .LT. 0) CALL mat_files(G_RIO,G_BUF,status='old')
>          IF (FLAG .GE. 4)call journal(' PAUSE MODE. Enter blank lines.')
>          G_SYM = G_EOL
>          G_MSTK(G_TOP) = 0
4262,4270c4838,4848
<       K = WTE
<       WTE = LUN
<       IF (LUN .LT. 0) WTE = 7
<       IF (LUN .LT. 0) CALL mat_files(WTE,BUF)
< 
<       L = LCT(2)
<       LCT(2) = 9999
<       IF (RHS .GT. 1) CALL mat_print(SYN,TOP2)
<       LCT(2) = L
---
>       K = G_WTE                                       ! HOLD
>       G_WTE = LUN
>       IF (LUN .LT. 0) G_WTE = 7
>       IF (LUN .LT. 0) CALL mat_files(G_WTE,G_BUF)
> 
>       L = G_LINECOUNT(2)                              ! HOLD
>       G_LINECOUNT(2) = 999999                         ! turn off paging of output
>       IF (G_RHS .GT. 1) CALL mat_print(G_SYN,TOP2)
> 
>       G_LINECOUNT(2) = L                              ! RESTORE
>       G_WTE = K                                       ! RESTORE
4272,4273c4850
<       WTE = K
<       MSTK(TOP) = 0
---
>       G_MSTK(G_TOP) = 0
4276,4277c4853,4854
<       IF (LUN < 0) CALL mat_files(8,BUF)
<       MSTK(TOP) = 0
---
>       IF (LUN < 0) CALL mat_files(8,G_BUF)
>       G_MSTK(G_TOP) = 0
4281c4858
<       IF (LUN .LT. 0) CALL mat_files(LUNIT,BUF)
---
>       IF (LUN .LT. 0) CALL mat_files(LUNIT,G_BUF)
4283,4293c4860,4870
<       K = LSIZE-4
<       IF (K .LT. BOT) K = LSIZE
<       IF (RHS .EQ. 2) K = TOP2
<       IF (RHS .EQ. 2) CALL mat_putid(IDSTK(1,K),SYN)
<    32 CONTINUE
<       L = LSTK(K)
<       M = MSTK(K)
<       N = NSTK(K)
<       DO I = 1, 4
<          J = IDSTK(I,K)+1
<          BUF(I) = ALFA(J)
---
>       K = G_MAX_NUMBER_OF_NAMES-4
>       IF (K .LT. G_BOT) K = G_MAX_NUMBER_OF_NAMES
>       IF (G_RHS .EQ. 2) K = TOP2
>       IF (G_RHS .EQ. 2) CALL mat_putid(G_IDSTK(1,K),G_SYN)
>       do
>          L = G_LSTK(K)
>          M = G_MSTK(K)
>          N = G_NSTK(K)
>          DO I = 1, G_MAX_NAME_LENGTH
>             J = G_IDSTK(I,K)+1
>             G_BUF(I) = G_CHARSET(J)
4296,4297c4873,4874
<       IF (mat_wasum(M*N,STKI(L),STKI(L),1) .NE. 0.0D0) IMG = 1
<       IF(FE .EQ. 0)CALL mat_savlod(LUNIT,BUF,M,N,IMG,0,STKR(L),STKI(L))
---
>          IF (mat_wasum(M*N,G_STKI(L),G_STKI(L),1) .NE. 0.0D0) IMG = 1
>          IF(.not.G_FILE_OPEN_ERROR)CALL mat_savlod(LUNIT,G_BUF,M,N,IMG,0,G_STKR(L),G_STKI(L))
4299,4301c4876,4879
<       IF (K .GE. BOT) GOTO 32
<       CALL mat_files(-LUNIT,BUF)
<       MSTK(TOP) = 0
---
>          IF (K .LT. G_BOT) exit
>       enddo
>       CALL mat_files(-LUNIT,G_BUF)
>       G_MSTK(G_TOP) = 0
4305c4883
<       IF (LUN .LT. 0) CALL mat_files(LUNIT,BUF) ! open the unit
---
>       IF (LUN .LT. 0) CALL mat_files(LUNIT,G_BUF) ! open the unit
4307,4313c4885,4891
<    36 CONTINUE
<       JOB = LSTK(BOT) - L
<       IF(FE .EQ. 0)CALL mat_savlod(LUNIT,ID,MSTK(TOP),NSTK(TOP),IMG,JOB,STKR(L),STKI(L))
<       MN = MSTK(TOP)*NSTK(TOP)
<       IF (MN .EQ. 0) GOTO 39
<       IF (IMG .EQ. 0) CALL mat_rset(MN,0.0D0,STKI(L),1)
<       DO I = 1, 4
---
>       do
>          JOB = G_LSTK(G_BOT) - L
>          IF(.not.G_FILE_OPEN_ERROR)CALL mat_savlod(LUNIT,ID,G_MSTK(G_TOP),G_NSTK(G_TOP),IMG,JOB,G_STKR(L),G_STKI(L))
>          MN = G_MSTK(G_TOP)*G_NSTK(G_TOP)
>          IF (MN .NE. 0)then
>             IF (IMG .EQ. 0) CALL mat_rset(MN,0.0D0,G_STKI(L),1)
>             DO I = 1, G_MAX_NAME_LENGTH
4315c4893
<    37    CONTINUE
---
>                do
4317c4895,4897
<          IF (ID(I).NE.ALFA(J) .AND. J.LE.BLANK) GOTO 37
---
>                   IF (ID(I).NE.G_CHARSET(J) .AND. J.LE.BLANK) cycle
>                   exit
>                enddo
4320,4328c4900,4909
<       SYM = SEMI
<       RHS = 0
<       CALL mat_stackp(ID)
<       TOP = TOP + 1
<       GOTO 36
< 
<    39 CONTINUE
<       CALL mat_files(-LUNIT,BUF) ! close unit
<       MSTK(TOP) = 0
---
>             G_SYM = SEMI
>             G_RHS = 0
>             CALL MAT_STACK_PUT(ID)
>             G_TOP = G_TOP + 1
>          else
>             exit
>          endif
>       enddo
>       CALL mat_files(-LUNIT,G_BUF) ! close unit
>       G_MSTK(G_TOP) = 0
4331c4912
<       if (rhs .ne. 2) then
---
>       if (G_rhs .ne. 2) then
4334c4915
<          if (lhs .eq. 2) l2 = l + mn
---
>          if (G_lhs .eq. 2) l2 = l + mn
4336,4343c4917,4924
<          err = lw + lrat - lstk(bot)
<          if (err .gt. 0) call mat_err(17)
<          if (err .gt. 0) return
<          if (lhs .eq. 2) top = top + 1
<          lstk(top) = l2
<          mstk(top) = m
<          nstk(top) = n
<          call mat_rset(lhs*mn,0.0d0,stki(l),1)
---
>          G_err = lw + lrat - G_LSTK(G_BOT)
>          if (G_err .gt. 0) call mat_err(17)
>          if (G_err .gt. 0) return
>          if (G_lhs .eq. 2) G_top = G_top + 1
>          G_LSTK(G_top) = l2
>          G_MSTK(G_top) = m
>          G_NSTK(G_top) = n
>          call mat_rset(G_lhs*mn,0.0d0,G_STKI(l),1)
4345,4348c4926,4929
<             call mat_rat(stkr(l),lrat,mrat,s,t,stkr(lw))
<             stkr(l) = s
<             stkr(l2) = t
<             if (lhs .eq. 1) stkr(l) = mat_flop(s/t)
---
>             call mat_rat(G_stkr(l),lrat,mrat,s,t,G_stkr(lw))
>             G_stkr(l) = s
>             G_stkr(l2) = t
>             if (G_lhs .eq. 1) G_stkr(l) = mat_flop(s/t)
4353,4356c4934,4937
<          mrat = idint(stkr(l))
<          lrat = idint(stkr(l-1))
<          top = top - 1
<          mstk(top) = 0
---
>          mrat = int(G_stkr(l))
>          lrat = int(G_stkr(l-1))
>          G_top = G_top - 1
>          G_MSTK(G_top) = 0
4360,4364c4941,4945
<       K = IABS(IDINT(STKR(L)))
<       IF (M*N.NE.1 .OR. K.GE.alflq) CALL mat_err(36)
<       IF (ERR .GT. 0) exit FUN5
<       CH = ALFA(K+1)
<       IF (STKR(L) .LT. 0.0D0) CH = ALFB(K+1)
---
>       K = IABS(int(G_STKR(L)))
>       IF (M*N.NE.1 .OR. K.GE.G_CHARSET_SIZE) CALL mat_err(36)
>       IF (G_ERR .GT. 0) exit FUN5
>       CH = G_CHARSET(K+1)
>       IF (G_STKR(L) .LT. 0.0D0) CH = G_ALT_CHARSET(K+1)
4367c4948
<       READ(RTE,'(A1)') CH_CHAR
---
>       READ(G_RTE,'(A1)') CH_CHAR
4369,4371c4950,4952
<       IF (STKR(L) .GE. 0.0D0) ALFA(K+1) = CH
<       IF (STKR(L) .LT. 0.0D0) ALFB(K+1) = CH
<       MSTK(TOP) = 0
---
>       IF (G_STKR(L) .GE. 0.0D0) G_CHARSET(K+1) = CH
>       IF (G_STKR(L) .LT. 0.0D0) G_ALT_CHARSET(K+1) = CH
>       G_MSTK(G_TOP) = 0
4376,4377c4957,4958
<       if (FIN.eq.7)goto 65
<       IF (RHS .EQ. 2) GOTO 65
---
>       if (G_FIN.eq.7)goto 65
>       IF (G_RHS .EQ. 2) GOTO 65
4382,4384c4963,4965
<         CH = IDINT(STKR(LS))
<         TEXT = TEXT .AND. (CH.GE.0) .AND. (CH.LT.alflq)
<         TEXT = TEXT .AND. (DFLOAT(CH).EQ.STKR(LS))
---
>         CH = int(G_STKR(LS))
>         TEXT = TEXT .AND. (CH.GE.0) .AND. (CH.LT.G_CHARSET_SIZE)
>         TEXT = TEXT .AND. (dble(CH).EQ.G_STKR(LS))
4390,4394c4971,4975
<            IF (STKR(LS) .EQ. 0.0D0) CH = BLANK
<            IF (STKR(LS) .GT. 0.0D0) CH = PLUS
<            IF (STKR(LS) .LT. 0.0D0) CH = MINUS
<            IF (TEXT) CH = IDINT(STKR(LS))
<            BUF(J) = ALFA(CH+1)
---
>            IF (G_STKR(LS) .EQ. 0.0D0) CH = BLANK
>            IF (G_STKR(LS) .GT. 0.0D0) CH = PLUS
>            IF (G_STKR(LS) .LT. 0.0D0) CH = MINUS
>            IF (TEXT) CH = int(G_STKR(LS))
>            G_BUF(J) = G_CHARSET(CH+1)
4396c4977
<          call mat_buf2str(mline,buf,n)
---
>          call mat_buf2str(mline,G_buf,n)
4399c4980
<       MSTK(TOP) = 0
---
>       G_MSTK(G_TOP) = 0
4404,4407c4985,4988
<       IF (RHS .NE. 2) CALL mat_err(39)
<       IF (STKR(L) .LE. 1.0D0) CALL mat_err(36)
<       IF (ERR .GT. 0) exit FUN5
<       B = STKR(L)
---
>       IF (G_RHS .NE. 2) CALL mat_err(39)
>       IF (G_STKR(L) .LE. 1.0D0) CALL mat_err(36)
>       IF (G_ERR .GT. 0) exit FUN5
>       B = G_STKR(L)
4409,4413c4990,4994
<       TOP = TOP-1
<       RHS = 1
<       L = LSTK(TOP)
<       M = MSTK(TOP)*NSTK(TOP)
<       EPS = STKR(VSIZE-4)
---
>       G_TOP = G_TOP-1
>       G_RHS = 1
>       L = G_LSTK(G_TOP)
>       M = G_MSTK(G_TOP)*G_NSTK(G_TOP)
>       EPS = G_STKR(G_VSIZE-4)
4417c4998
<          CALL mat_base(STKR(LL),B,EPS,STKR(LS),N)
---
>          CALL mat_base(G_STKR(LL),B,EPS,G_STKR(LS),N)
4419,4422c5000,5003
<       CALL mat_rset(M*N,0.0D0,STKI(L2),1)
<       CALL mat_wcopy(M*N,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
<       MSTK(TOP) = N
<       NSTK(TOP) = M
---
>       CALL mat_rset(M*N,0.0D0,G_STKI(L2),1)
>       CALL mat_wcopy(M*N,G_STKR(L2),G_STKI(L2),1,G_STKR(L),G_STKI(L),1)
>       G_MSTK(G_TOP) = N
>       G_NSTK(G_TOP) = M
4424c5005
<       IF (FIN .EQ. 6) GOTO 60
---
>       IF (G_FIN .EQ. 6) GOTO 60
4428,4429c5009,5010
<       LCT(2) = IDINT(STKR(L))
<       MSTK(TOP) = 0
---
>       G_LINECOUNT(2) = int(G_STKR(L))
>       G_MSTK(G_TOP) = 0
4432c5013
<       IF (RHS .GE. 2) GOTO 82
---
>       IF (G_RHS .GE. 2) GOTO 82
4436c5017
<          STKI(LL) = DFLOAT(I)
---
>          G_STKI(LL) = dble(I)
4438,4439c5019,5020
<       CALL mat_plot(WTE,STKI(L),STKR(L),N,TDUM,0)
<       MSTK(TOP) = 0
---
>       CALL mat_plot(G_WTE,G_STKI(L),G_STKR(L),N,TDUM,0)
>       G_MSTK(G_TOP) = 0
4444,4455c5025,5036
<       IF (RHS .EQ. 2) K = 0
<       IF (RHS .EQ. 3) K = M*N
<       IF (RHS .GT. 3) K = RHS - 2
<       TOP = TOP - (RHS - 1)
<       N = MSTK(TOP)*NSTK(TOP)
<       IF (MSTK(TOP+1)*NSTK(TOP+1) .NE. N) CALL mat_err(5)
<       IF (ERR .GT. 0) exit FUN5
<       LX = LSTK(TOP)
<       LY = LSTK(TOP+1)
<       IF (RHS .GT. 3) L = LSTK(TOP+2)
<       CALL mat_plot(WTE,STKR(LX),STKR(LY),N,STKR(L),K)
<       MSTK(TOP) = 0
---
>       IF (G_RHS .EQ. 2) K = 0
>       IF (G_RHS .EQ. 3) K = M*N
>       IF (G_RHS .GT. 3) K = G_RHS - 2
>       G_TOP = G_TOP - (G_RHS - 1)
>       N = G_MSTK(G_TOP)*G_NSTK(G_TOP)
>       IF (G_MSTK(G_TOP+1)*G_NSTK(G_TOP+1) .NE. N) CALL mat_err(5)
>       IF (G_ERR .GT. 0) exit FUN5
>       LX = G_LSTK(G_TOP)
>       LY = G_LSTK(G_TOP+1)
>       IF (G_RHS .GT. 3) L = G_LSTK(G_TOP+2)
>       CALL mat_plot(G_WTE,G_STKR(LX),G_STKR(LY),N,G_STKR(L),K)
>       G_MSTK(G_TOP) = 0
4458,4460c5039,5041
<       DDT = IDINT(STKR(L))
<       call journal('sc',' DEBUG ',DDT)
<       MSTK(TOP) = 0
---
>       G_DEBUG_LEVEL = int(G_STKR(L))
>       call journal('sc',' DEBUG ',G_DEBUG_LEVEL)
>       G_MSTK(G_TOP) = 0
4463c5044
<       call mat_buf2str(name,buf,256)
---
>       call mat_buf2str(name,G_buf,256)
4468,4469c5049,5050
<             close(unit=-lunit,iostat=ios)
<             call journal('sc','*doc* user guide including all help text in the Appendix is on file',trim(name) )
---
>             close(unit=temp_lun,iostat=ios)
>             call journal('sc','<INFO> user guide including all help text in the Appendix is on file',trim(name) )
4473c5054
<       MSTK(TOP) = 0
---
>       G_MSTK(G_TOP) = 0
4481c5062
< SUBROUTINE mat_stackg(ID)
---
> SUBROUTINE MAT_STACK_GET(ID)
4483c5064
< $@(#) M_matrix::mat_stackg(3fp): get variables from storage
---
> ! ident_35="@(#)M_matrix::MAT_STACK_GET(3fp): get variables from storage"
4485c5066
< integer       :: id(4)
---
> integer,intent(in)  :: id(G_MAX_NAME_LENGTH)
4494c5075
< integer       :: lk
---
> integer             :: current_location
4502,4506c5083,5096
<       IF (DDT .EQ. 1)then
<          call journal('sc','STACKG(1)=',ID(1))
<          call journal('sc','STACKG(2)=',ID(2))
<          call journal('sc','STACKG(3)=',ID(3))
<          call journal('sc','STACKG(4)=',ID(4))
---
> character(len=G_MAX_NAME_LENGTH)    :: id_name
>    if (G_DEBUG_LEVEL .eq. 1)then
>       call journal('sc','*MAT_STACK_GET* ID(1)=',id(1), id(2), id(3), id(4))
>    endif
>    call mat_putid(G_IDSTK(1,G_BOT-1), ID)  ! copy ID to next blank entry in G_IDSTK in case it is not there(?)
> 
>    do k=G_MAX_NUMBER_OF_NAMES,1,-1                       ! start at bottom and search up through names till find the name
>       if (mat_eqid(G_IDSTK(1,k), id))exit                ! if found name exit loop
>    enddo
>    ! if (?)
>    ! or if matched the name inserted above did not find it.
>    if ( (k .ge. G_MAX_NUMBER_OF_NAMES-1 .and. G_RHS .gt. 0) .or. (k .eq. G_BOT-1) ) then
>       g_fin = 0
>       return
4508,4546c5098,5105
<       CALL mat_putid(IDSTK(1,BOT-1), ID)
<       K = LSIZE+1
< !===================================================================================================================================
<    10 continue
<       K = K-1
<       IF (.NOT.mat_eqid(IDSTK(1,K), ID)) GOTO 10
<       IF (K .GE. LSIZE-1 .AND. RHS .GT. 0) GOTO 98
<       IF (K .EQ. BOT-1) GOTO 98
<       LK = LSTK(K)
<       IF (RHS .EQ. 1) GOTO 40
<       IF (RHS .EQ. 2) GOTO 60
<       IF (RHS .GT. 2) CALL mat_err(21)
<       IF (ERR .GT. 0) RETURN
<       L = 1
<       IF (TOP .GT. 0) L = LSTK(TOP) + MSTK(TOP)*NSTK(TOP)
<       IF (TOP+1 .GE. BOT) CALL mat_err(18)
<       IF (ERR .GT. 0) RETURN
<       TOP = TOP+1
< !
< !     LOAD VARIABLE TO TOP OF STACK
<       LSTK(TOP) = L
<       MSTK(TOP) = MSTK(K)
<       NSTK(TOP) = NSTK(K)
<       MN = MSTK(K)*NSTK(K)
<       ERR = L+MN - LSTK(BOT)
<       IF (ERR .GT. 0) CALL mat_err(17)
<       IF (ERR .GT. 0) RETURN
< !     IF RAND, MATFN6 GENERATES RANDOM NUMBER
<       IF (K .EQ. LSIZE) GOTO 97
<       CALL mat_wcopy(MN,STKR(LK),STKI(LK),1,STKR(L),STKI(L),1)
<       GOTO 99
< !===================================================================================================================================
< !     VECT(ARG)
<    40 continue
<       IF (MSTK(TOP) .EQ. 0) GOTO 99
<       L = LSTK(TOP)
<       MN = MSTK(TOP)*NSTK(TOP)
<       MNK = MSTK(K)*NSTK(K)
<       IF (MSTK(TOP) .LT. 0) MN = MNK
---
> 
>    current_location = G_LSTK(K)                                       ! found it, so this is the location where the data begins
>    IF (G_RHS .EQ. 1) then                                             ! VECT(ARG)
>       IF (G_MSTK(G_TOP) .EQ. 0) GOTO 99
>       L = G_LSTK(G_TOP)
>       MN = G_MSTK(G_TOP)*G_NSTK(G_TOP)
>       MNK = G_MSTK(K)*G_NSTK(K)                                       ! number of values in this variable
>       IF (G_MSTK(G_TOP) .LT. 0) MN = MNK
4549,4559c5108,5118
<         LS = LK+I-1
<         IF (MSTK(TOP) .GT. 0) LS = LK + IDINT(STKR(LL)) - 1
<         IF (LS .LT. LK .OR. LS .GE. LK+MNK) CALL mat_err(21)
<         IF (ERR .GT. 0) RETURN
<         STKR(LL) = STKR(LS)
<         STKI(LL) = STKI(LS)
<       enddo
<       MSTK(TOP) = 1
<       NSTK(TOP) = 1
<       IF (MSTK(K) .GT. 1) MSTK(TOP) = MN
<       IF (MSTK(K) .EQ. 1) NSTK(TOP) = MN
---
>         LS = current_location+I-1
>         IF (G_MSTK(G_TOP) .GT. 0) LS = current_location + int(G_STKR(LL)) - 1
>         IF (LS .LT. current_location .OR. LS .GE. current_location+MNK) CALL mat_err(21)          ! Subscript out of range
>         IF (G_ERR .GT. 0) RETURN
>         G_STKR(LL) = G_STKR(LS)
>         G_STKI(LL) = G_STKI(LS)
>       enddo
>       G_MSTK(G_TOP) = 1
>       G_NSTK(G_TOP) = 1
>       IF (G_MSTK(K) .GT. 1) G_MSTK(G_TOP) = MN
>       IF (G_MSTK(K) .EQ. 1) G_NSTK(G_TOP) = MN
4561,4572c5120,5129
< !===================================================================================================================================
< !     MATRIX(ARG,ARG)
<    60 continue
<       TOP = TOP-1
<       L = LSTK(TOP)
<       IF (MSTK(TOP+1) .EQ. 0) MSTK(TOP) = 0
<       IF (MSTK(TOP) .EQ. 0) GOTO 99
<       L2 = LSTK(TOP+1)
<       M = MSTK(TOP)*NSTK(TOP)
<       IF (MSTK(TOP) .LT. 0) M = MSTK(K)
<       N = MSTK(TOP+1)*NSTK(TOP+1)
<       IF (MSTK(TOP+1) .LT. 0) N = NSTK(K)
---
>    elseif (G_RHS .EQ. 2) then                                              ! MATRIX(ARG,ARG)
>       G_TOP = G_TOP-1
>       L = G_LSTK(G_TOP)
>       IF (G_MSTK(G_TOP+1) .EQ. 0) G_MSTK(G_TOP) = 0
>       IF (G_MSTK(G_TOP) .EQ. 0) GOTO 99
>       L2 = G_LSTK(G_TOP+1)
>       M = G_MSTK(G_TOP)*G_NSTK(G_TOP)
>       IF (G_MSTK(G_TOP) .LT. 0) M = G_MSTK(K)
>       N = G_MSTK(G_TOP+1)*G_NSTK(G_TOP+1)
>       IF (G_MSTK(G_TOP+1) .LT. 0) N = G_NSTK(K)
4574,4575c5131,5132
<       MK = MSTK(K)
<       MNK = MSTK(K)*NSTK(K)
---
>       MK = G_MSTK(K)
>       MNK = G_MSTK(K)*G_NSTK(K)
4579c5136
<            IF (MSTK(TOP) .GT. 0) LI = L + IDINT(STKR(LI)) - 1
---
>            IF (G_MSTK(G_TOP) .GT. 0) LI = L + int(G_STKR(LI)) - 1
4581,4584c5138,5141
<            IF (MSTK(TOP+1) .GT. 0) LJ = L2 + IDINT(STKR(LJ)) - 1
<            LS = LK + LI-L + (LJ-L2)*MK
<            IF (LS.LT.LK .OR. LS.GE.LK+MNK) CALL mat_err(21)
<            IF (ERR .GT. 0) RETURN
---
>            IF (G_MSTK(G_TOP+1) .GT. 0) LJ = L2 + int(G_STKR(LJ)) - 1
>            LS = current_location + LI-L + (LJ-L2)*MK
>            IF (LS.LT.current_location .OR. LS.GE.current_location+MNK) CALL mat_err(21)
>            IF (G_ERR .GT. 0) RETURN
4586,4587c5143,5144
<            STKR(LL) = STKR(LS)
<            STKI(LL) = STKI(LS)
---
>            G_STKR(LL) = G_STKR(LS)
>            G_STKI(LL) = G_STKI(LS)
4591,4593c5148,5150
<       CALL mat_wcopy(MN,STKR(L3),STKI(L3),1,STKR(L),STKI(L),1)
<       MSTK(TOP) = M
<       NSTK(TOP) = N
---
>       CALL mat_wcopy(MN,G_STKR(L3),G_STKI(L3),1,G_STKR(L),G_STKI(L),1)
>       G_MSTK(G_TOP) = M
>       G_NSTK(G_TOP) = N
4595,4598c5152,5170
< !===================================================================================================================================
<    97 continue
<       FIN = 7
<       FUN = 6
---
>    elseif (G_RHS .GT. 2) then
>       CALL mat_err(21)                                                     ! Subscript out of range
>       IF (G_ERR .GT. 0) RETURN
>    else                                                                    ! SCALAR
>       L = 1
>       IF (G_TOP .GT. 0) L = G_LSTK(G_TOP) + G_MSTK(G_TOP)*G_NSTK(G_TOP)
>       IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)                             ! Too many names
>       IF (G_ERR .GT. 0) RETURN
> 
>       G_TOP = G_TOP+1
> 
>       !  LOAD VARIABLE TO TOP OF STACK
>       G_LSTK(G_TOP) = L
>       G_MSTK(G_TOP) = G_MSTK(K)
>       G_NSTK(G_TOP) = G_NSTK(K)
>       MN = G_MSTK(K)*G_NSTK(K)
>       G_ERR = L+MN - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) then
>          CALL mat_err(17)                                                  ! Too much memory required
4600,4602c5172,5177
< !===================================================================================================================================
<    98 continue
<       FIN = 0
---
>       endif
> 
>       !  IF RAND, MATFN6 GENERATES RANDOM NUMBER
>       IF (K .EQ. G_MAX_NUMBER_OF_NAMES) then
>          G_FIN = 7
>          G_FUN = 6
4604,4609c5179,5187
< !===================================================================================================================================
<    99 continue
<       FIN = -1
<       FUN = 0
< !===================================================================================================================================
< END SUBROUTINE mat_stackg
---
>       endif
>       CALL mat_wcopy(MN,G_STKR(current_location),G_STKI(current_location),1,G_STKR(L),G_STKI(L),1)
>    endif
> 
> 99 continue
>    G_FIN = -1
>    G_FUN = 0
> 
> END SUBROUTINE MAT_STACK_GET
4615c5193
< $@(#) M_matrix::ml_stackp(3fp): binary and ternary operations
---
> ! ident_36="@(#)M_matrix::ml_stackp(3fp): binary and ternary operations"
4646a5225
> integer           :: op_select
4648,4679c5227,5307
<    IF (DDT .EQ. 1) call journal('sc',',STACK2 ',OP)
<    L2 = LSTK(TOP)
<    M2 = MSTK(TOP)
<    N2 = NSTK(TOP)
<    TOP = TOP-1
<    L = LSTK(TOP)
<    M = MSTK(TOP)
<    N = NSTK(TOP)
<    FUN = 0
<    IF (OP .EQ. PLUS) GOTO 01
<    IF (OP .EQ. MINUS) GOTO 03
<    IF (OP .EQ. STAR) GOTO 05
<    IF (OP .EQ. DSTAR) GOTO 30
<    IF (OP .EQ. SLASH) GOTO 20
<    IF (OP .EQ. BSLASH) GOTO 25
<    IF (OP .EQ. COLON) GOTO 60
<    IF (OP .GT. 2*DOT) GOTO 80
<    IF (OP .GT. DOT) GOTO 70
< !
< !     ADDITION
< 01 IF (M .LT. 0) GOTO 50
<    IF (M2 .LT. 0) GOTO 52
<    IF (M .NE. M2) CALL mat_err(8)
<    IF (ERR .GT. 0) RETURN
<    IF (N .NE. N2) CALL mat_err(8)
<    IF (ERR .GT. 0) RETURN
<    CALL matX_waxpy(M*N,1.0D0,0.0D0,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
<    GOTO 99
< !
< !     SUBTRACTION
< 03 IF (M .LT. 0) GOTO 54
<    IF (M2 .LT. 0) GOTO 56
---
>    IF (G_DEBUG_LEVEL .EQ. 1) call journal('sc',',STACK2 ',OP)
>    L2 = G_LSTK(G_TOP)
>    M2 = G_MSTK(G_TOP)
>    N2 = G_NSTK(G_TOP)
>    G_TOP = G_TOP-1
>    L = G_LSTK(G_TOP)
>    M = G_MSTK(G_TOP)
>    N = G_NSTK(G_TOP)
>    G_FUN = 0
> 
>    if(op.eq.dstar)then
>       op_select=-op
>    else
>       op_select=op
>    endif
>    DO_OP: select case(op_select)
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (PLUS) ! ADDITION
>       if (m .lt. 0) then
>          if (m2 .ne. n2) call mat_err(8)
>          if (g_err .gt. 0) then
>             exit do_op
>          endif
>          m = m2
>          n = n2
>          g_mstk(g_top) = m
>          g_nstk(g_top) = n
>          sr = g_stkr(l)
>          si = g_stki(l)
>          call mat_wcopy(m*n,g_stkr(l+1),g_stki(l+1),1,g_stkr(l),g_stki(l),1)
>          call finish()
>          exit do_op
>       endif
>       if (m2 .lt. 0)then
>          if (m .ne. n) call mat_err(8)
>          if (g_err .gt. 0) then
>             exit do_op
>          endif
>          sr = g_stkr(l2)
>          si = g_stki(l2)
>          call finish()
>          exit do_op
>       endif
>       if (m .ne. m2) call mat_err(8)
>       if (g_err .gt. 0)then
>          exit do_op
>       endif
>       if (n .ne. n2) call mat_err(8)
>       if (g_err .gt. 0)then
>          exit do_op
>       endif
>       CALL matX_waxpy(M*N,1.0D0,0.0D0,G_STKR(L2),G_STKI(L2),1,G_STKR(L),G_STKI(L),1)
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (MINUS) ! SUBTRACTION
>       IF (M .LT. 0) then
>          IF (M2 .NE. N2) CALL mat_err(9)
>          IF (G_ERR .GT. 0) then
>             exit do_op
>          endif
>          M = M2
>          N = N2
>          G_MSTK(G_TOP) = M
>          G_NSTK(G_TOP) = N
>          SR = G_STKR(L)
>          SI = G_STKI(L)
>          CALL mat_wcopy(M*N,G_STKR(L+1),G_STKI(L+1),1,G_STKR(L),G_STKI(L),1)
>          CALL mat_wrscal(M*N,-1.0D0,G_STKR(L),G_STKI(L),1)
>          call finish()
>          exit DO_OP
>       endif
>       IF (M2 .LT. 0) then
>          !     ADD OR SUBTRACT SCALAR
>          IF (M .NE. N) CALL mat_err(9)
>          IF (G_ERR .GT. 0) then
>             exit do_op
>          endif
>          SR = -G_STKR(L2)
>          SI = -G_STKI(L2)
>          call finish()
>          exit DO_OP
>       endif
4681c5309,5311
<    IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
4683,4688c5313,5318
<    IF (ERR .GT. 0) RETURN
<    CALL matX_waxpy(M*N,-1.0D0,0.0D0,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
<    GOTO 99
< !
< !     MULTIPLICATION
< 05 continue
---
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
>       CALL matX_waxpy(M*N,-1.0D0,0.0D0,G_STKR(L2),G_STKI(L2),1,G_STKR(L),G_STKI(L),1)
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (STAR) ! MULTIPLICATION
4693c5323,5325
<    IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
4696,4699c5328,5333
<    ERR = LL+M*N+M2*N2 - LSTK(BOT)
<    IF (ERR .GT. 0) CALL mat_err(17)
<    IF (ERR .GT. 0) RETURN
<    CALL mat_wcopy(M*N+M2*N2,STKR(L),STKI(L),-1,STKR(LL),STKI(LL),-1)
---
>       G_ERR = LL+M*N+M2*N2 - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
>       CALL mat_wcopy(M*N+M2*N2,G_STKR(L),G_STKI(L),-1,G_STKR(LL),G_STKI(LL),-1)
4705,4706c5339,5340
<          STKR(K) = mat_wdotur(N,STKR(K1),STKI(K1),M,STKR(K2),STKI(K2),1)
<          STKI(K) = mat_wdotui(N,STKR(K1),STKI(K1),M,STKR(K2),STKI(K2),1)
---
>             G_STKR(K) = mat_wdotur(N,G_STKR(K1),G_STKI(K1),M,G_STKR(K2),G_STKI(K2),1)
>             G_STKI(K) = mat_wdotui(N,G_STKR(K1),G_STKI(K1),M,G_STKR(K2),G_STKI(K2),1)
4709,4715c5343,5349
<    NSTK(TOP) = N2
<    GOTO 99
< !
< !     MULTIPLICATION BY SCALAR
< 10 continue
<    SR = STKR(L2)
<    SI = STKI(L2)
---
>       G_NSTK(G_TOP) = N2
>       exit do_op
> !-----------------------------------------------------------------------------------------------------------------------------------
>    !     MULTIPLICATION BY SCALAR
>    10 continue
>       SR = G_STKR(L2)
>       SI = G_STKI(L2)
4718,4720c5352,5354
< 11 continue
<    SR = STKR(L)
<    SI = STKI(L)
---
>    11 continue
>       SR = G_STKR(L)
>       SI = G_STKI(L)
4722,4771c5356,5363
<    MSTK(TOP) = M2
<    NSTK(TOP) = N2
< 13 continue
<    MN = MSTK(TOP)*NSTK(TOP)
<    CALL mat_wscal(MN,SR,SI,STKR(L1),STKI(L1),1)
<    IF (L1.NE.L) CALL mat_wcopy(MN,STKR(L1),STKI(L1),1,STKR(L),STKI(L),1)
<    GOTO 99
< !
< !     RIGHT DIVISION
< 20 continue
<    IF (M2*N2 .EQ. 1) GOTO 21
<    IF (M2 .EQ. N2) FUN = 1
<    IF (M2 .NE. N2) FUN = 4
<    FIN = -1
<    RHS = 2
<    GOTO 99
< 21 continue
<    SR = STKR(L2)
<    SI = STKI(L2)
<    MN = M*N
<    DO I = 1, MN
<       LL = L+I-1
<       CALL mat_wdiv(STKR(LL),STKI(LL),SR,SI,STKR(LL),STKI(LL))
<       IF (ERR .GT. 0) RETURN
<    enddo
<    GOTO 99
< !
< !     LEFT DIVISION
< 25 continue
<    IF (M*N .EQ. 1) GOTO 26
<    IF (M .EQ. N) FUN = 1
<    IF (M .NE. N) FUN = 4
<    FIN = -2
<    RHS = 2
<    GOTO 99
< 26 continue
<    SR = STKR(L)
<    SI = STKI(L)
<    MSTK(TOP) = M2
<    NSTK(TOP) = N2
<    MN = M2*N2
<    DO I = 1, MN
<       LL = L+I-1
<       CALL mat_wdiv(STKR(LL+1),STKI(LL+1),SR,SI,STKR(LL),STKI(LL))
<       IF (ERR .GT. 0) RETURN
<    enddo
<    GOTO 99
< !
< !     POWER
< 30 continue
---
>       G_MSTK(G_TOP) = M2
>       G_NSTK(G_TOP) = N2
>    13 continue
>       MN = G_MSTK(G_TOP)*G_NSTK(G_TOP)
>       CALL mat_wscal(MN,SR,SI,G_STKR(L1),G_STKI(L1),1)
>       IF (L1.NE.L) CALL mat_wcopy(MN,G_STKR(L1),G_STKI(L1),1,G_STKR(L),G_STKI(L),1)
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (-DSTAR) ! POWER
4773c5365,5367
<    IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
4775,4779c5369,5380
<    IF (ERR .GT. 0) RETURN
<    NEXP = IDINT(STKR(L2))
<    IF (STKR(L2) .NE. DFLOAT(NEXP)) GOTO 39
<    IF (STKI(L2) .NE. 0.0D0) GOTO 39
<    IF (NEXP .LT. 2) GOTO 39
---
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
>       NEXP = int(G_STKR(L2))
> 
>       IF ( (G_STKR(L2) .NE. dble(NEXP)) .or. (G_STKI(L2) .NE. 0.0D0) .or. (NEXP .LT. 2) )then
>          ! NONINTEGER OR NONPOSITIVE POWER, USE EIGENVECTORS
>          G_FUN = 2
>          G_FIN = 0
>          exit DO_OP
>       endif
> 
4781,4784c5382,5387
<    ERR = L2+MN+N - LSTK(BOT)
<    IF (ERR .GT. 0) CALL mat_err(17)
<    IF (ERR .GT. 0) RETURN
<    CALL mat_wcopy(MN,STKR(L),STKI(L),1,STKR(L2),STKI(L2),1)
---
>       G_ERR = L2+MN+N - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
>       CALL mat_wcopy(MN,G_STKR(L),G_STKI(L),1,G_STKR(L2),G_STKI(L2),1)
4789c5392
<          CALL mat_wcopy(N,STKR(LS),STKI(LS),1,STKR(L3),STKI(L3),1)
---
>             CALL mat_wcopy(N,G_STKR(LS),G_STKI(LS),1,G_STKR(L3),G_STKI(L3),1)
4793,4794c5396,5397
<             STKR(LL)=mat_wdotur(N,STKR(LS),STKI(LS),N,STKR(L3),STKI(L3),1)
<             STKI(LL)=mat_wdotui(N,STKR(LS),STKI(LS),N,STKR(L3),STKI(L3),1)
---
>                G_STKR(LL)=mat_wdotur(N,G_STKR(LS),G_STKI(LS),N,G_STKR(L3),G_STKI(L3),1)
>                G_STKI(LL)=mat_wdotui(N,G_STKR(LS),G_STKI(LS),N,G_STKR(L3),G_STKI(L3),1)
4798,4846c5401,5416
<    GOTO 99
< !
< !     NONINTEGER OR NONPOSITIVE POWER, USE EIGENVECTORS
< 39 continue
<    FUN = 2
<    FIN = 0
<    GOTO 99
< !
< !     ADD OR SUBTRACT SCALAR
< 50 continue
<    IF (M2 .NE. N2) CALL mat_err(8)
<    IF (ERR .GT. 0) RETURN
<    M = M2
<    N = N2
<    MSTK(TOP) = M
<    NSTK(TOP) = N
<    SR = STKR(L)
<    SI = STKI(L)
<    CALL mat_wcopy(M*N,STKR(L+1),STKI(L+1),1,STKR(L),STKI(L),1)
<    GOTO 58
< 52 continue
<    IF (M .NE. N) CALL mat_err(8)
<    IF (ERR .GT. 0) RETURN
<    SR = STKR(L2)
<    SI = STKI(L2)
<    GOTO 58
< 54 continue
<    IF (M2 .NE. N2) CALL mat_err(9)
<    IF (ERR .GT. 0) RETURN
<    M = M2
<    N = N2
<    MSTK(TOP) = M
<    NSTK(TOP) = N
<    SR = STKR(L)
<    SI = STKI(L)
<    CALL mat_wcopy(M*N,STKR(L+1),STKI(L+1),1,STKR(L),STKI(L),1)
<    CALL mat_wrscal(M*N,-1.0D0,STKR(L),STKI(L),1)
<    GOTO 58
< 56 continue
<    IF (M .NE. N) CALL mat_err(9)
<    IF (ERR .GT. 0) RETURN
<    SR = -STKR(L2)
<    SI = -STKI(L2)
<    GOTO 58
< 58 continue
<    DO I = 1, N
<       LL = L + (I-1)*(N+1)
<       STKR(LL) = mat_flop(STKR(LL)+SR)
<       STKI(LL) = mat_flop(STKI(LL)+SI)
---
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (SLASH) ! RIGHT DIVISION
>       IF (M2*N2 .NE. 1) then
>          IF (M2 .EQ. N2) G_FUN = 1
>          IF (M2 .NE. N2) G_FUN = 4
>          G_FIN = -1
>          G_RHS = 2
>          exit DO_OP
>       endif
>       SR = G_STKR(L2)
>       SI = G_STKI(L2)
>       MN = M*N
>       DO I = 1, MN
>          LL = L+I-1
>          CALL mat_wdiv(G_STKR(LL),G_STKI(LL),SR,SI,G_STKR(LL),G_STKI(LL))
>          IF (G_ERR .GT. 0) exit
4848,4852c5418,5439
<    GOTO 99
< !
< !     COLON
< 60 continue
<    E2 = STKR(L2)
---
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (BSLASH) ! LEFT DIVISION
>       IF (M*N .NE. 1) then
>          IF (M .EQ. N) G_FUN = 1
>          IF (M .NE. N) G_FUN = 4
>          G_FIN = -2
>          G_RHS = 2
>          exit DO_OP
>       endif
>       SR = G_STKR(L)
>       SI = G_STKI(L)
>       G_MSTK(G_TOP) = M2
>       G_NSTK(G_TOP) = N2
>       MN = M2*N2
>       DO I = 1, MN
>          LL = L+I-1
>          CALL mat_wdiv(G_STKR(LL+1),G_STKI(LL+1),SR,SI,G_STKR(LL),G_STKI(LL))
>          IF (G_ERR .GT. 0) exit
>       enddo
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (COLON) ! COLON
>       E2 = G_STKR(L2)
4855,4858c5442,5445
<    IF (RHS .LT. 3) GOTO 61
<    ST = STKR(L)
<    TOP = TOP-1
<    L = LSTK(TOP)
---
>       IF (G_RHS .LT. 3) GOTO 61
>       ST = G_STKR(L)
>       G_TOP = G_TOP-1
>       L = G_LSTK(G_TOP)
4860,4869c5447,5466
< 61 continue
<    E1 = STKR(L)
< !     CHECK FOR CLAUSE
<    IF (RSTK(PT) .EQ. 3) GOTO 64
<    ERR = L + MAX0(3,IDINT((E2-E1)/ST)) - LSTK(BOT)
<    IF (ERR .GT. 0) CALL mat_err(17)
<    IF (ERR .GT. 0) RETURN
< 62 continue
<    IF (ST .GT. 0.0D0 .AND. STKR(L) .GT. E2) GOTO 63
<    IF (ST .LT. 0.0D0 .AND. STKR(L) .LT. E2) GOTO 63
---
>    61 continue
>       E1 = G_STKR(L)
>       ! CHECK FOR CLAUSE
>       IF (G_RSTK(G_PT) .EQ. 3) then
>    !     FOR CLAUSE
>          G_STKR(L) = E1
>          G_STKR(L+1) = ST
>          G_STKR(L+2) = E2
>          G_MSTK(G_TOP) = -3
>          G_NSTK(G_TOP) = -1
>          exit DO_OP
>       endif
>       G_ERR = L + MAX0(3,int((E2-E1)/ST)) - G_LSTK(G_BOT)
>       IF (G_ERR .GT. 0) CALL mat_err(17)
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
>    62 continue
>       IF (ST .GT. 0.0D0 .AND. G_STKR(L) .GT. E2) GOTO 63
>       IF (ST .LT. 0.0D0 .AND. G_STKR(L) .LT. E2) GOTO 63
4872,4873c5469,5470
<    STKR(L) = E1 + DFLOAT(N)*ST
<    STKI(L) = 0.0D0
---
>       G_STKR(L) = E1 + dble(N)*ST
>       G_STKI(L) = 0.0D0
4875,4891c5472,5477
< 63 continue
<    NSTK(TOP) = N
<    MSTK(TOP) = 1
<    IF (N .EQ. 0) MSTK(TOP) = 0
<    GOTO 99
< !
< !     FOR CLAUSE
< 64 continue
<    STKR(L) = E1
<    STKR(L+1) = ST
<    STKR(L+2) = E2
<    MSTK(TOP) = -3
<    NSTK(TOP) = -1
<    GOTO 99
< !
< !     ELEMENTWISE OPERATIONS
< 70 continue
---
>    63 continue
>       G_NSTK(G_TOP) = N
>       G_MSTK(G_TOP) = 1
>       IF (N .EQ. 0) G_MSTK(G_TOP) = 0
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (DOT+1:2*DOT) ! ELEMENTWISE OPERATIONS
4894c5480,5482
<    IF (ERR .GT. 0) RETURN
---
>       IF (G_ERR .GT. 0) then
>          exit do_op
>       endif
4899,4902c5487,5490
<       IF (OP .EQ. STAR)CALL mat_wmul(STKR(J),STKI(J),STKR(K),STKI(K),STKR(J),STKI(J))
<       IF (OP .EQ. SLASH)CALL mat_wdiv(STKR(J),STKI(J),STKR(K),STKI(K),STKR(J),STKI(J))
<       IF (OP .EQ. BSLASH)CALL mat_wdiv(STKR(K),STKI(K),STKR(J),STKI(J),STKR(J),STKI(J))
<       IF (ERR .GT. 0) RETURN
---
>          IF (OP .EQ. STAR)CALL mat_wmul(G_STKR(J),G_STKI(J),G_STKR(K),G_STKI(K),G_STKR(J),G_STKI(J))
>          IF (OP .EQ. SLASH)CALL mat_wdiv(G_STKR(J),G_STKI(J),G_STKR(K),G_STKI(K),G_STKR(J),G_STKI(J))
>          IF (OP .EQ. BSLASH)CALL mat_wdiv(G_STKR(K),G_STKI(K),G_STKR(J),G_STKI(J),G_STKR(J),G_STKI(J))
>          IF (G_ERR .GT. 0) exit
4904,4914c5492,5511
<    GOTO 99
< !
< !     KRONECKER
< 80 continue
<    FIN = OP - 2*DOT - STAR + 11
<    FUN = 6
<    TOP = TOP + 1
<    RHS = 2
<    GOTO 99
< !
< 99 continue
---
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case (2*DOT+1:) ! KRONECKER
>       G_FIN = OP - 2*DOT - STAR + 11
>       G_FUN = 6
>       G_TOP = G_TOP + 1
>       G_RHS = 2
> !-----------------------------------------------------------------------------------------------------------------------------------
>    case default
>       write(*,*)'<ERROR> unknown operator ',op
>       stop
>    end select DO_OP
> !-----------------------------------------------------------------------------------------------------------------------------------
> contains
> subroutine finish()
>    DO I = 1, N
>       LL = L + (I-1)*(N+1)
>       G_STKR(LL) = mat_flop(G_STKR(LL)+SR)
>       G_STKI(LL) = mat_flop(G_STKI(LL)+SI)
>    enddo
> end subroutine finish
4922a5520
> character(len=1024) :: shift_mline
4924a5523
> integer             :: istat
4930c5529
< integer,parameter   :: RETU(4)=[26,30,18,29]
---
> integer,parameter   :: RETU(G_MAX_NAME_LENGTH)=[26,30,18,29,G_PAD(:)]
4938c5537
<       L = LPT(1)
---
>       L = G_LPT(1)
4942c5541
<          BUF(J) = ALFA(BLANK+1)
---
>          G_BUF(J) = G_CHARSET(BLANK+1)
4947,4955c5546,5554
<       IF(ISTRINGQ.GT.0)THEN                  ! read from string instead of file
<          CALL REDO(stringq,'.')              ! This is a no-op except for storing the line into the input history
<          call mat_str2buf(stringq,buf,lrecl)     ! read input line from MAT88 call string
<          call journal('c',stringq)           ! write as a comment
<          IF(INITQ.EQ.2)THEN                  ! terminate after processing STRINGQ
<             ISTRINGQ=4
<             STRINGQ='quit'
<          ELSE                                ! go to normal MAT88 mode after processing STRINGQ
<             ISTRINGQ=0
---
>       IF(G_ISTRING.GT.0)THEN                    ! read from string instead of file
>          CALL REDO(G_STRING,'.')                ! This is a no-op except for storing the line into the input history
>          call mat_str2buf(G_STRING,G_buf,lrecl) ! read input line from MAT88 call string
>          call journal('c',G_STRING)             ! write as a comment
>          IF(G_INIT.EQ.2)THEN                    ! terminate after processing G_STRING
>             G_ISTRING=4
>             G_STRING='quit'
>          ELSE                                   ! go to normal MAT88 mode after processing G_STRING
>             G_ISTRING=0
4960,4962c5559,5563
<          READ(RIO,'(A)',END=50,ERR=15) mline ! read input line from file
<          CALL REDO(mline,'.')  ! pass line to REDO(3f). This is a no-op except for storing the line into the input history
<                                ! (unless the input line is the "r" command)
---
>          READ(G_RIO,'(A)',END=50,ERR=15) mline  ! read input line from file
>          shift_mline=adjustl(mline)
>          if(shift_mline(1:2).eq.'!!')then                             ! edit command line history
>             mline='. '//mline(3:)
>          endif
4964c5565
<          if(RIO.eq.5)then
---
>          if(G_RIO.eq.5)then
4969,4970c5570,5587
<          if(mline(1:1).eq.'#')goto 11        ! ignore lines with a # in column 1
<          call mat_str2buf(mline,buf,lrecl)       ! read input line from file
---
>          CALL REDO(mline,'.')         ! pass line to REDO(3f). This is a no-op except for storing the line into the input history
>                                       ! (unless the input line is the "r" command)
> 
>          ! look for other lines to immediately process and then ignore
>          shift_mline=adjustl(mline)
>          if(shift_mline(1:1).eq.'#')then
>             mline=''                                                      ! ignore lines with a # as first non-blank character
>          elseif(shift_mline(1:1).eq.'!')then
>             if(shift_mline.eq.'!')then
>                call get_environment_variable('SHELL',shift_mline)         ! get command to execute
>                call execute_command_line(shift_mline,cmdstat=istat)       ! call system shell
>             else
>                call execute_command_line(shift_mline(2:),cmdstat=istat)   ! call system shell
>             endif
>             mline=''
>          endif
> 
>          call mat_str2buf(mline,G_buf,lrecl)    ! convert input line to "Hollerith" buffer
4977c5594
<       else IF (BUF(N) .EQ. ALFA(BLANK+1))then
---
>       elseif (G_BUF(N) .EQ. G_CHARSET(BLANK+1))then
4981,4982c5598,5599
<       IF (MOD(LCT(4),2) .EQ. 1) then
<               call mat_buf2str(mline,buf,n) ! convert ADE buffer to character
---
>       IF (MOD(G_LINECOUNT(4),2) .EQ. 1) then
>               call mat_buf2str(mline,G_buf,n) ! convert ADE buffer to character
4987,4988c5604,5605
<          DO K = 1, alflq  ! make sure this letter is in set of MAT88 characters and get it's MAT88 number
<            IF (BUF(J).EQ.ALFA(K) .OR. BUF(J).EQ.ALFB(K)) GOTO 30
---
>          DO K = 1, G_CHARSET_SIZE  ! make sure this letter is in set of MAT88 characters and get its MAT88 number
>            IF (G_BUF(J).EQ.G_CHARSET(K) .OR. G_BUF(J).EQ.G_ALT_CHARSET(K)) GOTO 30
4991,4993c5608,5610
<          K = EOL+1
<          IF (K .GT. EOL) GOTO 10   ! UNKNOWN CHARACTER , K NOT CHANGED. get new line
<          IF (K .EQ. EOL) GOTO 45
---
>          K = G_EOL+1
>          IF (K .GT. G_EOL) GOTO 10   ! UNKNOWN CHARACTER , K NOT CHANGED. get new line
>          IF (K .EQ. G_EOL) GOTO 45
4999,5000c5616,5617
<          IF (K.EQ.SLASH .AND. BUF(J+1).EQ.BUF(J)) GOTO 45  ! if // rest is comment
<          IF (K.EQ.DOT .AND. BUF(J+1).EQ.BUF(J)) GOTO 11    ! if .. line continuation
---
>          IF (K.EQ.SLASH .AND. G_BUF(J+1).EQ.G_BUF(J)) GOTO 45  ! if // rest is comment
>          IF (K.EQ.DOT .AND. G_BUF(J+1).EQ.G_BUF(J)) GOTO 11    ! if .. line continuation
5002c5619
<          LIN(L) = K
---
>          G_LIN(L) = K
5008,5014c5625,5631
<       LIN(L) = EOL
<       LPT(6) = L
<       LPT(4) = LPT(1)
<       LPT(3) = 0
<       LPT(2) = 0
<       LCT(1) = 0
<       CALL mat_getch() ! load first character onto CHRA
---
>       G_LIN(L) = G_EOL
>       G_LPT(6) = L
>       G_LPT(4) = G_LPT(1)
>       G_LPT(3) = 0
>       G_LPT(2) = 0
>       G_LINECOUNT(1) = 0
>       CALL mat_getch() ! load first character onto G_CHRA
5018c5635
<       CALL mat_putid(LIN(L),RETU) ! store RETU onto LIN(L) to simulate RETURN command
---
>       CALL mat_putid(G_LIN(L),RETU) ! store RETU onto G_LIN(L) to simulate RETURN command
5023c5640
<       N = LPT(6) - LPT(1)
---
>       N = G_LPT(6) - G_LPT(1)
5026,5028c5643,5644
<          K = LIN(J)
<          BUF(I) = ALFA(K+1)
<          IF (CASE.EQ.1 .AND. K.LT.36) BUF(I) = ALFB(K+1)
---
>          K = G_LIN(J)
>          G_BUF(I) = G_CHARSET(K+1)
5030c5646
<       !!CALL ML_EDIT(BUF,N)
---
>       !!CALL ML_EDIT(G_BUF,N)
5050,5056c5666,5672
< integer,parameter  :: FOR(4)=[15,24,27,36]
< integer,parameter  :: WHILE(4)=[32,17,18,21]
< integer,parameter  :: IFF(4)=[18,15,36,36]
< integer,parameter  :: ELSE(4)=[14,21,28,14]
< integer,parameter  :: ENND(4)=[14,23,13,36]
< integer,parameter  :: DO(4)=[13,24,36,36]
< integer,parameter  :: THENN(4)=[29,17,14,23]
---
> integer,parameter  :: FOR(G_MAX_NAME_LENGTH)=[15,24,27,36,G_PAD(:)]
> integer,parameter  :: WHILE(G_MAX_NAME_LENGTH)=[32,17,18,21,G_PAD(:)]
> integer,parameter  :: IFF(G_MAX_NAME_LENGTH)=[18,15,36,36,G_PAD(:)]
> integer,parameter  :: ELSE(G_MAX_NAME_LENGTH)=[14,21,28,14,G_PAD(:)]
> integer,parameter  :: ENND(G_MAX_NAME_LENGTH)=[14,23,13,36,G_PAD(:)]
> integer,parameter  :: DO(G_MAX_NAME_LENGTH)=[13,24,36,36,G_PAD(:)]
> integer,parameter  :: THENN(G_MAX_NAME_LENGTH)=[29,17,14,23,G_PAD(:)]
5066,5069c5682,5685
<    R = -FIN-10
<    FIN = 0
<    IF (DDT .EQ. 1)then
<       WRITE(mline,'('' CLAUSE '',3I4)') PT,RSTK(PT),R
---
>    R = -G_FIN-10
>    G_FIN = 0
>    IF (G_DEBUG_LEVEL .EQ. 1)then
>       WRITE(mline,'('' CLAUSE '',3I4)') G_PT,G_RSTK(G_PT),R
5075c5691
<    R = RSTK(PT)
---
>    R = G_RSTK(G_PT)
5084,5087c5700,5703
<    IF (SYM .NE. NAME) CALL mat_err(34) ! improper for clause
<    IF (ERR .GT. 0) RETURN
<    PT = PT+2
<    CALL mat_putid(IDS(1,PT),SYN)
---
>    IF (G_SYM .NE. NAME) CALL mat_err(34) ! improper for clause
>    IF (G_ERR .GT. 0) RETURN
>    G_PT = G_PT+2
>    CALL mat_putid(G_IDS(1,G_PT),G_SYN)
5089,5090c5705,5706
<    IF (SYM .NE. EQUAL) CALL mat_err(34) ! improper for clause
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_SYM .NE. EQUAL) CALL mat_err(34) ! improper for clause
>    IF (G_ERR .GT. 0) RETURN
5092c5708
<    RSTK(PT) = 3
---
>    G_RSTK(G_PT) = 3
5096,5101c5712,5717
<    PSTK(PT-1) = 0
<    PSTK(PT) = LPT(4) - 1
<    IF (mat_eqid(SYN,DO)) SYM = SEMI
<    IF (SYM .EQ. COMMA) SYM = SEMI
<    IF (SYM .NE. SEMI) CALL mat_err(34) ! improper for clause
<    IF (ERR .GT. 0) RETURN
---
>    G_PSTK(G_PT-1) = 0
>    G_PSTK(G_PT) = G_LPT(4) - 1
>    IF (mat_eqid(G_SYN,DO)) G_SYM = SEMI
>    IF (G_SYM .EQ. COMMA) G_SYM = SEMI
>    IF (G_SYM .NE. SEMI) CALL mat_err(34) ! improper for clause
>    IF (G_ERR .GT. 0) RETURN
5103,5106c5719,5722
<    J = PSTK(PT-1)
<    LPT(4) = PSTK(PT)
<    SYM = SEMI
<    CHRA = BLANK
---
>    J = G_PSTK(G_PT-1)
>    G_LPT(4) = G_PSTK(G_PT)
>    G_SYM = SEMI
>    G_CHRA = BLANK
5108,5110c5724,5726
<    L = LSTK(TOP)
<    M = MSTK(TOP)
<    N = NSTK(TOP)
---
>    L = G_LSTK(G_TOP)
>    M = G_MSTK(G_TOP)
>    N = G_NSTK(G_TOP)
5116,5119c5732,5735
<    STKR(LJ) = STKR(L) + DFLOAT(J-1)*STKR(L+1)
<    STKI(LJ) = 0.0d0
<    IF (STKR(L+1).GT.0.0D0 .AND. STKR(LJ).GT.STKR(L+2)) GOTO 20
<    IF (STKR(L+1).LT.0.0D0 .AND. STKR(LJ).LT.STKR(L+2)) GOTO 20
---
>    G_STKR(LJ) = G_STKR(L) + dble(J-1)*G_STKR(L+1)
>    G_STKI(LJ) = 0.0d0
>    IF (G_STKR(L+1).GT.0.0D0 .AND. G_STKR(LJ).GT.G_STKR(L+2)) GOTO 20
>    IF (G_STKR(L+1).LT.0.0D0 .AND. G_STKR(LJ).LT.G_STKR(L+2)) GOTO 20
5124,5139c5740,5755
<    IF (TOP+1 .GE. BOT) CALL mat_err(18) ! too many names
<    IF (ERR .GT. 0) RETURN
<    TOP = TOP+1
<    LSTK(TOP) = L2
<    MSTK(TOP) = M
<    NSTK(TOP) = 1
<    ERR = L2+M - LSTK(BOT)
<    IF (ERR .GT. 0) CALL mat_err(17)   ! too much memory required
<    IF (ERR .GT. 0) RETURN
<    CALL mat_wcopy(M,STKR(LJ),STKI(LJ),1,STKR(L2),STKI(L2),1)
<    RHS = 0
<    CALL mat_stackp(IDS(1,PT))
<    IF (ERR .GT. 0) RETURN
<    PSTK(PT-1) = J
<    PSTK(PT) = LPT(4)
<    RSTK(PT) = 13
---
>    IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18) ! too many names
>    IF (G_ERR .GT. 0) RETURN
>    G_TOP = G_TOP+1
>    G_LSTK(G_TOP) = L2
>    G_MSTK(G_TOP) = M
>    G_NSTK(G_TOP) = 1
>    G_ERR = L2+M - G_LSTK(G_BOT)
>    IF (G_ERR .GT. 0) CALL mat_err(17)   ! too much memory required
>    IF (G_ERR .GT. 0) RETURN
>    CALL mat_wcopy(M,G_STKR(LJ),G_STKI(LJ),1,G_STKR(L2),G_STKI(L2),1)
>    G_RHS = 0
>    CALL MAT_STACK_PUT(G_IDS(1,G_PT))
>    IF (G_ERR .GT. 0) RETURN
>    G_PSTK(G_PT-1) = J
>    G_PSTK(G_PT) = G_LPT(4)
>    G_RSTK(G_PT) = 13
5145,5150c5761,5766
<    MSTK(TOP) = 0
<    NSTK(TOP) = 0
<    RHS = 0
<    CALL mat_stackp(IDS(1,PT))
<    IF (ERR .GT. 0) RETURN
<    PT = PT-2
---
>    G_MSTK(G_TOP) = 0
>    G_NSTK(G_TOP) = 0
>    G_RHS = 0
>    CALL MAT_STACK_PUT(G_IDS(1,G_PT))
>    IF (G_ERR .GT. 0) RETURN
>    G_PT = G_PT-2
5157,5159c5773,5775
<    PT = PT+1
<    CALL mat_putid(IDS(1,PT),SYN)
<    PSTK(PT) = LPT(4)-1
---
>    G_PT = G_PT+1
>    CALL mat_putid(G_IDS(1,G_PT),G_SYN)
>    G_PSTK(G_PT) = G_LPT(4)-1
5161,5162c5777,5778
<    LPT(4) = PSTK(PT)
<    CHRA = BLANK
---
>    G_LPT(4) = G_PSTK(G_PT)
>    G_CHRA = BLANK
5164c5780
<    RSTK(PT) = 4
---
>    G_RSTK(G_PT) = 4
5168,5170c5784,5786
<    IF (SYM.NE.EQUAL .AND. SYM.NE.LESS .AND. SYM.NE.GREAT)CALL mat_err(35)    ! improper WHILE or IF clause
<    IF (ERR .GT. 0) RETURN
<    OP = SYM
---
>    IF (G_SYM.NE.EQUAL .AND. G_SYM.NE.LESS .AND. G_SYM.NE.GREAT)CALL mat_err(35)    ! improper WHILE or IF clause
>    IF (G_ERR .GT. 0) RETURN
>    OP = G_SYM
5172c5788
<    IF (SYM.EQ.EQUAL .OR. SYM.EQ.GREAT) OP = OP + SYM
---
>    IF (G_SYM.EQ.EQUAL .OR. G_SYM.EQ.GREAT) OP = OP + G_SYM
5174,5175c5790,5791
<    PSTK(PT) = 256*PSTK(PT) + OP
<    RSTK(PT) = 5
---
>    G_PSTK(G_PT) = 256*G_PSTK(G_PT) + OP
>    G_RSTK(G_PT) = 5
5179,5189c5795,5805
<    OP = MOD(PSTK(PT),256)
<    PSTK(PT) = PSTK(PT)/256
<    L = LSTK(TOP-1)
<    E1 = STKR(L)
<    L = LSTK(TOP)
<    E2 = STKR(L)
<    TOP = TOP - 2
<    IF (mat_eqid(SYN,DO) .OR. mat_eqid(SYN,THENN)) SYM = SEMI
<    IF (SYM .EQ. COMMA) SYM = SEMI
<    IF (SYM .NE. SEMI) CALL mat_err(35) ! improper WHILE or IF clause
<    IF (ERR .GT. 0) RETURN
---
>    OP = MOD(G_PSTK(G_PT),256)
>    G_PSTK(G_PT) = G_PSTK(G_PT)/256
>    L = G_LSTK(G_TOP-1)
>    E1 = G_STKR(L)
>    L = G_LSTK(G_TOP)
>    E2 = G_STKR(L)
>    G_TOP = G_TOP - 2
>    IF (mat_eqid(G_SYN,DO) .OR. mat_eqid(G_SYN,THENN)) G_SYM = SEMI
>    IF (G_SYM .EQ. COMMA) G_SYM = SEMI
>    IF (G_SYM .NE. SEMI) CALL mat_err(35) ! improper WHILE or IF clause
>    IF (G_ERR .GT. 0) RETURN
5196c5812
<    PT = PT-1
---
>    G_PT = G_PT-1
5199c5815
<    RSTK(PT) = 14
---
>    G_RSTK(G_PT) = 14
5203,5205c5819,5821
<    IF (mat_eqid(IDS(1,PT),WHILE)) GOTO 35
<    PT = PT-1
<    IF (mat_eqid(SYN,ELSE)) GOTO 80
---
>    IF (mat_eqid(G_IDS(1,G_PT),WHILE)) GOTO 35
>    G_PT = G_PT-1
>    IF (mat_eqid(G_SYN,ELSE)) GOTO 80
5214,5219c5830,5835
<    IF (SYM .EQ. EOL) RETURN
<    IF (SYM .NE. NAME) GOTO 83
<    IF (mat_eqid(SYN,ENND) .AND. KOUNT.EQ.0) RETURN
<    IF (mat_eqid(SYN,ELSE) .AND. KOUNT.EQ.0) RETURN
<    IF (mat_eqid(SYN,ENND) .OR. mat_eqid(SYN,ELSE))KOUNT = KOUNT-1
<    IF (mat_eqid(SYN,FOR) .OR. mat_eqid(SYN,WHILE).OR.mat_eqid(SYN,IFF)) KOUNT = KOUNT+1
---
>    IF (G_SYM .EQ. G_EOL) RETURN
>    IF (G_SYM .NE. NAME) GOTO 83
>    IF (mat_eqid(G_SYN,ENND) .AND. KOUNT.EQ.0) RETURN
>    IF (mat_eqid(G_SYN,ELSE) .AND. KOUNT.EQ.0) RETURN
>    IF (mat_eqid(G_SYN,ENND) .OR. mat_eqid(G_SYN,ELSE))KOUNT = KOUNT-1
>    IF (mat_eqid(G_SYN,FOR) .OR. mat_eqid(G_SYN,WHILE).OR.mat_eqid(G_SYN,IFF)) KOUNT = KOUNT+1
5227,5228c5843,5844
<    IF (DDT .EQ. 1)then
<       WRITE(mline,'('' EXIT '',10I4)') (RSTK(I),I=1,PT)
---
>    IF (G_DEBUG_LEVEL .EQ. 1)then
>       WRITE(mline,'('' EXIT '',10I4)') (G_RSTK(I),I=1,G_PT)
5231,5236c5847,5852
<    IF (RSTK(PT) .EQ. 14) PT = PT-1
<    IF (PT .LE. PTZ) RETURN
<    IF (RSTK(PT) .EQ. 14) PT = PT-1
<    IF (PT-1 .LE. PTZ) RETURN
<    IF (RSTK(PT) .EQ. 13) TOP = TOP-1
<    IF (RSTK(PT) .EQ. 13) PT = PT-2
---
>    IF (G_RSTK(G_PT) .EQ. 14) G_PT = G_PT-1
>    IF (G_PT .LE. G_PTZ) RETURN
>    IF (G_RSTK(G_PT) .EQ. 14) G_PT = G_PT-1
>    IF (G_PT-1 .LE. G_PTZ) RETURN
>    IF (G_RSTK(G_PT) .EQ. 13) G_TOP = G_TOP-1
>    IF (G_RSTK(G_PT) .EQ. 13) G_PT = G_PT-2
5242c5858
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5249c5865
< $@(#) M_matrix::mat_rat(3fp): A/B = continued fraction approximation to X using  len  terms each less than MAXD
---
> ! ident_37="@(#)M_matrix::mat_rat(3fp): A/B = continued fraction approximation to X using  len  terms each less than MAXD"
5267c5883
<       if (dabs(z)*dfloat(maxd) .le. 1.0d0) exit
---
>       if (dabs(z)*dble(maxd) .le. 1.0d0) exit
5282,5283c5898,5899
<    if (ddt .eq. 27)then
<       write(wte,50) x,t,s,(d(i),i=1,k) ! debug 27
---
>    if (G_DEBUG_LEVEL .eq. 27)then
>       write(G_WTE,50) x,t,s,(d(i),i=1,k) ! debug 27
5301c5917
< integer,parameter :: EYE(4)=[14,34,14,36]
---
> integer,parameter :: EYE(G_MAX_NAME_LENGTH)=[14,34,14,36,G_PAD(:)]
5306,5307c5922,5923
<    if (ddt .eq. 1) then
<       write(mline,'('' EXPR '',2I4)') pt,rstk(pt)
---
>    if (G_DEBUG_LEVEL .eq. 1) then
>       write(mline,'('' EXPR '',2I4)') G_pt,G_RSTK(G_pt)
5310c5926
<    r = rstk(pt)
---
>    r = G_RSTK(G_pt)
5315,5316c5931,5932
<    if (sym .eq. colon) call mat_putid(syn,eye)
<    if (sym .eq. colon) sym = name
---
>    if (G_sym .eq. colon) call mat_putid(G_syn,eye)
>    if (G_sym .eq. colon) G_sym = name
5320,5326c5936,5942
<    if (sym .eq. minus) sign = minus
<    if (sym.eq.plus .or. sym.eq.minus) call mat_getsym()
<    pt = pt+1
<    if (pt .gt. psize-1) call mat_err(26) ! too complicated (stack overflow)
<    if (err .gt. 0) return
<    pstk(pt) = sign + 256*kount
<    rstk(pt) = 6
---
>    if (G_sym .eq. minus) sign = minus
>    if (G_sym.eq.plus .or. G_sym.eq.minus) call mat_getsym()
>    G_pt = G_pt+1
>    if (G_pt .gt. G_PSIZE-1) call mat_err(26) ! too complicated (stack overflow)
>    if (G_err .gt. 0) return
>    G_PSTK(G_pt) = sign + 256*kount
>    G_RSTK(G_pt) = 6
5330,5332c5946,5948
<    sign = mod(pstk(pt),256)
<    kount = pstk(pt)/256
<    pt = pt-1
---
>    sign = mod(G_PSTK(G_pt),256)
>    kount = G_PSTK(G_pt)/256
>    G_pt = G_pt-1
5334c5950
<    if (err .gt. 0) return
---
>    if (G_err .gt. 0) return
5336c5952
<    if (sym.eq.plus .or. sym.eq.minus) goto 20
---
>    if (G_sym.eq.plus .or. G_sym.eq.minus) goto 20
5339c5955
<    if (rstk(pt) .ne. 10) goto 21
---
>    if (G_RSTK(G_pt) .ne. 10) goto 21
5341,5342c5957,5958
<    ls = lpt(3) - 2
<    if (lin(ls) .eq. blank) goto 50
---
>    ls = G_LPT(3) - 2
>    if (G_LIN(ls) .eq. blank) goto 50
5344c5960
<    op = sym
---
>    op = G_sym
5346,5348c5962,5964
<    pt = pt+1
<    pstk(pt) = op + 256*kount
<    rstk(pt) = 7
---
>    G_pt = G_pt+1
>    G_PSTK(G_pt) = op + 256*kount
>    G_RSTK(G_pt) = 7
5352,5354c5968,5970
<    op = mod(pstk(pt),256)
<    kount = pstk(pt)/256
<    pt = pt-1
---
>    op = mod(G_PSTK(G_pt),256)
>    kount = G_PSTK(G_pt)/256
>    G_pt = G_pt-1
5356c5972
<    if (err .gt. 0) return
---
>    if (G_err .gt. 0) return
5359c5975
<    if (sym .ne. colon) goto 60
---
>    if (G_sym .ne. colon) goto 60
5365,5366c5981,5982
<    if (err .gt. 0) return
<    rhs = kount
---
>    if (G_err .gt. 0) return
>    G_rhs = kount
5368c5984
<    if (err .gt. 0) return
---
>    if (G_err .gt. 0) return
5372c5988
<    if (err .gt. 0) return
---
>    if (G_err .gt. 0) return
5380c5996
< INTEGER           :: ID(4)
---
> INTEGER           :: ID(G_MAX_NAME_LENGTH)
5402,5403c6018,6019
<    IF (DDT .EQ. 1) then
<       WRITE(mline,'('' FACTOR '',3I4)') PT,RSTK(PT),SYM
---
>    IF (G_DEBUG_LEVEL .EQ. 1) then
>       WRITE(mline,'('' FACTOR '',3I4)') G_PT,G_RSTK(G_PT),G_SYM
5406c6022
<    R = RSTK(PT)
---
>    R = G_RSTK(G_PT)
5409,5410c6025,6026
<    IF (SYM.EQ.NUM .OR. SYM.EQ.QUOTE .OR.  SYM.EQ.LESS) GOTO 10
<    IF (SYM .EQ. GREAT) GOTO 30
---
>    IF (G_SYM.EQ.NUM .OR. G_SYM.EQ.QUOTE .OR.  G_SYM.EQ.LESS) GOTO 10
>    IF (G_SYM .EQ. GREAT) GOTO 30
5412c6028
<    IF (SYM .EQ. NAME) GOTO 40
---
>    IF (G_SYM .EQ. NAME) GOTO 40
5414c6030
<    IF (SYM .EQ. LPAREN) GOTO 42
---
>    IF (G_SYM .EQ. LPAREN) GOTO 42
5416c6032
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5421,5433c6037,6049
<    IF (TOP .GT. 0) L = LSTK(TOP) + MSTK(TOP)*NSTK(TOP)
<    IF (TOP+1 .GE. BOT) CALL mat_err(18)
<    IF (ERR .GT. 0) RETURN
<    TOP = TOP+1
<    LSTK(TOP) = L
<    IF (SYM .EQ. QUOTE) GOTO 15
<    IF (SYM .EQ. LESS) GOTO 20
< !
< !     SINGLE NUMBER, GETSYM STORED IT IN STKI
<    MSTK(TOP) = 1
<    NSTK(TOP) = 1
<    STKR(L) = STKI(VSIZE)
<    STKI(L) = 0.0D0
---
>    IF (G_TOP .GT. 0) L = G_LSTK(G_TOP) + G_MSTK(G_TOP)*G_NSTK(G_TOP)
>    IF (G_TOP+1 .GE. G_BOT) CALL mat_err(18)
>    IF (G_ERR .GT. 0) RETURN
>    G_TOP = G_TOP+1
>    G_LSTK(G_TOP) = L
>    IF (G_SYM .EQ. QUOTE) GOTO 15
>    IF (G_SYM .EQ. LESS) GOTO 20
> !
> !     SINGLE NUMBER, GETSYM STORED IT IN G_STKI
>    G_MSTK(G_TOP) = 1
>    G_NSTK(G_TOP) = 1
>    G_STKR(L) = G_STKI(G_VSIZE)
>    G_STKI(L) = 0.0D0
5440c6056
<    LPT(4) = LPT(3)
---
>    G_LPT(4) = G_LPT(3)
5443c6059
<    IF (CHRA .EQ. QUOTE) GOTO 18
---
>    IF (G_CHRA .EQ. QUOTE) GOTO 18
5446,5449c6062,6065
<    IF (CHRA .EQ. EOL) CALL mat_err(31)
<    IF (ERR .GT. 0) RETURN
<    STKR(LN) = DFLOAT(CHRA)
<    STKI(LN) = 0.0D0
---
>    IF (G_CHRA .EQ. G_EOL) CALL mat_err(31)
>    IF (G_ERR .GT. 0) RETURN
>    G_STKR(LN) = dble(G_CHRA)
>    G_STKI(LN) = 0.0D0
5455c6071
<    IF (CHRA .EQ. QUOTE) GOTO 17
---
>    IF (G_CHRA .EQ. QUOTE) GOTO 17
5457,5459c6073,6075
<    IF (ERR .GT. 0) RETURN
<    MSTK(TOP) = 1
<    NSTK(TOP) = N
---
>    IF (G_ERR .GT. 0) RETURN
>    G_MSTK(G_TOP) = 1
>    G_NSTK(G_TOP) = N
5465,5466c6081,6082
<    MSTK(TOP) = 0
<    NSTK(TOP) = 0
---
>    G_MSTK(G_TOP) = 0
>    G_NSTK(G_TOP) = 0
5468,5471c6084,6087
<    TOP = TOP + 1
<    LSTK(TOP) = LSTK(TOP-1) + MSTK(TOP-1)*NSTK(TOP-1)
<    MSTK(TOP) = 0
<    NSTK(TOP) = 0
---
>    G_TOP = G_TOP + 1
>    G_LSTK(G_TOP) = G_LSTK(G_TOP-1) + G_MSTK(G_TOP-1)*G_NSTK(G_TOP-1)
>    G_MSTK(G_TOP) = 0
>    G_NSTK(G_TOP) = 0
5474,5477c6090,6093
<    IF (SYM.EQ.SEMI .OR. SYM.EQ.GREAT .OR. SYM.EQ.EOL) GOTO 27
<    IF (SYM .EQ. COMMA) CALL mat_getsym()
<    PT = PT+1
<    RSTK(PT) = 10
---
>    IF (G_SYM.EQ.SEMI .OR. G_SYM.EQ.GREAT .OR. G_SYM.EQ.G_EOL) GOTO 27
>    IF (G_SYM .EQ. COMMA) CALL mat_getsym()
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 10
5481,5486c6097,6102
<    PT = PT-1
<    TOP = TOP - 1
<    IF (MSTK(TOP) .EQ. 0) MSTK(TOP) = MSTK(TOP+1)
<    IF (MSTK(TOP) .NE. MSTK(TOP+1)) CALL mat_err(5)
<    IF (ERR .GT. 0) RETURN
<    NSTK(TOP) = NSTK(TOP) + NSTK(TOP+1)
---
>    G_PT = G_PT-1
>    G_TOP = G_TOP - 1
>    IF (G_MSTK(G_TOP) .EQ. 0) G_MSTK(G_TOP) = G_MSTK(G_TOP+1)
>    IF (G_MSTK(G_TOP) .NE. G_MSTK(G_TOP+1)) CALL mat_err(5)
>    IF (G_ERR .GT. 0) RETURN
>    G_NSTK(G_TOP) = G_NSTK(G_TOP) + G_NSTK(G_TOP+1)
5489c6105
<    IF (SYM.EQ.SEMI .AND. CHRA.EQ.EOL) CALL mat_getsym()
---
>    IF (G_SYM.EQ.SEMI .AND. G_CHRA.EQ.G_EOL) CALL mat_getsym()
5491,5498c6107,6114
<    IF (ERR .GT. 0) RETURN
<    TOP = TOP - 1
<    IF (MSTK(TOP) .EQ. 0) MSTK(TOP) = MSTK(TOP+1)
<    IF (MSTK(TOP).NE.MSTK(TOP+1).AND.MSTK(TOP+1).GT.0)CALL mat_err(6)
<    IF (ERR .GT. 0) RETURN
<    NSTK(TOP) = NSTK(TOP) + NSTK(TOP+1)
<    IF (SYM .EQ. EOL) CALL mat_getlin()
<    IF (SYM .NE. GREAT) GOTO 21
---
>    IF (G_ERR .GT. 0) RETURN
>    G_TOP = G_TOP - 1
>    IF (G_MSTK(G_TOP) .EQ. 0) G_MSTK(G_TOP) = G_MSTK(G_TOP+1)
>    IF (G_MSTK(G_TOP).NE.G_MSTK(G_TOP+1).AND.G_MSTK(G_TOP+1).GT.0)CALL mat_err(6)
>    IF (G_ERR .GT. 0) RETURN
>    G_NSTK(G_TOP) = G_NSTK(G_TOP) + G_NSTK(G_TOP+1)
>    IF (G_SYM .EQ. G_EOL) CALL mat_getlin()
>    IF (G_SYM .NE. GREAT) GOTO 21
5500c6116
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5507,5510c6123,6126
<    IF (SYM.EQ.LESS .AND. CHRA.EQ.EOL) CALL mat_err(28)
<    IF (ERR .GT. 0) RETURN
<    PT = PT+1
<    RSTK(PT) = 18
---
>    IF (G_SYM.EQ.LESS .AND. G_CHRA.EQ.G_EOL) CALL mat_err(28)
>    IF (G_ERR .GT. 0) RETURN
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 18
5514,5522c6130,6138
<    PT = PT-1
<    IF (SYM.NE.LESS .AND. SYM.NE.EOL) CALL mat_err(37)
<    IF (ERR .GT. 0) RETURN
<    IF (SYM .EQ. LESS) CALL mat_getsym()
<    K = LPT(6)
<    LIN(K+1) = LPT(1)
<    LIN(K+2) = LPT(2)
<    LIN(K+3) = LPT(6)
<    LPT(1) = K + 4
---
>    G_PT = G_PT-1
>    IF (G_SYM.NE.LESS .AND. G_SYM.NE.G_EOL) CALL mat_err(37)
>    IF (G_ERR .GT. 0) RETURN
>    IF (G_SYM .EQ. LESS) CALL mat_getsym()
>    K = G_LPT(6)
>    G_LIN(K+1) = G_LPT(1)
>    G_LIN(K+2) = G_LPT(2)
>    G_LIN(K+3) = G_LPT(6)
>    G_LPT(1) = K + 4
5524,5526c6140,6142
<    K = LPT(1)
<    L = LSTK(TOP)
<    N = MSTK(TOP)*NSTK(TOP)
---
>    K = G_LPT(1)
>    L = G_LSTK(G_TOP)
>    N = G_MSTK(G_TOP)*G_NSTK(G_TOP)
5529,5531c6145,6147
<       LIN(K) = IDINT(STKR(LS))
<       IF (LIN(K).LT.0 .OR. LIN(K).GE.IALF) CALL mat_err(37)
<       IF (ERR .GT. 0) RETURN
---
>       G_LIN(K) = int(G_STKR(LS))
>       IF (G_LIN(K).LT.0 .OR. G_LIN(K).GE.G_CHARSET_SIZE) CALL mat_err(37)
>       IF (G_ERR .GT. 0) RETURN
5535,5542c6151,6158
<    TOP = TOP-1
<    LIN(K) = EOL
<    LPT(6) = K
<    LPT(4) = LPT(1)
<    LPT(3) = 0
<    LPT(2) = 0
<    LCT(1) = 0
<    CHRA = BLANK
---
>    G_TOP = G_TOP-1
>    G_LIN(K) = G_EOL
>    G_LPT(6) = K
>    G_LPT(4) = G_LPT(1)
>    G_LPT(3) = 0
>    G_LPT(2) = 0
>    G_LINECOUNT(1) = 0
>    G_CHRA = BLANK
5544,5545c6160,6161
<    PT = PT+1
<    RSTK(PT) = 19
---
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 19
5549,5554c6165,6170
<    PT = PT-1
<    K = LPT(1) - 4
<    LPT(1) = LIN(K+1)
<    LPT(4) = LIN(K+2)
<    LPT(6) = LIN(K+3)
<    CHRA = BLANK
---
>    G_PT = G_PT-1
>    K = G_LPT(1) - 4
>    G_LPT(1) = G_LIN(K+1)
>    G_LPT(4) = G_LIN(K+2)
>    G_LPT(6) = G_LIN(K+3)
>    G_CHRA = BLANK
5560c6176
<    CALL mat_putid(ID,SYN)
---
>    CALL mat_putid(ID,G_SYN)
5562,5563c6178,6179
<    IF (SYM .EQ. LPAREN) GOTO 42
<    RHS = 0
---
>    IF (G_SYM .EQ. LPAREN) GOTO 42
>    G_RHS = 0
5565,5572c6181,6188
<    IF (FIN .NE. 0) CALL mat_err(25)
<    IF (ERR .GT. 0) RETURN
<    CALL mat_stackg(ID)
<    IF (ERR .GT. 0) RETURN
<    IF (FIN .EQ. 7) GOTO 50
<    IF (FIN .EQ. 0) CALL mat_putid(IDS(1,PT+1),ID)
<    IF (FIN .EQ. 0) CALL mat_err(4)
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_FIN .NE. 0) CALL mat_err(25)
>    IF (G_ERR .GT. 0) RETURN
>    CALL MAT_STACK_GET(ID)
>    IF (G_ERR .GT. 0) RETURN
>    IF (G_FIN .EQ. 7) GOTO 50
>    IF (G_FIN .EQ. 0) CALL mat_putid(G_IDS(1,G_PT+1),ID)
>    IF (G_FIN .EQ. 0) CALL mat_err(4)
>    IF (G_ERR .GT. 0) RETURN
5578,5581c6194,6197
<    PT = PT+1
<    PSTK(PT) = EXCNT
<    CALL mat_putid(IDS(1,PT),ID)
<    RSTK(PT) = 11
---
>    G_PT = G_PT+1
>    G_PSTK(G_PT) = EXCNT
>    CALL mat_putid(G_IDS(1,G_PT),ID)
>    G_RSTK(G_PT) = 11
5586,5592c6202,6208
<    CALL mat_putid(ID,IDS(1,PT))
<    EXCNT = PSTK(PT)
<    PT = PT-1
<    IF (SYM .EQ. COMMA) GOTO 42
<    IF (SYM .NE. RPAREN) CALL mat_err(3)
<    IF (ERR .GT. 0) RETURN
<    IF (SYM .EQ. RPAREN) CALL mat_getsym()
---
>    CALL mat_putid(ID,G_IDS(1,G_PT))
>    EXCNT = G_PSTK(G_PT)
>    G_PT = G_PT-1
>    IF (G_SYM .EQ. COMMA) GOTO 42
>    IF (G_SYM .NE. RPAREN) CALL mat_err(3)
>    IF (G_ERR .GT. 0) RETURN
>    IF (G_SYM .EQ. RPAREN) CALL mat_getsym()
5594,5599c6210,6215
<    RHS = EXCNT
<    CALL mat_stackg(ID)
<    IF (ERR .GT. 0) RETURN
<    IF (FIN .EQ. 0) CALL mat_funs(ID)
<    IF (FIN .EQ. 0) CALL mat_err(4)
<    IF (ERR .GT. 0) RETURN
---
>    G_RHS = EXCNT
>    CALL MAT_STACK_GET(ID)
>    IF (G_ERR .GT. 0) RETURN
>    IF (G_FIN .EQ. 0) CALL mat_funs(ID)
>    IF (G_FIN .EQ. 0) CALL mat_err(4)
>    IF (G_ERR .GT. 0) RETURN
5603,5604c6219,6220
<    PT = PT+1
<    RSTK(PT) = 16
---
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 16
5608c6224
<    PT = PT-1
---
>    G_PT = G_PT-1
5613,5615c6229,6231
<    IF (SYM .NE. QUOTE) GOTO 62
<    I = LPT(3) - 2
<    IF (LIN(I) .EQ. BLANK) GOTO 90
---
>    IF (G_SYM .NE. QUOTE) GOTO 62
>    I = G_LPT(3) - 2
>    IF (G_LIN(I) .EQ. BLANK) GOTO 90
5617c6233
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5620c6236
<    IF (SYM.NE.STAR .OR. CHRA.NE.STAR) GOTO 90
---
>    IF (G_SYM.NE.STAR .OR. G_CHRA.NE.STAR) GOTO 90
5623,5624c6239,6240
<    PT = PT+1
<    RSTK(PT) = 12
---
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 12
5628c6244
<    PT = PT-1
---
>    G_PT = G_PT-1
5630,5631c6246,6247
<    IF (ERR .GT. 0) RETURN
<    IF (FUN .NE. 2) GOTO 90
---
>    IF (G_ERR .GT. 0) RETURN
>    IF (G_FUN .NE. 2) GOTO 90
5633,5634c6249,6250
<    PT = PT+1
<    RSTK(PT) = 17
---
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 17
5638c6254
<    PT = PT-1
---
>    G_PT = G_PT-1
5643c6259
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5660c6276
<    IF (DDT .EQ. 1) then
---
>    IF (G_DEBUG_LEVEL .EQ. 1) then
5662,5663c6278,6279
<       call mat_appnum(real(pt),mline,ilen,ierr)
<       call mat_appnum(real(rstk(pt)),mline,ilen,ierr)
---
>       call mat_appnum(real(G_pt),mline,ilen,ierr)
>       call mat_appnum(real(G_RSTK(G_pt)),mline,ilen,ierr)
5666c6282
<    R = RSTK(PT)
---
>    R = G_RSTK(G_PT)
5669,5670c6285,6286
<    PT = PT+1
<    RSTK(PT) = 8
---
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 8
5675c6291
<    PT = PT-1
---
>    G_PT = G_PT-1
5678,5680c6294,6296
<    IF (SYM .EQ. DOT) OP = DOT
<    IF (SYM .EQ. DOT) CALL mat_getsym
<    IF (SYM.EQ.STAR .OR. SYM.EQ.SLASH .OR. SYM.EQ.BSLASH) GOTO 20
---
>    IF (G_SYM .EQ. DOT) OP = DOT
>    IF (G_SYM .EQ. DOT) CALL mat_getsym
>    IF (G_SYM.EQ.STAR .OR. G_SYM.EQ.SLASH .OR. G_SYM.EQ.BSLASH) GOTO 20
5684c6300
<    OP = OP + SYM
---
>    OP = OP + G_SYM
5686,5690c6302,6306
<    IF (SYM .EQ. DOT) OP = OP + SYM
<    IF (SYM .EQ. DOT) CALL mat_getsym()
<    PT = PT+1
<    PSTK(PT) = OP
<    RSTK(PT) = 9
---
>    IF (G_SYM .EQ. DOT) OP = OP + G_SYM
>    IF (G_SYM .EQ. DOT) CALL mat_getsym()
>    G_PT = G_PT+1
>    G_PSTK(G_PT) = OP
>    G_RSTK(G_PT) = 9
5695,5696c6311,6312
<    OP = PSTK(PT)
<    PT = PT-1
---
>    OP = G_PSTK(G_PT)
>    G_PT = G_PT-1
5698c6314
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5700,5702c6316,6318
<    IF (FUN .EQ. 0) GOTO 10
<    PT = PT+1
<    RSTK(PT) = 15
---
>    IF (G_FUN .EQ. 0) GOTO 10
>    G_PT = G_PT+1
>    G_RSTK(G_PT) = 15
5707c6323
<    PT = PT-1
---
>    G_PT = G_PT-1
5712c6328
<    IF (ERR .GT. 0) RETURN
---
>    IF (G_ERR .GT. 0) RETURN
5721c6337
< integer                      :: id(4)
---
> integer                        :: id(G_MAX_NAME_LENGTH)
5728c6344
< character(len=4)             :: cid
---
> character(len=G_MAX_NAME_LENGTH) :: cid
5731c6347
< $@(#) M_matrix::mat_savlod(3fp): read next variable from a "save" file or write next variable to it
---
> ! ident_38="@(#)M_matrix::mat_savlod(3fp): read next variable from a save file or write next variable to it"
5746c6362
<          call mat_buf2str(cid,id,4) ! convert ID to a character string
---
>          call mat_buf2str(cid,id,G_MAX_NAME_LENGTH) ! convert ID to a character string
5757c6373
<          call mat_str2buf(cid,id,4) ! convert character string to and ID
---
>          call mat_str2buf(cid,id,G_MAX_NAME_LENGTH) ! convert character string to an ID
5779,5780d6394
< ! INSERT HERE JSU
< !==================================================================================================================================!
5782a6397
> doubleprecision function mat_urand(iy)
5807d6421
< doubleprecision function mat_urand(iy)
5828,5829c6442,6443
<       ia = 8*idint(halfm*datan(1.d0)/8.d0) + 5          !  COMPUTE MULTIPLIER AND INCREMENT FOR LINEAR CONGRUENTIAL METHOD
<       ic = 2*idint(halfm*(0.5d0-dsqrt(3.d0)/6.d0)) + 1
---
>       ia = 8*int(halfm*datan(1.d0)/8.d0) + 5          !  COMPUTE MULTIPLIER AND INCREMENT FOR LINEAR CONGRUENTIAL METHOD
>       ic = 2*int(halfm*(0.5d0-dsqrt(3.d0)/6.d0)) + 1
5842c6456
<    mat_urand = dfloat(iy)*s
---
>    mat_urand = dble(iy)*s
5992c6606
< $@(#) M_matrix::mat_iwamax(3fp):index of norminf(x)
---
> ! ident_39="@(#)M_matrix::mat_iwamax(3fp):index of norminf(x)"
6019a6634
> doubleprecision function mat_flop(x)
6036d6650
< doubleprecision function mat_flop(x)
6043,6057c6657,6700
< real,save                  :: mas(2,14)=reshape([ &
<    & transfer(Z'ffffffff',0.0),transfer(Z'fff0ffff',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'ff00ffff',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'f000ffff',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'0000ffff',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'0000fff0',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'0000ff00',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'0000f000',0.0),     &
<    & transfer(Z'ffffffff',0.0),transfer(Z'00000000',0.0),     &
<    & transfer(Z'fff0ffff',0.0),transfer(Z'00000000',0.0),     &
<    & transfer(Z'ff00ffff',0.0),transfer(Z'00000000',0.0),     &
<    & transfer(Z'f000ffff',0.0),transfer(Z'00000000',0.0),     &
<    & transfer(Z'0000ffff',0.0),transfer(Z'00000000',0.0),     &
<    & transfer(Z'0000fff0',0.0),transfer(Z'00000000',0.0),     &
<    & transfer(Z'0000ff80',0.0),transfer(Z'00000000',0.0)],shape(mas))
---
> !>>>>>>>>>>>>>>>>>>
> !*!GFORTRAN BUG in 8.3
> !*!real,save                  :: mas(2,14)=reshape([ &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'fff0ffff',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'ff00ffff',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'f000ffff',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000ffff',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000fff0',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000ff00',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000f000',kind=kind(0.0)),     &
> !*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
> !*!   & real(Z'fff0ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
> !*!   & real(Z'ff00ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
> !*!   & real(Z'f000ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
> !*!   & real(Z'0000ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
> !*!   & real(Z'0000fff0',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
> !*!   & real(Z'0000ff80',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0))],shape(mas))
> integer :: i,j
> logical,save :: setup=.false.
> real,save                  :: mas(2,14)
> character(len=8),save      :: setmas(2,14)=reshape([ &
>    & 'ffffffff','fff0ffff', &
>    & 'ffffffff','ff00ffff', &
>    & 'ffffffff','f000ffff', &
>    & 'ffffffff','0000ffff', &
>    & 'ffffffff','0000fff0', &
>    & 'ffffffff','0000ff00', &
>    & 'ffffffff','0000f000', &
>    & 'ffffffff','00000000', &
>    & 'fff0ffff','00000000', &
>    & 'ff00ffff','00000000', &
>    & 'f000ffff','00000000', &
>    & '0000ffff','00000000', &
>    & '0000fff0','00000000', &
>    & '0000ff80','00000000'],shape(mas))
>    if(.not.setup)then
>       do i=1,2
>          do j=1,14
>             read(setmas(i,j),'(z8)')mas(i,j)
>          enddo
>       enddo
>       setup=.true.
>    endif
> !<<<<<<<<<<<<<<<<<<
6059,6060c6702,6703
<    flp(1) = flp(1) + 1
<    k = flp(2)
---
>    G_FLOP_COUNTER(1) = G_FLOP_COUNTER(1) + 1
>    k = G_FLOP_COUNTER(2)
6081c6724
< !     check for equality of two names
---
> !     check for equality of two integer arrays
6083,6084c6726,6727
< integer,intent(in) :: x(4)
< integer,intent(in) :: y(4)
---
> integer,intent(in) :: x(G_MAX_NAME_LENGTH)
> integer,intent(in) :: y(G_MAX_NAME_LENGTH)
6090c6733
<    do i = 1, 4
---
>    do i = 1, G_MAX_NAME_LENGTH
6100c6743
< doubleprecision,save :: h=1.0d9
---
> doubleprecision,parameter :: h=1.0d9
6103c6746
<       if (y .eq. z) goto 40
---
>    if (y .ne. z)then
6106,6107c6749,6750
<    10 continue
<       if (e .ge. z) goto 20
---
>       do
>          if (e .ge. z) exit
6109,6111c6752,6754
<          goto 10
<    20 continue
<       if (e .le. h) goto 30
---
>       enddo
>       do
>          if (e .le. h) exit
6115,6117c6758,6759
<          goto 20
<    30 continue
<       z = idint(z + 0.5d0)
---
>       enddo
>       z = int(z + 0.5d0)
6121,6122c6763
<       return
<    40 continue
---
>    else
6123a6765
>    endif
6131,6132c6773
< INTRO Welcome to MAT88.
< 
---
> INTRO Welcome to MAT88. A categorized list of case-sensitive help topics:
6144c6785
<        | Macros            |  macro                                     |
---
>        | Macros            |  MACRO                                     |
6149,6154c6790,6795
<        | High Level        |           chop   cond  conjg    det   diag |
<        | Functions         |    eig     eye   hess   hilb           inv |
<        |                   |   kron      lu  magic   ones   orth   pinv |
<        |                   |   poly    prod     qr   rand   rank  rcond |
<        |                   |    rat           rref  roots         schur |
<        |                   |   size     sum    svd   tril   triu   user |
---
>        | High Level        |   chop    cond  conjg    det   diag    eig |
>        | Functions         |    eye    hess   hilb    inv   kron     lu |
>        |                   |  magic    ones   orth   pinv   poly   prod |
>        |                   |     qr    rand   rank  rcond    rat   rref |
>        |                   |  roots   schur   size    sum    svd   tril |
>        |                   |   triu    user                             |
6166a6808
> SAMPLE
6188c6830,6831
< NEWS  MAT88 NEWS dated May, 1981.
---
> NEWS
>       May, 1981.
6194a6838,6843
>       Mar, 1990.
> 
>       Input lines can now be recalled and edited.  A "." on a line by
>       itself calls the command history mode. Enter "?" after entering
>       the mode for details.
> 
6197,6199c6846,6849
< sh    Starts the command shell interactively.
<       If any characters follow the remainder of the line (restricted to
<       the MAT88 character set) is passed to the sh shell.
---
> sh    Starts the command shell interactively, using the command defined by
>       the environment variable SHELL. Note that in addition any line
>       starting with an exclamation (!) is passed to the system for
>       execution.
6233c6883
<       in the usualway. Used to enclose arguments of functions
---
>       in the usual way. Used to enclose arguments of functions
6277a6928,6930
> !     If the first character of a line the rest of the line is
>       passed to the system to be executed.
> 
6372c7025
< MACRO  The macro facility involves text and inward pointing angle
---
>        The macro facility involves text and inward pointing angle
6489,6496c7142,7153
<       Hermitian, the form is tridiagonal. <P,H> = HESS(A)
<       produces a unitary matrix P and a Hessenberg matrix H so
<       that A = P*H*P'. By itself, HESS(A) returns H.
< 
< hilb  Inverse Hilbert matrix. HILB(N) is the inverse of the N
<       by N  matrix with elements 1/(i+j-1), which is a famous
<       example of a badly conditioned matrix. The result is exact
<       for N less than about 15, depending upon the computer.
---
>       Hermitian, the form is tridiagonal. <P,H> = HESS(A) produces a
>       unitary matrix P and a Hessenberg matrix H so that A = P*H*P'. By
>       itself, HESS(A) returns H.
> 
> hilb  Inverse Hilbert matrix. HILB(N) is the inverse of a N_by_N
>       Hilbert matrix (which is a famous example of a badly conditioned
>       matrix). The result is exact for N less than about 15, depending
>       upon the computer.
> 
>          for i = 1:N, for j = 1:N, A(i,j) = 1/(i+j-1);
> 
>       generates the NxN Hilbert matrix.
6830c7487
<       file with a name like FT0kF001 to be assigne to unit k
---
>       file with a name like FT0kF001 to be assigned to unit k
6841a7499,7501
> 
>          If k = 0 , there is no echo, prompt or pause. This is the
>                     default if the exec command is followed by a semicolon.
6843a7504,7506
>          If k = 3 , there will be echos and prompts, but no pauses.
>                     This is the the default if the exec command is not
>                     followed by a semicolon.
6846,6847d7508
<       If k = 0 , there is no echo, prompt or pause. This is the
<       default if the exec command is followed by a semicolon.
6850,6852c7511
<       If k = 3 , there will be echos and prompts, but no pauses.
<       This is the the default if the exec command is not followed
<       by a semicolon.
---
> 
6854a7514
> 
6856c7516,7518
<       EXEC of another file. EXEC's may also be driven by FOR and
---
>       EXEC of another file.
> 
>       EXEC's may also be driven by FOR and
6906c7568,7570
< long  Determine output format. All computations are done in
---
> long   See SHORT also.
> 
>        Determine output format. All computations are done in
6911,6915c7575,7583
<        SHORT    Scaled fixed point format with about 5 digits.
<        LONG     Scaled fixed point format with about 15 digits.
<        SHORT E  Floating point format with about 5 digits.
<        LONG E   Floating point format with about 15 digits.
<        LONG Z   System dependent format, often hexadecimal.
---
>         long     // Scaled fixed point format with about 15 digits.
>         long e   // Floating point format with about 15 digits.
>         long z   // System dependent format, often hexadecimal.
> 
> short  See LONG also.
>        Determine output format. All computations are done in
>        complex arithmetic and double precision if it is available.
>        SHORT and LONG merely switch between different output
>        formats.
6917c7585,7586
< short  See LONG .
---
>         short    // Scaled fixed point format with about 5 digits.
>         short e  // Floating point format with about 5 digits.
6964d7632
< 
6969d7636
< 
7311c7978
<    number of letters and digits, but only the first 4 characters are
---
>    number of letters and digits, but only the first 32 characters are
7327d7993
< 
8013c8679
<    As a curiousity, we return to the degree six polynomial.
---
>    As a curiosity, we return to the degree six polynomial.
8061d8726
< 
8085d8749
< 
8363d9026
< 
8509d9171
< 
8528d9189
< 
8570d9230
< 
8611d9270
< 
8622d9280
< 
8629d9286
< 
8638,8639d9294
< 
< 
8662d9316
< 
8665d9318
< 
8735,8803d9387
<    Two large real arrays, STKR and STKI, are used to store all
<    the matrices. Four integer arrays are used to store the names,
<    the row and column dimensions, and the pointers into the real
<    stacks. The following diagram illustrates this storage scheme.
< 
<     TOP         IDSTK     MSTK NSTK LSTK               STKR       STKI
<      --      -- -- -- --   --   --   --              --------   --------
<     |  |--->|  |  |  |  | |  | |  | |  |----------->|        | |        |
<      --      -- -- -- --   --   --   --              --------   --------
<             |  |  |  |  | |  | |  | |  |            |        | |        |
<              -- -- -- --   --   --   --              --------   --------
<                   .         .    .    .                  .          .
<                   .         .    .    .                  .          .
<                   .         .    .    .                  .          .
<              -- -- -- --   --   --   --              --------   --------
<     BOT     |  |  |  |  | |  | |  | |  |            |        | |        |
<      --      -- -- -- --   --   --   --              --------   --------
<     |  |--->| X|  |  |  | | 2| | 1| |  |----------->|  3.14  | |  0.00  |
<      --      -- -- -- --   --   --   --              --------   --------
<             | A|  |  |  | | 2| | 2| |  |---------   |  0.00  | |  1.00  |
<              -- -- -- --   --   --   --          \   --------   --------
<             | E| P| S|  | | 1| | 1| |  |-------   ->| 11.00  | |  0.00  |
<              -- -- -- --   --   --   --        \     --------   --------
<             | F| L| O| P| | 1| | 2| |  |------  \   | 21.00  | |  0.00  |
<              -- -- -- --   --   --   --       \  \   --------   --------
<             | E| Y| E|  | |-1| |-1| |  |---    \ |  | 12.00  | |  0.00  |
<              -- -- -- --   --   --   --    \   | |   --------   --------
<             | R| A| N| D| | 1| | 1| |  |-   \  | |  | 22.00  | |  0.00  |
<              -- -- -- --   --   --   --  \  |  \ \   --------   --------
<                                          |  \   \ ->| 1.E-15 | |  0.00  |
<                                          \   \   \   --------   --------
<                                           \   \   ->|  0.00  | |  0.00  |
<                                            \   \     --------   --------
<                                             \   \   |  0.00  | |  0.00  |
<                                              \   \   --------   --------
<                                               \   ->|  1.00  | |  0.00  |
<                                                \     --------   --------
<                                                 --->| URAND  | |  0.00  |
<                                                      --------   --------
< 
<    The top portion of the stack is used for temporary variables
<    and the bottom portion for saved variables. The figure shows the
<    situation after the line
< 
<       A = <11,12; 21,22>,  x = <3.14, sqrt(-1)>'
< 
<    has been processed. The four permanent names, EPS, FLOP, RAND
<    and EYE, occupy the last four positions of the variable stacks.
<    RAND has dimensions 1 by 1, but whenever its value is requested,
<    a random number generator is used instead. EYE has dimensions -1
<    by -1 to indicate that the actual dimensions must be determined
<    later by context. The two saved variables have dimensions 2 by 2
<    and 2 by 1 and so take up a total of 6 locations.
< 
<    Subsequent statements involving A and x will result in
<    temporary copies being made in the top of the stack for use in
<    the actual calculations. Whenever the top of the stack reaches
<    the bottom, a message indicating memory has been exceeded is
<    printed, but the current variables are not affected.
< 
<    This modular structure makes it possible to implement MAT88
<    on a system with a limited amount of memory. The object code for
<    the MATFN's and the LINPACK-EISPACK subroutines is rarely needed.
<    Although it is not standard, many Fortran operating systems
<    provide some overlay mechanism so that this code is brought into
<    the main memory only when required. The variables, which occupy
<    a relatively small portion of the memory, remain in place, while
<    the subroutines which process them are loaded a few at a time.
< 
9092c9676
<    variable FLP is essentially the first component of the variable
---
>    variable G_FLOP_COUNTER is essentially the first component of the variable
9101,9102c9685,9686
<          INTEGER FLP,CHP
<          COMMON FLP,CHP
---
>          INTEGER G_FLOP_COUNTER,CHP
>          COMMON G_FLOP_COUNTER,CHP
9105c9689
<          FLP = FLP + 1
---
>          G_FLOP_COUNTER = G_FLOP_COUNTER + 1
9171c9755
<             N = IDINT(A(1))
---
>             N = int(A(1))
9261c9845
<    but which is not used by MAT88 itself. The preample of MATZ is:
---
>    but which is not used by MAT88 itself. The preamble of MATZ is:
9263,9264c9847,9849
<          SUBROUTINE MATZ(A,LDA,M,N,IDA,JOB,IERR)
<          INTEGER LDA,M,N,IDA(1),JOB,IERR
---
>          SUBROUTINE MATZ(A,LDA,M,N,ID,JOB,IERR)
>          INTEGER LDA,M,N,JOB,IERR
>          character(len=*) :: id
9270,9272c9855
<          ! IDA IS THE NAME OF A.
<          !     IF IDA IS AN INTEGER K LESS THAN 10, THEN THE NAME IS 'A'K
<          !     OTHERWISE, IDA(1:4) IS FOUR CHARACTERS, FORMAT 4A1.
---
>          ! ID IS THE NAME OF A. ID IS UP TO FOUR CHARACTERS.
9282c9865
<         The preample of subroutine MAT88 is:
---
>         The preamble of subroutine MAT88 is:
9292d9874
<             INTEGER IDA(4),IDX(4)
9294d9875
<             DATA IDA/'A',' ',' ',' '/, IDX/'X',' ',' ',' '/
9302c9883
<             CALL MATZ(A,LDA,N,N,IDA,1,IERR)
---
>             CALL MATZ(A,LDA,N,N,'A',1,IERR)
9305c9886
<             CALL MATZ(X,LDA,N,N,IDX,0,IERR)
---
>             CALL MATZ(X,LDA,N,N,'X',0,IERR)
9383c9964,10780
< $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
---
> !===================================================================================================================================
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
> !===================================================================================================================================
> SUBROUTINE mat88_get(A,LDA,M,N,CID,JOB,IERR) !JSU
> ! ACCESS MATLAB VARIABLE STACK AND PUT OR GET A VARIABLE NAME AND ITS DATA FROM THE STACK
> ! USES MATLAB ROUTINES MAT_STACK_GET, MAT_STACK_PUT AND MAT_ERROR
> integer                     :: lda,m,n
> character(len=*),intent(in) :: cid        ! THE NAME OF A.  ID IS FOUR CHARACTERS
> doubleprecision             :: a(lda,n)   ! A IS AN M BY N MATRIX, STORED IN AN ARRAY WITH LEADING DIMENSION LDA.
> integer,intent(in)          :: job        ! JOB =  0  GET REAL A FROM MATLAB, JOB  = 10  GET IMAGINARY A INTO MATLAB,
> integer,INTENT(OUT)         :: ierr       ! RETURN WITH NONZERO IERR AFTER MATLAB ERROR MESSAGE.
> integer                     :: id(G_MAX_NAME_LENGTH)
> integer                     :: i,j,k
>    G_RHS=0
>    G_ERR=0
>    IERR=0
>    ! convert character name to mat88 character set
>    call mat_str2buf(cid,id,len(cid))
>    do j=1,G_MAX_NAME_LENGTH
>       do k = 1, G_CHARSET_SIZE  ! make sure this letter is in set of MAT88 characters and get its MAT88 number
>          if (id(j).eq.G_CHARSET(k) .or. id(j).eq.G_ALT_CHARSET(k)) then
>             id(j)=k-1
>          endif
>       enddo
>    enddo
> 
>    call mat_stack_get(id)
>    if(G_ERR.eq.0)G_ERR=4
>    if(G_ERR.gt.0)then
>       call mat_err(G_ERR)
>       IERR=G_ERR
>    else
>       M=G_MSTK(G_TOP)
>       N=G_NSTK(G_TOP)
>       k=0
>       do i=1,m
>          do j=1,n
>             k=k+1
>             if(job.eq.0)then
>                a(i,j)=g_stkr(k)       ! JOB =  0  GET REAL A FROM MATLAB,
>             else
>                a(i,j)=g_stki(k)       ! JOB =  10  GET IMAGINARY A FROM MATLAB,
>             endif
>          enddo
>       enddo
>    endif
>    if(G_DEBUG_LEVEL.ne.0)then
>       call printit()
>    endif
> 
>    contains
> 
> subroutine printit()
> character(len=G_MAX_NAME_LENGTH) :: name
> integer          :: l
>    write(*,*)repeat('=',80)
>    write(*,*)'CID=',CID
>    write(*,*)'ID=',ID(:)
>    write(*,*)'G_TOP=',G_TOP
>    write(*,*)'G_ERR=',G_ERR
>    if(G_ERR.lt.1.and.G_TOP.gt.0)then
>       write(*,*)'G_LSTK(G_TOP)=',G_LSTK(G_TOP)
>       write(*,*)'G_MSTK(G_TOP)=',G_MSTK(G_TOP),M
>       write(*,*)'G_NSTK(G_TOP)=',G_NSTK(G_TOP),N
>       l=G_LSTK(G_TOP)
>       write(*,'(*(g0.4,1x))')'REAL VALUES=     ',G_STKR(L:L+(M*N-1))
>       write(*,'(*(g0.4,1x))')'IMAGINARY VALUES=',G_STKI(L:L+(M*N-1))
>    endif
> end subroutine printit
> 
> end subroutine mat88_get
> !===================================================================================================================================
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
> !===================================================================================================================================
> SUBROUTINE mat88_put(A,LDA,M,N,CID,JOB,IERR) !JSU
> ! ACCESS MATLAB VARIABLE STACK AND PUT OR GET A VARIABLE NAME AND ITS DATA FROM THE STACK
> INTEGER                     :: LDA,M,N
> character(len=*),intent(in) :: cid        ! THE NAME OF A.  ID IS FOUR CHARACTERS
> DOUBLE PRECISION            :: A(LDA,N)   ! A IS AN M BY N MATRIX, STORED IN AN ARRAY WITH LEADING DIMENSION LDA.
> INTEGER,intent(in)          :: JOB
>                                           !     JOB =  0  GET REAL A FROM MATLAB,
>                                           !         =  1  PUT REAL A INTO MATLAB,
>                                           !         = 10  GET IMAG PART OF A FROM MATLAB,
>                                           !         = 11  PUT IMAG PART OF A INTO MATLAB.
> INTEGER,intent(out)         :: IERR       ! RETURN WITH NONZERO IERR AFTER MATLAB ERROR MESSAGE.
> INTEGER                     :: ID(G_MAX_NAME_LENGTH)
> integer                     :: i,j,k
> !
> !     USES MATLAB ROUTINES MAT_STACK_GET, MAT_STACK_PUT AND MAT_ERROR
> !
>    G_RHS=0
>    G_ERR=0
>    IERR=0
>    ! convert character name to mat88 character set
>    call mat_str2buf(cid,id,len(cid))
>    do j=1,G_MAX_NAME_LENGTH
>       do k = 1, G_CHARSET_SIZE  ! make sure this letter is in set of MAT88 characters and get its MAT88 number
>          if (id(j).eq.G_CHARSET(k) .or. id(j).eq.G_ALT_CHARSET(k)) then
>             id(j)=k-1
>          endif
>       enddo
>    enddo
> 
>    call mat_stack_get(id)
>    if(G_ERR.eq.0)G_ERR=4
>    if(G_ERR.gt.0)then
>       call mat_err(G_ERR)
>       iERR=G_ERR
>    else
>       call printit()
>       M=G_MSTK(G_TOP)
>       N=G_NSTK(G_TOP)
>       k=0
>       do i=1,m
>          do j=1,n
>                k=k+1
>                if(job.eq.0)then
>                   a(i,j)=g_stkr(k) ! JOB =  0  GET REAL A FROM MATLAB,
>                else
>                   a(i,j)=g_stki(k) ! JOB =  10  GET IMAGINARY A FROM MATLAB,
>                endif
>          enddo
>       enddo
>    endif
> 
>    contains
> 
> subroutine printit()
> character(len=G_MAX_NAME_LENGTH) :: name
> integer          :: l
>    write(*,*)repeat('=',80)
>    write(*,*)'CID=',CID
>    write(*,*)'ID=',ID(:)
>    write(*,*)'G_TOP=',G_TOP
>    write(*,*)'G_ERR=',G_ERR
>    if(G_ERR.lt.1.and.G_TOP.gt.0)then
>       write(*,*)'G_LSTK(G_TOP)=',G_LSTK(G_TOP)
>       write(*,*)'G_MSTK(G_TOP)=',G_MSTK(G_TOP)
>       write(*,*)'G_NSTK(G_TOP)=',G_NSTK(G_TOP)
>       l=G_LSTK(G_TOP)
>       write(*,'(*(g0.4,1x))')'REAL VALUES=     ',G_STKR(L:L+(M*N-1))
>       write(*,'(*(g0.4,1x))')'IMAGINARY VALUES=',G_STKI(L:L+(M*N-1))
>    endif
> end subroutine printit
> 
> end subroutine mat88_put
> !===================================================================================================================================
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
> !===================================================================================================================================
> subroutine test_suite_M_matrix()
> use M_verify, only : unit_check_start,unit_check,unit_check_done,unit_check_good,unit_check_bad,unit_check_msg
> use M_verify, only : unit_check_level
> 
> !! setup
>    call test_mat88()
>    call test_mat_appnum()
>    call test_mat_base()
>    call test_mat_buf2str()
>    call test_mat_clause()
>    call test_mat_comand()
>    call test_mat_eqid()
>    call test_mat_err()
>    call test_mat_expr()
>    call test_mat_factor()
>    call test_mat_files()
>    call test_mat_flop()
>    call test_mat_formz()
>    call test_mat_funs()
>    call test_mat_getch()
>    call test_mat_getlin()
>    call test_mat_getsym()
>    call test_mat_getval()
>    call test_mat_hilber()
>    call test_mat_iwamax()
>    call test_mat_magic()
>    call test_mat_make_help()
>    call test_mat_make_manual()
>    call test_mat_matfn1()
>    call test_mat_matfn2()
>    call test_mat_matfn3()
>    call test_mat_matfn4()
>    call test_mat_matfn5()
>    call test_mat_matfn6()
>    call test_mat_parse()
>    call test_mat_plot()
>    call test_mat_print()
>    call test_mat_prntid()
>    call test_mat_prompt()
>    call test_mat_putid()
>    call test_mat_pythag()
>    call test_mat_rat()
>    call test_mat_round()
>    call test_mat_rref()
>    call test_mat_rrot()
>    call test_mat_rrotg()
>    call test_mat_rset()
>    call test_mat_rswap()
>    call test_mat_savlod()
>    call test_mat_stack1()
>    call test_mat_stack2()
>    call test_MAT_STACK_GET()
>    call test_mat_stackp()
>    call test_mat_str2buf()
>    call test_mat_term()
>    call test_mat_urand()
>    call test_mat_wasum()
>    call test_mat_watan()
>    call test_mat_wcopy()
>    call test_mat_wdiv()
>    call test_mat_wdotci()
>    call test_mat_wdotcr()
>    call test_mat_wdotui()
>    call test_mat_wdotur()
>    call test_mat_wlog()
>    call test_mat_wmul()
>    call test_mat_wnrm2()
>    call test_mat_wpofa()
>    call test_mat_wrscal()
>    call test_mat_wscal()
>    call test_mat_wset()
>    call test_mat_wsign()
>    call test_mat_wsqrt()
>    call test_mat_wswap()
>    call test_matx_waxpy()
>    call test_ml_comqr3()
>    call test_ml_corth()
>    call test_ml_htribk()
>    call test_ml_htridi()
>    call test_ml_imtql2()
>    call test_ml_wgeco()
>    call test_ml_wgedi()
>    call test_ml_wgefa()
>    call test_ml_wgesl()
>    call test_ml_wqrdc()
>    call test_ml_wqrsl()
>    call test_ml_wsvdc()
> !! teardown
> contains
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat88()
> 
>    call unit_check_start('mat88',msg='')
>    !!call unit_check('mat88', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat88',msg='')
> end subroutine test_mat88
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_appnum()
> 
>    call unit_check_start('mat_appnum',msg='')
>    !!call unit_check('mat_appnum', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_appnum',msg='')
> end subroutine test_mat_appnum
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_base()
> 
>    call unit_check_start('mat_base',msg='')
>    !!call unit_check('mat_base', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_base',msg='')
> end subroutine test_mat_base
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_buf2str()
> 
>    call unit_check_start('mat_buf2str',msg='')
>    !!call unit_check('mat_buf2str', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_buf2str',msg='')
> end subroutine test_mat_buf2str
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_clause()
> 
>    call unit_check_start('mat_clause',msg='')
>    !!call unit_check('mat_clause', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_clause',msg='')
> end subroutine test_mat_clause
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_comand()
> 
>    call unit_check_start('mat_comand',msg='')
>    !!call unit_check('mat_comand', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_comand',msg='')
> end subroutine test_mat_comand
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_eqid()
> 
>    call unit_check_start('mat_eqid',msg='')
>    !!call unit_check('mat_eqid', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_eqid',msg='')
> end subroutine test_mat_eqid
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_err()
> 
>    call unit_check_start('mat_err',msg='')
>    !!call unit_check('mat_err', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_err',msg='')
> end subroutine test_mat_err
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_expr()
> 
>    call unit_check_start('mat_expr',msg='')
>    !!call unit_check('mat_expr', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_expr',msg='')
> end subroutine test_mat_expr
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_factor()
> 
>    call unit_check_start('mat_factor',msg='')
>    !!call unit_check('mat_factor', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_factor',msg='')
> end subroutine test_mat_factor
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_files()
> 
>    call unit_check_start('mat_files',msg='')
>    !!call unit_check('mat_files', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_files',msg='')
> end subroutine test_mat_files
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_flop()
> 
>    call unit_check_start('mat_flop',msg='')
>    !!call unit_check('mat_flop', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_flop',msg='')
> end subroutine test_mat_flop
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_formz()
> 
>    call unit_check_start('mat_formz',msg='')
>    !!call unit_check('mat_formz', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_formz',msg='')
> end subroutine test_mat_formz
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_funs()
> 
>    call unit_check_start('mat_funs',msg='')
>    !!call unit_check('mat_funs', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_funs',msg='')
> end subroutine test_mat_funs
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_getch()
> 
>    call unit_check_start('mat_getch',msg='')
>    !!call unit_check('mat_getch', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_getch',msg='')
> end subroutine test_mat_getch
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_getlin()
> 
>    call unit_check_start('mat_getlin',msg='')
>    !!call unit_check('mat_getlin', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_getlin',msg='')
> end subroutine test_mat_getlin
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_getsym()
> 
>    call unit_check_start('mat_getsym',msg='')
>    !!call unit_check('mat_getsym', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_getsym',msg='')
> end subroutine test_mat_getsym
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_getval()
> 
>    call unit_check_start('mat_getval',msg='')
>    !!call unit_check('mat_getval', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_getval',msg='')
> end subroutine test_mat_getval
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_hilber()
> 
>    call unit_check_start('mat_hilber',msg='')
>    !!call unit_check('mat_hilber', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_hilber',msg='')
> end subroutine test_mat_hilber
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_iwamax()
> 
>    call unit_check_start('mat_iwamax',msg='')
>    !!call unit_check('mat_iwamax', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_iwamax',msg='')
> end subroutine test_mat_iwamax
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_magic()
> 
>    call unit_check_start('mat_magic',msg='')
>    !!call unit_check('mat_magic', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_magic',msg='')
> end subroutine test_mat_magic
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_make_help()
> 
>    call unit_check_start('mat_make_help',msg='')
>    !!call unit_check('mat_make_help', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_make_help',msg='')
> end subroutine test_mat_make_help
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_make_manual()
> 
>    call unit_check_start('mat_make_manual',msg='')
>    !!call unit_check('mat_make_manual', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_make_manual',msg='')
> end subroutine test_mat_make_manual
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_matfn1()
> 
>    call unit_check_start('mat_matfn1',msg='')
>    !!call unit_check('mat_matfn1', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_matfn1',msg='')
> end subroutine test_mat_matfn1
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_matfn2()
> 
>    call unit_check_start('mat_matfn2',msg='')
>    !!call unit_check('mat_matfn2', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_matfn2',msg='')
> end subroutine test_mat_matfn2
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_matfn3()
> 
>    call unit_check_start('mat_matfn3',msg='')
>    !!call unit_check('mat_matfn3', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_matfn3',msg='')
> end subroutine test_mat_matfn3
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_matfn4()
> 
>    call unit_check_start('mat_matfn4',msg='')
>    !!call unit_check('mat_matfn4', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_matfn4',msg='')
> end subroutine test_mat_matfn4
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_matfn5()
> 
>    call unit_check_start('mat_matfn5',msg='')
>    !!call unit_check('mat_matfn5', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_matfn5',msg='')
> end subroutine test_mat_matfn5
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_matfn6()
> 
>    call unit_check_start('mat_matfn6',msg='')
>    !!call unit_check('mat_matfn6', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_matfn6',msg='')
> end subroutine test_mat_matfn6
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_parse()
> 
>    call unit_check_start('mat_parse',msg='')
>    !!call unit_check('mat_parse', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_parse',msg='')
> end subroutine test_mat_parse
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_plot()
> 
>    call unit_check_start('mat_plot',msg='')
>    !!call unit_check('mat_plot', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_plot',msg='')
> end subroutine test_mat_plot
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_print()
> 
>    call unit_check_start('mat_print',msg='')
>    !!call unit_check('mat_print', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_print',msg='')
> end subroutine test_mat_print
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_prntid()
> 
>    call unit_check_start('mat_prntid',msg='')
>    !!call unit_check('mat_prntid', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_prntid',msg='')
> end subroutine test_mat_prntid
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_prompt()
> 
>    call unit_check_start('mat_prompt',msg='')
>    !!call unit_check('mat_prompt', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_prompt',msg='')
> end subroutine test_mat_prompt
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_putid()
> 
>    call unit_check_start('mat_putid',msg='')
>    !!call unit_check('mat_putid', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_putid',msg='')
> end subroutine test_mat_putid
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_pythag()
> 
>    call unit_check_start('mat_pythag',msg='')
>    !!call unit_check('mat_pythag', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_pythag',msg='')
> end subroutine test_mat_pythag
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_rat()
> 
>    call unit_check_start('mat_rat',msg='')
>    !!call unit_check('mat_rat', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_rat',msg='')
> end subroutine test_mat_rat
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_round()
> 
>    call unit_check_start('mat_round',msg='')
>    !!call unit_check('mat_round', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_round',msg='')
> end subroutine test_mat_round
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_rref()
> 
>    call unit_check_start('mat_rref',msg='')
>    !!call unit_check('mat_rref', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_rref',msg='')
> end subroutine test_mat_rref
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_rrot()
> 
>    call unit_check_start('mat_rrot',msg='')
>    !!call unit_check('mat_rrot', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_rrot',msg='')
> end subroutine test_mat_rrot
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_rrotg()
> 
>    call unit_check_start('mat_rrotg',msg='')
>    !!call unit_check('mat_rrotg', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_rrotg',msg='')
> end subroutine test_mat_rrotg
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_rset()
> 
>    call unit_check_start('mat_rset',msg='')
>    !!call unit_check('mat_rset', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_rset',msg='')
> end subroutine test_mat_rset
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_rswap()
> 
>    call unit_check_start('mat_rswap',msg='')
>    !!call unit_check('mat_rswap', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_rswap',msg='')
> end subroutine test_mat_rswap
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_savlod()
> 
>    call unit_check_start('mat_savlod',msg='')
>    !!call unit_check('mat_savlod', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_savlod',msg='')
> end subroutine test_mat_savlod
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_stack1()
> 
>    call unit_check_start('mat_stack1',msg='')
>    !!call unit_check('mat_stack1', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_stack1',msg='')
> end subroutine test_mat_stack1
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_stack2()
> 
>    call unit_check_start('mat_stack2',msg='')
>    !!call unit_check('mat_stack2', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_stack2',msg='')
> end subroutine test_mat_stack2
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_MAT_STACK_GET()
> 
>    call unit_check_start('MAT_STACK_GET',msg='')
>    !!call unit_check('MAT_STACK_GET', 0.eq.0, 'checking', 100)
>    call unit_check_done('MAT_STACK_GET',msg='')
> end subroutine test_MAT_STACK_GET
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_stackp()
> 
>    call unit_check_start('MAT_STACK_PUT',msg='')
>    !!call unit_check('MAT_STACK_PUT', 0.eq.0, 'checking', 100)
>    call unit_check_done('MAT_STACK_PUT',msg='')
> end subroutine test_mat_stackp
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_str2buf()
> 
>    call unit_check_start('mat_str2buf',msg='')
>    !!call unit_check('mat_str2buf', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_str2buf',msg='')
> end subroutine test_mat_str2buf
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_term()
> 
>    call unit_check_start('mat_term',msg='')
>    !!call unit_check('mat_term', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_term',msg='')
> end subroutine test_mat_term
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_urand()
> 
>    call unit_check_start('mat_urand',msg='')
>    !!call unit_check('mat_urand', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_urand',msg='')
> end subroutine test_mat_urand
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wasum()
> 
>    call unit_check_start('mat_wasum',msg='')
>    !!call unit_check('mat_wasum', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wasum',msg='')
> end subroutine test_mat_wasum
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_watan()
> 
>    call unit_check_start('mat_watan',msg='')
>    !!call unit_check('mat_watan', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_watan',msg='')
> end subroutine test_mat_watan
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wcopy()
> 
>    call unit_check_start('mat_wcopy',msg='')
>    !!call unit_check('mat_wcopy', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wcopy',msg='')
> end subroutine test_mat_wcopy
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wdiv()
> 
>    call unit_check_start('mat_wdiv',msg='')
>    !!call unit_check('mat_wdiv', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wdiv',msg='')
> end subroutine test_mat_wdiv
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wdotci()
> 
>    call unit_check_start('mat_wdotci',msg='')
>    !!call unit_check('mat_wdotci', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wdotci',msg='')
> end subroutine test_mat_wdotci
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wdotcr()
> 
>    call unit_check_start('mat_wdotcr',msg='')
>    !!call unit_check('mat_wdotcr', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wdotcr',msg='')
> end subroutine test_mat_wdotcr
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wdotui()
> 
>    call unit_check_start('mat_wdotui',msg='')
>    !!call unit_check('mat_wdotui', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wdotui',msg='')
> end subroutine test_mat_wdotui
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wdotur()
> 
>    call unit_check_start('mat_wdotur',msg='')
>    !!call unit_check('mat_wdotur', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wdotur',msg='')
> end subroutine test_mat_wdotur
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wlog()
> 
>    call unit_check_start('mat_wlog',msg='')
>    !!call unit_check('mat_wlog', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wlog',msg='')
> end subroutine test_mat_wlog
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wmul()
> 
>    call unit_check_start('mat_wmul',msg='')
>    !!call unit_check('mat_wmul', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wmul',msg='')
> end subroutine test_mat_wmul
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wnrm2()
> 
>    call unit_check_start('mat_wnrm2',msg='')
>    !!call unit_check('mat_wnrm2', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wnrm2',msg='')
> end subroutine test_mat_wnrm2
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wpofa()
> 
>    call unit_check_start('mat_wpofa',msg='')
>    !!call unit_check('mat_wpofa', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wpofa',msg='')
> end subroutine test_mat_wpofa
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wrscal()
> 
>    call unit_check_start('mat_wrscal',msg='')
>    !!call unit_check('mat_wrscal', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wrscal',msg='')
> end subroutine test_mat_wrscal
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wscal()
> 
>    call unit_check_start('mat_wscal',msg='')
>    !!call unit_check('mat_wscal', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wscal',msg='')
> end subroutine test_mat_wscal
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wset()
> 
>    call unit_check_start('mat_wset',msg='')
>    !!call unit_check('mat_wset', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wset',msg='')
> end subroutine test_mat_wset
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wsign()
> 
>    call unit_check_start('mat_wsign',msg='')
>    !!call unit_check('mat_wsign', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wsign',msg='')
> end subroutine test_mat_wsign
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wsqrt()
> 
>    call unit_check_start('mat_wsqrt',msg='')
>    !!call unit_check('mat_wsqrt', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wsqrt',msg='')
> end subroutine test_mat_wsqrt
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_mat_wswap()
> 
>    call unit_check_start('mat_wswap',msg='')
>    !!call unit_check('mat_wswap', 0.eq.0, 'checking', 100)
>    call unit_check_done('mat_wswap',msg='')
> end subroutine test_mat_wswap
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_matx_waxpy()
> 
>    call unit_check_start('matx_waxpy',msg='')
>    !!call unit_check('matx_waxpy', 0.eq.0, 'checking', 100)
>    call unit_check_done('matx_waxpy',msg='')
> end subroutine test_matx_waxpy
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_comqr3()
> 
>    call unit_check_start('ml_comqr3',msg='')
>    !!call unit_check('ml_comqr3', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_comqr3',msg='')
> end subroutine test_ml_comqr3
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_corth()
> 
>    call unit_check_start('ml_corth',msg='')
>    !!call unit_check('ml_corth', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_corth',msg='')
> end subroutine test_ml_corth
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_htribk()
> 
>    call unit_check_start('ml_htribk',msg='')
>    !!call unit_check('ml_htribk', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_htribk',msg='')
> end subroutine test_ml_htribk
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_htridi()
> 
>    call unit_check_start('ml_htridi',msg='')
>    !!call unit_check('ml_htridi', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_htridi',msg='')
> end subroutine test_ml_htridi
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_imtql2()
> 
>    call unit_check_start('ml_imtql2',msg='')
>    !!call unit_check('ml_imtql2', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_imtql2',msg='')
> end subroutine test_ml_imtql2
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wgeco()
> 
>    call unit_check_start('ml_wgeco',msg='')
>    !!call unit_check('ml_wgeco', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wgeco',msg='')
> end subroutine test_ml_wgeco
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wgedi()
> 
>    call unit_check_start('ml_wgedi',msg='')
>    !!call unit_check('ml_wgedi', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wgedi',msg='')
> end subroutine test_ml_wgedi
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wgefa()
> 
>    call unit_check_start('ml_wgefa',msg='')
>    !!call unit_check('ml_wgefa', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wgefa',msg='')
> end subroutine test_ml_wgefa
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wgesl()
> 
>    call unit_check_start('ml_wgesl',msg='')
>    !!call unit_check('ml_wgesl', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wgesl',msg='')
> end subroutine test_ml_wgesl
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wqrdc()
> 
>    call unit_check_start('ml_wqrdc',msg='')
>    !!call unit_check('ml_wqrdc', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wqrdc',msg='')
> end subroutine test_ml_wqrdc
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wqrsl()
> 
>    call unit_check_start('ml_wqrsl',msg='')
>    !!call unit_check('ml_wqrsl', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wqrsl',msg='')
> end subroutine test_ml_wqrsl
> !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
> subroutine test_ml_wsvdc()
> 
>    call unit_check_start('ml_wsvdc',msg='')
>    !!call unit_check('ml_wsvdc', 0.eq.0, 'checking', 100)
>    call unit_check_done('ml_wsvdc',msg='')
> end subroutine test_ml_wsvdc
> !===================================================================================================================================
> end subroutine test_suite_M_matrix
> !===================================================================================================================================
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
> !===================================================================================================================================
9384a10782,13633
> $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> subroutine matX_waxpy(N,SR,SI,xr,xi,INCX,yr,yi,INCY)
> use M_matrix
> implicit none
> integer,intent(in)         :: n
> doubleprecision,intent(in) :: sr
> doubleprecision,intent(in) :: si
> doubleprecision,intent(in) :: xr(*)
> doubleprecision,intent(in) :: xi(*)
> integer,intent(in)         :: incx
> integer,intent(in)         :: incy
> 
> doubleprecision :: yr(*)
> doubleprecision :: yi(*)
> integer         :: ix, iy
> 
> integer         :: i
> 
>    if (n .le. 0) return
>    if (sr .eq. 0.0d0 .and. si .eq. 0.0d0) return
>    ix = 1
>    iy = 1
>    if (incx.lt.0) ix = (-n+1)*incx + 1
>    if (incy.lt.0) iy = (-n+1)*incy + 1
>    do i = 1, n
>       yr(iy) = mat_flop(yr(iy) + sr*xr(ix) - si*xi(ix))
>       yi(iy) = yi(iy) + sr*xi(ix) + si*xr(ix)
>       if (yi(iy) .ne. 0.0d0) yi(iy) = mat_flop(yi(iy))
>       ix = ix + incx
>       iy = iy + incy
>    enddo
> end subroutine matX_waxpy
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
>       SUBROUTINE ML_WGECO(AR,AI,LDA,N,IPVT,RCOND,ZR,ZI)
>       use M_matrix
>       INTEGER LDA,N,IPVT(*)
>       DOUBLEPRECISION AR(LDA,*),AI(LDA,*),ZR(*),ZI(*)
>       DOUBLEPRECISION RCOND
> !
> !     WGECO FACTORS A DOUBLE-COMPLEX MATRIX BY GAUSSIAN ELIMINATION
> !     AND ESTIMATES THE CONDITION OF THE MATRIX.
> !
> !     IF  RCOND  IS NOT NEEDED, WGEFA IS SLIGHTLY FASTER.
> !     TO SOLVE  A*X = B , FOLLOW WGECO BY WGESL.
> !     TO COMPUTE  INVERSE(A)*C , FOLLOW WGECO BY WGESL.
> !     TO COMPUTE  DETERMINANT(A) , FOLLOW WGECO BY WGEDI.
> !     TO COMPUTE  INVERSE(A) , FOLLOW WGECO BY WGEDI.
> !
> !     ON ENTRY
> !
> !        A       DOUBLE-COMPLEX(LDA, N)
> !                THE MATRIX TO BE FACTORED.
> !
> !        LDA     INTEGER
> !                THE LEADING DIMENSION OF THE ARRAY  A .
> !
> !        N       INTEGER
> !                THE ORDER OF THE MATRIX  A .
> !
> !     ON RETURN
> !
> !        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
> !                WHICH WERE USED TO OBTAIN IT.
> !                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
> !                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
> !                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
> !
> !        IPVT    INTEGER(N)
> !                AN INTEGER VECTOR OF PIVOT INDICES.
> !
> !        RCOND   DOUBLEPRECISION
> !                AN ESTIMATE OF THE RECIPROCAL CONDITION OF  A .
> !                FOR THE SYSTEM  A*X = B , RELATIVE PERTURBATIONS
> !                IN  A  AND  B  OF SIZE  EPSILON  MAY CAUSE
> !                RELATIVE PERTURBATIONS IN  X  OF SIZE  EPSILON/RCOND .
> !                IF  RCOND  IS SO SMALL THAT THE LOGICAL EXPRESSION
> !        1.0 + RCOND .EQ. 1.0
> !                IS TRUE, THEN  A  MAY BE SINGULAR TO WORKING
> !                PRECISION.  IN PARTICULAR,  RCOND  IS ZERO  IF
> !                EXACT SINGULARITY IS DETECTED OR THE ESTIMATE
> !                UNDERFLOWS.
> !
> !        Z       DOUBLE-COMPLEX(N)
> !                A WORK VECTOR WHOSE CONTENTS ARE USUALLY UNIMPORTANT.
> !                IF  A  IS CLOSE TO A SINGULAR MATRIX, THEN  Z  IS
> !                AN APPROXIMATE NULL VECTOR IN THE SENSE THAT
> !                NORM(A*Z) = RCOND*NORM(A)*NORM(Z) .
> !
> !     LINPACK. THIS VERSION DATED 07/01/79 .
> !     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
> !
> !     SUBROUTINES AND FUNCTIONS
> !
> !     LINPACK WGEFA
> !     BLAS WAXPY,WDOTC,mat_wasum
> !     FORTRAN DABS,DMAX1
> !
> !     INTERNAL VARIABLES
> !
>       DOUBLEPRECISION EKR,EKI,TR,TI,WKR,WKI,WKMR,WKMI
>       DOUBLEPRECISION ANORM,S,SM,YNORM
>       INTEGER INFO,J,K,KB,KP1,L
> !
>       DOUBLEPRECISION ZDUMR,ZDUMI
>       DOUBLEPRECISION CABS1
>       CABS1(ZDUMR,ZDUMI) = DABS(ZDUMR) + DABS(ZDUMI)
> !
> !     COMPUTE 1-NORM OF A
> !
>       ANORM = 0.0D0
>       DO J = 1, N
>          ANORM = DMAX1(ANORM,mat_wasum(N,AR(1,J),AI(1,J),1))
>       enddo
> !
> !     FACTOR
> !
>       CALL ML_WGEFA(AR,AI,LDA,N,IPVT,INFO)
> !
> !     RCOND = 1/(NORM(A)*(ESTIMATE OF NORM(INVERSE(A)))) .
> !     ESTIMATE = NORM(Z)/NORM(Y) WHERE  A*Z = Y  AND  CTRANS(A)*Y = E .
> !     CTRANS(A)  IS THE CONJUGATE TRANSPOSE OF A .
> !     THE COMPONENTS OF  E  ARE CHOSEN TO CAUSE MAXIMUM LOCAL
> !     GROWTH IN THE ELEMENTS OF W  WHERE  CTRANS(U)*W = E .
> !     THE VECTORS ARE FREQUENTLY RESCALED TO AVOID OVERFLOW.
> !
> !     SOLVE CTRANS(U)*W = E
> !
>       EKR = 1.0D0
>       EKI = 0.0D0
>       DO J = 1, N
>          ZR(J) = 0.0D0
>          ZI(J) = 0.0D0
>       enddo
>       DO 110 K = 1, N
>          CALL mat_wsign(EKR,EKI,-ZR(K),-ZI(K),EKR,EKI)
>          IF (CABS1(EKR-ZR(K),EKI-ZI(K)) .LE. CABS1(AR(K,K),AI(K,K))) GOTO 40
>             S = CABS1(AR(K,K),AI(K,K)) / CABS1(EKR-ZR(K),EKI-ZI(K))
>             CALL mat_wrscal(N,S,ZR,ZI,1)
>             EKR = S*EKR
>             EKI = S*EKI
>    40    CONTINUE
>          WKR = EKR - ZR(K)
>          WKI = EKI - ZI(K)
>          WKMR = -EKR - ZR(K)
>          WKMI = -EKI - ZI(K)
>          S = CABS1(WKR,WKI)
>          SM = CABS1(WKMR,WKMI)
>          IF (CABS1(AR(K,K),AI(K,K)) .EQ. 0.0D0) GOTO 50
>             CALL mat_wdiv(WKR,WKI,AR(K,K),-AI(K,K),WKR,WKI)
>             CALL mat_wdiv(WKMR,WKMI,AR(K,K),-AI(K,K),WKMR,WKMI)
>          GOTO 60
>    50    CONTINUE
>             WKR = 1.0D0
>             WKI = 0.0D0
>             WKMR = 1.0D0
>             WKMI = 0.0D0
>    60    CONTINUE
>          KP1 = K + 1
>          IF (KP1 .GT. N) GOTO 100
>             DO J = KP1, N
>                CALL mat_wmul(WKMR,WKMI,AR(K,J),-AI(K,J),TR,TI)
>                SM = mat_flop(SM + CABS1(ZR(J)+TR,ZI(J)+TI))
>                CALL matX_waxpy(1,WKR,WKI,[AR(K,J)],[-AI(K,J)],1,ZR(J),ZI(J),1)
>                S = mat_flop(S + CABS1(ZR(J),ZI(J)))
>             enddo
>             IF (S .GE. SM) GOTO 90
>                TR = WKMR - WKR
>                TI = WKMI - WKI
>                WKR = WKMR
>                WKI = WKMI
>                DO J = KP1, N
>                   CALL matX_waxpy(1,TR,TI,[AR(K,J)],[-AI(K,J)],1,ZR(J),ZI(J),1)
>                enddo
>    90       CONTINUE
>   100    CONTINUE
>          ZR(K) = WKR
>          ZI(K) = WKI
>   110 CONTINUE
>       S = 1.0D0/mat_wasum(N,ZR,ZI,1)
>       CALL mat_wrscal(N,S,ZR,ZI,1)
> !
> !     SOLVE CTRANS(L)*Y = W
> !
>       DO KB = 1, N
>          K = N + 1 - KB
>          IF (K .GE. N) GOTO 120
>             ZR(K) = ZR(K) + mat_wdotcr(N-K,AR(K+1,K),AI(K+1,K),1,ZR(K+1),ZI(K+1),1)
>             ZI(K) = ZI(K) + mat_wdotci(N-K,AR(K+1,K),AI(K+1,K),1,ZR(K+1),ZI(K+1),1)
>   120    CONTINUE
>          IF (CABS1(ZR(K),ZI(K)) .LE. 1.0D0) GOTO 130
>             S = 1.0D0/CABS1(ZR(K),ZI(K))
>             CALL mat_wrscal(N,S,ZR,ZI,1)
>   130    CONTINUE
>          L = IPVT(K)
>          TR = ZR(L)
>          TI = ZI(L)
>          ZR(L) = ZR(K)
>          ZI(L) = ZI(K)
>          ZR(K) = TR
>          ZI(K) = TI
>       enddo
>       S = 1.0D0/mat_wasum(N,ZR,ZI,1)
>       CALL mat_wrscal(N,S,ZR,ZI,1)
> !
>       YNORM = 1.0D0
> !
> !     SOLVE L*V = Y
> !
>       DO K = 1, N
>          L = IPVT(K)
>          TR = ZR(L)
>          TI = ZI(L)
>          ZR(L) = ZR(K)
>          ZI(L) = ZI(K)
>          ZR(K) = TR
>          ZI(K) = TI
>          IF (K .LT. N) CALL matX_waxpy(N-K,TR,TI,AR(K+1,K),AI(K+1,K),1,ZR(K+1),ZI(K+1),1)
>          IF (CABS1(ZR(K),ZI(K)) .LE. 1.0D0) cycle
>             S = 1.0D0/CABS1(ZR(K),ZI(K))
>             CALL mat_wrscal(N,S,ZR,ZI,1)
>             YNORM = S*YNORM
>       enddo
>       S = 1.0D0/mat_wasum(N,ZR,ZI,1)
>       CALL mat_wrscal(N,S,ZR,ZI,1)
>       YNORM = S*YNORM
> !
> !     SOLVE  U*Z = V
> !
>       DO KB = 1, N
>          K = N + 1 - KB
>          IF (CABS1(ZR(K),ZI(K)) .LE. CABS1(AR(K,K),AI(K,K))) GOTO 170
>             S = CABS1(AR(K,K),AI(K,K)) / CABS1(ZR(K),ZI(K))
>             CALL mat_wrscal(N,S,ZR,ZI,1)
>             YNORM = S*YNORM
>   170    CONTINUE
>          IF (CABS1(AR(K,K),AI(K,K)) .EQ. 0.0D0) GOTO 180
>             CALL mat_wdiv(ZR(K),ZI(K),AR(K,K),AI(K,K),ZR(K),ZI(K))
>   180    CONTINUE
>          IF (CABS1(AR(K,K),AI(K,K)) .NE. 0.0D0) GOTO 190
>             ZR(K) = 1.0D0
>             ZI(K) = 0.0D0
>   190    CONTINUE
>          TR = -ZR(K)
>          TI = -ZI(K)
>          CALL matX_waxpy(K-1,TR,TI,AR(1,K),AI(1,K),1,ZR(1),ZI(1),1)
>       enddo
> !     MAKE ZNORM = 1.0
>       S = 1.0D0/mat_wasum(N,ZR,ZI,1)
>       CALL mat_wrscal(N,S,ZR,ZI,1)
>       YNORM = S*YNORM
> !
>       IF (ANORM .NE. 0.0D0) RCOND = YNORM/ANORM
>       IF (ANORM .EQ. 0.0D0) RCOND = 0.0D0
>       END SUBROUTINE ML_WGECO
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_WGEFA(AR,AI,LDA,N,IPVT,INFO)
>       use M_matrix
>       INTEGER LDA,N,IPVT(*),INFO
>       DOUBLEPRECISION AR(LDA,*),AI(LDA,*)
> !
> !     WGEFA FACTORS A DOUBLE-COMPLEX MATRIX BY GAUSSIAN ELIMINATION.
> !
> !     WGEFA IS USUALLY CALLED BY WGECO, BUT IT CAN BE CALLED
> !     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
> !     (TIME FOR WGECO) = (1 + 9/N)*(TIME FOR WGEFA) .
> !
> !     ON ENTRY
> !
> !        A       DOUBLE-COMPLEX(LDA, N)
> !                THE MATRIX TO BE FACTORED.
> !
> !        LDA     INTEGER
> !                THE LEADING DIMENSION OF THE ARRAY  A .
> !
> !        N       INTEGER
> !                THE ORDER OF THE MATRIX  A .
> !
> !     ON RETURN
> !
> !        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
> !                WHICH WERE USED TO OBTAIN IT.
> !                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
> !                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
> !                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
> !
> !        IPVT    INTEGER(N)
> !                AN INTEGER VECTOR OF PIVOT INDICES.
> !
> !        INFO    INTEGER
> !                = 0  NORMAL VALUE.
> !                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
> !  CONDITION FOR THIS SUBROUTINE, BUT IT DOES
> !  INDICATE THAT WGESL OR WGEDI WILL DIVIDE BY ZERO
> !  IF CALLED.  USE  RCOND  IN WGECO FOR A RELIABLE
> !  INDICATION OF SINGULARITY.
> !
> !     LINPACK. THIS VERSION DATED 07/01/79 .
> !     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
> !
> !     SUBROUTINES AND FUNCTIONS
> !
> !     BLAS WAXPY,WSCAL,mat_iwamax
> !     FORTRAN DABS
> !
> !     INTERNAL VARIABLES
> !
>       DOUBLEPRECISION TR,TI
>       INTEGER J,K,KP1,L,NM1
> !
>       DOUBLEPRECISION ZDUMR,ZDUMI
>       DOUBLEPRECISION CABS1
>       CABS1(ZDUMR,ZDUMI) = DABS(ZDUMR) + DABS(ZDUMI)
> !
> !     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
> !
>       INFO = 0
>       NM1 = N - 1
>       IF (NM1 .LT. 1) GOTO 70
>       DO 60 K = 1, NM1
>          KP1 = K + 1
> !
> !        FIND L = PIVOT INDEX
> !
>          L = mat_iwamax(N-K+1,AR(K,K),AI(K,K),1) + K - 1
>          IPVT(K) = L
> !
> !        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
> !
>          IF (CABS1(AR(L,K),AI(L,K)) .EQ. 0.0D0) GOTO 40
> !
> !           INTERCHANGE IF NECESSARY
> !
>             IF (L .EQ. K) GOTO 10
>                TR = AR(L,K)
>                TI = AI(L,K)
>                AR(L,K) = AR(K,K)
>                AI(L,K) = AI(K,K)
>                AR(K,K) = TR
>                AI(K,K) = TI
>    10       CONTINUE
> !
> !           COMPUTE MULTIPLIERS
> !
>             CALL mat_wdiv(-1.0D0,0.0D0,AR(K,K),AI(K,K),TR,TI)
>             CALL mat_wscal(N-K,TR,TI,AR(K+1,K),AI(K+1,K),1)
> !
> !           ROW ELIMINATION WITH COLUMN INDEXING
> !
>             DO J = KP1, N
>                TR = AR(L,J)
>                TI = AI(L,J)
>                IF (L .EQ. K) GOTO 20
>                   AR(L,J) = AR(K,J)
>                   AI(L,J) = AI(K,J)
>                   AR(K,J) = TR
>                   AI(K,J) = TI
>    20          CONTINUE
>                CALL matX_waxpy(N-K,TR,TI,AR(K+1,K),AI(K+1,K),1,AR(K+1,J),AI(K+1,J),1)
>             enddo
>          GOTO 50
>    40    CONTINUE
>             INFO = K
>    50    CONTINUE
>    60 CONTINUE
>    70 CONTINUE
>       IPVT(N) = N
>       IF (CABS1(AR(N,N),AI(N,N)) .EQ. 0.0D0) INFO = N
>       END SUBROUTINE ML_WGEFA
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_WGESL(AR,AI,LDA,N,IPVT,BR,BI,JOB)
> use M_matrix
> INTEGER LDA,N,IPVT(*),JOB
> DOUBLEPRECISION AR(LDA,*),AI(LDA,*),BR(*),BI(*)
> !
> !     WGESL SOLVES THE DOUBLE-COMPLEX SYSTEM
> !     A * X = B  OR  CTRANS(A) * X = B
> !     USING THE FACTORS COMPUTED BY WGECO OR WGEFA.
> !
> !     ON ENTRY
> !
> !        A       DOUBLE-COMPLEX(LDA, N)
> !                THE OUTPUT FROM WGECO OR WGEFA.
> !
> !        LDA     INTEGER
> !                THE LEADING DIMENSION OF THE ARRAY  A .
> !
> !        N       INTEGER
> !                THE ORDER OF THE MATRIX  A .
> !
> !        IPVT    INTEGER(N)
> !                THE PIVOT VECTOR FROM WGECO OR WGEFA.
> !
> !        B       DOUBLE-COMPLEX(N)
> !                THE RIGHT HAND SIDE VECTOR.
> !
> !        JOB     INTEGER
> !                = 0         TO SOLVE  A*X = B ,
> !                = NONZERO   TO SOLVE  CTRANS(A)*X = B  WHERE
> !         CTRANS(A)  IS THE CONJUGATE TRANSPOSE.
> !
> !     ON RETURN
> !
> !        B       THE SOLUTION VECTOR  X .
> !
> !     ERROR CONDITION
> !
> !        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
> !        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
> !        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
> !        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
> !        CALLED CORRECTLY AND IF WGECO HAS SET RCOND .GT. 0.0
> !        OR WGEFA HAS SET INFO .EQ. 0 .
> !
> !     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
> !     WITH  P  COLUMNS
> !           CALL ML_WGECO(A,LDA,N,IPVT,RCOND,Z)
> !           IF (RCOND IS TOO SMALL) GOTO ...
> !           DO J = 1, P
> !              CALL ML_WGESL(A,LDA,N,IPVT,C(1,J),0)
> !           enddo
> !
> !     LINPACK. THIS VERSION DATED 07/01/79 .
> !     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
> !
> !     SUBROUTINES AND FUNCTIONS
> !
> !     BLAS WAXPY,WDOTC
> !
> !     INTERNAL VARIABLES
> !
> DOUBLEPRECISION TR,TI
> INTEGER K,KB,L,NM1
> !
>    NM1 = N - 1
>    IF (JOB .NE. 0) GOTO 50
> !
> !        JOB = 0 , SOLVE  A * X = B
> !        FIRST SOLVE  L*Y = B
> !
>    IF (NM1 .GT. 1) then
>       DO K = 1, NM1
>          L = IPVT(K)
>          TR = BR(L)
>          TI = BI(L)
>          IF (L .NE. K) then
>             BR(L) = BR(K)
>             BI(L) = BI(K)
>             BR(K) = TR
>             BI(K) = TI
>          endif
>          CALL matX_waxpy(N-K,TR,TI,AR(K+1,K),AI(K+1,K),1,BR(K+1),BI(K+1),1)
>       enddo
>    endif
> !
> !        NOW SOLVE  U*X = Y
> !
>    DO KB = 1, N
>       K = N + 1 - KB
>       CALL mat_wdiv(BR(K),BI(K),AR(K,K),AI(K,K),BR(K),BI(K))
>       TR = -BR(K)
>       TI = -BI(K)
>       CALL matX_waxpy(K-1,TR,TI,AR(1,K),AI(1,K),1,BR(1),BI(1),1)
>    enddo
>    GOTO 100
> 50 CONTINUE
> !
> !  JOB = NONZERO, SOLVE  CTRANS(A) * X = B
> !  FIRST SOLVE  CTRANS(U)*Y = B
> !
>    DO K = 1, N
>       TR = BR(K) - mat_wdotcr(K-1,AR(1,K),AI(1,K),1,BR(1),BI(1),1)
>       TI = BI(K) - mat_wdotci(K-1,AR(1,K),AI(1,K),1,BR(1),BI(1),1)
>       CALL mat_wdiv(TR,TI,AR(K,K),-AI(K,K),BR(K),BI(K))
>    enddo
> !
> !        NOW SOLVE CTRANS(L)*X = Y
> !
>    IF (NM1 .GE. 1) then
>       DO KB = 1, NM1
>          K = N - KB
>          BR(K) = BR(K) + mat_wdotcr(N-K,AR(K+1,K),AI(K+1,K),1,BR(K+1),BI(K+1),1)
>          BI(K) = BI(K) + mat_wdotci(N-K,AR(K+1,K),AI(K+1,K),1,BR(K+1),BI(K+1),1)
>          L = IPVT(K)
>          IF (L .EQ. K) cycle
>          TR = BR(L)
>          TI = BI(L)
>          BR(L) = BR(K)
>          BI(L) = BI(K)
>          BR(K) = TR
>          BI(K) = TI
>       enddo
>    endif
> 100 continue
> end subroutine ml_wgesl
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_WGEDI(ar,ai,LDA,N,ipvt,detr,deti,workr,worki,JOB)
>       use M_matrix
>       INTEGER LDA,N,IPVT(*),JOB
>       DOUBLEPRECISION AR(LDA,*),AI(LDA,*),DETR(2),DETI(2),WORKR(*),WORKI(*)
> !
> !     WGEDI COMPUTES THE DETERMINANT AND INVERSE OF A MATRIX
> !     USING THE FACTORS COMPUTED BY WGECO OR WGEFA.
> !
> !     ON ENTRY
> !
> !        A       DOUBLE-COMPLEX(LDA, N)
> !                THE OUTPUT FROM WGECO OR WGEFA.
> !
> !        LDA     INTEGER
> !                THE LEADING DIMENSION OF THE ARRAY  A .
> !
> !        N       INTEGER
> !                THE ORDER OF THE MATRIX  A .
> !
> !        IPVT    INTEGER(N)
> !                THE PIVOT VECTOR FROM WGECO OR WGEFA.
> !
> !        WORK    DOUBLE-COMPLEX(N)
> !                WORK VECTOR.  CONTENTS DESTROYED.
> !
> !        JOB     INTEGER
> !                = 11   BOTH DETERMINANT AND INVERSE.
> !                = 01   INVERSE ONLY.
> !                = 10   DETERMINANT ONLY.
> !
> !     ON RETURN
> !
> !        A       INVERSE OF ORIGINAL MATRIX IF REQUESTED.
> !                OTHERWISE UNCHANGED.
> !
> !        DET     DOUBLE-COMPLEX(2)
> !                DETERMINANT OF ORIGINAL MATRIX IF REQUESTED.
> !                OTHERWISE NOT REFERENCED.
> !                DETERMINANT = DET(1) * 10.0**DET(2)
> !                WITH  1.0 .LE. CABS1(DET(1) .LT. 10.0
> !                OR  DET(1) .EQ. 0.0 .
> !
> !     ERROR CONDITION
> !
> !        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS
> !        A ZERO ON THE DIAGONAL AND THE INVERSE IS REQUESTED.
> !        IT WILL NOT OCCUR IF THE SUBROUTINES ARE CALLED CORRECTLY
> !        AND IF WGECO HAS SET RCOND .GT. 0.0 OR WGEFA HAS SET
> !        INFO .EQ. 0 .
> !
> !     LINPACK. THIS VERSION DATED 07/01/79 .
> !     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
> !
> !     SUBROUTINES AND FUNCTIONS
> !
> !     BLAS WAXPY,WSCAL,WSWAP
> !     FORTRAN DABS,MOD
> !
> !     INTERNAL VARIABLES
> !
>       DOUBLEPRECISION TR,TI
>       DOUBLEPRECISION TEN
>       INTEGER I,J,K,KB,KP1,L,NM1
> !
>       DOUBLEPRECISION ZDUMR,ZDUMI
>       DOUBLEPRECISION CABS1
>       CABS1(ZDUMR,ZDUMI) = DABS(ZDUMR) + DABS(ZDUMI)
> !
> !     COMPUTE DETERMINANT
> !
>       IF (JOB/10 .EQ. 0) GOTO 80
>          DETR(1) = 1.0D0
>          DETI(1) = 0.0D0
>          DETR(2) = 0.0D0
>          DETI(2) = 0.0D0
>          TEN = 10.0D0
>          DO 60 I = 1, N
>            IF (IPVT(I) .EQ. I) GOTO 10
>               DETR(1) = -DETR(1)
>               DETI(1) = -DETI(1)
>    10      CONTINUE
>            CALL mat_wmul(AR(I,I),AI(I,I),DETR(1),DETI(1),DETR(1),DETI(1))
> !          ...EXIT
> !       ...EXIT
>            IF (CABS1(DETR(1),DETI(1)) .EQ. 0.0D0) GOTO 70
>    20      IF (CABS1(DETR(1),DETI(1)) .GE. 1.0D0) GOTO 30
>               DETR(1) = TEN*DETR(1)
>               DETI(1) = TEN*DETI(1)
>               DETR(2) = DETR(2) - 1.0D0
>               DETI(2) = DETI(2) - 0.0D0
>            GOTO 20
>    30      CONTINUE
>    40      IF (CABS1(DETR(1),DETI(1)) .LT. TEN) GOTO 50
>               DETR(1) = DETR(1)/TEN
>               DETI(1) = DETI(1)/TEN
>               DETR(2) = DETR(2) + 1.0D0
>               DETI(2) = DETI(2) + 0.0D0
>            GOTO 40
>    50      CONTINUE
>    60    CONTINUE
>    70    CONTINUE
>    80 CONTINUE
> !
> !     COMPUTE INVERSE(U)
> !
>       IF (MOD(JOB,10) .EQ. 0) GOTO 160
>          DO K = 1, N
>             CALL mat_wdiv(1.0D0,0.0D0,AR(K,K),AI(K,K),AR(K,K),AI(K,K))
>             TR = -AR(K,K)
>             TI = -AI(K,K)
>             CALL mat_wscal(K-1,TR,TI,AR(1,K),AI(1,K),1)
>             KP1 = K + 1
>             IF (N .LT. KP1) cycle
>             DO J = KP1, N
>               TR = AR(K,J)
>               TI = AI(K,J)
>               AR(K,J) = 0.0D0
>               AI(K,J) = 0.0D0
>               CALL matX_waxpy(K,TR,TI,AR(1,K),AI(1,K),1,AR(1,J),AI(1,J),1)
>             enddo
>          enddo
> !
> !        FORM INVERSE(U)*INVERSE(L)
> !
>          NM1 = N - 1
>          IF (NM1 .LT. 1) GOTO 150
>          DO KB = 1, NM1
>             K = N - KB
>             KP1 = K + 1
>             DO I = KP1, N
>                WORKR(I) = AR(I,K)
>                WORKI(I) = AI(I,K)
>                AR(I,K) = 0.0D0
>                AI(I,K) = 0.0D0
>             enddo
>             DO J = KP1, N
>               TR = WORKR(J)
>               TI = WORKI(J)
>               CALL matX_waxpy(N,TR,TI,AR(1,J),AI(1,J),1,AR(1,K),AI(1,K),1)
>             enddo
>             L = IPVT(K)
>             IF (L .NE. K)CALL mat_wswap(N,AR(1,K),AI(1,K),1,AR(1,L),AI(1,L),1)
>          enddo
>   150    CONTINUE
>   160 CONTINUE
>       END SUBROUTINE ML_WGEDI
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_HTRIDI(NM,N,AR,AI,D,E,E2,TAU)
>       use M_matrix
> !
>       INTEGER I,J,K,L,N,II,NM,JP1
>       DOUBLEPRECISION AR(NM,N),AI(NM,N),D(N),E(N),E2(N),TAU(2,N)
>       DOUBLEPRECISION F,G,H,FI,GI,HH,SI,SCALE
> !
> !     THIS SUBROUTINE IS A TRANSLATION OF A COMPLEX ANALOGUE OF
> !     THE ALGOL PROCEDURE TRED1, NUM. MATH. 11, 181-195(1968)
> !     BY MARTIN, REINSCH, AND WILKINSON.
> !     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
> !
> !     THIS SUBROUTINE REDUCES A COMPLEX HERMITIAN MATRIX
> !     TO A REAL SYMMETRIC TRIDIAGONAL MATRIX USING
> !     UNITARY SIMILARITY TRANSFORMATIONS.
> !
> !     ON INPUT.
> !
> !        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
> !          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
> !          DIMENSION STATEMENT.
> !
> !        N IS THE ORDER OF THE MATRIX.
> !
> !        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE COMPLEX HERMITIAN INPUT MATRIX.
> !          ONLY THE LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
> !
> !     ON OUTPUT.
> !
> !        AR AND AI CONTAIN INFORMATION ABOUT THE UNITARY TRANS-
> !          FORMATIONS USED IN THE REDUCTION IN THEIR FULL LOWER
> !          TRIANGLES.  THEIR STRICT UPPER TRIANGLES AND THE
> !          DIAGONAL OF AR ARE UNALTERED.
> !
> !        D CONTAINS THE DIAGONAL ELEMENTS OF THE THE TRIDIAGONAL MATRIX.
> !
> !        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
> !          MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO.
> !
> !        E2 CONTAINS THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
> !          E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
> !
> !        TAU CONTAINS FURTHER INFORMATION ABOUT THE TRANSFORMATIONS.
> !
> !     MODIFIED TO GET RID OF ALL COMPLEX ARITHMETIC, C. MOLER, 6/27/79.
> !
> !     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
> !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
> !
> !     ------------------------------------------------------------------
> !
>       TAU(1,N) = 1.0D0
>       TAU(2,N) = 0.0D0
> !
>       DO I = 1, N
>          D(I) = AR(I,I)
>       enddo
> !     .......... FOR I=N STEP -1 UNTIL 1 DO -- ..........
>       DO 300 II = 1, N
>          I = N + 1 - II
>          L = I - 1
>          H = 0.0D0
>          SCALE = 0.0D0
>          IF (L .LT. 1) GOTO 130
> !     .......... SCALE ROW (ALGOL TOL THEN NOT NEEDED) ..........
>          DO K = 1, L
>             SCALE = mat_flop(SCALE + DABS(AR(I,K)) + DABS(AI(I,K)))
>          enddo
> !
>          IF (SCALE .NE. 0.0D0) GOTO 140
>          TAU(1,L) = 1.0D0
>          TAU(2,L) = 0.0D0
>   130    E(I) = 0.0D0
>          E2(I) = 0.0D0
>          GOTO 290
> !
>   140    continue
>          DO K = 1, L
>             AR(I,K) = mat_flop(AR(I,K)/SCALE)
>             AI(I,K) = mat_flop(AI(I,K)/SCALE)
>             H = mat_flop(H + AR(I,K)*AR(I,K) + AI(I,K)*AI(I,K))
>          enddo
> !
>          E2(I) = mat_flop(SCALE*SCALE*H)
>          G = mat_flop(DSQRT(H))
>          E(I) = mat_flop(SCALE*G)
>          F = mat_pythag(AR(I,L),AI(I,L))
> !     .......... FORM NEXT DIAGONAL ELEMENT OF MATRIX T ..........
>          IF (F .EQ. 0.0D0) GOTO 160
>          TAU(1,L) = mat_flop((AI(I,L)*TAU(2,I) - AR(I,L)*TAU(1,I))/F)
>          SI = mat_flop((AR(I,L)*TAU(2,I) + AI(I,L)*TAU(1,I))/F)
>          H = mat_flop(H + F*G)
>          G = mat_flop(1.0D0 + G/F)
>          AR(I,L) = mat_flop(G*AR(I,L))
>          AI(I,L) = mat_flop(G*AI(I,L))
>          IF (L .EQ. 1) GOTO 270
>          GOTO 170
>   160    TAU(1,L) = -TAU(1,I)
>          SI = TAU(2,I)
>          AR(I,L) = G
>   170    F = 0.0D0
> !
>          DO J = 1, L
>             G = 0.0D0
>             GI = 0.0D0
> !     .......... FORM ELEMENT OF A*U ..........
>             DO K = 1, J
>                G = mat_flop(G + AR(J,K)*AR(I,K) + AI(J,K)*AI(I,K))
>                GI = mat_flop(GI - AR(J,K)*AI(I,K) + AI(J,K)*AR(I,K))
>             enddo
> !
>             JP1 = J + 1
>             IF (L .LT. JP1) GOTO 220
> !
>             DO K = JP1, L
>                G = mat_flop(G + AR(K,J)*AR(I,K) - AI(K,J)*AI(I,K))
>                GI = mat_flop(GI - AR(K,J)*AI(I,K) - AI(K,J)*AR(I,K))
>             enddo
> !     .......... FORM ELEMENT OF P ..........
>   220       continue
>             E(J) = mat_flop(G/H)
>             TAU(2,J) = mat_flop(GI/H)
>             F = mat_flop(F + E(J)*AR(I,J) - TAU(2,J)*AI(I,J))
>          enddo
> !
>          HH = mat_flop(F/(H + H))
> !     .......... FORM REDUCED A ..........
>          DO J = 1, L
>             F = AR(I,J)
>             G = mat_flop(E(J) - HH*F)
>             E(J) = G
>             FI = -AI(I,J)
>             GI = mat_flop(TAU(2,J) - HH*FI)
>             TAU(2,J) = -GI
> !
>             DO K = 1, J
>                AR(J,K) = mat_flop(AR(J,K) - F*E(K) - G*AR(I,K) + FI*TAU(2,K) + GI*AI(I,K))
>                AI(J,K) = mat_flop(AI(J,K) - F*TAU(2,K) - G*AI(I,K) - FI*E(K) - GI*AR(I,K))
>             enddo
>          enddo
> !
>   270    continue
>          DO K = 1, L
>             AR(I,K) = mat_flop(SCALE*AR(I,K))
>             AI(I,K) = mat_flop(SCALE*AI(I,K))
>          enddo
> !
>          TAU(2,L) = -SI
>   290    HH = D(I)
>          D(I) = AR(I,I)
>          AR(I,I) = HH
>          AI(I,I) = mat_flop(SCALE*DSQRT(H))
>   300 CONTINUE
> !
> END SUBROUTINE ML_HTRIDI
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_HTRIBK(NM,N,AR,AI,TAU,M,ZR,ZI)
> use M_matrix
> !
> INTEGER I,J,K,L,M,N,NM
> DOUBLEPRECISION AR(NM,N),AI(NM,N),TAU(2,N),ZR(NM,M),ZI(NM,M)
> DOUBLEPRECISION H,S,SI
> !
> !     THIS SUBROUTINE IS A TRANSLATION OF A COMPLEX ANALOGUE OF
> !     THE ALGOL PROCEDURE TRBAK1, NUM. MATH. 11, 181-195(1968)
> !     BY MARTIN, REINSCH, AND WILKINSON.
> !     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
> !
> !     THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX HERMITIAN
> !     MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
> !     REAL SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY  HTRIDI.
> !
> !     ON INPUT.
> !
> !        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
> !          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
> !          DIMENSION STATEMENT.
> !
> !        N IS THE ORDER OF THE MATRIX.
> !
> !        AR AND AI CONTAIN INFORMATION ABOUT THE UNITARY TRANS-
> !          FORMATIONS USED IN THE REDUCTION BY  HTRIDI  IN THEIR
> !          FULL LOWER TRIANGLES EXCEPT FOR THE DIAGONAL OF AR.
> !
> !        TAU CONTAINS FURTHER INFORMATION ABOUT THE TRANSFORMATIONS.
> !
> !        M IS THE NUMBER OF EIGENVECTORS TO BE BACK TRANSFORMED.
> !
> !        ZR CONTAINS THE EIGENVECTORS TO BE BACK TRANSFORMED
> !          IN ITS FIRST M COLUMNS.
> !
> !     ON OUTPUT.
> !
> !        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE TRANSFORMED EIGENVECTORS
> !          IN THEIR FIRST M COLUMNS.
> !
> !     NOTE THAT THE LAST COMPONENT OF EACH RETURNED VECTOR
> !     IS REAL AND THAT VECTOR EUCLIDEAN NORMS ARE PRESERVED.
> !
> !     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
> !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
> !
> !     ------------------------------------------------------------------
> !
>    IF (M .EQ. 0) GOTO 200
> !     .......... TRANSFORM THE EIGENVECTORS OF THE REAL SYMMETRIC
> !                TRIDIAGONAL MATRIX TO THOSE OF THE HERMITIAN
> !                TRIDIAGONAL MATRIX. ..........
>    DO K = 1, N
>       DO J = 1, M
>          ZI(K,J) = mat_flop(-(ZR(K,J)*TAU(2,K)))
>          ZR(K,J) = mat_flop(ZR(K,J)*TAU(1,K))
>       enddo
>    enddo
> !
>    IF (N .EQ. 1) GOTO 200
> !     .......... RECOVER AND APPLY THE HOUSEHOLDER MATRICES ..........
>    DO I = 2, N
>       L = I - 1
>       H = AI(I,I)
>       IF (H .EQ. 0.0D0) exit
>       DO J = 1, M
>          S = 0.0D0
>          SI = 0.0D0
>          DO K = 1, L
>             S = mat_flop(S + AR(I,K)*ZR(K,J) - AI(I,K)*ZI(K,J))
>             SI = mat_flop(SI + AR(I,K)*ZI(K,J) + AI(I,K)*ZR(K,J))
>          enddo
> !     .......... DOUBLE DIVISIONS AVOID POSSIBLE UNDERFLOW ..........
>          S = mat_flop((S/H)/H)
>          SI = mat_flop((SI/H)/H)
>          DO K = 1, L
>             ZR(K,J) = mat_flop(ZR(K,J) - S*AR(I,K) - SI*AI(I,K))
>             ZI(K,J) = mat_flop(ZI(K,J) - SI*AR(I,K) + S*AI(I,K))
>          enddo
>       enddo
>    enddo
> !
> 200 continue
> END SUBROUTINE ML_HTRIBK
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_IMTQL2(NM,N,D,E,Z,IERR,JOB)
>       use M_matrix
>       IMPLICIT NONE
>       INTEGER I,J,K,L,M,N,II,NM,MML,IERR
>       integer :: job
>       DOUBLEPRECISION D(N),E(N),Z(NM,N)
>       DOUBLEPRECISION B,C,F,G,P,R,S
> !
> !     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE IMTQL2,
> !     NUM. MATH. 12, 377-383(1968) BY MARTIN AND WILKINSON,
> !     AS MODIFIED IN NUM. MATH. 15, 450(1970) BY DUBRULLE.
> !     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 241-248(1971).
> !
> !     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
> !     OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE IMPLICIT QL METHOD.
> !     THE EIGENVECTORS OF A FULL SYMMETRIC MATRIX CAN ALSO
> !     BE FOUND IF  TRED2  HAS BEEN USED TO REDUCE THIS
> !     FULL MATRIX TO TRIDIAGONAL FORM.
> !
> !     ON INPUT.
> !
> !        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
> !          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
> !          DIMENSION STATEMENT.
> !
> !        N IS THE ORDER OF THE MATRIX.
> !
> !        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
> !
> !        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
> !          IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY.
> !
> !        Z CONTAINS THE TRANSFORMATION MATRIX PRODUCED IN THE
> !          REDUCTION BY  TRED2, IF PERFORMED.  IF THE EIGENVECTORS
> !          OF THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN
> !          THE IDENTITY MATRIX.
> !
> !      ON OUTPUT.
> !
> !        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
> !          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT
> !          UNORDERED FOR INDICES 1,2,...,IERR-1.
> !
> !        E HAS BEEN DESTROYED.
> !
> !        Z CONTAINS ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
> !          TRIDIAGONAL (OR FULL) MATRIX.  IF AN ERROR EXIT IS MADE,
> !          Z CONTAINS THE EIGENVECTORS ASSOCIATED WITH THE STORED
> !          EIGENVALUES.
> !
> !        IERR IS SET TO
> !          ZERO       FOR NORMAL RETURN,
> !          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
> !  DETERMINED AFTER 30 ITERATIONS.
> !
> !     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
> !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
> !
> !     ------------------------------------------------------------------
> !
> !
> !*****
> !     MODIFIED BY C. MOLER TO ELIMINATE MACHEP 11/22/78
> !     MODIFIED TO ADD JOB PARAMETER 08/27/79
> !*****
>       IERR = 0
>       IF (N .EQ. 1) GOTO 1001
> !
>       DO I = 2, N
>          E(I-1) = E(I)
>       enddo
> !
>       E(N) = 0.0D0
> !
>       DO 240 L = 1, N
>          J = 0
> !     .......... LOOK FOR SMALL SUB-DIAGONAL ELEMENT ..........
>   105    continue
>          DO M = L, N
>             IF (M .EQ. N) GOTO 120
> !*****
>             P = mat_flop(DABS(D(M)) + DABS(D(M+1)))
>             S = mat_flop(P + DABS(E(M)))
>             IF (P .EQ. S) GOTO 120
> !*****
>          enddo
> !
>   120    continue
>          P = D(L)
>          IF (M .EQ. L) GOTO 240
>          IF (J .EQ. 30) GOTO 1000
>          J = J + 1
> !     .......... FORM SHIFT ..........
>          G = mat_flop((D(L+1) - P)/(2.0D0*E(L)))
>          R = mat_flop(DSQRT(G*G+1.0D0))
>          G = mat_flop(D(M) - P + E(L)/(G + DSIGN(R,G)))
>          S = 1.0D0
>          C = 1.0D0
>          P = 0.0D0
>          MML = M - L
> !     .......... FOR I=M-1 STEP -1 UNTIL L DO -- ..........
>          DO 200 II = 1, MML
>             I = M - II
>             F = mat_flop(S*E(I))
>             B = mat_flop(C*E(I))
>             IF (DABS(F) .LT. DABS(G)) GOTO 150
>             C = mat_flop(G/F)
>             R = mat_flop(DSQRT(C*C+1.0D0))
>             E(I+1) = mat_flop(F*R)
>             S = mat_flop(1.0D0/R)
>             C = mat_flop(C*S)
>             GOTO 160
>   150       S = mat_flop(F/G)
>             R = mat_flop(DSQRT(S*S+1.0D0))
>             E(I+1) = mat_flop(G*R)
>             C = mat_flop(1.0D0/R)
>             S = mat_flop(S*C)
>   160       G = mat_flop(D(I+1) - P)
>             R = mat_flop((D(I) - G)*S + 2.0D0*C*B)
>             P = mat_flop(S*R)
>             D(I+1) = G + P
>             G = mat_flop(C*R - B)
>             IF (JOB .EQ. 0) GOTO 185
> !     .......... FORM VECTOR ..........
>             DO K = 1, N
>                F = Z(K,I+1)
>                Z(K,I+1) = mat_flop(S*Z(K,I) + C*F)
>                Z(K,I) = mat_flop(C*Z(K,I) - S*F)
>             enddo
>   185       CONTINUE
> !
>   200    CONTINUE
> !
>          D(L) = mat_flop(D(L) - P)
>          E(L) = G
>          E(M) = 0.0D0
>          GOTO 105
>   240 CONTINUE
> !     .......... ORDER EIGENVALUES AND EIGENVECTORS ..........
>       DO II = 2, N
>          I = II - 1
>          K = I
>          P = D(I)
> !
>          DO J = II, N
>             IF (D(J) .GE. P) exit
>             K = J
>             P = D(J)
>          enddo
> !
>          IF (K .EQ. I) exit
>          D(K) = D(I)
>          D(I) = P
> !
>          IF (JOB .EQ. 0) cycle
>          DO J = 1, N
>             P = Z(J,I)
>             Z(J,I) = Z(J,K)
>             Z(J,K) = P
>          enddo
>       enddo
> !
>       GOTO 1001
> !     .......... SET ERROR -- NO CONVERGENCE TO AN
> !                EIGENVALUE AFTER 30 ITERATIONS ..........
>  1000 CONTINUE
>       IERR = L
>  1001 CONTINUE
>       RETURN
>       END SUBROUTINE ML_IMTQL2
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_CORTH(NM,N,LOW,IGH,AR,AI,ORTR,ORTI)
> use M_matrix
> !
> INTEGER I,J,M,N,II,JJ,LA,MP,NM,IGH,KP1,LOW
> DOUBLEPRECISION AR(NM,N),AI(NM,N),ORTR(IGH),ORTI(IGH)
> DOUBLEPRECISION F,G,H,FI,FR,SCALE
> !
> !     THIS SUBROUTINE IS A TRANSLATION OF A COMPLEX ANALOGUE OF
> !     THE ALGOL PROCEDURE ORTHES, NUM. MATH. 12, 349-368(1968)
> !     BY MARTIN AND WILKINSON.
> !     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 339-358(1971).
> !
> !     GIVEN A COMPLEX GENERAL MATRIX, THIS SUBROUTINE
> !     REDUCES A SUBMATRIX SITUATED IN ROWS AND COLUMNS
> !     LOW THROUGH IGH TO UPPER HESSENBERG FORM BY
> !     UNITARY SIMILARITY TRANSFORMATIONS.
> !
> !     ON INPUT.
> !
> !        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
> !          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
> !          DIMENSION STATEMENT.
> !
> !        N IS THE ORDER OF THE MATRIX.
> !
> !        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING
> !          SUBROUTINE ML_CBAL.  IF  CBAL  HAS NOT BEEN USED,
> !          SET LOW=1, IGH=N.
> !
> !        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE COMPLEX INPUT MATRIX.
> !
> !     ON OUTPUT.
> !
> !        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE HESSENBERG MATRIX.  INFORMATION
> !          ABOUT THE UNITARY TRANSFORMATIONS USED IN THE REDUCTION
> !          IS STORED IN THE REMAINING TRIANGLES UNDER THE
> !          HESSENBERG MATRIX.
> !
> !        ORTR AND ORTI CONTAIN FURTHER INFORMATION ABOUT THE
> !          TRANSFORMATIONS.  ONLY ELEMENTS LOW THROUGH IGH ARE USED.
> !
> !     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
> !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
> !
> !     ------------------------------------------------------------------
> !
>    LA = IGH - 1
>    KP1 = LOW + 1
>    IF (LA .LT. KP1) GOTO 200
> !
>    DO M = KP1, LA
>       H = 0.0D0
>       ORTR(M) = 0.0D0
>       ORTI(M) = 0.0D0
>       SCALE = 0.0D0
> !     .......... SCALE COLUMN (ALGOL TOL THEN NOT NEEDED) ..........
>       DO I = M, IGH
>          SCALE = mat_flop(SCALE + DABS(AR(I,M-1)) + DABS(AI(I,M-1)))
>       enddo
> !
>       IF (SCALE .EQ. 0.0D0) cycle
>       MP = M + IGH
> !     .......... FOR I=IGH STEP -1 UNTIL M DO -- ..........
>       DO II = M, IGH
>          I = MP - II
>          ORTR(I) = mat_flop(AR(I,M-1)/SCALE)
>          ORTI(I) = mat_flop(AI(I,M-1)/SCALE)
>          H = mat_flop(H + ORTR(I)*ORTR(I) + ORTI(I)*ORTI(I))
>       enddo
> !
>       G = mat_flop(DSQRT(H))
>       F = mat_pythag(ORTR(M),ORTI(M))
>       IF (F .EQ. 0.0D0) GOTO 103
>       H = mat_flop(H + F*G)
>       G = mat_flop(G/F)
>       ORTR(M) = mat_flop((1.0D0 + G)*ORTR(M))
>       ORTI(M) = mat_flop((1.0D0 + G)*ORTI(M))
>       GOTO 105
> !
> 103   continue
>       ORTR(M) = G
>       AR(M,M-1) = SCALE
> !     .......... FORM (I-(U*UT)/H)*A ..........
> 105   continue
>       DO J = M, N
>          FR = 0.0D0
>          FI = 0.0D0
> !     .......... FOR I=IGH STEP -1 UNTIL M DO -- ..........
>          DO II = M, IGH
>             I = MP - II
>             FR = mat_flop(FR + ORTR(I)*AR(I,J) + ORTI(I)*AI(I,J))
>             FI = mat_flop(FI + ORTR(I)*AI(I,J) - ORTI(I)*AR(I,J))
>          enddo
> !
>          FR = mat_flop(FR/H)
>          FI = mat_flop(FI/H)
> !
>          DO I = M, IGH
>             AR(I,J) = mat_flop(AR(I,J) - FR*ORTR(I) + FI*ORTI(I))
>             AI(I,J) = mat_flop(AI(I,J) - FR*ORTI(I) - FI*ORTR(I))
>          enddo
> !
>       enddo
> !     .......... FORM (I-(U*UT)/H)*A*(I-(U*UT)/H) ..........
>       DO I = 1, IGH
>          FR = 0.0D0
>          FI = 0.0D0
> !     .......... FOR J=IGH STEP -1 UNTIL M DO -- ..........
>          DO JJ = M, IGH
>             J = MP - JJ
>             FR = mat_flop(FR + ORTR(J)*AR(I,J) - ORTI(J)*AI(I,J))
>             FI = mat_flop(FI + ORTR(J)*AI(I,J) + ORTI(J)*AR(I,J))
>          enddo
> !
>          FR = mat_flop(FR/H)
>          FI = mat_flop(FI/H)
> !
>          DO J = M, IGH
>             AR(I,J) = mat_flop(AR(I,J) - FR*ORTR(J) - FI*ORTI(J))
>             AI(I,J) = mat_flop(AI(I,J) + FR*ORTI(J) - FI*ORTR(J))
>          enddo
> !
>       enddo
> !
>       ORTR(M) = mat_flop(SCALE*ORTR(M))
>       ORTI(M) = mat_flop(SCALE*ORTI(M))
>       AR(M,M-1) = mat_flop(-(G*AR(M,M-1)))
>       AI(M,M-1) = mat_flop(-(G*AI(M,M-1)))
>    enddo
> !
> 200 continue
> END SUBROUTINE ML_CORTH
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> subroutine ml_comqr3(nm,n,low,igh,ortr,orti,hr,hi,wr,wi,zr,zi,ierr ,job)
> !*****
> !     MODIFICATION OF EISPACK COMQR2 TO ADD JOB PARAMETER
> !     JOB = 0  OUTPUT H = SCHUR TRIANGULAR FORM, Z NOT USED
> !         = 1  OUTPUT H = SCHUR FORM, Z = UNITARY SIMILARITY
> !         = 2  SAME AS COMQR2
> !         = 3  OUTPUT H = HESSENBERG FORM, Z = UNITARY SIMILARITY
> !     ALSO ELIMINATE MACHEP
> !     C. MOLER, 11/22/78 AND 09/14/80
> !     OVERFLOW CONTROL IN EIGENVECTOR BACKSUBSTITUTION, 3/16/82
> !*****
> !
> !
> !     THIS SUBROUTINE IS A TRANSLATION OF A UNITARY ANALOGUE OF THE
> !     ALGOL PROCEDURE  COMLR2, NUM. MATH. 16, 181-204(1970) BY PETERS
> !     AND WILKINSON.
> !     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971).
> !     THE UNITARY ANALOGUE SUBSTITUTES THE QR ALGORITHM OF FRANCIS
> !     (COMP. JOUR. 4, 332-345(1962)) FOR THE LR ALGORITHM.
> !
> !     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
> !     OF A COMPLEX UPPER HESSENBERG MATRIX BY THE QR
> !     METHOD.  THE EIGENVECTORS OF A COMPLEX GENERAL MATRIX
> !     CAN ALSO BE FOUND IF  CORTH  HAS BEEN USED TO REDUCE
> !     THIS GENERAL MATRIX TO HESSENBERG FORM.
> !
> !     ON INPUT.
> !
> !        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
> !          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
> !          DIMENSION STATEMENT.
> !
> !        N IS THE ORDER OF THE MATRIX.
> !
> !        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING
> !          SUBROUTINE ML_CBAL.  IF  CBAL  HAS NOT BEEN USED,
> !          SET LOW=1, IGH=N.
> !
> !        ORTR AND ORTI CONTAIN INFORMATION ABOUT THE UNITARY TRANS-
> !          FORMATIONS USED IN THE REDUCTION BY  CORTH, IF PERFORMED.
> !          ONLY ELEMENTS LOW THROUGH IGH ARE USED.  IF THE EIGENVECTORS
> !          OF THE HESSENBERG MATRIX ARE DESIRED, SET ORTR(J) AND
> !          ORTI(J) TO 0.0D0 FOR THESE ELEMENTS.
> !
> !        HR AND HI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE COMPLEX UPPER HESSENBERG MATRIX.
> !          THEIR LOWER TRIANGLES BELOW THE SUBDIAGONAL CONTAIN FURTHER
> !          INFORMATION ABOUT THE TRANSFORMATIONS WHICH WERE USED IN THE
> !          REDUCTION BY  CORTH, IF PERFORMED.  IF THE EIGENVECTORS OF
> !          THE HESSENBERG MATRIX ARE DESIRED, THESE ELEMENTS MAY BE
> !          ARBITRARY.
> !
> !     ON OUTPUT.
> !
> !        ORTR, ORTI, AND THE UPPER HESSENBERG PORTIONS OF HR AND HI
> !          HAVE BEEN DESTROYED.
> !
> !        WR AND WI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE EIGENVALUES.  IF AN ERROR
> !          EXIT IS MADE, THE EIGENVALUES SHOULD BE CORRECT
> !          FOR INDICES IERR+1,...,N.
> !
> !        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,
> !          RESPECTIVELY, OF THE EIGENVECTORS.  THE EIGENVECTORS
> !          ARE UNNORMALIZED.  IF AN ERROR EXIT IS MADE, NONE OF
> !          THE EIGENVECTORS HAS BEEN FOUND.
> !
> !        IERR IS SET TO
> !          ZERO       FOR NORMAL RETURN,
> !          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
> !  DETERMINED AFTER A TOTAL OF 30*N ITERATIONS.
> !
> !     MODIFIED TO GET RID OF ALL COMPLEX ARITHMETIC, C. MOLER, 6/27/79.
> !
> !     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
> !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
> !
> !     ------------------------------------------------------------------
> use M_matrix
> integer i,j,k,l,m,n,en,ii,ll,nm,nn,igh,ip1,itn,its,low,lp1,enm1,iend,ierr
> doubleprecision hr(nm,n),hi(nm,n),wr(n),wi(n),zr(nm,n),zi(nm,n),ortr(igh),orti(igh)
> doubleprecision si,sr,ti,tr,xi,xr,yi,yr,zzi,zzr,norm
> integer :: job
> integer :: jj
>    ierr = 0
>    !*****
>    if (job .eq. 0) goto 150
>    !*****
> !     .......... INITIALIZE EIGENVECTOR MATRIX ..........
>    do i = 1, n
>       do j = 1, n
>          zr(i,j) = 0.0d0
>          zi(i,j) = 0.0d0
>          if (i .eq. j) zr(i,j) = 1.0d0
>       enddo
>    enddo
> !     .......... FORM THE MATRIX OF ACCUMULATED TRANSFORMATIONS
> !                FROM THE INFORMATION LEFT BY CORTH ..........
>    iend = igh - low - 1
>    if (iend) 180, 150, 105
> !     .......... for i=igh-1 step -1 until low+1 do -- ..........
> 105 continue
>    do ii = 1, iend
>       i = igh - ii
>       if (ortr(i) .eq. 0.0d0 .and. orti(i) .eq. 0.0d0) cycle
>       if (hr(i,i-1) .eq. 0.0d0 .and. hi(i,i-1) .eq. 0.0d0) cycle
> !     .......... NORM BELOW IS NEGATIVE OF H FORMED IN CORTH ..........
>       norm = mat_flop(hr(i,i-1)*ortr(i) + hi(i,i-1)*orti(i))
>       ip1 = i + 1
> 
>       do k = ip1, igh
>          ortr(k) = hr(k,i-1)
>          orti(k) = hi(k,i-1)
>       enddo
> 
>       do j = i, igh
>          sr = 0.0d0
>          si = 0.0d0
> 
>          do k = i, igh
>             sr = mat_flop(sr + ortr(k)*zr(k,j) + orti(k)*zi(k,j))
>             si = mat_flop(si + ortr(k)*zi(k,j) - orti(k)*zr(k,j))
>          enddo
> 
>          sr = mat_flop(sr/norm)
>          si = mat_flop(si/norm)
> 
>          do k = i, igh
>             zr(k,j) = mat_flop(zr(k,j) + sr*ortr(k) - si*orti(k))
>             zi(k,j) = mat_flop(zi(k,j) + sr*orti(k) + si*ortr(k))
>          enddo
> 
>       enddo
> 
>    enddo
>    !*****
>    if (job .eq. 3) goto 1001
>    !*****
> !     .......... CREATE REAL SUBDIAGONAL ELEMENTS ..........
> 150 continue
>    l = low + 1
> 
>    do i = l, igh
>       ll = min0(i+1,igh)
>       if (hi(i,i-1) .eq. 0.0d0) cycle
>       norm = mat_pythag(hr(i,i-1),hi(i,i-1))
>       yr = mat_flop(hr(i,i-1)/norm)
>       yi = mat_flop(hi(i,i-1)/norm)
>       hr(i,i-1) = norm
>       hi(i,i-1) = 0.0d0
> 
>       do j = i, n
>          si = mat_flop(yr*hi(i,j) - yi*hr(i,j))
>          hr(i,j) = mat_flop(yr*hr(i,j) + yi*hi(i,j))
>          hi(i,j) = si
>       enddo
> 
>       do j = 1, ll
>          si = mat_flop(yr*hi(j,i) + yi*hr(j,i))
>          hr(j,i) = mat_flop(yr*hr(j,i) - yi*hi(j,i))
>          hi(j,i) = si
>       enddo
>       !*****
>       if (job .eq. 0) cycle
>       !*****
>       do j = low, igh
>          si = mat_flop(yr*zi(j,i) + yi*zr(j,i))
>          zr(j,i) = mat_flop(yr*zr(j,i) - yi*zi(j,i))
>          zi(j,i) = si
>       enddo
> 
>    enddo
> !     .......... STORE ROOTS ISOLATED BY CBAL ..........
> 180 continue
>    do i = 1, n
>       if (i .ge. low .and. i .le. igh) cycle
>       wr(i) = hr(i,i)
>       wi(i) = hi(i,i)
>    enddo
> 
>    en = igh
>    tr = 0.0d0
>    ti = 0.0d0
>    itn = 30*n
> !     .......... SEARCH FOR NEXT EIGENVALUE ..........
> 220 continue
>    if (en .lt. low) goto 680
>    its = 0
>    enm1 = en - 1
> !     .......... LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT
> !                FOR L=EN STEP -1 UNTIL LOW DO -- ..........
> 240 continue
>    do ll = low, en
>       l = en + low - ll
>       if (l .eq. low) exit
>       !*****
>       xr = mat_flop(dabs(hr(l-1,l-1)) + dabs(hi(l-1,l-1)) + dabs(hr(l,l)) +dabs(hi(l,l)))
>       yr = mat_flop(xr + dabs(hr(l,l-1)))
>       if (xr .eq. yr) exit
>       !*****
>    enddo
> !     .......... FORM SHIFT ..........
>    if (l .eq. en) goto 660
>    if (itn .eq. 0) goto 1000
>    if (its .eq. 10 .or. its .eq. 20) goto 320
>    sr = hr(en,en)
>    si = hi(en,en)
>    xr = mat_flop(hr(enm1,en)*hr(en,enm1))
>    xi = mat_flop(hi(enm1,en)*hr(en,enm1))
>    if (xr .eq. 0.0d0 .and. xi .eq. 0.0d0) goto 340
>    yr = mat_flop((hr(enm1,enm1) - sr)/2.0d0)
>    yi = mat_flop((hi(enm1,enm1) - si)/2.0d0)
>    call mat_wsqrt(yr**2-yi**2+xr,2.0d0*yr*yi+xi,zzr,zzi)
>    if (yr*zzr + yi*zzi .ge. 0.0d0) goto 310
>    zzr = -zzr
>    zzi = -zzi
> 310 continue
>    call mat_wdiv(xr,xi,yr+zzr,yi+zzi,zzr,zzi)
>    sr = mat_flop(sr - zzr)
>    si = mat_flop(si - zzi)
>    goto 340
> !     .......... FORM EXCEPTIONAL SHIFT ..........
> 320 continue
>    sr = mat_flop(dabs(hr(en,enm1)) + dabs(hr(enm1,en-2)))
>    si = 0.0d0
> 
> 340 continue
>    do i = low, en
>       hr(i,i) = mat_flop(hr(i,i) - sr)
>       hi(i,i) = mat_flop(hi(i,i) - si)
>    enddo
> 
>    tr = mat_flop(tr + sr)
>    ti = mat_flop(ti + si)
>    its = its + 1
>    itn = itn - 1
> !     .......... REDUCE TO TRIANGLE (ROWS) ..........
>    lp1 = l + 1
> 
>    do i = lp1, en
>       sr = hr(i,i-1)
>       hr(i,i-1) = 0.0d0
>       norm= mat_flop(dabs(hr(i-1,i-1)) + dabs(hi(i-1,i-1)) + dabs(sr))
>       norm= mat_flop(norm*dsqrt((hr(i-1,i-1)/norm)**2 + (hi(i-1,i-1)/norm)**2 + (sr/norm)**2))
>       xr = mat_flop(hr(i-1,i-1)/norm)
>       wr(i-1) = xr
>       xi = mat_flop(hi(i-1,i-1)/norm)
>       wi(i-1) = xi
>       hr(i-1,i-1) = norm
>       hi(i-1,i-1) = 0.0d0
>       hi(i,i-1) = mat_flop(sr/norm)
> 
>       do j = i, n
>          yr = hr(i-1,j)
>          yi = hi(i-1,j)
>          zzr = hr(i,j)
>          zzi = hi(i,j)
>          hr(i-1,j) = mat_flop(xr*yr + xi*yi + hi(i,i-1)*zzr)
>          hi(i-1,j) = mat_flop(xr*yi - xi*yr + hi(i,i-1)*zzi)
>          hr(i,j) = mat_flop(xr*zzr - xi*zzi - hi(i,i-1)*yr)
>          hi(i,j) = mat_flop(xr*zzi + xi*zzr - hi(i,i-1)*yi)
>       enddo
> 
>    enddo
> 
>    si = hi(en,en)
>    if (si .eq. 0.0d0) goto 540
>    norm = mat_pythag(hr(en,en),si)
>    sr = mat_flop(hr(en,en)/norm)
>    si = mat_flop(si/norm)
>    hr(en,en) = norm
>    hi(en,en) = 0.0d0
>    if (en .eq. n) goto 540
>    ip1 = en + 1
> 
>    do j = ip1, n
>       yr = hr(en,j)
>       yi = hi(en,j)
>       hr(en,j) = mat_flop(sr*yr + si*yi)
>       hi(en,j) = mat_flop(sr*yi - si*yr)
>    enddo
> !     .......... INVERSE OPERATION (COLUMNS) ..........
> 540 continue
>    do j = lp1, en
>       xr = wr(j-1)
>       xi = wi(j-1)
> 
>       do i = 1, j
>          yr = hr(i,j-1)
>          yi = 0.0d0
>          zzr = hr(i,j)
>          zzi = hi(i,j)
>          if (i .eq. j) goto 560
>          yi = hi(i,j-1)
>          hi(i,j-1) = mat_flop(xr*yi + xi*yr + hi(j,j-1)*zzi)
> 560      continue
>          hr(i,j-1) = mat_flop(xr*yr - xi*yi + hi(j,j-1)*zzr)
>          hr(i,j) = mat_flop(xr*zzr + xi*zzi - hi(j,j-1)*yr)
>          hi(i,j) = mat_flop(xr*zzi - xi*zzr - hi(j,j-1)*yi)
>       enddo
> !*****
>       if (job .eq. 0) cycle
> !*****
>       do i = low, igh
>          yr = zr(i,j-1)
>          yi = zi(i,j-1)
>          zzr = zr(i,j)
>          zzi = zi(i,j)
>          zr(i,j-1) = mat_flop(xr*yr - xi*yi + hi(j,j-1)*zzr)
>          zi(i,j-1) = mat_flop(xr*yi + xi*yr + hi(j,j-1)*zzi)
>          zr(i,j) = mat_flop(xr*zzr + xi*zzi - hi(j,j-1)*yr)
>          zi(i,j) = mat_flop(xr*zzi - xi*zzr - hi(j,j-1)*yi)
>       enddo
> 
>    enddo
> 
>    if (si .eq. 0.0d0) goto 240
> 
>    do i = 1, en
>       yr = hr(i,en)
>       yi = hi(i,en)
>       hr(i,en) = mat_flop(sr*yr - si*yi)
>       hi(i,en) = mat_flop(sr*yi + si*yr)
>    enddo
> !*****
>    if (job .eq. 0) goto 240
> !*****
>    do i = low, igh
>       yr = zr(i,en)
>       yi = zi(i,en)
>       zr(i,en) = mat_flop(sr*yr - si*yi)
>       zi(i,en) = mat_flop(sr*yi + si*yr)
>    enddo
> 
>    goto 240
> !     .......... A ROOT FOUND ..........
> 660 continue
>    hr(en,en) = mat_flop(hr(en,en) + tr)
>    wr(en) = hr(en,en)
>    hi(en,en) = mat_flop(hi(en,en) + ti)
>    wi(en) = hi(en,en)
>    en = enm1
>    goto 220
> !     .......... ALL ROOTS FOUND.  BACKSUBSTITUTE TO FIND
> !                VECTORS OF UPPER TRIANGULAR FORM ..........
> !
> !*****  THE FOLLOWING SECTION CHANGED FOR OVERFLOW CONTROL
> !       C. MOLER, 3/16/82
> !
> 680 continue
>    if (job .ne. 2) goto 1001
> 
>    norm = 0.0d0
>    do i = 1, n
>       do j = i, n
>          tr = mat_flop(dabs(hr(i,j))) + mat_flop(dabs(hi(i,j)))
>          if (tr .gt. norm) norm = tr
>       enddo
>    enddo
>    if (n .eq. 1 .or. norm .eq. 0.0d0) goto 1001
> !     .......... FOR EN=N STEP -1 UNTIL 2 DO -- ..........
>    do nn = 2, n
>       en = n + 2 - nn
>       xr = wr(en)
>       xi = wi(en)
>       hr(en,en) = 1.0d0
>       hi(en,en) = 0.0d0
>       enm1 = en - 1
> !     .......... FOR I=EN-1 STEP -1 UNTIL 1 DO -- ..........
>       do ii = 1, enm1
>          i = en - ii
>          zzr = 0.0d0
>          zzi = 0.0d0
>          ip1 = i + 1
>          do j = ip1, en
>             zzr = mat_flop(zzr + hr(i,j)*hr(j,en) - hi(i,j)*hi(j,en))
>             zzi = mat_flop(zzi + hr(i,j)*hi(j,en) + hi(i,j)*hr(j,en))
>          enddo
>          yr = mat_flop(xr - wr(i))
>          yi = mat_flop(xi - wi(i))
>          if (yr .ne. 0.0d0 .or. yi .ne. 0.0d0) goto 765
>          yr = norm
> 760      continue
>          yr = mat_flop(yr/100.0d0)
>          yi = mat_flop(norm + yr)
>          if (yi .ne. norm) goto 760
>          yi = 0.0d0
> 765      continue
>          call mat_wdiv(zzr,zzi,yr,yi,hr(i,en),hi(i,en))
>          tr = mat_flop(dabs(hr(i,en))) + mat_flop(dabs(hi(i,en)))
>          if (tr .eq. 0.0d0) cycle
>          if (tr + 1.0d0/tr .gt. tr)cycle
>          do j = i, en
>             hr(j,en) = mat_flop(hr(j,en)/tr)
>             hi(j,en) = mat_flop(hi(j,en)/tr)
>          enddo
>       enddo
>    enddo
> !*****
> !     .......... END BACKSUBSTITUTION ..........
>    enm1 = n - 1
> !     .......... VECTORS OF ISOLATED ROOTS ..........
>    do  i = 1, enm1
>       if (i .ge. low .and. i .le. igh) cycle
>       ip1 = i + 1
> 
>       do j = ip1, n
>          zr(i,j) = hr(i,j)
>          zi(i,j) = hi(i,j)
>       enddo
> 
>    enddo
> !     .......... MULTIPLY BY TRANSFORMATION MATRIX TO GIVE
> !                VECTORS OF ORIGINAL FULL MATRIX.
> !                FOR J=N STEP -1 UNTIL LOW+1 DO -- ..........
>    do jj = low, enm1
>       j = n + low - jj
>       m = min0(j,igh)
> 
>       do i = low, igh
>          zzr = 0.0d0
>          zzi = 0.0d0
> 
>          do k = low, m
>             zzr = mat_flop(zzr + zr(i,k)*hr(k,j) - zi(i,k)*hi(k,j))
>             zzi = mat_flop(zzi + zr(i,k)*hi(k,j) + zi(i,k)*hr(k,j))
>          enddo
> 
>          zr(i,j) = zzr
>          zi(i,j) = zzi
>       enddo
>    enddo
> !
>    goto 1001
> !     .......... SET ERROR -- NO CONVERGENCE TO AN
> !                EIGENVALUE AFTER 30 ITERATIONS ..........
> 1000 continue
>    ierr = en
> 1001 continue
> end subroutine ml_comqr3
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_WSVDC(xr,xi,LDX,N,P,sr,si,er,ei,ur,ui,LDU,vr,vi,LDV,workr,worki,JOB,INFO)
>       use M_matrix
>       INTEGER LDX,N,P,LDU,LDV,JOB,INFO
>       DOUBLEPRECISION XR(LDX,*),XI(LDX,*),SR(*),SI(*),ER(*),EI(*), UR(LDU,*),UI(LDU,*),VR(LDV,*),VI(LDV,*), WORKR(*),WORKI(*)
> !
> !
> !     WSVDC IS A SUBROUTINE TO REDUCE A DOUBLE-COMPLEX NXP MATRIX X BY
> !     UNITARY TRANSFORMATIONS U AND V TO DIAGONAL FORM.  THE
> !     DIAGONAL ELEMENTS S(I) ARE THE SINGULAR VALUES OF X.  THE
> !     COLUMNS OF U ARE THE CORRESPONDING LEFT SINGULAR VECTORS,
> !     AND THE COLUMNS OF V THE RIGHT SINGULAR VECTORS.
> !
> !     ON ENTRY
> !
> !         X         DOUBLE-COMPLEX(LDX,P), WHERE LDX.GE.N.
> !                   X CONTAINS THE MATRIX WHOSE SINGULAR VALUE
> !                   DECOMPOSITION IS TO BE COMPUTED.  X IS
> !                   DESTROYED BY WSVDC.
> !
> !         LDX       INTEGER.
> !                   LDX IS THE LEADING DIMENSION OF THE ARRAY X.
> !
> !         N         INTEGER.
> !                   N IS THE NUMBER OF COLUMNS OF THE MATRIX X.
> !
> !         P         INTEGER.
> !                   P IS THE NUMBER OF ROWS OF THE MATRIX X.
> !
> !         LDU       INTEGER.
> !                   LDU IS THE LEADING DIMENSION OF THE ARRAY U
> !                   (SEE BELOW).
> !
> !         LDV       INTEGER.
> !                   LDV IS THE LEADING DIMENSION OF THE ARRAY V
> !                   (SEE BELOW).
> !
> !         WORK      DOUBLE-COMPLEX(N).
> !                   WORK IS A SCRATCH ARRAY.
> !
> !         JOB       INTEGER.
> !                   JOB CONTROLS THE COMPUTATION OF THE SINGULAR
> !                   VECTORS.  IT HAS THE DECIMAL EXPANSION AB
> !                   WITH THE FOLLOWING MEANING
> !
> !     A.EQ.0    DO NOT COMPUTE THE LEFT SINGULAR
> !               VECTORS.
> !     A.EQ.1    RETURN THE N LEFT SINGULAR VECTORS
> !               IN U.
> !     A.GE.2    RETURNS THE FIRST MIN(N,P)
> !               LEFT SINGULAR VECTORS IN U.
> !     B.EQ.0    DO NOT COMPUTE THE RIGHT SINGULAR
> !               VECTORS.
> !     B.EQ.1    RETURN THE RIGHT SINGULAR VECTORS
> !               IN V.
> !
> !     ON RETURN
> !
> !         S         DOUBLE-COMPLEX(MM), WHERE MM=MIN(N+1,P).
> !                   THE FIRST MIN(N,P) ENTRIES OF S CONTAIN THE
> !                   SINGULAR VALUES OF X ARRANGED IN DESCENDING
> !                   ORDER OF MAGNITUDE.
> !
> !         E         DOUBLE-COMPLEX(P).
> !                   E ORDINARILY CONTAINS ZEROS.  HOWEVER SEE THE
> !                   DISCUSSION OF INFO FOR EXCEPTIONS.
> !
> !         U         DOUBLE-COMPLEX(LDU,K), WHERE LDU.GE.N.
> !                   IF JOBA.EQ.1 THEN K.EQ.N,
> !                   IF JOBA.EQ.2 THEN K.EQ.MIN(N,P).
> !                   U CONTAINS THE MATRIX OF RIGHT SINGULAR VECTORS.
> !                   U IS NOT REFERENCED IF JOBA.EQ.0.  IF N.LE.P
> !                   OR IF JOBA.GT.2, THEN U MAY BE IDENTIFIED WITH X
> !                   IN THE SUBROUTINE CALL.
> !
> !         V         DOUBLE-COMPLEX(LDV,P), WHERE LDV.GE.P.
> !                   V CONTAINS THE MATRIX OF RIGHT SINGULAR VECTORS.
> !                   V IS NOT REFERENCED IF JOBB.EQ.0.  IF P.LE.N,
> !                   THEN V MAY BE IDENTIFIED WHTH X IN THE
> !                   SUBROUTINE ML_CALL.
> !
> !         INFO      INTEGER.
> !                   THE SINGULAR VALUES (AND THEIR CORRESPONDING
> !                   SINGULAR VECTORS) S(INFO+1),S(INFO+2),...,S(M)
> !                   ARE CORRECT (HERE M=MIN(N,P)).  THUS IF
> !                   INFO.EQ.0, ALL THE SINGULAR VALUES AND THEIR
> !                   VECTORS ARE CORRECT.  IN ANY EVENT, THE MATRIX
> !                   B = CTRANS(U)*X*V IS THE BIDIAGONAL MATRIX
> !                   WITH THE ELEMENTS OF S ON ITS DIAGONAL AND THE
> !                   ELEMENTS OF E ON ITS SUPER-DIAGONAL (CTRANS(U)
> !                   IS THE CONJUGATE-TRANSPOSE OF U).  THUS THE
> !                   SINGULAR VALUES OF X AND B ARE THE SAME.
> !
> !     LINPACK. THIS VERSION DATED 07/03/79 .
> !     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB.
> !
> !     WSVDC USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS.
> !
> !     BLAS    matX_waxpy,mat_pythag,mat_wdotcr,mat_wdotci,mat_wscal,WSWAP,
> !             mat_rrotg,mat_wnrm2
> !     FORTRAN DABS,DIMAG,DMAX1
> !     FORTRAN MAX0,MIN0,MOD,DSQRT
> !
> !     INTERNAL VARIABLES
> !
>       INTEGER I,ITER,J,JOBU,K,KASE,KK,L,LL,LLS,LM1,LP1,LS,LU,M,MAXIT,MM,MM1,MP1,NCT,NCTP1,NCU,NRT,NRTP1
>       DOUBLEPRECISION TR,TI,RR,RI
>       DOUBLEPRECISION B,C,CS,EL,EMM1,F,G,SCALE,SHIFT,SL,SM,SN,SMM1,T1,TEST,ZTEST,SMALL
>       LOGICAL WANTU,WANTV
> !
>       DOUBLEPRECISION ZDUMR,ZDUMI
>       DOUBLEPRECISION CABS1
>       CABS1(ZDUMR,ZDUMI) = DABS(ZDUMR) + DABS(ZDUMI)
> !
> !     SET THE MAXIMUM NUMBER OF ITERATIONS.
> !
>       MAXIT = 75
> !
> !     SMALL NUMBER, ROUGHLY MACHINE EPSILON, USED TO AVOID UNDERFLOW
> !
>       SMALL = 1.D0/2.D0**48
> !
> !     DETERMINE WHAT IS TO BE COMPUTED.
> !
>       WANTU = .FALSE.
>       WANTV = .FALSE.
>       JOBU = MOD(JOB,100)/10
>       NCU = N
>       IF (JOBU .GT. 1) NCU = MIN0(N,P)
>       IF (JOBU .NE. 0) WANTU = .TRUE.
>       IF (MOD(JOB,10) .NE. 0) WANTV = .TRUE.
> !
> !     REDUCE X TO BIDIAGONAL FORM, STORING THE DIAGONAL ELEMENTS
> !     IN S AND THE SUPER-DIAGONAL ELEMENTS IN E.
> !
>       INFO = 0
>       NCT = MIN0(N-1,P)
>       NRT = MAX0(0,MIN0(P-2,N))
>       LU = MAX0(NCT,NRT)
>       IF (LU .LT. 1) GOTO 190
>       DO 180 L = 1, LU
>          LP1 = L + 1
>          IF (L .GT. NCT) GOTO 30
> !
> !           COMPUTE THE TRANSFORMATION FOR THE L-TH COLUMN AND
> !           PLACE THE L-TH DIAGONAL IN S(L).
> !
>             SR(L) = mat_wnrm2(N-L+1,XR(L,L),XI(L,L),1)
>             SI(L) = 0.0D0
>             IF (CABS1(SR(L),SI(L)) .EQ. 0.0D0) GOTO 20
>                IF (CABS1(XR(L,L),XI(L,L)) .EQ. 0.0D0) GOTO 10
>                   CALL mat_wsign(SR(L),SI(L),XR(L,L),XI(L,L),SR(L),SI(L))
>    10          CONTINUE
>                CALL mat_wdiv(1.0D0,0.0D0,SR(L),SI(L),TR,TI)
>                CALL mat_wscal(N-L+1,TR,TI,XR(L,L),XI(L,L),1)
>                XR(L,L) = mat_flop(1.0D0 + XR(L,L))
>    20       CONTINUE
>             SR(L) = -SR(L)
>             SI(L) = -SI(L)
>    30    CONTINUE
>          IF (P .LT. LP1) GOTO 60
>          DO 50 J = LP1, P
>             IF (L .GT. NCT) GOTO 40
>             IF (CABS1(SR(L),SI(L)) .EQ. 0.0D0) GOTO 40
> !
> !              APPLY THE TRANSFORMATION.
> !
>                TR= -mat_wdotcr(N-L+1,XR(L,L),XI(L,L),1,XR(L,J),XI(L,J),1)
>                TI= -mat_wdotci(N-L+1,XR(L,L),XI(L,L),1,XR(L,J),XI(L,J),1)
>                CALL mat_wdiv(TR,TI,XR(L,L),XI(L,L),TR,TI)
>                CALL matX_waxpy(N-L+1,TR,TI,XR(L,L),XI(L,L),1,XR(L,J),XI(L,J),1)
>    40       CONTINUE
> !
> !           PLACE THE L-TH ROW OF X INTO  E FOR THE
> !           SUBSEQUENT CALCULATION OF THE ROW TRANSFORMATION.
> !
>             ER(J) = XR(L,J)
>             EI(J) = -XI(L,J)
>    50    CONTINUE
>    60    CONTINUE
>          IF (.NOT.WANTU .OR. L .GT. NCT) GOTO 80
> !
> !           PLACE THE TRANSFORMATION IN U FOR SUBSEQUENT BACK
> !           MULTIPLICATION.
> !
>             DO I = L, N
>                UR(I,L) = XR(I,L)
>                UI(I,L) = XI(I,L)
>             enddo
>    80    CONTINUE
>          IF (L .GT. NRT) GOTO 170
> !
> !           COMPUTE THE L-TH ROW TRANSFORMATION AND PLACE THE
> !           L-TH SUPER-DIAGONAL IN E(L).
> !
>             ER(L) = mat_wnrm2(P-L,ER(LP1),EI(LP1),1)
>             EI(L) = 0.0D0
>             IF (CABS1(ER(L),EI(L)) .EQ. 0.0D0) GOTO 100
>                IF (CABS1(ER(LP1),EI(LP1)) .EQ. 0.0D0) GOTO 90
>                   CALL mat_wsign(ER(L),EI(L),ER(LP1),EI(LP1),ER(L),EI(L))
>    90          CONTINUE
>                CALL mat_wdiv(1.0D0,0.0D0,ER(L),EI(L),TR,TI)
>                CALL mat_wscal(P-L,TR,TI,ER(LP1),EI(LP1),1)
>                ER(LP1) = mat_flop(1.0D0 + ER(LP1))
>   100       CONTINUE
>             ER(L) = -ER(L)
>             EI(L) = +EI(L)
>             IF (LP1 .GT. N .OR. CABS1(ER(L),EI(L)) .EQ. 0.0D0) GOTO 140
> !
> !              APPLY THE TRANSFORMATION.
> !
>                DO I = LP1, N
>                   WORKR(I) = 0.0D0
>                   WORKI(I) = 0.0D0
>                enddo
>                DO J = LP1, P
>                   CALL matX_waxpy(N-L,ER(J),EI(J),XR(LP1,J),XI(LP1,J),1, WORKR(LP1),WORKI(LP1),1)
>                enddo
>                DO J = LP1, P
>                   CALL mat_wdiv(-ER(J),-EI(J),ER(LP1),EI(LP1),TR,TI)
>                   CALL matX_waxpy(N-L,TR,-TI,WORKR(LP1),WORKI(LP1),1, XR(LP1,J),XI(LP1,J),1)
>                enddo
>   140       CONTINUE
>             IF (.NOT.WANTV) GOTO 160
> !
> !              PLACE THE TRANSFORMATION IN V FOR SUBSEQUENT
> !              BACK MULTIPLICATION.
> !
>                DO I = LP1, P
>                   VR(I,L) = ER(I)
>                   VI(I,L) = EI(I)
>                enddo
>   160       CONTINUE
>   170    CONTINUE
>   180 CONTINUE
>   190 CONTINUE
> !
> !     SET UP THE FINAL BIDIAGONAL MATRIX OR ORDER M.
> !
>       M = MIN0(P,N+1)
>       NCTP1 = NCT + 1
>       NRTP1 = NRT + 1
>       IF (NCT .GE. P) GOTO 200
>          SR(NCTP1) = XR(NCTP1,NCTP1)
>          SI(NCTP1) = XI(NCTP1,NCTP1)
>   200 CONTINUE
>       IF (N .GE. M) GOTO 210
>          SR(M) = 0.0D0
>          SI(M) = 0.0D0
>   210 CONTINUE
>       IF (NRTP1 .GE. M) GOTO 220
>          ER(NRTP1) = XR(NRTP1,M)
>          EI(NRTP1) = XI(NRTP1,M)
>   220 CONTINUE
>       ER(M) = 0.0D0
>       EI(M) = 0.0D0
> !
> !     IF REQUIRED, GENERATE U.
> !
>       IF (.NOT.WANTU) GOTO 350
>          IF (NCU .LT. NCTP1) GOTO 250
>          DO J = NCTP1, NCU
>             DO I = 1, N
>                UR(I,J) = 0.0D0
>                UI(I,J) = 0.0D0
>             enddo
>             UR(J,J) = 1.0D0
>             UI(J,J) = 0.0D0
>          enddo
>   250    CONTINUE
>          IF (NCT .LT. 1) GOTO 340
>          DO LL = 1, NCT
>             L = NCT - LL + 1
>             IF (CABS1(SR(L),SI(L)) .EQ. 0.0D0) GOTO 300
>                LP1 = L + 1
>                IF (NCU .LT. LP1) GOTO 270
>                DO J = LP1, NCU
>                   TR = -mat_wdotcr(N-L+1,UR(L,L),UI(L,L),1,UR(L,J), UI(L,J),1)
>                   TI = -mat_wdotci(N-L+1,UR(L,L),UI(L,L),1,UR(L,J), UI(L,J),1)
>                   CALL mat_wdiv(TR,TI,UR(L,L),UI(L,L),TR,TI)
>                   CALL matX_waxpy(N-L+1,TR,TI,UR(L,L),UI(L,L),1,UR(L,J), UI(L,J),1)
>                enddo
>   270          CONTINUE
>                CALL mat_wrscal(N-L+1,-1.0D0,UR(L,L),UI(L,L),1)
>                UR(L,L) = mat_flop(1.0D0 + UR(L,L))
>                LM1 = L - 1
>                IF (LM1 .LT. 1) GOTO 290
>                DO I = 1, LM1
>                   UR(I,L) = 0.0D0
>                   UI(I,L) = 0.0D0
>                enddo
>   290          CONTINUE
>             GOTO 320
>   300       CONTINUE
>                DO I = 1, N
>                   UR(I,L) = 0.0D0
>                   UI(I,L) = 0.0D0
>                enddo
>                UR(L,L) = 1.0D0
>                UI(L,L) = 0.0D0
>   320       CONTINUE
>          enddo
>   340    CONTINUE
>   350 CONTINUE
> !
> !     IF IT IS REQUIRED, GENERATE V.
> !
>       IF (.NOT.WANTV) GOTO 400
>          DO LL = 1, P
>             L = P - LL + 1
>             LP1 = L + 1
>             IF (L .GT. NRT) GOTO 370
>             IF (CABS1(ER(L),EI(L)) .EQ. 0.0D0) GOTO 370
>                DO J = LP1, P
>                   TR = -mat_wdotcr(P-L,VR(LP1,L),VI(LP1,L),1,VR(LP1,J),VI(LP1,J),1)
>                   TI = -mat_wdotci(P-L,VR(LP1,L),VI(LP1,L),1,VR(LP1,J),VI(LP1,J),1)
>                   CALL mat_wdiv(TR,TI,VR(LP1,L),VI(LP1,L),TR,TI)
>                   CALL matX_waxpy(P-L,TR,TI,VR(LP1,L),VI(LP1,L),1,VR(LP1,J),VI(LP1,J),1)
>                enddo
>   370       CONTINUE
>             DO I = 1, P
>                VR(I,L) = 0.0D0
>                VI(I,L) = 0.0D0
>             enddo
>             VR(L,L) = 1.0D0
>             VI(L,L) = 0.0D0
>          enddo
>   400 CONTINUE
> !
> !     TRANSFORM S AND E SO THAT THEY ARE REAL.
> !
>       DO I = 1, M
>             TR = mat_pythag(SR(I),SI(I))
>             IF (TR .EQ. 0.0D0) GOTO 405
>             RR = SR(I)/TR
>             RI = SI(I)/TR
>             SR(I) = TR
>             SI(I) = 0.0D0
>             IF (I .LT. M) CALL mat_wdiv(ER(I),EI(I),RR,RI,ER(I),EI(I))
>             IF (WANTU) CALL mat_wscal(N,RR,RI,UR(1,I),UI(1,I),1)
>   405    CONTINUE
> !     ...EXIT
>          IF (I .EQ. M) exit
>             TR = mat_pythag(ER(I),EI(I))
>             IF (TR .EQ. 0.0D0) GOTO 410
>             CALL mat_wdiv(TR,0.0D0,ER(I),EI(I),RR,RI)
>             ER(I) = TR
>             EI(I) = 0.0D0
>             CALL mat_wmul(SR(I+1),SI(I+1),RR,RI,SR(I+1),SI(I+1))
>             IF (WANTV) CALL mat_wscal(P,RR,RI,VR(1,I+1),VI(1,I+1),1)
>   410    CONTINUE
>       enddo
> !
> !     MAIN ITERATION LOOP FOR THE SINGULAR VALUES.
> !
>       MM = M
>       ITER = 0
>   440 CONTINUE
> !
> !        QUIT IF ALL THE SINGULAR VALUES HAVE BEEN FOUND.
> !
> !     ...EXIT
>          IF (M .EQ. 0) GOTO 700
> !
> !        IF TOO MANY ITERATIONS HAVE BEEN PERFORMED, SET
> !        FLAG AND RETURN.
> !
>          IF (ITER .LT. MAXIT) GOTO 450
>             INFO = M
> !     ......EXIT
>             GOTO 700
>   450    CONTINUE
> !
> !        THIS SECTION OF THE PROGRAM INSPECTS FOR
> !        NEGLIGIBLE ELEMENTS IN THE S AND E ARRAYS.  ON
> !        COMPLETION THE VARIABLE KASE IS SET AS FOLLOWS.
> !
> !           KASE = 1     IF SR(M) AND ER(L-1) ARE NEGLIGIBLE AND L.LT.M
> !           KASE = 2     IF SR(L) IS NEGLIGIBLE AND L.LT.M
> !           KASE = 3     IF ER(L-1) IS NEGLIGIBLE, L.LT.M, AND
> !     SR(L), ..., SR(M) ARE NOT NEGLIGIBLE (QR STEP).
> !           KASE = 4     IF ER(M-1) IS NEGLIGIBLE (CONVERGENCE).
> !
>          DO LL = 1, M
>             L = M - LL
> !        ...EXIT
>             IF (L .EQ. 0) GOTO 480
>             TEST = mat_flop(DABS(SR(L)) + DABS(SR(L+1)))
>             ZTEST = mat_flop(TEST + DABS(ER(L))/2.0D0)
>             IF (SMALL*ZTEST .NE. SMALL*TEST) GOTO 460
>                ER(L) = 0.0D0
> !        ......EXIT
>                GOTO 480
>   460       CONTINUE
>          enddo
>   480    CONTINUE
>          IF (L .NE. M - 1) GOTO 490
>             KASE = 4
>          GOTO 560
>   490    CONTINUE
>             LP1 = L + 1
>             MP1 = M + 1
>             DO LLS = LP1, MP1
>                LS = M - LLS + LP1
> !           ...EXIT
>                IF (LS .EQ. L) GOTO 520
>                TEST = 0.0D0
>                IF (LS .NE. M) TEST = mat_flop(TEST + DABS(ER(LS)))
>                IF (LS .NE. L + 1) TEST = mat_flop(TEST + DABS(ER(LS-1)))
>                ZTEST = mat_flop(TEST + DABS(SR(LS))/2.0D0)
>                IF (SMALL*ZTEST .NE. SMALL*TEST) GOTO 500
>                   SR(LS) = 0.0D0
> !           ......EXIT
>                   GOTO 520
>   500          CONTINUE
>             enddo
>   520       CONTINUE
>             IF (LS .NE. L) GOTO 530
>                KASE = 3
>             GOTO 550
>   530       CONTINUE
>             IF (LS .NE. M) GOTO 540
>                KASE = 1
>             GOTO 550
>   540       CONTINUE
>                KASE = 2
>                L = LS
>   550       CONTINUE
>   560    CONTINUE
>          L = L + 1
> !
> !        PERFORM THE TASK INDICATED BY KASE.
> !
>          GOTO (570, 600, 620, 650), KASE
> !
> !        DEFLATE NEGLIGIBLE SR(M).
> !
>   570    CONTINUE
>             MM1 = M - 1
>             F = ER(M-1)
>             ER(M-1) = 0.0D0
>             DO KK = L, MM1
>                K = MM1 - KK + L
>                T1 = SR(K)
>                CALL mat_rrotg(T1,F,CS,SN)
>                SR(K) = T1
>                IF (K .EQ. L) GOTO 580
>                   F = mat_flop(-(SN*ER(K-1)))
>                   ER(K-1) = mat_flop(CS*ER(K-1))
>   580          CONTINUE
>                IF (WANTV) CALL mat_rrot(P,VR(1,K),1,VR(1,M),1,CS,SN)
>                IF (WANTV) CALL mat_rrot(P,VI(1,K),1,VI(1,M),1,CS,SN)
>             enddo
>          GOTO 690
> !
> !        SPLIT AT NEGLIGIBLE SR(L).
> !
>   600    CONTINUE
>             F = ER(L-1)
>             ER(L-1) = 0.0D0
>             DO K = L, M
>                T1 = SR(K)
>                CALL mat_rrotg(T1,F,CS,SN)
>                SR(K) = T1
>                F = mat_flop(-(SN*ER(K)))
>                ER(K) = mat_flop(CS*ER(K))
>                IF (WANTU) CALL mat_rrot(N,UR(1,K),1,UR(1,L-1),1,CS,SN)
>                IF (WANTU) CALL mat_rrot(N,UI(1,K),1,UI(1,L-1),1,CS,SN)
>             enddo
>          GOTO 690
> !
> !        PERFORM ONE QR STEP.
> !
>   620    CONTINUE
> !
> !           CALCULATE THE SHIFT.
> !
>             SCALE = DMAX1(DABS(SR(M)),DABS(SR(M-1)),DABS(ER(M-1)), DABS(SR(L)),DABS(ER(L)))
>             SM = SR(M)/SCALE
>             SMM1 = SR(M-1)/SCALE
>             EMM1 = ER(M-1)/SCALE
>             SL = SR(L)/SCALE
>             EL = ER(L)/SCALE
>             B = mat_flop(((SMM1 + SM)*(SMM1 - SM) + EMM1**2)/2.0D0)
>             C = mat_flop((SM*EMM1)**2)
>             SHIFT = 0.0D0
>             IF (B .EQ. 0.0D0 .AND. C .EQ. 0.0D0) GOTO 630
>                SHIFT = mat_flop(DSQRT(B**2+C))
>                IF (B .LT. 0.0D0) SHIFT = -SHIFT
>                SHIFT = mat_flop(C/(B + SHIFT))
>   630       CONTINUE
>             F = mat_flop((SL + SM)*(SL - SM) - SHIFT)
>             G = mat_flop(SL*EL)
> !
> !           CHASE ZEROS.
> !
>             MM1 = M - 1
>             DO K = L, MM1
>                CALL mat_rrotg(F,G,CS,SN)
>                IF (K .NE. L) ER(K-1) = F
>                F = mat_flop(CS*SR(K) + SN*ER(K))
>                ER(K) = mat_flop(CS*ER(K) - SN*SR(K))
>                G = mat_flop(SN*SR(K+1))
>                SR(K+1) = mat_flop(CS*SR(K+1))
>                IF (WANTV) CALL mat_rrot(P,VR(1,K),1,VR(1,K+1),1,CS,SN)
>                IF (WANTV) CALL mat_rrot(P,VI(1,K),1,VI(1,K+1),1,CS,SN)
>                CALL mat_rrotg(F,G,CS,SN)
>                SR(K) = F
>                F = mat_flop(CS*ER(K) + SN*SR(K+1))
>                SR(K+1) = mat_flop(-(SN*ER(K)) + CS*SR(K+1))
>                G = mat_flop(SN*ER(K+1))
>                ER(K+1) = mat_flop(CS*ER(K+1))
>                IF (WANTU .AND. K .LT. N) CALL mat_rrot(N,UR(1,K),1,UR(1,K+1),1,CS,SN)
>                IF (WANTU .AND. K .LT. N) CALL mat_rrot(N,UI(1,K),1,UI(1,K+1),1,CS,SN)
>             enddo
>             ER(M-1) = F
>             ITER = ITER + 1
>          GOTO 690
> !
> !        CONVERGENCE
> !
>   650    CONTINUE
> !
> !           MAKE THE SINGULAR VALUE  POSITIVE
> !
>             IF (SR(L) .GE. 0.0D0) GOTO 660
>                SR(L) = -SR(L)
>              IF (WANTV) CALL mat_wrscal(P,-1.0D0,VR(1,L),VI(1,L),1)
>   660       CONTINUE
> !
> !           ORDER THE SINGULAR VALUE.
> !
>   670       IF (L .EQ. MM) GOTO 680
> !           ...EXIT
>                IF (SR(L) .GE. SR(L+1)) GOTO 680
>                TR = SR(L)
>                SR(L) = SR(L+1)
>                SR(L+1) = TR
>                IF (WANTV .AND. L .LT. P)CALL mat_wswap(P,VR(1,L),VI(1,L),1,VR(1,L+1),VI(1,L+1),1)
>                IF (WANTU .AND. L .LT. N)CALL mat_wswap(N,UR(1,L),UI(1,L),1,UR(1,L+1),UI(1,L+1),1)
>                L = L + 1
>             GOTO 670
>   680       CONTINUE
>             ITER = 0
>             M = M - 1
>   690    CONTINUE
>       GOTO 440
>   700 CONTINUE
>       END SUBROUTINE ML_WSVDC
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_WQRDC(XR,XI,LDX,N,P,QRAUXR,QRAUXI,JPVT,WORKR,WORKI, JOB)
>       use M_matrix
>       INTEGER LDX,N,P,JOB
>       INTEGER JPVT(*)
>       DOUBLEPRECISION XR(LDX,*),XI(LDX,*),QRAUXR(*),QRAUXI(*), WORKR(*),WORKI(*)
> !
> !     WQRDC USES HOUSEHOLDER TRANSFORMATIONS TO COMPUTE THE QR
> !     FACTORIZATION OF AN N BY P MATRIX X.  COLUMN PIVOTING
> !     BASED ON THE 2-NORMS OF THE REDUCED COLUMNS MAY BE
> !     PERFORMED AT THE USERS OPTION.
> !
> !     ON ENTRY
> !
> !        X       DOUBLE-COMPLEX(LDX,P), WHERE LDX .GE. N.
> !                X CONTAINS THE MATRIX WHOSE DECOMPOSITION IS TO BE
> !                COMPUTED.
> !
> !        LDX     INTEGER.
> !                LDX IS THE LEADING DIMENSION OF THE ARRAY X.
> !
> !        N       INTEGER.
> !                N IS THE NUMBER OF ROWS OF THE MATRIX X.
> !
> !        P       INTEGER.
> !                P IS THE NUMBER OF COLUMNS OF THE MATRIX X.
> !
> !        JPVT    INTEGER(P).
> !                JPVT CONTAINS INTEGERS THAT CONTROL THE SELECTION
> !                OF THE PIVOT COLUMNS.  THE K-TH COLUMN X(K) OF X
> !                IS PLACED IN ONE OF THREE CLASSES ACCORDING TO THE
> !                VALUE OF JPVT(K).
> !
> !                   IF JPVT(K) .GT. 0, THEN X(K) IS AN INITIAL
> !                   COLUMN.
> !
> !                   IF JPVT(K) .EQ. 0, THEN X(K) IS A FREE COLUMN.
> !
> !                   IF JPVT(K) .LT. 0, THEN X(K) IS A FINAL COLUMN.
> !
> !                BEFORE THE DECOMPOSITION IS COMPUTED, INITIAL COLUMNS
> !                ARE MOVED TO THE BEGINNING OF THE ARRAY X AND FINAL
> !                COLUMNS TO THE END.  BOTH INITIAL AND FINAL COLUMNS
> !                ARE FROZEN IN PLACE DURING THE COMPUTATION AND ONLY
> !                FREE COLUMNS ARE MOVED.  AT THE K-TH STAGE OF THE
> !                REDUCTION, IF X(K) IS OCCUPIED BY A FREE COLUMN
> !                IT IS INTERCHANGED WITH THE FREE COLUMN OF LARGEST
> !                REDUCED NORM.  JPVT IS NOT REFERENCED IF
> !                JOB .EQ. 0.
> !
> !        WORK    DOUBLE-COMPLEX(P).
> !                WORK IS A WORK ARRAY.  WORK IS NOT REFERENCED IF
> !                JOB .EQ. 0.
> !
> !        JOB     INTEGER.
> !                JOB IS AN INTEGER THAT INITIATES COLUMN PIVOTING.
> !                IF JOB .EQ. 0, NO PIVOTING IS DONE.
> !                IF JOB .NE. 0, PIVOTING IS DONE.
> !
> !     ON RETURN
> !
> !        X       X CONTAINS IN ITS UPPER TRIANGLE THE UPPER
> !                TRIANGULAR MATRIX R OF THE QR FACTORIZATION.
> !                BELOW ITS DIAGONAL X CONTAINS INFORMATION FROM
> !                WHICH THE UNITARY PART OF THE DECOMPOSITION
> !                CAN BE RECOVERED.  NOTE THAT IF PIVOTING HAS
> !                BEEN REQUESTED, THE DECOMPOSITION IS NOT THAT
> !                OF THE ORIGINAL MATRIX X BUT THAT OF X
> !                WITH ITS COLUMNS PERMUTED AS DESCRIBED BY JPVT.
> !
> !        QRAUX   DOUBLE-COMPLEX(P).
> !                QRAUX CONTAINS FURTHER INFORMATION REQUIRED TO RECOVER
> !                THE UNITARY PART OF THE DECOMPOSITION.
> !
> !        JPVT    JPVT(K) CONTAINS THE INDEX OF THE COLUMN OF THE
> !                ORIGINAL MATRIX THAT HAS BEEN INTERCHANGED INTO
> !                THE K-TH COLUMN, IF PIVOTING WAS REQUESTED.
> !
> !     LINPACK. THIS VERSION DATED 07/03/79 .
> !     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB.
> !
> !     WQRDC USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS.
> !
> !     BLAS matX_waxpy,mat_pythag,mat_wdotcr,mat_wdotci,mat_wscal
> !     blas mat_wswap ,mat_wnrm2
> !     FORTRAN DABS,DIMAG,DMAX1,MIN0
> !
> !     INTERNAL VARIABLES
> !
> integer :: jj
>       INTEGER J,JP,L,LP1,LUP,MAXJ,PL,PU
>       DOUBLEPRECISION MAXNRM,TT
>       DOUBLEPRECISION NRMXLR,NRMXLI,TR,TI
>       LOGICAL NEGJ,SWAPJ
> !
>       DOUBLEPRECISION ZDUMR,ZDUMI
>       DOUBLEPRECISION CABS1
>       CABS1(ZDUMR,ZDUMI) = DABS(ZDUMR) + DABS(ZDUMI)
> !
>       PL = 1
>       PU = 0
>       IF (JOB .EQ. 0) GOTO 60
> !
> !        PIVOTING HAS BEEN REQUESTED.  REARRANGE THE COLUMNS
> !        ACCORDING TO JPVT.
> !
>          DO 20 J = 1, P
>             SWAPJ = JPVT(J) .GT. 0
>             NEGJ = JPVT(J) .LT. 0
>             JPVT(J) = J
>             IF (NEGJ) JPVT(J) = -J
>             IF (.NOT.SWAPJ) GOTO 10
>                IF (J .NE. PL) CALL mat_wswap(N,XR(1,PL),XI(1,PL),1,XR(1,J),XI(1,J),1)
>                JPVT(J) = JPVT(PL)
>                JPVT(PL) = J
>                PL = PL + 1
>    10       CONTINUE
>    20    CONTINUE
>          PU = P
>          DO 50 JJ = 1, P
>             J = P - JJ + 1
>             IF (JPVT(J) .GE. 0) GOTO 40
>                JPVT(J) = -JPVT(J)
>                IF (J .EQ. PU) GOTO 30
>                   CALL mat_wswap(N,XR(1,PU),XI(1,PU),1,XR(1,J),XI(1,J),1)
>                   JP = JPVT(PU)
>                   JPVT(PU) = JPVT(J)
>                   JPVT(J) = JP
>    30          CONTINUE
>                PU = PU - 1
>    40       CONTINUE
>    50    CONTINUE
>    60 CONTINUE
> !
> !     COMPUTE THE NORMS OF THE FREE COLUMNS.
> !
>       IF (PU .LT. PL) GOTO 80
>       DO 70 J = PL, PU
>          QRAUXR(J) = mat_wnrm2(N,XR(1,J),XI(1,J),1)
>          QRAUXI(J) = 0.0D0
>          WORKR(J) = QRAUXR(J)
>          WORKI(J) = QRAUXI(J)
>    70 CONTINUE
>    80 CONTINUE
> !
> !     PERFORM THE HOUSEHOLDER REDUCTION OF X.
> !
>       LUP = MIN0(N,P)
>       DO 210 L = 1, LUP
>          IF (L .LT. PL .OR. L .GE. PU) GOTO 120
> !
> !           LOCATE THE COLUMN OF LARGEST NORM AND BRING IT
> !           INTO THE PIVOT POSITION.
> !
>             MAXNRM = 0.0D0
>             MAXJ = L
>             DO J = L, PU
>                IF (QRAUXR(J) .LE. MAXNRM) cycle
>                MAXNRM = QRAUXR(J)
>                MAXJ = J
>             enddo
>             IF (MAXJ .EQ. L) GOTO 110
>               CALL mat_wswap(N,XR(1,L),XI(1,L),1,XR(1,MAXJ),XI(1,MAXJ),1)
>               QRAUXR(MAXJ) = QRAUXR(L)
>               QRAUXI(MAXJ) = QRAUXI(L)
>               WORKR(MAXJ) = WORKR(L)
>               WORKI(MAXJ) = WORKI(L)
>               JP = JPVT(MAXJ)
>               JPVT(MAXJ) = JPVT(L)
>               JPVT(L) = JP
>   110       CONTINUE
>   120    CONTINUE
>          QRAUXR(L) = 0.0D0
>          QRAUXI(L) = 0.0D0
>          IF (L .EQ. N) GOTO 200
> !
> !           COMPUTE THE HOUSEHOLDER TRANSFORMATION FOR COLUMN L.
> !
>             NRMXLR = mat_wnrm2(N-L+1,XR(L,L),XI(L,L),1)
>             NRMXLI = 0.0D0
>             IF (CABS1(NRMXLR,NRMXLI) .EQ. 0.0D0) GOTO 190
>               IF (CABS1(XR(L,L),XI(L,L)) .EQ. 0.0D0) GOTO 130
>               CALL mat_wsign(NRMXLR,NRMXLI,XR(L,L),XI(L,L),NRMXLR,NRMXLI)
>   130         CONTINUE
>               CALL mat_wdiv(1.0D0,0.0D0,NRMXLR,NRMXLI,TR,TI)
>               CALL mat_wscal(N-L+1,TR,TI,XR(L,L),XI(L,L),1)
>               XR(L,L) = mat_flop(1.0D0 + XR(L,L))
> !
> !             APPLY THE TRANSFORMATION TO THE REMAINING COLUMNS,
> !             UPDATING THE NORMS.
> !
>               LP1 = L + 1
>               IF (P .LT. LP1) GOTO 180
>               DO 170 J = LP1, P
>                   TR = -mat_wdotcr(N-L+1,XR(L,L),XI(L,L),1,XR(L,J), XI(L,J),1)
>                   TI = -mat_wdotci(N-L+1,XR(L,L),XI(L,L),1,XR(L,J), XI(L,J),1)
>                   CALL mat_wdiv(TR,TI,XR(L,L),XI(L,L),TR,TI)
>                   CALL matX_waxpy(N-L+1,TR,TI,XR(L,L),XI(L,L),1,XR(L,J), XI(L,J),1)
>                   IF (J .LT. PL .OR. J .GT. PU) GOTO 160
>                   IF (CABS1(QRAUXR(J),QRAUXI(J)) .EQ. 0.0D0) GOTO 160
>                     TT=1.0D0 - (mat_pythag(XR(L,J),XI(L,J))/QRAUXR(J))**2
>                     TT=DMAX1(TT,0.0D0)
>                     TR=mat_flop(TT)
>                     TT=mat_flop(1.0D0+0.05D0*TT*(QRAUXR(J)/WORKR(J))**2)
>                     IF (TT .EQ. 1.0D0) GOTO 140
>                      QRAUXR(J) = QRAUXR(J)*DSQRT(TR)
>                      QRAUXI(J) = QRAUXI(J)*DSQRT(TR)
>                      GOTO 150
>   140                CONTINUE
>                      QRAUXR(J) = mat_wnrm2(N-L,XR(L+1,J),XI(L+1,J),1)
>                      QRAUXI(J) = 0.0D0
>                      WORKR(J) = QRAUXR(J)
>                      WORKI(J) = QRAUXI(J)
>   150                CONTINUE
>   160             CONTINUE
>   170          CONTINUE
>   180          CONTINUE
> !
> !              SAVE THE TRANSFORMATION.
> !
>                QRAUXR(L) = XR(L,L)
>                QRAUXI(L) = XI(L,L)
>                XR(L,L) = -NRMXLR
>                XI(L,L) = -NRMXLI
>   190       CONTINUE
>   200    CONTINUE
>   210 CONTINUE
>       END SUBROUTINE ML_WQRDC
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> SUBROUTINE ML_WQRSL(XR,XI,LDX,N,K,QRAUXR,QRAUXI,YR,YI,QYR,QYI,QTYR,QTYI,BR,BI,RSDR,RSDI,XBR,XBI,JOB,INFO)
> use M_matrix
> IMPLICIT NONE
> INTEGER LDX,N,K,JOB,INFO
> DOUBLEPRECISION XR(LDX,*),XI(LDX,*),QRAUXR(*),QRAUXI(*),YR(*),     &
>    &                YI(*),QYR(*),QYI(*),QTYR(*),QTYI(*),BR(*),BI(*),   &
>    &                RSDR(*),RSDI(*),XBR(*),XBI(*)
> !
> !     WQRSL APPLIES THE OUTPUT OF WQRDC TO COMPUTE COORDINATE
> !     TRANSFORMATIONS, PROJECTIONS, AND LEAST SQUARES SOLUTIONS.
> !     FOR K .LE. MIN(N,P), LET XK BE THE MATRIX
> !
> !            XK = (X(JPVT(1)),X(JPVT(2)), ... ,X(JPVT(K)))
> !
> !     FORMED FROM COLUMNS JPVT(1), ... ,JPVT(K) OF THE ORIGINAL
> !     N X P MATRIX X THAT WAS INPUT TO WQRDC (IF NO PIVOTING WAS
> !     DONE, XK CONSISTS OF THE FIRST K COLUMNS OF X IN THEIR
> !     ORIGINAL ORDER).  WQRDC PRODUCES A FACTORED UNITARY MATRIX Q
> !     AND AN UPPER TRIANGULAR MATRIX R SUCH THAT
> !
> !              XK = Q * (R)
> !    (0)
> !
> !     THIS INFORMATION IS CONTAINED IN CODED FORM IN THE ARRAYS
> !     X AND QRAUX.
> !
> !     ON ENTRY
> !
> !        X      DOUBLE-COMPLEX(LDX,P).
> !               X CONTAINS THE OUTPUT OF WQRDC.
> !
> !        LDX    INTEGER.
> !               LDX IS THE LEADING DIMENSION OF THE ARRAY X.
> !
> !        N      INTEGER.
> !               N IS THE NUMBER OF ROWS OF THE MATRIX XK.  IT MUST
> !               HAVE THE SAME VALUE AS N IN WQRDC.
> !
> !        K      INTEGER.
> !               K IS THE NUMBER OF COLUMNS OF THE MATRIX XK.  K
> !               MUST NNOT BE GREATER THAN MIN(N,P), WHERE P IS THE
> !               SAME AS IN THE CALLING SEQUENCE TO WQRDC.
> !
> !        QRAUX  DOUBLE-COMPLEX(P).
> !               QRAUX CONTAINS THE AUXILIARY OUTPUT FROM WQRDC.
> !
> !        Y      DOUBLE-COMPLEX(N)
> !               Y CONTAINS AN N-VECTOR THAT IS TO BE MANIPULATED
> !               BY WQRSL.
> !
> !        JOB    INTEGER.
> !               JOB SPECIFIES WHAT IS TO BE COMPUTED.  JOB HAS
> !               THE DECIMAL EXPANSION ABCDE, WITH THE FOLLOWING
> !               MEANING.
> !
> ! IF A.NE.0, COMPUTE QY.
> ! IF B,C,D, OR E .NE. 0, COMPUTE QTY.
> ! IF C.NE.0, COMPUTE B.
> ! IF D.NE.0, COMPUTE RSD.
> ! IF E.NE.0, COMPUTE XB.
> !
> !               NOTE THAT A REQUEST TO COMPUTE B, RSD, OR XB
> !               AUTOMATICALLY TRIGGERS THE COMPUTATION OF QTY, FOR
> !               WHICH AN ARRAY MUST BE PROVIDED IN THE CALLING
> !               SEQUENCE.
> !
> !     ON RETURN
> !
> !        QY     DOUBLE-COMPLEX(N).
> !               QY CONTAINS Q*Y, IF ITS COMPUTATION HAS BEEN
> !               REQUESTED.
> !
> !        QTY    DOUBLE-COMPLEX(N).
> !               QTY CONTAINS CTRANS(Q)*Y, IF ITS COMPUTATION HAS
> !               BEEN REQUESTED.  HERE CTRANS(Q) IS THE CONJUGATE
> !               TRANSPOSE OF THE MATRIX Q.
> !
> !        B      DOUBLE-COMPLEX(K)
> !               B CONTAINS THE SOLUTION OF THE LEAST SQUARES PROBLEM
> !
> ! MINIMIZE NORM2(Y - XK*B),
> !
> !               IF ITS COMPUTATION HAS BEEN REQUESTED.  (NOTE THAT
> !               IF PIVOTING WAS REQUESTED IN WQRDC, THE J-TH
> !               COMPONENT OF B WILL BE ASSOCIATED WITH COLUMN JPVT(J)
> !               OF THE ORIGINAL MATRIX X THAT WAS INPUT INTO WQRDC.)
> !
> !        RSD    DOUBLE-COMPLEX(N).
> !               RSD CONTAINS THE LEAST SQUARES RESIDUAL Y - XK*B,
> !               IF ITS COMPUTATION HAS BEEN REQUESTED.  RSD IS
> !               ALSO THE ORTHOGONAL PROJECTION OF Y ONTO THE
> !               ORTHOGONAL COMPLEMENT OF THE COLUMN SPACE OF XK.
> !
> !        XB     DOUBLE-COMPLEX(N).
> !               XB CONTAINS THE LEAST SQUARES APPROXIMATION XK*B,
> !               IF ITS COMPUTATION HAS BEEN REQUESTED.  XB IS ALSO
> !               THE ORTHOGONAL PROJECTION OF Y ONTO THE COLUMN SPACE
> !               OF X.
> !
> !        INFO   INTEGER.
> !               INFO IS ZERO UNLESS THE COMPUTATION OF B HAS
> !               BEEN REQUESTED AND R IS EXACTLY SINGULAR.  IN
> !               THIS CASE, INFO IS THE INDEX OF THE FIRST ZERO
> !               DIAGONAL ELEMENT OF R AND B IS LEFT UNALTERED.
> !
> !     THE PARAMETERS QY, QTY, B, RSD, AND XB ARE NOT REFERENCED
> !     IF THEIR COMPUTATION IS NOT REQUESTED AND IN THIS CASE
> !     CAN BE REPLACED BY DUMMY VARIABLES IN THE CALLING PROGRAM.
> !     TO SAVE STORAGE, THE USER MAY IN SOME CASES USE THE SAME
> !     ARRAY FOR DIFFERENT PARAMETERS IN THE CALLING SEQUENCE.  A
> !     FREQUENTLY OCCURRING EXAMPLE IS WHEN ONE WISHES TO COMPUTE
> !     ANY OF B, RSD, OR XB AND DOES NOT NEED Y OR QTY.  IN THIS
> !     CASE ONE MAY IDENTIFY Y, QTY, AND ONE OF B, RSD, OR XB, WHILE
> !     PROVIDING SEPARATE ARRAYS FOR ANYTHING ELSE THAT IS TO BE
> !     COMPUTED.  THUS THE CALLING SEQUENCE
> !
> !          CALL ML_WQRSL(X,LDX,N,K,QRAUX,Y,DUM,Y,B,Y,DUM,110,INFO)
> !
> !     WILL RESULT IN THE COMPUTATION OF B AND RSD, WITH RSD
> !     OVERWRITING Y.  MORE GENERALLY, EACH ITEM IN THE FOLLOWING
> !     LIST CONTAINS GROUPS OF PERMISSIBLE IDENTIFICATIONS FOR
> !     A SINGLE CALLING SEQUENCE.
> !
> !          1. (Y,QTY,B) (RSD) (XB) (QY)
> !
> !          2. (Y,QTY,RSD) (B) (XB) (QY)
> !
> !          3. (Y,QTY,XB) (B) (RSD) (QY)
> !
> !          4. (Y,QY) (QTY,B) (RSD) (XB)
> !
> !          5. (Y,QY) (QTY,RSD) (B) (XB)
> !
> !          6. (Y,QY) (QTY,XB) (B) (RSD)
> !
> !     IN ANY GROUP THE VALUE RETURNED IN THE ARRAY ALLOCATED TO
> !     THE GROUP CORRESPONDS TO THE LAST MEMBER OF THE GROUP.
> !
> !     LINPACK. THIS VERSION DATED 07/03/79 .
> !     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB.
> !
> !     ML_WQRSL USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS.
> !
> !     BLAS matX_waxpy,WCOPY,mat_wdotcr,mat_wdotci
> !     FORTRAN DABS,DIMAG,MIN0,MOD
> !
> !     INTERNAL VARIABLES
> !
>    INTEGER I,J,JJ,JU,KP1
>    DOUBLEPRECISION TR,TI,TEMPR,TEMPI
>    LOGICAL CB,CQY,CQTY,CR,CXB
> !
>    DOUBLEPRECISION ZDUMR,ZDUMI
>    DOUBLEPRECISION CABS1
>    CABS1(ZDUMR,ZDUMI) = DABS(ZDUMR) + DABS(ZDUMI)
> !
> !     SET INFO FLAG.
> !
>    INFO = 0
> !
> !     DETERMINE WHAT IS TO BE COMPUTED.
> !
>    CQY = JOB/10000 .NE. 0
>    CQTY = MOD(JOB,10000) .NE. 0
>    CB = MOD(JOB,1000)/100 .NE. 0
>    CR = MOD(JOB,100)/10 .NE. 0
>    CXB = MOD(JOB,10) .NE. 0
>    JU = MIN0(K,N-1)
> !
> !     SPECIAL ACTION WHEN N=1.
> !
>    IF (JU .NE. 0) GOTO 80
>    IF (.NOT.CQY) GOTO 10
>    QYR(1) = YR(1)
>    QYI(1) = YI(1)
> 10 CONTINUE
>    IF (.NOT.CQTY) GOTO 20
>    QTYR(1) = YR(1)
>    QTYI(1) = YI(1)
> 20 CONTINUE
>    IF (.NOT.CXB) GOTO 30
>    XBR(1) = YR(1)
>    XBI(1) = YI(1)
> 30 CONTINUE
>    IF (.NOT.CB) GOTO 60
>    IF (CABS1(XR(1,1),XI(1,1)) .NE. 0.0D0) GOTO 40
>    INFO = 1
>    GOTO 50
> 40 CONTINUE
>    CALL mat_wdiv(YR(1),YI(1),XR(1,1),XI(1,1),BR(1),BI(1))
> 50 CONTINUE
> 60 CONTINUE
>    IF (.NOT.CR) GOTO 70
>    RSDR(1) = 0.0D0
>    RSDI(1) = 0.0D0
> 70 CONTINUE
>    GOTO 290
> 80 CONTINUE
> !
> !        SET UP TO COMPUTE QY OR QTY.
> !
>    IF (CQY) CALL mat_wcopy(N,YR,YI,1,QYR,QYI,1)
>    IF (CQTY) CALL mat_wcopy(N,YR,YI,1,QTYR,QTYI,1)
>    IF (.NOT.CQY) GOTO 110
> !
> !           COMPUTE QY.
> !
>    DO JJ = 1, JU
>       J = JU - JJ + 1
>       IF (CABS1(QRAUXR(J),QRAUXI(J)) .EQ. 0.0D0) cycle
>       TEMPR = XR(J,J)
>       TEMPI = XI(J,J)
>       XR(J,J) = QRAUXR(J)
>       XI(J,J) = QRAUXI(J)
>       TR=-mat_wdotcr(N-J+1,XR(J,J),XI(J,J),1,QYR(J),QYI(J),1)
>       TI=-mat_wdotci(N-J+1,XR(J,J),XI(J,J),1,QYR(J),QYI(J),1)
>       CALL mat_wdiv(TR,TI,XR(J,J),XI(J,J),TR,TI)
>       CALL matX_waxpy(N-J+1,TR,TI,XR(J,J),XI(J,J),1,QYR(J), QYI(J),1)
>       XR(J,J) = TEMPR
>       XI(J,J) = TEMPI
>    enddo
> 110 CONTINUE
>    IF (.NOT.CQTY) GOTO 140
> !
> !           COMPUTE CTRANS(Q)*Y.
> !
>    DO J = 1, JU
>       IF (CABS1(QRAUXR(J),QRAUXI(J)) .EQ. 0.0D0) cycle
>       TEMPR = XR(J,J)
>       TEMPI = XI(J,J)
>       XR(J,J) = QRAUXR(J)
>       XI(J,J) = QRAUXI(J)
>       TR = -mat_wdotcr(N-J+1,XR(J,J),XI(J,J),1,QTYR(J), QTYI(J),1)
>       TI = -mat_wdotci(N-J+1,XR(J,J),XI(J,J),1,QTYR(J), QTYI(J),1)
>       CALL mat_wdiv(TR,TI,XR(J,J),XI(J,J),TR,TI)
>       CALL matX_waxpy(N-J+1,TR,TI,XR(J,J),XI(J,J),1,QTYR(J), QTYI(J),1)
>       XR(J,J) = TEMPR
>       XI(J,J) = TEMPI
>    enddo
> 140 CONTINUE
> !
> !        SET UP TO COMPUTE B, RSD, OR XB.
> !
>    IF (CB) CALL mat_wcopy(K,QTYR,QTYI,1,BR,BI,1)
>    KP1 = K + 1
>    IF (CXB) CALL mat_wcopy(K,QTYR,QTYI,1,XBR,XBI,1)
>    IF (CR .AND. K .LT. N)CALL mat_wcopy(N-K,QTYR(KP1),QTYI(KP1),1,RSDR(KP1),RSDI(KP1),1)
>    IF (.NOT.CXB .OR. KP1 .GT. N) GOTO 160
>    DO I = KP1, N
>       XBR(I) = 0.0D0
>       XBI(I) = 0.0D0
>    enddo
> 160 CONTINUE
>    IF (.NOT.CR) GOTO 180
>    DO I = 1, K
>       RSDR(I) = 0.0D0
>       RSDI(I) = 0.0D0
>    enddo
> 180 CONTINUE
>    IF (.NOT.CB) GOTO 230
> !
> !           COMPUTE B.
> !
>    DO JJ = 1, K
>       J = K - JJ + 1
>       IF (CABS1(XR(J,J),XI(J,J)) .NE. 0.0D0) GOTO 190
>       INFO = J
> !                 ......EXIT
> !           ......EXIT
>       GOTO 220
> 190   CONTINUE
>       CALL mat_wdiv(BR(J),BI(J),XR(J,J),XI(J,J),BR(J),BI(J))
>       IF (J .EQ. 1) GOTO 200
>       TR = -BR(J)
>       TI = -BI(J)
>       CALL matX_waxpy(J-1,TR,TI,XR(1,J),XI(1,J),1,BR,BI,1)
> 200   CONTINUE
>    enddo
> 220 CONTINUE
> 230 CONTINUE
>    IF (.NOT.CR .AND. .NOT.CXB) GOTO 280
> !
> !           COMPUTE RSD OR XB AS REQUIRED.
> !
>    DO JJ = 1, JU
>       J = JU - JJ + 1
>       IF (CABS1(QRAUXR(J),QRAUXI(J)) .EQ. 0.0D0) cycle
>       TEMPR = XR(J,J)
>       TEMPI = XI(J,J)
>       XR(J,J) = QRAUXR(J)
>       XI(J,J) = QRAUXI(J)
>       IF (CR) then
>          TR = -mat_wdotcr(N-J+1,XR(J,J),XI(J,J),1,RSDR(J), RSDI(J),1)
>          TI = -mat_wdotci(N-J+1,XR(J,J),XI(J,J),1,RSDR(J), RSDI(J),1)
>          CALL mat_wdiv(TR,TI,XR(J,J),XI(J,J),TR,TI)
>          CALL matX_waxpy(N-J+1,TR,TI,XR(J,J),XI(J,J),1,RSDR(J), RSDI(J),1)
>       endif
>       IF (CXB) then
>          TR = -mat_wdotcr(N-J+1,XR(J,J),XI(J,J),1,XBR(J), XBI(J),1)
>          TI = -mat_wdotci(N-J+1,XR(J,J),XI(J,J),1,XBR(J), XBI(J),1)
>          CALL mat_wdiv(TR,TI,XR(J,J),XI(J,J),TR,TI)
>          CALL matX_waxpy(N-J+1,TR,TI,XR(J,J),XI(J,J),1,XBR(J), XBI(J),1)
>       endif
>       XR(J,J) = TEMPR
>       XI(J,J) = TEMPI
>    enddo
> 280 CONTINUE
> 290 CONTINUE
> END SUBROUTINE ML_WQRSL
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> 
> $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> $ifdef TESTPRG90
> !-----------------------------------------------------------------------
>       program bigmat
>       use M_matrix
>       use M_journal, only : journal
>       !!call journal('O','mtrail.txt') ! open up trail file
>       CALL MAT88(0,' ')              ! call interpreter
>       !!call journal('O','')           ! close trail file
>       stop
>       end program bigmat
> !-----------------------------------------------------------------------
>       subroutine mat88_user_0(a,m,n,s,t)  ! sample mat88_user routine
>       doubleprecision a(m,n),s,t
> !
>       integer a3(9)
>       save a3
>       data a3 /-149,537,-27,-50,180,-9,-154,546,-25/
>       if (a(1,1) .ne. 3.0d0) return
>       do i = 1, 9
>          a(i,1) = dfloat(a3(i))
>       enddo
>       m = 3
>       n = 3
>       return
>       end
> !-----------------------------------------------------------------------
>       SUBROUTINE mat88_user_S(A,M,N,S,T)  ! sample mat88_user routine
>       use M_journal, only : journal
>       use M_strings, only : v2s
>       character*100 MLINE
>       DOUBLEPRECISION A(M,N),S,T
> !
>       if(s.eq.0.and.t.eq.0)then
>          ! print statistics for matrix, for example
>          MLINE='M='//v2s(M)//',N='//v2s(N)//',S='//v2s(N)//',T='//v2s(T)
>          call journal(mline)
> 
>          DO i10 = 1, M
>             DO i20 = 1, N
>                write(*,*)i10,i20,a(i10,i20)
>             enddo
>          enddo
>       else  ! a(i,j)=a(i,j)*s+t  in a linear fashion
>          DO i30 = 1, M
>             DO i40 = 1, N
>                a(i30,i40)=a(i30,i40)*S+T
>             enddo
>          enddo
>       endif
>       END SUBROUTINE mat88_user_S
> !==================================================================================================================================!
> !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
> !==================================================================================================================================!
> $endif
> $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> $BLOCK NULL
> # ********************** A Sample Session ***********************************
> #
> a=<1 2 3;5 4 6;7 8 9>            <---  you enter this
> #  A     =                             <---  MAT88 response
> #      1.    2.    3.
> #      5.    4.    6.
> #      7.    8.    9.
> b=<5;6;7>                        <--- you enter this
> #  B     =                             <--- MAT88 response
> #      5.
> #      6.
> #      7.
> a*b             <--- you enter "multiply a and b"
> #  ans   =            <--- MAT88 response
> #     38.
> #     91.
> #    146.
> !  <> b*a             <---you enter "multiply b and a"
> #     /--ERROR                         <--- MAT88 response
> #  INCOMPATIBLE FOR MULTIPLICATION
> det(a)         <--- Take the determinant of a
> #  ans   =           <---MAT88 response
> #     18.
> exit           <--- you quit MAT88
> #  total flops        34
> #  adios
> $BLOCK
> $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> $BLOCK NULL
>       1 ml_corth
>       1 ml_htribk
>       1 ml_htridi
>       1 ml_imtql2
>       2 ml_comqr3
>       2 ml_wgedi
> 
>       2 ml_wgesl
>       2 ml_wqrdc
>       2 ml_wqrsl
>       3 ml_wgefa
>       4 ml_wgeco
>       5 ml_wsvdc
> 
>       1 mat88_user
> $BLOCK
> $BLOCK NULL
