module M_matrix
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT
Originally based on a routine called MATLAB, although heavily modified
since. The original stated ...

   MATLAB stands for MATrix LABoratory.  It is a FORTRAN package developed
   by Argonne National Laboratories for in-house use.  It provides
   comprehensive vector and tensor operations in a package which may be
   programmed, either through a macro language or through execution of
   script files.

   Matlab is reentrant and recursive.  Functions supported include (but
   are not by any means limited to) sin, cos, tan, arcfunctions, upper
   triangular, lower triangular, determinants, matrix multiplication,
   identity, Hilbert matrices, eigenvalues and eigenvectors, matrix
   roots and products, inversion and so on and so forth.

   The file available on the bulletin board as Matlab.arc contains an
   Amiga-ized executable copy of MATLAB and the online help file, as
   well as this intro.

   If you want the source code (over 300K) and a manual, or if your
   bulletin board only has this message and not the package, send $5.00
   and a 3.5" disk to:

                              Jim Locker
                              4443 N. Hyland Ave.
                              Dayton, OH 45424

   The package is public domain, but of course postage and reproduction
   cost money.  Believe me, this package is a bargain at the price.
   Please feel free to distribute the package.

   The source was taken off a VAX 11/780. It ran without modification
   (except the file handler and some minor error handling) on an Amiga
   1000 using ABSoft Fortran v2.2.  It will run in 512K environment.
   I have seen it on IBM mainframes and IBM PCs.
================================================================================
   Changes per John S. Urban:

   Converted to do most I/O via journal() so can be used with my codes
   more easily. Also allow additional comment indicator (# in column 1)
   so can read back in trail files made by DIARY command.

   Added command history editor command ";"

   Made call to system shell with SH command

   Made case-sensitive

   Made it take directives from string on routine call

   Allow longer filenames

   Partly converted program away from use of HOLLERITH towards use of ADE
   or maybe even character variables (enough to be able to use GNU g95
   compiler, anyway). Might have to change the way I make a letter
   "hollerith" on non little-endian non-32bit platforms.

   changed RETURN command to QUIT

   built-in help document

   Sample compile commands:

      g77 --no-backslash matrix.f90
      g95 matrix.f90
      gfortran -fno-range-check matrix.f90

$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
use M_journal, only : journal
implicit none
integer,parameter :: BIGMEM=200005
public MAT88
! till get rid of type mismatches, the following are public
!==================================================================================================================================!
character(len=1024),save :: STRINGQ
integer,save             :: ISTRINGQ
integer,save             :: INITQ
!==================================================================================================================================!
INTEGER,PARAMETER        :: IALF=78
DOUBLEPRECISION          :: STKR(BIGMEM),STKI(BIGMEM)
INTEGER                  :: IDSTK(4,48),LSTK(48),MSTK(48),NSTK(48),VSIZE,LSIZE,BOT,TOP
INTEGER                  :: ALFA(IALF),ALFB(IALF),alflq,CASE
INTEGER                  :: IDS(4,32),PSTK(32),RSTK(32),PSIZE,PT,PTZ
INTEGER                  :: DDT,ERR,FMT,LCT(4),LIN(1024),LPT(6),HIO,RIO,RTE,WTE,FE
INTEGER                  :: SYM,SYN(4),BUF(1024),CHRA,FLP(2),FIN,FUN,LHS,RHS,RAN(2)
!==================================================================================================================================!
!                                       0---------1---------2---------3---------4--------- 5---------6---------7-------
!                                       01234567890123456789012345678901234567890123456789 0123456789012345678901234567
character(len=ialf),parameter ::  CH_A='0123456789abcdefghijklmnopqrstuvwxyz ();:+-*/\=.,''<>ABCDEFGHIJKLMNOPQRSTUVWXYZ'

! ALTERNATE CHARACTER SET
!                                       0---------1---------2---------3---------4---------5---------6---------7-------
!                                       012345678901234567890123456789012345678901234567890123456789012345678901234567
character(len=ialf),parameter ::  CH_B='0123456789abcdefghijklmnopqrstuvwxyz {};|+-*/$=@,"[]ABCDEFGHIJKLMNOPQRSTUVWXYZ'
!==================================================================================================================================!
integer,parameter :: eol=99
contains
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT -file mat88.3m_matrix.man
NAME
    MAT88(3f) - [M_matrix] initialize and/or pass commands to matrix laboratory interpreter
SYNOPSIS
  subroutine MAT88(init,cmd)

   integer,intent(in)          :: init
   character(len=*),intent(in) :: cmd)
DESCRIPTION
   MAT88(3f) is modeled on MATLAB(3f) (MATrix LABoratory), a FORTRAN
   package developed by Argonne National Laboratories for in-house use.
   It provides comprehensive vector and tensor operations in a package
   which may be programmed, either through a macro language or through
   execution of script files.

   Matlab is reentrant and recursive. Functions supported include (but
   are not by any means limited to) sin, cos, tan, arcfunctions, upper
   triangular, lower triangular, determinants, matrix multiplication,
   identity, Hilbert matrices, eigenvalues and eigenvectors, matrix
   roots and products, inversion and so on and so forth.

   The HELP command describes using the interpreter.

OPTIONS
   INIT   flag indicating purpose of call

            0 For ordinary first entry with reads from stdin
           -1 negative for silent initialization (ignores CMD)
            1 positive for subsequent entries, enter command mode
              reading commands from stdin.
            2 subsequent entry , return after doing CMD

   CMD     MAT88 command to perform
EXAMPLE
  Sample program

      program demo_MAT88
      use M_matrix, only : mat88
      call MAT88(0,' ')
      end program demo_MAT88
      !-------------------------------------------------------------
      SUBROUTINE mat88_user(A,M,N,S,T)  ! sample mat88_user routine
      ! Allows personal  Fortran  subroutines  to  be  linked  into
      ! MAT88. The subroutine should have the heading
      !
      !               SUBROUTINE mat88_user(A,M,N,S,T)
      !               DOUBLEPRECISION A(M,N),S,T
      !
      ! The MAT88 statement Y = USER(X,s,t) results in a call to
      ! the subroutine with a copy of the matrix X stored in the
      ! argument A, its column and row dimensions in M and N,
      ! and the scalar parameters S and T stored in S and T.
      ! If S and T are omitted, they are set to 0.0. After
      ! the return, A is stored in Y. The dimensions M and
      ! N may be reset within the subroutine. The statement Y =
      ! USER(K) results in a call with M = 1, N = 1 and A(1,1) =
      ! FLOAT(K). After the subroutine has been written, it must
      ! be compiled and linked to the MAT88 object code within the
      ! local operating system.
      !
      integer M,N
      DOUBLEPRECISION A(M,N),S,T
      !
      if(s.eq.0.and.t.eq.0)then
         ! print statistics for matrix, for example
         write(*,*)'m=',m
         write(*,*)'n=',n
         write(*,*)'s=',s
         write(*,*)'t=',t

         DO i10 = 1, M
            write(*,*)(a(i10,i20),i20=1,n)
         enddo
      else  ! a(i,j)=a(i,j)*s+t  in a linear fashion
         DO i30 = 1, M
            DO i40 = 1, N
               a(i30,i40)=a(i30,i40)*S+T
            enddo
         enddo
      endif
      END SUBROUTINE mat88_user

  Example 2:

   program bigmat
   use M_matrix, only : mat88
   ! pass strings to MAT88 but do not enter interactive mode
   call mat88(-1,' ')                    ! initialize
   call mat88( 2,'a=<1 2 3 4; 5 6 7 8>')
   call mat88( 2,'save("file1")')
   call mat88( 2,'help INTRO')
   end
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
subroutine MAT88(init,string0)

$@(#) M_matrix::mat88(3f): initialize and/or pass commands to matrix laboratory interpreter

character(len=*),intent(in) :: string0
integer                     :: init
integer                     :: istring0
doubleprecision             :: s,t
integer,save                :: EPS(4)=   [14,25,28,36]
integer,save                :: FLOPS(4)= [15,21,24,25]
integer,save                :: EYE(4)=   [14,34,14,36]
integer,save                :: RAND(4)=  [27,10,23,13]
!
!     CHARACTER SET
!            0       10       20       30       40       50
!
!     0      0        A        K        U   COLON  :  LESS   <
!     1      1        B        L        V   PLUS   +  GREAT  >
!     2      2        C        M        W   MINUS  -
!     3      3        D        N        X   STAR   *
!     4      4        E        O        Y   SLASH  /
!     5      5        F        P        Z   BSLASH \
!     6      6        G        Q  BLANK     EQUAL  =
!     7      7        H        R  LPAREN (  DOT    .
!     8      8        I        S  RPAREN )  COMMA  ,
!     9      9        J        T  SEMI   ;  QUOTE  '
!----------------------------------------------------------------
      STRINGQ=STRING0
      ISTRING0=LEN(STRING0)
      ISTRINGQ=len_trim(STRING0(1:ISTRING0))
      IF(ISTRINGQ.LE.0.AND.INIT.EQ.2)THEN
         STRINGQ='quit'
         ISTRINGQ=4
      ENDIF
      INITQ=INIT
!----------------------------------------------------------------
      IF (INIT .NE. 0 .and. INIT .ne. -1) GOTO 90     ! already initialized
      RTE = 5                                         ! unit number for terminal input
      CALL mat_files(RTE,BUF)
      RIO = RTE                                       ! current file to read commands from
      WTE = 6                                         ! unit number for terminal  output
      CALL mat_files(WTE,BUF)

      IF (INIT .GE. 0) then                           ! initializing verbose
         call journal('  < M A T 8 8 >')
         call journal(' based on MATLAB Version of 05/25/82')
      endif

      HIO = 11                                        ! UNIT NUMBER FOR HELP FILE
      CALL mat_files(HIO,BUF)                         ! open HELP FILE
      RAN(1) = 0                                      ! RANDOM NUMBER SEED
      LCT(2) = 25                                     ! INITIAL LINE LIMIT

      alflq = IALF
      CASE = 0
!     CASE = 1 for file names in lower case
!------------------------------------------------------------------------
      call mat_str2buf(ch_a,alfa,alflq) ! convert string to hollerith
      call mat_str2buf(ch_b,alfb,alflq) ! convert string to hollerith
!------------------------------------------------------------------------
!
      VSIZE = BIGMEM
      LSIZE = 48
      PSIZE = 32
      BOT = LSIZE-3
      CALL mat_wset(5,0.0D0,0.0D0,STKR(VSIZE-4),STKI(VSIZE-4),1)
      CALL mat_putid(IDSTK(1,LSIZE-3),EPS)
      LSTK(LSIZE-3) = VSIZE-4
      MSTK(LSIZE-3) = 1
      NSTK(LSIZE-3) = 1

      S = 1.0D0
   30 continue
      S = S/2.0D0
      T = 1.0D0 + S
      IF (T .GT. 1.0D0) GOTO 30
      STKR(VSIZE-4) = 2.0D0*S

      CALL mat_putid(IDSTK(1,LSIZE-2),FLOPS)
      LSTK(LSIZE-2) = VSIZE-3
      MSTK(LSIZE-2) = 1
      NSTK(LSIZE-2) = 2
      CALL mat_putid(IDSTK(1,LSIZE-1), EYE)
      LSTK(LSIZE-1) = VSIZE-1
      MSTK(LSIZE-1) = -1
      NSTK(LSIZE-1) = -1
      STKR(VSIZE-1) = 1.0D0
      CALL mat_putid(IDSTK(1,LSIZE), RAND)
      LSTK(LSIZE) = VSIZE
      MSTK(LSIZE) = 1
      NSTK(LSIZE) = 1
      FMT = 1
      FLP(1) = 0
      FLP(2) = 0
      DDT = 0
      RAN(2) = 0
      PTZ = 0
      PT = PTZ
      ERR = 0
      IF (INIT .EQ. -1) RETURN
!
90    continue
      INFINITE : do
         CALL mat_parse(INIT)
         select case(fun)
         case(1) ; call mat_matfn1()
         case(2) ; call mat_matfn2()
         case(3) ; call mat_matfn3()
         case(4) ; call mat_matfn4()
         case(5) ; call mat_matfn5()
         case(6) ; call mat_matfn6()
         case(21); call mat_matfn1()
         case(99); exit INFINITE
         case default
         end select
      enddo INFINITE

end subroutine MAT88
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_err(n)
integer,intent(in) :: n
integer,parameter         :: linelen=255
character(len=linelen)    :: blh
character(len=linelen)    :: msg
character(len=linelen+20) :: mline
integer                   :: iend
integer                   :: k
integer                   :: kk
integer                   :: i
integer                   :: i9400
integer                   :: lb
integer                   :: lt

   blh(1:linelen)='        '
!
   k = lpt(2) - lpt(1)
   if (k .lt. 1) k = 1
   select case(n)
    case(1); msg='IMPROPER MULTIPLE ASSIGNMENT'
    case(2); msg='IMPROPER FACTOR'
    case(3); msg='EXPECT RIGHT PARENTHESIS'
!.......................................................................
    case(4);
      DO I9400 = 1, 4
         KK = IDS(I9400,PT+1)
         BUF(I9400) = ALFA(KK+1)
      enddo
      call mat_buf2str(msg,buf,4)
      msg='UNDEFINED VARIABLE: '//msg(1:4)
!.......................................................................
    case(5); msg='COLUMN LENGTHS DO NOT MATCH'
    case(6); msg='ROW LENGTHS DO NOT MATCH'
    case(7); msg='TEXT TOO LONG'
    case(8); msg='Incompatible for ADDITION'
    case(9); msg='Incompatible for SUBTRACTION'
    case(10); msg='Incompatible for MULTIPLICATION'
    case(11); msg='Incompatible for RIGHT DIVISION'
    case(12); msg='Incompatible for LEFT DIVISION'
    case(13); msg='Improper assignment to PERMANENT VARIABLE'
    case(14); msg='EYE-dentity undefined by CONTEXT'
    case(15); msg='IMPROPER ASSIGNMENT TO SUBMATRIX'
    case(16); msg='IMPROPER COMMAND'
!.......................................................................
    case(17)
      LB = VSIZE - LSTK(BOT) + 1
      LT = ERR + LSTK(BOT)
      call journal(' TOO MUCH MEMORY REQUIRED')
      WRITE(MLINE,'(1X,I7,'' VARIABLES,'',I7,'' TEMPORARIES,'',I7,'' AVAILABLE.'')') LB,LT,VSIZE
      call journal(MLINE)
      GOTO 999
!.......................................................................
    case(18); msg='TOO MANY NAMES'
    case(19); msg='MATRIX IS SINGULAR TO WORKING PRECISION'
    case(20); msg='MATRIX MUST BE SQUARE'
    case(21); msg='SUBSCRIPT OUT OF RANGE'
!.......................................................................
    case(22)
      WRITE(MLINE,122) (RSTK(I),I=1,PT)
122   FORMAT(1X,'RECURSION DIFFICULTIES',10I4)
      call journal(mline)
      GOTO 999
!.......................................................................
    case(23); msg='ONLY 1, 2 OR INF NORM OF MATRIX'
    case(24); msg='NO CONVERGENCE'
    case(25); msg='CAN NOT USE FUNCTION NAME AS VARIABLE'
    case(26); msg='TOO COMPLICATED (STACK OVERFLOW)'
    case(27); msg='DIVISION BY ZERO IS A NO-NO'
    case(28); msg='EMPTY MACRO'
    case(29); msg='NOT POSITIVE DEFINITE'
    case(30); msg='IMPROPER EXPONENT'
    case(31); msg='IMPROPER STRING'
    case(32); msg='SINGULARITY OF LOG OR ATAN'
    case(33); msg='TOO MANY COLONS'
    case(34); msg='IMPROPER FOR CLAUSE'
    case(35); msg='IMPROPER WHILE OR IF CLAUSE'
    case(36); msg='ARGUMENT OUT OF RANGE'
    case(37); msg='IMPROPER MACRO'
    case(38); msg='IMPROPER FILE NAME'
    case(39); msg='INCORRECT NUMBER OF ARGUMENTS'
    case(40); msg='EXPECT STATEMENT TERMINATOR'
!.......................................................................
    case default
    call journal('sc','*mat_err* unknown error code =',n)
    goto 999
!.......................................................................
   end select


   iend=max(1,len_trim(msg))

   if(k+iend.lt.len(mline))then
      write(mline,'(1x,a,''/^--ERROR:'',a)') blh(1:k),msg(1:iend)
      call journal(mline)
   else
      WRITE(mline,'(1x,a,''/^--ERROR:'')') blh(1:k)
      call journal(mline)
      call journal(msg)
   endif
   goto 999
!.......................................................................
999 continue
   err = n
end subroutine mat_err
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_files(lunit,iname)
integer :: lunit !  logical unit number
   ! if LUNIT is zero, return
   ! if LUNIT = standard input, return
   ! if LUNIT = standard output, return
   ! if LUNIT is 11, open the help file
   ! if LUNIT is -11 and HIO .ne. 0 , rewind the help file
   ! if LUNIT is positive, open the unit to file name INAME
   ! if LUNIT is negative, close the unit number
!     INAME = FILE NAME, 1 character per word
   ! how to know length of iname?
integer                      :: iname(256)
character(len=1024)          :: name
character(len=1024)          :: temp1
integer                      :: ios
integer                      :: itemp
integer                      :: itemp1
!  Amiga dependent stuff squeezes the NAME from one CHAR per word to one per byte
!.......................................................................
   if (ddt .eq. 1) then
      call journal('sc','*MLFILES* LUNIT=', LUNIT)
      name(1:10)='*MLFILES* INAME='
      call mat_buf2str(name(11:),iname,256)
      call journal(name)
   endif
!.......................................................................
   fe=0
   select case(lunit)
    case(0) ! error catcher
    case(5) ! if unit is standard input return
    case(6) ! if unit is standard output return
    case(8) ! diary file
       call mat_buf2str(name,iname,256)
       call journal('O',trim(name)) ! open up trail file
    case(11)                                                         ! HELP FILE
      temp1=' '
      call get_environment_variable('ML88_HELP',temp1)              ! get default name for helpfile to override built-in file
      if(temp1(:).eq.' ')then                                       ! create and open scratch help file
         !! temp1='MAT88_help.txt'
         open(11,status='scratch',iostat=ios)
         call mat_make_help(lunit)
         rewind(11,iostat=ios)
      else                                                          ! try to use user-specified help file instead of built-in file
         itemp1=max(1,len_trim(temp1))
         open(11,file=temp1(:itemp1),status='old',iostat=ios)       ! open help file
         if(ios.ne.0)then                                           ! HELP FILE NOT FOUND
            call journal('HELP IS NOT AVAILABLE ON FILE ...')
            call journal(temp1(1:itemp1))
            HIO = 0
         else
            !call journal('HELP is available')
         endif
      endif
    case(:-1)
      if( lunit .eq. -11 .and. hio .ne. 0)then                       ! SPECIAL CASE FOR HELP FILE
         rewind (11,iostat=ios)
      elseif(lunit.eq.-8)then
         call journal('O','')                                        ! close trail file
      else                                                           ! if LUNIT is negative, close the unit
         flush(unit=-lunit,iostat=ios)
         close(unit=-lunit,iostat=ios)
      endif
    case default                                                     !  ALL OTHER FILES
      call mat_buf2str(name,iname,256)
      itemp=len_trim(name)
      !call journal('filename='//name(:itemp)
      open(unit=lunit,file=name(:itemp),status='unknown',iostat=ios) ! open a file
      if(ios.ne.0)then                                               ! general file open failure
         call journal('*mat_files* OPEN FILE FAILED')
         call journal(name(1:len_trim(name)))
         fe=1                                                        ! set the I/O to terminal I/O
         rio=rte                                                     ! set current file to read input lines from/to RTE
      endif
   end select
end subroutine mat_files
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getsym()

$@(#) m_matrix::mat_getsym(3fp): get a symbol

character(len=80) ::  mline
integer,parameter :: a2=52
integer,parameter :: z2=77

doubleprecision   :: syv
doubleprecision   :: s

integer,save :: BLANK=36
integer,save :: Z=35
integer,save :: DOT=47

integer,parameter  :: d=13, d_up=55
integer,parameter  :: e=14, e_up=56

integer,save :: PLUS=41
integer,save :: MINUS=42
integer,save :: NAME=1
integer,save :: NUM=0
integer,save :: STAR=43
integer,save :: SLASH=44
integer,save :: BSLASH=45

integer      :: SIGN
integer      :: CHCNT
integer      :: SS
integer      :: i
!.......................................................................
   INFINITE : do
      if (chra .ne. blank) exit INFINITE
      call mat_getch() ! get next character
   enddo INFINITE
!.......................................................................
   lpt(2) = lpt(3)
   lpt(3) = lpt(4)
   if (chra .le. 9) goto 50                                 ! numeric character (0-9)
   if (chra .le. z.or.(chra.ge.a2.and.chra.le.z2)) goto 30  ! alphameric (A-Z OR a-z)
!.......................................................................
!     special character
   ss = sym
   sym = chra
   call mat_getch() ! get next character
   if (sym .ne. dot) goto 90
!
!     is dot part of number or operator
   syv = 0.0d0
   if (chra .le. 9) goto 55  ! a number character
   if (chra.eq.star.or.chra.eq.slash.or.chra.eq.bslash) goto 90
   if (ss.eq.star .or. ss.eq.slash .or. ss.eq.bslash) goto 90
   goto 55
!.......................................................................
!     name
30 continue
   sym = name
   syn(1) = chra
   chcnt = 1
40 continue
   call mat_getch() ! get next character
   chcnt = chcnt+1
   if (chra .ge. a2.and.chra.le.z2) goto  44! alternate case letter
   if (chra .gt. z) goto 45  ! a control character not alphanumeric and not special like eol
44 continue
   if (chcnt .le. 4) syn(chcnt) = chra
   goto 40
45 continue
   if (chcnt .gt. 4) goto 47
   do i = chcnt, 4
      syn(i) = blank
   enddo
47 continue
   goto 90
!.......................................................................
!     number
50 continue
   call mat_getval(syv)
   if (chra .ne. dot) goto 60
   call mat_getch() ! get next character
55 continue
   chcnt = lpt(4)
   call mat_getval(s)
   chcnt = lpt(4) - chcnt
   if (chra .eq. eol) chcnt = chcnt+1
   syv = syv + s/10.0d0**chcnt
60 continue
   if (chra.ne.d .and. chra.ne.e .and. chra.ne.d_up .and. chra.ne.e_up ) goto 70
   call mat_getch() ! get next character
   sign = chra
   if (sign.eq.minus .or. sign.eq.plus) call mat_getch() ! get next character
   call mat_getval(s)
   if (sign .ne. minus) syv = syv*10.0d0**s
   if (sign .eq. minus) syv = syv/10.0d0**s
70 continue
   stki(vsize) = mat_flop(syv)
   sym = num
!
90 continue
   if (chra .ne. blank) goto 99
   call mat_getch() ! get next character
   goto 90
99 continue
   if (ddt .ne. 1) return
   if (sym.gt.name .and. sym.lt.alflq) then
      call journal(char(alfa(sym+1)))
   endif
   if (sym .ge. alflq) call journal('eol')
   if (sym .eq. name) call mat_prntid(syn,1)
   if (sym .eq. num) then
      write(mline,'(1x,g8.2)') syv
      call journal(mline)
   endif
end subroutine mat_getsym
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_str2buf(string,buf,lrecl)

$@(#) M_matrix::mat_str2buf(3fp) :: convert string to hollerith

! g95 compiler does not support Hollerith, this is a KLUDGE to give time to think about it

character(len=*),intent(in) ::  string
integer,intent(out)         :: buf(lrecl)
integer,intent(in)          :: lrecl
integer                     :: i10

   do i10=1,lrecl
      buf(i10)=ichar(string(i10:i10))+538976304-48
   enddo

end subroutine mat_str2buf
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_buf2str(string,buf,lrecl) ! convert string to hollerith
integer,intent(in)           :: lrecl
integer,intent(in)           :: buf(lrecl)
character(len=*)             :: string
integer                      :: i10
   string(:)=' '
   do i10=1,lrecl
      if(buf(i10).eq.0)exit
      string(i10:i10)=char(buf(i10)-538976304+48)
   enddo
end subroutine mat_buf2str
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_hilber(a,lda,n)

$@(#) M_matrix::ml_hilbr(3fp): generate inverse hilbert matrix

integer         :: lda
integer         :: n
doubleprecision :: a(lda,n)
doubleprecision :: p
doubleprecision :: r
integer         :: i
integer         :: j
integer         :: ip1

   p = dfloat(n)

   do i = 1, n
      if (i.ne.1) p = (dfloat(n-i+1)*p*dfloat(n+i-1))/dfloat(i-1)**2
      r = p*p
      a(i,i) = r/dfloat(2*i-1)
      if (i.eq.n) cycle
      ip1 = i+1
      do j = ip1, n
         r = (-1)*(dfloat(n-j+1)*r*(n+j-1))/dfloat(j-1)**2
         a(i,j) = r/dfloat(i+j-1)
         a(j,i) = a(i,j)
      enddo
   enddo

end subroutine mat_hilber
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn6()
!
$@(#) M_matrix::mat_matfn6(3f):evaluate utility functions
!
integer :: i
integer :: ia
integer :: ib
integer :: j
integer :: ja
integer :: jb
integer :: k
integer :: l
integer :: la
integer :: lb
integer :: ld
integer :: lj
integer :: ll
integer :: ls
integer :: m
integer :: ma
integer :: mn
integer :: n
integer :: na
integer :: nn

integer,save      :: semi=39
integer,save      :: unifor(4) =[30,23,18,15]
integer,save      :: normal(4) =[23,24,27,22]
integer,save      :: seed(4)   =[28,14,14,13]
integer           :: id(4)
doubleprecision   :: eps0,eps,s,sr,si,t
character(len=80) :: mline
!
      IF (DDT .EQ. 1) call journal('sc','*MATFN6* ',FIN)
!     FUNCTIONS/FIN
!     MAGI DIAG SUM  PROD USER EYE  RAND ONES CHOP SIZE KRON  TRIL TRIU
!       1    2    3    4    5    6    7    8    9   10  11-13  14   15
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      FUN6: select case(fin)
!===================================================================================================================================
!  COMMAND::KRONECKER PRODUCT
   case(11,12,13)
      IF (RHS .NE. 2) CALL mat_err(39)
      IF (ERR .GT. 0) RETURN
      TOP = TOP - 1
      L = LSTK(TOP)
      MA = MSTK(TOP)
      NA = NSTK(TOP)
      LA = L + MAX0(M*N*MA*NA,M*N+MA*NA)
      LB = LA + MA*NA
      ERR = LB + M*N - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
!     MOVE A AND B ABOVE RESULT
      CALL mat_wcopy(MA*NA+M*N,STKR(L),STKI(L),1,STKR(LA),STKI(LA),1)
      DO JA = 1, NA
        DO J = 1, N
          LJ = LB + (J-1)*M
          DO IA = 1, MA
!           GET J-TH COLUMN OF B
            CALL mat_wcopy(M,STKR(LJ),STKI(LJ),1,STKR(L),STKI(L),1)
!           ADDRESS OF A(IA,JA)
            LS = LA + IA-1 + (JA-1)*MA
            DO I = 1, M
!             A(IA,JA) OP B(I,J)
              IF (FIN .EQ. 11) CALL mat_wmul(STKR(LS),STKI(LS),STKR(L),STKI(L),STKR(L),STKI(L))
              IF (FIN .EQ. 12) CALL mat_wdiv(STKR(LS),STKI(LS),STKR(L),STKI(L),STKR(L),STKI(L))
              IF (FIN .EQ. 13) CALL mat_wdiv(STKR(L),STKI(L),STKR(LS),STKI(LS),STKR(L),STKI(L))
              IF (ERR .GT. 0) RETURN
              L = L + 1
            ENDDO
          enddo
        enddo
      enddo
      MSTK(TOP) = M*MA
      NSTK(TOP) = N*NA
!===================================================================================================================================
      case(9) ! COMMAND::CHOP
      EPS0 = 1.0D0
   61 continue
      EPS0 = EPS0/2.0D0
      T = mat_flop(1.0D0 + EPS0)
      IF (T .GT. 1.0D0) GOTO 61
      EPS0 = 2.0D0*EPS0
      FLP(2) = IDINT(STKR(L))
      IF (SYM .NE. SEMI) then
         WRITE(mline,'(''CHOP '',I2,'' PLACES.'')') FLP(2)
         call journal(mline)
      endif
      EPS = 1.0D0
   63 continue
      EPS = EPS/2.0D0
      T = mat_flop(1.0D0 + EPS)
      IF (T .GT. 1.0D0) GOTO 63
      EPS = 2.0D0*EPS
      T = STKR(VSIZE-4)
      IF (T.LT.EPS .OR. T.EQ.EPS0) STKR(VSIZE-4) = EPS
      MSTK(TOP) = 0
!===================================================================================================================================
      case(3) ! COMMAND::SUM
      SR = 0.0D0
      SI = 0.0D0
      MN = M*N
      DO I = 1, MN
         LS = L+I-1
         SR = mat_flop(SR+STKR(LS))
         SI = mat_flop(SI+STKI(LS))
      enddo
      STKR(L) = SR
      STKI(L) = SI
      MSTK(TOP) = 1
      NSTK(TOP) = 1
!===================================================================================================================================
      case(4) ! COMMAND::PROD
      SR = 1.0D0
      SI = 0.0D0
      MN = M*N
      DO I = 1, MN
         LS = L+I-1
         CALL mat_wmul(STKR(LS),STKI(LS),SR,SI,SR,SI)
      enddo
      STKR(L) = SR
      STKI(L) = SI
      MSTK(TOP) = 1
      NSTK(TOP) = 1
!===================================================================================================================================
      case(5) ! COMMAND::USER
      S = 0.0D0
      T = 0.0D0
      IF (RHS .LT. 2) GOTO 72
      IF (RHS .LT. 3) GOTO 71
      T = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
   71 continue
      S = STKR(L)
      TOP = TOP-1
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
   72 continue
      CALL mat88_user(STKR(L),M,N,S,T)
      CALL mat_rset(M*N,0.0D0,STKI(L),1)
      MSTK(TOP) = M
      NSTK(TOP) = N
!===================================================================================================================================
      case(1) ! COMMAND::MAGIC
      N = MAX0(IDINT(STKR(L)),0)
      IF (N .EQ. 2) N = 0
      IF (N .GT. 0) CALL mat_magic(STKR(L),N,N)
      CALL mat_rset(N*N,0.0D0,STKI(L),1)
      MSTK(TOP) = N
      NSTK(TOP) = N
!===================================================================================================================================
      case(10) ! COMMAND::SIZE
      STKR(L) = M
      STKR(L+1) = N
      STKI(L) = 0.0D0
      STKI(L+1) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 2
      IF (LHS .EQ. 1) exit FUN6
      NSTK(TOP) = 1
      TOP = TOP + 1
      LSTK(TOP) = L+1
      MSTK(TOP) = 1
      NSTK(TOP) = 1
!===================================================================================================================================
      case(2,14,15) ! COMMAND::DIAG=2 ! COMMAND::TRIL=14 ! COMMAND::TRIU=15
      K = 0
      IF (RHS .NE. 2) GOTO 81
         K = IDINT(STKR(L))
         TOP = TOP-1
         L = LSTK(TOP)
         M = MSTK(TOP)
         N = NSTK(TOP)
   81 continue
      IF (FIN .GE. 14) GOTO 85
      IF (M .EQ. 1 .OR. N .EQ. 1) GOTO 83
      IF (K.GE.0) MN=MIN0(M,N-K)
      IF (K.LT.0) MN=MIN0(M+K,N)
      MSTK(TOP) = MAX0(MN,0)
      NSTK(TOP) = 1
      IF (MN .LE. 0) exit FUN6
      DO I = 1, MN
         IF (K.GE.0) LS = L+(I-1)+(I+K-1)*M
         IF (K.LT.0) LS = L+(I-K-1)+(I-1)*M
         LL = L+I-1
         STKR(LL) = STKR(LS)
         STKI(LL) = STKI(LS)
      enddo
      exit FUN6
!-----------------------------------------------------------------------------------------------------------------------------------
   83 continue
      N = MAX0(M,N)+IABS(K)
      ERR = L+N*N - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      MSTK(TOP) = N
      NSTK(TOP) = N
      DO JB = 1, N
         DO IB = 1, N
            J = N+1-JB
            I = N+1-IB
            SR = 0.0D0
            SI = 0.0D0
            IF (K.GE.0) LS = L+I-1
            IF (K.LT.0) LS = L+J-1
            LL = L+I-1+(J-1)*N
            IF (J-I .EQ. K) SR = STKR(LS)
            IF (J-I .EQ. K) SI = STKI(LS)
            STKR(LL) = SR
            STKI(LL) = SI
         enddo
      enddo
      exit FUN6
!-----------------------------------------------------------------------------------------------------------------------------------
! COMMAND::TRIL, COMMAND::TRIU
   85 continue
      DO J = 1, N
         LD = L + J - K - 1 + (J-1)*M
         IF (FIN .EQ. 14) LL = J - K - 1
         IF (FIN .EQ. 14) LS = LD - LL
         IF (FIN .EQ. 15) LL = M - J + K
         IF (FIN .EQ. 15) LS = LD + 1
         IF (LL .GT. 0) CALL mat_wset(LL,0.0D0,0.0D0,STKR(LS),STKI(LS),1)
      enddo
!===================================================================================================================================
      case(6,7,8) ! COMMAND::EYE, COMMAND::RAND, COMMAND::ONES
      IF (M.GT.1 .OR. RHS.EQ.0) GOTO 94
      IF (RHS .NE. 2) GOTO 91
        NN = IDINT(STKR(L))
        TOP = TOP-1
        L = LSTK(TOP)
        N = NSTK(TOP)
   91 continue
      IF (FIN.NE.7 .OR. N.LT.4) GOTO 93
      DO I = 1, 4
        LS = L+I-1
        ID(I) = IDINT(STKR(LS))
      enddo
      IF (mat_eqid(ID,UNIFOR).OR.mat_eqid(ID,NORMAL)) GOTO 97
      IF (mat_eqid(ID,SEED)) GOTO 98
   93 continue
      IF (N .GT. 1) GOTO 94
      M = MAX0(IDINT(STKR(L)),0)
      IF (RHS .EQ. 2) N = MAX0(NN,0)
      IF (RHS .NE. 2) N = M
      ERR = L+M*N - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      MSTK(TOP) = M
      NSTK(TOP) = N
      IF (M*N .EQ. 0) exit FUN6
   94 continue
      DO J = 1, N
         DO I = 1, M
           LL = L+I-1+(J-1)*M
           STKR(LL) = 0.0D0
           STKI(LL) = 0.0D0
           IF(I.EQ.J .OR. FIN.EQ.8) STKR(LL) = 1.0D0
           IF(FIN.EQ.7 .AND. RAN(2).EQ.0)STKR(LL)=mat_flop(mat_urand(RAN(1)))
           IF(FIN.NE.7 .OR. RAN(2).EQ.0) cycle
      95      continue
              SR = 2.0D0*mat_urand(RAN(1))-1.0D0
              SI = 2.0D0*mat_urand(RAN(1))-1.0D0
              T = SR*SR + SI*SI
              IF (T .GT. 1.0D0) GOTO 95
           STKR(LL) = mat_flop(SR*DSQRT((-(2.0D0*DLOG(T)))/T))
         enddo
      enddo
      exit FUN6
!-----------------------------------------------------------------------------------------------------------------------------------
!     SWITCH UNIFORM AND NORMAL
   97 continue
      RAN(2) = ID(1) - UNIFOR(1)
      MSTK(TOP) = 0
      exit FUN6
!-----------------------------------------------------------------------------------------------------------------------------------
   98 continue ! COMMAND::SEED
      IF (RHS .EQ. 2) RAN(1) = NN
      STKR(L) = RAN(1)
      MSTK(TOP) = 1
      IF (RHS .EQ. 2) MSTK(TOP) = 0
      NSTK(TOP) = 1
      exit FUN6
!===================================================================================================================================
      end select FUN6
end subroutine mat_matfn6
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_funs(id)

$@(#) M_matrix::ml_funcs(3fp):scan function list

integer,intent(in) :: id(4)
integer,parameter  :: funl=58                      ! number of functions
integer,save       :: funn(4,funl)                 ! names of functions encoded
integer,save       :: funp(funl)                   ! calling codes corresponding to the function names
integer            :: k
!
!    function names per letter position
   data funn/                                              &
   &  10,11,28,36, 10,29,10,23, 11,10,28,14, 12,17,10,27,  & !    1   ABS   ATAN  BASE  CHAR
   &  12,17,24,21, 12,17,24,25, 12,24,23,13, 12,24,23,19,  & !    2   CHOL  CHOP  COND  CONJ
   &  12,24,28,36, 13,14,29,36, 13,18,10,16, 13,18,10,27,  & !    3   COS   DET   DIAG  DIAR
   &  13,18,28,25, 14,18,16,36, 14,25,28,36, 14,33,14,12,  & !    4   DISP  EIG   EPS   EXEC
   &  14,33,25,36, 14,34,14,36, 15,21,24,25, 17,14,28,28,  & !    5   EXP   EYE   FLOP  HESS
   &  17,18,21,11, 18,22,10,16, 18,23,31,36, 20,27,24,23,  & !    6   HILB  IMAG  INV   KRON
   &  21,18,23,14, 21,24,10,13, 21,24,16,36, 21,30,36,36,  & !    7   LINE  LOAD  LOG   LU
   &  22,10,16,18, 23,24,27,22, 24,23,14,28, 24,27,29,17,  & !    8   MAGIC NORM  ONES  ORTH
   &  25,18,23,31, 25,21,24,29, 25,24,21,34, 25,27,18,23,  & !    9   PINV  PLOT  POLY  PRINT
   &  25,27,24,13, 26,27,36,36, 27,10,23,13, 27,10,23,20,  & !    10  PROD  QR    RAND  RANK
   &  27,10,29,36, 27,12,24,23, 27,14,10,21, 27,24,24,29,  & !    11  RAT   RCOND REAL  ROOT
   &  27,24,30,23, 27,27,14,15, 28,10,31,14, 28,12,17,30,  & !    12  ROUND RREF  SAVE  SCHUR
   &  28,18,23,36, 28,18,35,14, 28,26,27,29, 28,30,22,36,  & !    13  SIN   SIZE  SQRT  SUM
   &  28,31,13,36, 29,27,18,21, 29,27,18,30, 30,28,14,27,  & !    14  SVD   TRIL  TRIU  USER
   &  13,14,11,30, 13,24,12,36 /                             !    15  DEBUG DOC
!
!    determine what to call for each name.
!     o first digit indicates which routine to call (SUBROUTINE ML_MATFN[1-6])
!     o remaining digits indicate nth number in computed goto in called routine
!
   data funp/                                              &
   &  221,203,507,509, 106,609,303,225, 202,102,602,505,   &
   &  506,211,000,501, 204,606,000,213, 105,224,101,611,   &
   &  508,503,206,104, 601,304,608,402, 302,510,214,504,   &
   &  604,401,607,305, 511,103,223,215, 222,107,502,212,   &
   &  201,610,205,603, 301,614,615,605, 512,513 /
!
!  print function names and return
   if (id(1).eq.0) then
      call mat_prntid(funn,funl)
      return
   endif
!
!  find FUNP value for given function name
   do k = 1, funl
      if (mat_eqid(id,funn(1,k))) goto 20
   enddo
!  function name was not found
   fin = 0
   return
!  found name so great FIN and FUN value from corresponding FUNP code

20 continue
   fin = mod(funp(k),100) ! which routine to call (SUBROUTINE ML_MATFN[1-6])
   fun = funp(k)/100      ! which case to select in called procedure

   if (rhs.eq.0 .and. funp(k).eq.606) fin = 0
   if (rhs.eq.0 .and. funp(k).eq.607) fin = 0
end subroutine mat_funs
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_putid(x,y)

$@(#) M_matrix::mat_putid(3fp): store a name

integer,intent(out) :: x(4)
integer,intent(in)  :: y(4)
integer             :: i
      do i = 1, 4
         x(i) = y(i)
      enddo
end subroutine mat_putid
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getval(s)

$@(#) M_matrix::mat_getval(3fp): form numerical value

doubleprecision,intent(out) :: s
      s = 0.0d0
      INFINITE: do
         if (chra .gt. 9) exit INFINITE
         s = 10.0d0*s + dble(chra)
         call mat_getch() ! get next character
      enddo INFINITE
end subroutine mat_getval
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getch()

$@(#) M_matrix::mat_getch(3f): get next character from input line

integer :: l

   l = lpt(4)
   chra = lin(l)
   if (chra .ne. eol) lpt(4) = l + 1

end subroutine mat_getch
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotur(n,xr,xi,incx,yr,yi,incy)
integer,intent(in)         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

doubleprecision :: s
integer         :: ix
integer         :: iy
integer         :: i

   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         s = mat_flop(s + xr(ix)*yr(iy) - xi(ix)*yi(iy))
         ix = ix + incx
         iy = iy + incy
      enddo
   endif

   mat_wdotur = s

end function mat_wdotur
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_appnum(rval,string,ilen,ierr)
use M_strings, only: value_to_string

$@(#) M_matrix::mat_appnum(3fp): subroutine returns a string given a prefix string and a real value

!     Input string should have at least 20 blank characters at end
!     03/16/87 J. S. Urban
!
!-------------------------------------------------------------------------------
      real,intent(in)                :: rval   ! input value to convert to characters and append to STRING
      character(len=*)               :: string ! string to append string value of RVAL to
      integer,intent(out)            :: ilen   ! new length of STRING on output
      integer,intent(out)            :: ierr   ! flag to indicate if error occurred
!-------------------------------------------------------------------------------
      intrinsic                      :: len_trim
!-------------------------------------------------------------------------------
      character(len=20)              :: chars  ! scratch string to store string representation of RVAL in
      integer                        :: ilen2  ! length of string created by converting RVAL to a string
!-------------------------------------------------------------------------------
      ierr=0                                   ! initialize error flag to indicate no errors
      chars=' '                                ! initialize scratch string to all blanks
      ilen=len_trim(string(:len(string)))      ! find last non-blank character in initial input string

      call value_to_string(rval,chars,ilen2,ierr)         ! convert RVAL to a string in CHARS
      if(ilen+ilen2.gt.len(string))then
         call journal('sc','*mat_appnum* error: input string variable too short to store output string')
         call journal('sc','*mat_appnum* '//string,rval)
         ierr=-1
      else
         string=string(:ilen)//chars(:ilen2)   ! append CHARS to STRING
         ilen=ilen+ilen2                       ! calculate length of new string
      endif
end subroutine mat_appnum
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wcopy(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

integer :: ix
integer :: iy
integer :: i
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         yr(iy) = xr(ix)
         yi(iy) = xi(ix)
         ix = ix + incx
         iy = iy + incy
      enddo
   endif
end subroutine mat_wcopy
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wdiv(ar,ai,br,bi,cr,ci)

$@(#) M_matrix::mat_wdiv(3fp): c = a/b

doubleprecision :: ar
doubleprecision :: ai
doubleprecision :: br
doubleprecision :: bi
doubleprecision :: cr
doubleprecision :: ci

doubleprecision :: s
doubleprecision :: d
doubleprecision :: ars
doubleprecision :: ais
doubleprecision :: brs
doubleprecision :: bis

   s = dabs(br) + dabs(bi)
   if (s .eq. 0.0d0) call mat_err(27)
   if (s .eq. 0.0d0) return
   ars = ar/s
   ais = ai/s
   brs = br/s
   bis = bi/s
   d = brs**2 + bis**2
   cr = mat_flop((ars*brs + ais*bis)/d)
   ci = (ais*brs - ars*bis)/d
   if (ci .ne. 0.0d0) ci = mat_flop(ci)
end subroutine mat_wdiv
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wset(n,xr,xi,yr,yi,incy)
integer         :: n
doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

integer         :: iy
integer         :: i
   iy = 1
   if (n .le. 0 ) return
   do i = 1,n
      yr(iy) = xr
      yi(iy) = xi
      iy = iy + incy
   enddo
end subroutine mat_wset
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_base(x,b,eps,s,n)
doubleprecision :: x
doubleprecision :: b
doubleprecision :: eps
doubleprecision :: s(*)
integer         :: n

doubleprecision :: t
!
$@(#) M_matrix::mat_base(3fp): store base b representation of x in s(1:n)
!
integer,save :: plus=41
integer,save :: minus=42
integer,save :: dot=47
integer,save :: zero=0
integer,save :: comma=48

integer      :: l
integer      :: j
integer      :: k
integer      :: m

   l = 1
   if (x .ge. 0.0d0) s(l) = plus
   if (x .lt. 0.0d0) s(l) = minus
   s(l+1) = zero
   s(l+2) = dot
   x = dabs(x)
   if (x .ne. 0.0d0) then
      k = dlog(x)/dlog(b)
   else
      k = 0
   endif
   if (x .gt. 1.0d0) k = k + 1
   x = x/b**k
   if (b*x .ge. b) k = k + 1
   if (b*x .ge. b) x = x/b
   if (eps .ne. 0.0d0)then
      m = (-1)*dlog(eps)/dlog(b) + 4
   else
      m = 54
   endif
   do l = 4, m
      x = b*x
      j = idint(x)
      s(l) = dfloat(j)
      x = x - s(l)
   enddo
   s(m+1) = comma
   if (k .ge. 0) s(m+2) = plus
   if (k .lt. 0) s(m+2) = minus
   t = dabs(dfloat(k))
   n = m + 3
   if (t .ge. b) n = n + idint(dlog(t)/dlog(b))
   l = n
20 continue
   j = idint(dmod(t,b))
   s(l) = dfloat(j)
   l = l - 1
   t = t/b
   if (l .ge. m+3) goto 20
end subroutine mat_base
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wswap(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

doubleprecision :: t

integer         :: i
integer         :: ix
integer         :: iy

   if (n .le. 0) return
   ix = 1
   iy = 1
   if (incx.lt.0) ix = (-n+1)*incx + 1
   if (incy.lt.0) iy = (-n+1)*incy + 1
   do i = 1, n
      t = xr(ix)
      xr(ix) = yr(iy)
      yr(iy) = t
      t = xi(ix)
      xi(ix) = yi(iy)
      yi(iy) = t
      ix = ix + incx
      iy = iy + incy
   enddo
end subroutine mat_wswap
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_pythag(a,b)
doubleprecision :: a
doubleprecision :: b

doubleprecision :: p
doubleprecision :: q
doubleprecision :: r
doubleprecision :: s
doubleprecision :: t

   p = dmax1(dabs(a),dabs(b))
   q = dmin1(dabs(a),dabs(b))

   !------- DEBUG
   if (ddt .eq. 25) then
      call journal('sc','*mat_pythag* a) P=',real(P)) ! debug 25
      call journal('sc','*mat_pythag* a) Q=',real(Q)) ! debug 25
   endif

   if (q .ne. 0.0d0) then

      INFINITE : do
         r = (q/p)**2
         t = 4.0d0 + r
         if (t .eq. 4.0d0) exit INFINITE
         s = r/t
         p = p + 2.0d0*p*s
         q = q*s
         !------- DEBUG
         if (ddt .eq. 25) then
            call journal('sc','*mat_pythag* b) P=',real(P)) ! debug 25
            call journal('sc','*mat_pythag* b) Q=',real(Q)) ! debug 25
         endif
      enddo INFINITE

   endif

   mat_pythag = p
end function mat_pythag
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_print(ID,K)

$@(#) M_matrix::mat_print(3fp): primary output routine

integer           :: id(4)
integer           :: k

character(len=81) :: mline
character(len=80) :: form
character(len=1)  :: ls_char

doubleprecision   :: s
doubleprecision   :: tr
doubleprecision   :: ti
doubleprecision   :: pr(12)
doubleprecision   :: pi(12)
integer           :: sig(12)
integer           :: typ
integer           :: f
integer           :: l,m,n,mn
integer           :: ks
integer           :: i
integer           :: ios
integer           :: istep
integer           :: j
integer           :: j1
integer           :: j2
integer           :: j3
integer           :: jinc
integer           :: jm
integer           :: ls
integer,save      :: plus=41
integer,save      :: minus=42
integer,save      :: fno(11)= [11,12,21,22,23,24,31,32,33,34,-1]
integer,save      :: fnl(11)= [12, 6, 8, 4, 6, 3, 4, 2, 3, 1, 1]


! FORMAT NUMBERS AND LENGTHS
! FMT   1       2       3       4       5
!      SHORT   LONG   SHORT E  LONG E    Z
! TYP   1       2       3
!    INTEGER  REAL   COMPLEX
!.......................................................................
   IF (LCT(1) .LT. 0) GOTO 99
!.......................................................................
   L = LSTK(K)
   M = MSTK(K)
   N = NSTK(K)
   MN = M*N
   TYP = 1
   S = 0.0D0
   DO I = 1, MN
      LS = L+I-1
      TR = STKR(LS)
      TI = STKI(LS)
      S = DMAX1(S,DABS(TR),DABS(TI))
      IF (mat_round(TR) .NE. TR) TYP = MAX0(2,TYP)
      IF (TI .NE. 0.0D0) TYP = 3
   enddo
   IF (S .NE. 0.0D0) S = DLOG10(S)
   KS = IDINT(S)
   IF (-2 .LE. KS .AND. KS .LE. 1) KS = 0
   IF (KS .EQ. 2 .AND. FMT .EQ. 1 .AND. TYP .EQ. 2) KS = 0

   F=0                          ! initialize to bad value
   IF (TYP .EQ. 1 )THEN         ! if output type is integer
      IF( KS .LE. 2 )THEN
         F = 1
      ELSE
         F = 2
      ENDIF
   ENDIF
   IF (TYP .EQ. 1 .AND. KS .GT. 9) TYP = 2  !change type from integer to real

   IF (TYP .EQ. 2) F = FMT + 2   ! if type is real
   IF (TYP .EQ. 3) F = FMT + 6   ! if type is complex
   if(f.eq.0)then
      call journal('*mat_print* internal error - bad type')
      goto 99
   endif

   IF (MN.EQ.1 .AND. KS.NE.0 .AND. FMT.LT.3 .AND. TYP.NE.1) F = F+2

   IF (FMT .EQ. 5) F = 11

   JINC = FNL(F)
   F = FNO(F)

   S = 1.0D0
   IF (F.EQ.21 .OR. F.EQ.22 .OR. F.EQ.31 .OR. F.EQ.32) S = 10.0D0**KS
   LS = ((N-1)/JINC+1)*M + 2
!.......................................................................
   IF (LCT(1) + LS .LE. LCT(2)) GOTO 20
   LCT(1) = 0

   WRITE(mline,43) LS
43 FORMAT(' AT LEAST ',I5,' MORE LINES.','  ENTER BLANK LINE TO CONTINUE OUTPUT.')
   call journal(mline)

   READ(RTE,'(a1)',END=19) LS_CHAR  ! read response to pause from standard input
   IF (LS_CHAR .EQ. ' ') GOTO 20         ! if blank or a return display the values
   LCT(1) = -1
   GOTO 99
19 CONTINUE
   CALL mat_files(-RTE,BUF)
20 CONTINUE
!.......................................................................
   call journal(' ')
   CALL mat_prntid(ID,-1)
   LCT(1) = LCT(1)+2
   IF (S .NE. 1.0D0)then
      WRITE(mline,'(''  '',1PD9.1,2H *)') S
      if(wte.eq.6)then
         call journal(mline)
      else
         write(wte,'(a)')mline(1:80)
      endif
   endif
   DO 80 J1 = 1, N, JINC
      J2 = MIN0(N, J1+JINC-1)
      IF (N .GT. JINC)then
         WRITE(mline,'(''     COLUMNS'',I6,'' THRU'',I6)') J1,J2
         if(wte.eq.6)then
            call journal(mline)
         else
            write(wte,'(a)')mline(1:80)
         endif
      endif
      DO 70 I = 1, M
         JM = J2-J1+1
         DO J = 1, JM
            LS = L+I-1+(J+J1-2)*M
            PR(J) = STKR(LS)/S
            PI(J) = DABS(STKI(LS)/S)
            SIG(J) = ALFA(PLUS+1)
            IF (STKI(LS) .LT. 0.0D0) SIG(J) = ALFA(MINUS+1)
         enddo
         goto(11,12)F-10
         goto(21,22,23,24)F-20
         goto(31,32,33,34)F-30
         IF (F .EQ. -1) THEN
            CALL mat_formz(WTE,STKR(LS),STKI(LS))
            goto 71
         endif
         call journal('*internal error*')
         goto 99
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
11       CONTINUE
         FORM='(1X,12F6.0)'  ! integer
         ISTEP=12
         goto 716
12       CONTINUE
         FORM='(1X,6F12.0)'  ! integer
         ISTEP=6
         goto 716

716      CONTINUE
         J3=1
7161     CONTINUE
         WRITE(mline,FORM)(PR(J),J=J3,MIN(J3+ISTEP-1,JM))
         if(wte.eq.6)then
            call journal(mline)
         else
            write(wte,'(a)')mline(1:80)
         endif
         J3=J3+ISTEP
         if(J3.le.JM)goto 7161
         GOTO 71
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
21       CONTINUE
         FORM='(1X,F9.4,7F10.4)'  ! 8 numbers
         ISTEP=8
         goto 714
22       CONTINUE
         FORM='(1X,F19.15,3F20.15)'  ! 4 numbers
         ISTEP=4
         goto 714
23       CONTINUE
         FORM='(1X,1P6D13.4)'   ! 6 numbers
         ISTEP=6
         goto 714
24       CONTINUE
         FORM='(1X,1P3D24.15)'  ! 3 numbers
         ISTEP=3
         GOTO 714

714      CONTINUE
         J3=1
7141     CONTINUE
         WRITE(mline,FORM)(PR(J),J=J3,MIN(J3+ISTEP,JM))
         if(wte.eq.6)then
            call journal(mline)
         else
            write(wte,'(a)')mline(1:80)
         endif
         J3=J3+ISTEP
         if(J3.le.JM)goto 7141
         goto 71
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
31       CONTINUE
         FORM='(1X,4(F9.4,1X,A1,F7.4,''i''))'  ! 4x3
         ISTEP=12
         goto 718
32       CONTINUE
         FORM='(1X,F19.15,A1,F18.15,''i'',F20.15,A1,F18.15,''i'')'  ! 6
         ISTEP=6
         goto 718
33       CONTINUE
         FORM='(1X,3(1PD13.4,1X,A1,1PD10.4,''i''))'  ! 9
         ISTEP=9
         goto 718
34       CONTINUE
         FORM='(1X,1PD24.15,1X,A1,1PD21.15,''i'')'  ! 3
         ISTEP=3

718      CONTINUE
         J3=1
7181     CONTINUE
         WRITE(mline,form)(PR(J),SIG(J),PI(J),J=J3,MIN(J3+ISTEP-1,JM))
         if(wte.eq.6)then
            call journal(mline)
         else
            write(wte,'(a)')mline(1:80)
         endif
         J3=J3+ISTEP
         if(J3.le.JM)goto 7181
         goto 71
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
71       CONTINUE
         LCT(1) = LCT(1)+1
70    CONTINUE
80 CONTINUE
   GOTO 99
!.......................................................................
99 CONTINUE
   if(wte.ne.6)flush(unit=wte,iostat=ios)
!
END SUBROUTINE mat_print
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wsqrt(xr,xi,yr,yi)

$@(#) M_matrix::mat_wsqrt(3fp): y = sqrt(x) with yr .ge. 0.0 and sign(yi) .eq. sign(xi)

doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr
doubleprecision :: yi

doubleprecision :: s
doubleprecision :: tr
doubleprecision :: ti
!
   tr = xr
   ti = xi
   s = dsqrt(0.5d0*(mat_pythag(tr,ti) + dabs(tr)))
   if (tr .ge. 0.0d0) yr = mat_flop(s)
   if (ti .lt. 0.0d0) s = -s
   if (tr .le. 0.0d0) yi = mat_flop(s)
   if (tr .lt. 0.0d0) yr = mat_flop(0.5d0*(ti/yi))
   if (tr .gt. 0.0d0) yi = mat_flop(0.5d0*(ti/yr))
end subroutine mat_wsqrt
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wlog(xr,xi,yr,yi)

$@(#) M_matrix::mat_wlog(3fp): y = log(x)

doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr
doubleprecision :: yi
doubleprecision :: t
doubleprecision :: r
   r = mat_pythag(xr,xi)
   if (r .eq. 0.0d0) call mat_err(32)
   if (r .eq. 0.0d0) return
   t = datan2(xi,xr)
   if (xi.eq.0.0d0 .and. xr.lt.0.0d0) t = dabs(t)
   yr = dlog(r)
   yi = t
end subroutine mat_wlog
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_formz(lunit,x,y)

$@(#) M_matrix::mat_formz: system dependent routine to print with z format

integer                    :: lunit
doubleprecision,intent(in) :: x,y

character(len=36)          :: mline

   if (y .ne. 0.0d0) then
      write(mline,'(2z18)') x,y
   else
      write(mline,'(z18)') x
   endif

   call journal(mline)

end subroutine mat_formz
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_prompt(pause)

$@(#) issue interactive prompt with optional pause

integer,intent(in) :: pause
character(len=1)   :: dummy

   ! paranoid checks
   if(wte.le.0)then
      call journal('*mat_prompt* internal error: wte <= 0')
   elseif(rte.lt.0)then
      call journal('*mat_prompt* internal error: rte <= 0')
   else
      ! write prompt using format that stays on current line
      if(wte.eq.6)then
         WRITE(WTE,'(''<>'')',advance='no')   ! write prompt to interactive input
      endif
      if (pause .eq. 1) read(rte,'(a1)') dummy
   endif

end subroutine mat_prompt
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_magic(a,lda,n)
!
$@(#) M_matrix::mat_magic(3fp): Algorithms for magic squares

!        Algorithims taken from
!        Mathematical Recreations and Essays, 12th Ed.,
!        by W. W. Rouse Ball and H. S. M. Coxeter
!
integer         :: lda
doubleprecision :: a(lda,n)
integer         :: n

doubleprecision :: t
integer         :: i
integer         :: j
integer         :: k
integer         :: m
integer         :: mm
integer         :: i1
integer         :: im
integer         :: j1
integer         :: jm
integer         :: m1
integer         :: m2
!
   if (mod(n,4) .eq. 0) goto 100
   if (mod(n,2) .eq. 0) m = n/2
   if (mod(n,2) .ne. 0) m = n
!
!     odd order or upper corner of even order
!
   do j = 1,m
      do i = 1,m
         a(i,j) = 0
      enddo
   enddo
   i = 1
   j = (m+1)/2
   mm = m*m
   do k = 1, mm
      a(i,j) = k
      i1 = i-1
      j1 = j+1
      if(i1.lt.1) i1 = m
      if(j1.gt.m) j1 = 1
      if(idint(a(i1,j1)).eq.0) goto 30
      i1 = i+1
      j1 = j
30    continue
      i = i1
      j = j1
   enddo
   if (mod(n,2) .ne. 0) return
!
!     rest of even order
!
   t = dble(m*m)
   do i = 1, m
      do j = 1, m
         im = i+m
         jm = j+m
         a(i,jm) = a(i,j) + 2*t
         a(im,j) = a(i,j) + 3*t
         a(im,jm) = a(i,j) + t
      enddo
   enddo
   m1 = (m-1)/2
   if (m1.eq.0) return
   do j = 1, m1
      call mat_rswap(m,a(1,j),1,a(m+1,j),1)
   enddo
   m1 = (m+1)/2
   m2 = m1 + m
   call mat_rswap(1,a(m1,1),1,a(m2,1),1)
   call mat_rswap(1,a(m1,m1),1,a(m2,m1),1)
   m1 = n+1-(m-3)/2
   if(m1.gt.n) return
   do j = m1, n
      call mat_rswap(m,a(1,j),1,a(m+1,j),1)
   enddo
   return
!
!     double even order
!
100 continue
   k = 1
   do i = 1, n
      do j = 1, n
         a(i,j) = k
         if (mod(i,4)/2 .eq. mod(j,4)/2) a(i,j) = n*n+1 - k
         k = k+1
      enddo
   enddo
end subroutine mat_magic
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rswap(n,x,incx,y,incy)
integer         :: n
doubleprecision :: x(*)
integer         :: incx
doubleprecision :: y(*)
integer         :: incy

doubleprecision :: t
integer         :: ix
integer         :: iy
integer         :: i

   if (n .le. 0) return
   ix = 1
   iy = 1
   if (incx.lt.0) ix = (-n+1)*incx+1
   if (incy.lt.0) iy = (-n+1)*incy+1
   do i = 1, n
      t = x(ix)
      x(ix) = y(iy)
      y(iy) = t
      ix = ix + incx
      iy = iy + incy
   enddo
end subroutine mat_rswap
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rref(ar,ai,lda,m,n,eps)
integer,intent(in) :: lda
doubleprecision    :: ar(lda,*)
doubleprecision    :: ai(lda,*)
integer            :: m
integer            :: n
doubleprecision    :: eps

doubleprecision    :: tol
doubleprecision    :: tr
doubleprecision    :: ti
integer            :: i, j, k, l

   tol = 0.0d0
   do j = 1, n
      tol = dmax1(tol,mat_wasum(m,ar(1,j),ai(1,j),1))
   enddo
   tol = eps*dfloat(2*max0(m,n))*tol
   k = 1
   l = 1
   INFINITE: do
      IF (K.GT.M .OR. L.GT.N) RETURN

      i = mat_iwamax(m-k+1,ar(k,l),ai(k,l),1) + k-1
      if (dabs(ar(i,l))+dabs(ai(i,l)) .le. tol)then
         call mat_wset(m-k+1,0.0d0,0.0d0,ar(k,l),ai(k,l),1)
         l = l+1
         cycle INFINITE
      endif

      call mat_wswap(n-l+1,ar(i,l),ai(i,l),lda,ar(k,l),ai(k,l),lda)
      call mat_wdiv(1.0d0,0.0d0,ar(k,l),ai(k,l),tr,ti)
      call mat_wscal(n-l+1,tr,ti,ar(k,l),ai(k,l),lda)
      ar(k,l) = 1.0d0
      ai(k,l) = 0.0d0
      do i = 1, m
         tr = -ar(i,l)
         ti = -ai(i,l)
         if (i .ne. k) call matX_waxpy(n-l+1,tr,ti,ar(k,l),ai(k,l),lda,ar(i,l),ai(i,l),lda)
      enddo
      K = K+1
      L = L+1
   enddo INFINITE
end subroutine mat_rref
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wrscal(n,s,xr,xi,incx)
integer         :: n
doubleprecision :: s
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx

integer         :: ix
integer         :: i
   if (n .le. 0) return
   ix = 1
   do i = 1, n
      xr(ix) = mat_flop(s*xr(ix))
      if (xi(ix) .ne. 0.0d0) xi(ix) = mat_flop(s*xi(ix))
      ix = ix + incx
   enddo
end subroutine mat_wrscal
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wscal(n,sr,si,xr,xi,incx)
integer         :: n
doubleprecision :: sr
doubleprecision :: si
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
integer         :: ix
integer         :: i
   if (n .gt. 0) then
      ix = 1
      do i = 1, n
         call mat_wmul(sr,si,xr(ix),xi(ix),xr(ix),xi(ix))
         ix = ix + incx
      enddo
   endif
end subroutine mat_wscal
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wmul(ar,ai,br,bi,cr,ci)

$@(#) mat_wmul(3fp) - [M_matrix] c = a*b

doubleprecision :: ar
doubleprecision :: ai
doubleprecision :: br
doubleprecision :: bi
doubleprecision :: cr
doubleprecision :: ci

doubleprecision :: t
   t = ar*bi + ai*br
   if (t .ne. 0.0d0) t = mat_flop(t)
   cr = mat_flop(ar*br - ai*bi)
   ci = t
end subroutine mat_wmul
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_stack1(op)

$@(#) M_matrix::mat_stack1(3f): Unary Operations

integer           :: op
INTEGER,parameter :: QUOTE=49
integer           :: i
integer           :: j
integer           :: l
integer           :: ll
integer           :: ls
integer           :: m
integer           :: mn
integer           :: n

   IF (DDT .EQ. 1) call journal('sc','mat_stack1 ',OP)
   L = LSTK(TOP)
   M = MSTK(TOP)
   N = NSTK(TOP)
   MN = M*N
   IF (MN .EQ. 0) then
   elseIF (OP .ne. QUOTE) then                                 ! UNARY MINUS
      CALL mat_wrscal(MN,-1.0D0,STKR(L),STKI(L),1)
   else                                                        ! TRANSPOSE
      LL = L + MN
      ERR = LL+MN - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      CALL mat_wcopy(MN,STKR(L),STKI(L),1,STKR(LL),STKI(LL),1)
      M = NSTK(TOP)
      N = MSTK(TOP)
      MSTK(TOP) = M
      NSTK(TOP) = N
      DO I = 1, M
         DO J = 1, N
            LS = L+MN+(J-1)+(I-1)*N
            LL = L+(I-1)+(J-1)*M
            STKR(LL) = STKR(LS)
            STKI(LL) = -STKI(LS)
         enddo
      enddo
   endif
end subroutine mat_stack1
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rrot(n,dx,incx,dy,incy,c,s)

$@(#) M_matrix::mat_rrot(3f): Applies a plane rotation.

integer         :: n
doubleprecision :: dx(*)
integer         :: incx
doubleprecision :: dy(*)
integer         :: incy
doubleprecision :: c
doubleprecision :: s

doubleprecision :: dtemp
integer         :: i
integer         :: ix
integer         :: iy
!
   if (n.gt.0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1,n
           dtemp = mat_flop(c*dx(ix) + s*dy(iy))
           dy(iy) = mat_flop(c*dy(iy) - s*dx(ix))
           dx(ix) = dtemp
           ix = ix + incx
           iy = iy + incy
      enddo
   endif
end subroutine mat_rrot
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rset(n,dx,dy,incy)

$@(#) M_matrix::mat_rset(3f): copies a scalar, dx, to a scalar, dy.

integer         :: n
doubleprecision :: dx,dy(*)
integer         :: incy
integer         :: i
integer         :: iy

   if (n.gt.0) then
      iy = 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1,n
         dy(iy) = dx
         iy = iy + incy
      enddo
   endif
end subroutine mat_rset
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_prntid(id,argcnt)

$@(#) M_matrix::mat_prntid(3fp): print table of variable id names (up to) eight per line

!     ID     IS ARRAY OF 4-CHARACTER IDS TO PRINT
!     ARGCNT IS NUMBER OF IDS TO PRINT
!            IF = -1, PRINT ONE ID WITH AN "  =" SUFFIX
!
integer :: id(4,*)
integer :: argcnt

character(len=80)   :: mline           ! scratch space for building line to print
integer             :: linebuf(256)    ! scratch buffer for building up line

integer,parameter   ::  ade_blank=32
integer,parameter   ::  ade_equal=61
integer             :: j1
integer             :: i, j, k, l

   j1 = 1                              ! which ID to start the line with
   INFINITE : do
      linebuf(1)=ade_blank                ! put a space at beginning of line
      l = 2                               ! pointer into output line being built
      do j = j1,min0(j1+7,iabs(argcnt))   ! copy up to eight names into buffer
         do i = 1, 4                      !    copy one name into buffer
            k = id(i,j)+1                 ! this is the kth letter of the set
            linebuf(l) = alfa(k)
            l = l+1                       ! increment pointer into output
         enddo
         linebuf(l+0)=ade_blank           ! put two space between names
         linebuf(l+1)=ade_blank
         l=l+2
      enddo
      if (argcnt .eq. -1) then            ! special flag to print one word and  =
         linebuf(l) = ade_equal           ! put value for equal sign into buffer
      else
         l=l-3                            ! was prepared for another ID with two blanks
      endif
      !-----------------------------------------------
      call mat_buf2str(mline,linebuf,l)   ! write LINEBUF(1:L) line to a character variable
      if(wte.eq.6)then
         call journal(mline)              ! print the line
      else
         write(wte,'(a)')mline(1:80)      ! print the line
      endif
      !-----------------------------------------------
      j1 = j1+8                           ! prepare to get up to eight more IDs
      if (j1 .gt. iabs(argcnt)) exit INFINITE   ! if not done do another line
   enddo INFINITE
end subroutine mat_prntid
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_stackp(id)

$@(#) M_matrix::mat_stackp(3fp): put variables into storage

integer             :: id(4)
character(len=100)  :: mline
integer,parameter   :: semi=39
integer             :: i
integer             :: ib
integer             :: j
integer             :: k
integer             :: km1
integer             :: l
integer             :: l1
integer             :: l2
integer             :: li
integer             :: lj
integer             :: lk
integer             :: ll
integer             :: ls
integer             :: lt
integer             :: m
integer             :: m1
integer             :: m2
integer             :: mk
integer             :: mn
integer             :: mn1
integer             :: mn2
integer             :: mnk
integer             :: mt
integer             :: n
integer             :: nk
integer             :: nt

   if (ddt .eq. 1) then
      write(mline,'('' STACKP '',4i4)') id
      call journal(mline)
   endif

   if (top .le. 0) call mat_err(1)
   if (err .gt. 0) return

   call mat_funs(id)
   if (fin .ne. 0) call mat_err(25)
   if (err .gt. 0) return

   m = mstk(top)
   n = nstk(top)
   if (m .gt. 0) l = lstk(top)
   if (m .lt. 0) call mat_err(14)
   if (err .gt. 0) return

   if (m .eq. 0 .and. n .ne. 0) goto 99
   mn = m*n
   lk = 0
   mk = 1
   nk = 0
   lt = 0
   mt = 0
   nt = 0
!
!     DOES VARIABLE ALREADY EXIST
   call mat_putid(idstk(1,bot-1),id)
   k = lsize+1
05 continue
   k = k-1
   if (.not.mat_eqid(idstk(1,k),id)) goto 05
   if (k .eq. bot-1) goto 30
   lk = lstk(k)
   mk = mstk(k)
   nk = nstk(k)
   mnk = mk*nk
   if (rhs .eq. 0) goto 20
   if (rhs .gt. 2) call mat_err(15)
   if (err .gt. 0) return
   mt = mk
   nt = nk
   lt = l + mn
   err = lt + mnk - lstk(bot)
   if (err .gt. 0) call mat_err(17)
   if (err .gt. 0) return
   call mat_wcopy(mnk,stkr(lk),stki(lk),1,stkr(lt),stki(lt),1)
!
!     DOES IT FIT
20 continue
   if (rhs.eq.0 .and. mn.eq.mnk) goto 40
   if (k .ge. lsize-3) call mat_err(13)
   if (err .gt. 0) return
!
!     SHIFT STORAGE
   if (k .eq. bot) goto 25
   ls = lstk(bot)
   ll = ls + mnk
   call mat_wcopy(lk-ls,stkr(ls),stki(ls),-1,stkr(ll),stki(ll),-1)
   km1 = k-1
   do ib = bot, km1
      i = bot+km1-ib
      call mat_putid(idstk(1,i+1),idstk(1,i))
      mstk(i+1) = mstk(i)
      nstk(i+1) = nstk(i)
      lstk(i+1) = lstk(i)+mnk
   enddo
!
!     DESTROY OLD VARIABLE
25 continue
   bot = bot+1
!
!     CREATE NEW VARIABLE
30 continue
   if (mn .eq. 0) goto 99
   if (bot-2 .le. top) call mat_err(18)
   if (err .gt. 0) return
   k = bot-1
   call mat_putid(idstk(1,k), id)
   if (rhs .eq. 1) goto 50
   if (rhs .eq. 2) goto 55
!
!     STORE
40 continue
   if (k .lt. lsize) lstk(k) = lstk(k+1) - mn
   mstk(k) = m
   nstk(k) = n
   lk = lstk(k)
   call mat_wcopy(mn,stkr(l),stki(l),-1,stkr(lk),stki(lk),-1)
   goto 90
!
!     VECT(ARG)
50 continue
   if (mstk(top-1) .lt. 0) goto 59
   mn1 = 1
   mn2 = 1
   l1 = 0
   l2 = 0
   if (n.ne.1 .or. nk.ne.1) goto 52
   l1 = lstk(top-1)
   m1 = mstk(top-1)
   mn1 = m1*nstk(top-1)
   m2 = -1
   goto 60
52 continue
   if (m.ne.1 .or. mk.ne.1) call mat_err(15)
   if (err .gt. 0) return
   l2 = lstk(top-1)
   m2 = mstk(top-1)
   mn2 = m2*nstk(top-1)
   m1 = -1
   goto 60
!
!     matrix(arg,arg)
55 continue
   if (mstk(top-1).lt.0 .and. mstk(top-2).lt.0) goto 59
   l2 = lstk(top-1)
   m2 = mstk(top-1)
   mn2 = m2*nstk(top-1)
   if (m2 .lt. 0) mn2 = n
   l1 = lstk(top-2)
   m1 = mstk(top-2)
   mn1 = m1*nstk(top-2)
   if (m1 .lt. 0) mn1 = m
   goto 60
!
59 continue
   if (mn .ne. mnk) call mat_err(15)
   if (err .gt. 0) return
   lk = lstk(k)
   call mat_wcopy(mn,stkr(l),stki(l),-1,stkr(lk),stki(lk),-1)
   goto 90
!
60 continue
   if (mn1.ne.m .or. mn2.ne.n) call mat_err(15)
   if (err .gt. 0) return
   ll = 1
   if (m1 .lt. 0) goto 62
   do i = 1, mn1
      ls = l1+i-1
      mk = max0(mk,idint(stkr(ls)))
      ll = min0(ll,idint(stkr(ls)))
   enddo
62 continue
   mk = max0(mk,m)
   if (m2 .lt. 0) goto 64
   do i = 1, mn2
      ls = l2+i-1
      nk = max0(nk,idint(stkr(ls)))
      ll = min0(ll,idint(stkr(ls)))
   enddo
64 continue
   nk = max0(nk,n)
   if (ll .lt. 1) call mat_err(21)
   if (err .gt. 0) return
   mnk = mk*nk
   lk = lstk(k+1) - mnk
   err = lt + mt*nt - lk
   if (err .gt. 0) call mat_err(17)
   if (err .gt. 0) return
   lstk(k) = lk
   mstk(k) = mk
   nstk(k) = nk
   call mat_wset(mnk,0.0d0,0.0d0,stkr(lk),stki(lk),1)
   if (nt .lt. 1) goto 67
   do j = 1, nt
      ls = lt+(j-1)*mt
      ll = lk+(j-1)*mk
      call mat_wcopy(mt,stkr(ls),stki(ls),-1,stkr(ll),stki(ll),-1)
   enddo
67 continue
   do j = 1, n
      do i = 1, m
         li = l1+i-1
         if (m1 .gt. 0) li = l1 + idint(stkr(li)) - 1
         lj = l2+j-1
         if (m2 .gt. 0) lj = l2 + idint(stkr(lj)) - 1
         ll = lk+li-l1+(lj-l2)*mk
         ls = l+i-1+(j-1)*m
         stkr(ll) = stkr(ls)
         stki(ll) = stki(ls)
      enddo
   enddo
   goto 90
!
!     PRINT IF DESIRED AND POP STACK
90 continue
   if (sym.ne.semi .and. lct(3).eq.0) call mat_print(id,k)
   if (sym.eq.semi .and. lct(3).eq.1) call mat_print(id,k)
   if (k .eq. bot-1) bot = bot-1
99 continue
   if (m .ne. 0) top = top - 1 - rhs
   if (m .eq. 0) top = top - 1
end subroutine mat_stackp
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wpofa(ar,ai,lda,n,info)
integer          :: lda
doubleprecision  :: ar(lda,*)
doubleprecision  :: ai(lda,*)
integer          :: n
integer          :: info

doubleprecision  :: s
doubleprecision  :: TR
doubleprecision  :: TI
integer          :: j
integer          :: jm1
integer          :: k

   do j = 1, n
      info = j
      s = 0.0d0
      jm1 = j-1
      if (jm1 .ge. 1) then
         do k = 1, jm1
           tr=ar(k,j)-mat_wdotcr(k-1,ar(1,k),ai(1,k),1,ar(1,j),ai(1,j),1)
           ti=ai(k,j)-mat_wdotci(k-1,ar(1,k),ai(1,k),1,ar(1,j),ai(1,j),1)
           call mat_wdiv(tr,ti,ar(k,k),ai(k,k),tr,ti)
           ar(k,j) = tr
           ai(k,j) = ti
           s = s + tr*tr + ti*ti
         enddo
      endif
      s = ar(j,j) - s
      if (s.le.0.0d0 .or. ai(j,j).ne.0.0d0) goto 40
      ar(j,j) = dsqrt(s)
   enddo
   info = 0
40 continue
end subroutine mat_wpofa
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_watan(xr,xi,yr,yi)

$@(#) M_matrix::mat_watan(3fp): y = atan(x) = (i/2)*log((i+x)/(i-x))

doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr
doubleprecision :: yi
doubleprecision :: tr
doubleprecision :: ti

   if (xi .eq. 0.0d0) then
      yr = datan2(xr,1.0d0)
      yi = 0.0d0
   elseif (xr.ne.0.0d0 .or. dabs(xi).ne.1.0d0) then
      call mat_wdiv(xr,1.0d0+xi,-xr,1.0d0-xi,tr,ti)
      call mat_wlog(tr,ti,tr,ti)
      yr = -(ti/2.0d0)
      yi = tr/2.0d0
   else
      call mat_err(32)
   endif

end subroutine mat_watan
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rrotg(da,db,c,s)

$@(#) M_matrix::mat_rrotg(3fp): construct Givens plane rotation.

doubleprecision :: da
doubleprecision :: db
doubleprecision :: c
doubleprecision :: s

doubleprecision :: rho
doubleprecision :: r
doubleprecision :: z

   rho = db
   if ( dabs(da) .gt. dabs(db) ) rho = da
   c = 1.0d0
   s = 0.0d0
   z = 1.0d0
   r = mat_flop(dsign(mat_pythag(da,db),rho))
   if (r .ne. 0.0d0) c = mat_flop(da/r)
   if (r .ne. 0.0d0) s = mat_flop(db/r)
   if ( dabs(da) .gt. dabs(db) ) z = s
   if (dabs(db) .ge. dabs(da) .and. c .ne. 0.0d0)z = mat_flop(1.0d0/c)
   da = r
   db = z
end subroutine mat_rrotg
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wsign(xr,xi,yr,yi,zr,zi)

$@(#) M_matrix::mat_wsign(3fp): if y .ne. 0, z = x*y/abs(y); if y .eq. 0, z = x

doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr
doubleprecision :: yi
doubleprecision :: zr
doubleprecision :: zi
doubleprecision :: t
   t = mat_pythag(yr,yi)
   zr = xr
   zi = xi
   if (t .ne. 0.0d0) call mat_wmul(yr/t,yi/t,zr,zi,zr,zi)
end subroutine mat_wsign
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_parse(INIT)

integer            :: init
INTEGER,parameter  :: SEMI=39
integer,parameter  :: EQUAL=46
integer            :: ID(4)
integer            :: EXCNT
integer,parameter  :: LPAREN=37
integer,parameter  :: RPAREN=38
integer,parameter  :: COLON=40
integer            :: PTS
INTEGER,parameter  :: BLANK=36
integer,parameter  :: COMMA=48
integer,parameter  :: LESS=50
integer,parameter  :: GREAT=51
integer            :: NAME=1
integer,parameter  :: ANS(4) =[10,23,28,36]
integer,parameter  :: ENND(4)=[14,23,13,36]
integer,parameter  :: ELSE(4)=[14,21,28,14]
integer            :: P
integer            :: R
character(len=80)  :: mline
integer            :: i5
integer            :: ierr
integer            :: ilen
integer            :: j
integer            :: k
integer            :: l
integer            :: ls
integer            :: n
!
   01 CONTINUE
      R = 0
      IF (ERR .GT. 0) PTZ = 0
      IF (ERR.LE.0 .AND. PT.GT.PTZ) R = RSTK(PT)
      IF (DDT .EQ. 1) THEN
         WRITE(MLINE,'('' PARSE'',4I4)') PT,R,PTZ,ERR
         CALL JOURNAL(MLINE)
      ENDIF
      IF (R.EQ.15) GOTO 93
      IF (R.EQ.16 .OR. R.EQ.17) GOTO 94
      SYM = EOL
      TOP = 0
      IF (RIO .NE. RTE) CALL mat_files(-RIO,BUF)
      RIO = RTE
      LCT(3) = 0
      LCT(4) = 2
      LPT(1) = 1
   10 CONTINUE
      IF (SYM.EQ.EOL.AND.MOD(LCT(4)/2,2).EQ.1) CALL mat_prompt(LCT(4)/4)
      IF (SYM .EQ. EOL) CALL mat_getlin()
      ERR = 0
      PT = PTZ
   15 CONTINUE
      EXCNT = 0
      IF (DDT .EQ. 1) THEN
         MLINE='STATE'
         CALL mat_appnum(REAL(PT),MLINE,ILEN,IERR)
         CALL mat_appnum(REAL(TOP),MLINE,ILEN,IERR)
         call journal(mline)
      ENDIF
      LHS = 1
      CALL mat_putid(ID,ANS)
      CALL mat_getsym()
      IF (SYM.EQ.COLON .AND. CHRA.EQ.EOL) DDT = 1-DDT
      IF (SYM .EQ. COLON) CALL mat_getsym()
      IF (SYM.EQ.SEMI .OR. SYM.EQ.COMMA .OR. SYM.EQ.EOL) GOTO 80
      IF (SYM .EQ. NAME) GOTO 20
      IF (SYM .EQ. LESS) GOTO 40
      IF (SYM .EQ. GREAT) GOTO 45
      GOTO 50
!.......................................................................
!     LHS BEGINS WITH NAME
   20 CONTINUE
      CALL mat_comand(SYN)
      IF (ERR .GT. 0) GOTO 01
      IF (FUN .EQ. 99) GOTO 95
      IF (FIN .EQ. -15) GOTO 80
      IF (FIN .LT. 0) GOTO 91
      IF (FIN .GT. 0) GOTO 70
!     IF NAME IS A FUNCTION, MUST BE RHS
      RHS = 0
      CALL mat_funs(SYN)
      IF (FIN .NE. 0) GOTO 50
!     PEEK ONE CHARACTER AHEAD
      IF (CHRA.EQ.SEMI .OR. CHRA.EQ.COMMA .OR. CHRA.EQ.EOL) CALL mat_putid(ID,SYN)
      IF (CHRA .EQ. EQUAL) GOTO 25
      IF (CHRA .EQ. LPAREN) GOTO 30
      GOTO 50
!.......................................................................
!     LHS IS SIMPLE VARIABLE
   25 CONTINUE
      CALL mat_putid(ID,SYN)
      CALL mat_getsym()
      CALL mat_getsym()
      GOTO 50
!.......................................................................
!     LHS IS NAME(...)
   30 CONTINUE
      LPT(5) = LPT(4)
      CALL mat_putid(ID,SYN)
      CALL mat_getsym()
   32 CONTINUE
      CALL mat_getsym()
      EXCNT = EXCNT+1
      PT = PT+1
      CALL mat_putid(IDS(1,PT), ID)
      PSTK(PT) = EXCNT
      RSTK(PT) = 1
!     *CALL* EXPR
      GOTO 92
!.......................................................................
   35 CONTINUE
      CALL mat_putid(ID,IDS(1,PT))
      EXCNT = PSTK(PT)
      PT = PT-1
      IF (SYM .EQ. COMMA) GOTO 32
      IF (SYM .NE. RPAREN) CALL mat_err(3)
      IF (ERR .GT. 0) GOTO 01
      IF (ERR .GT. 0) RETURN
      IF (SYM .EQ. RPAREN) CALL mat_getsym()
      IF (SYM .EQ. EQUAL) GOTO 50
!     LHS IS REALLY RHS, FORGET SCAN JUST DONE
      TOP = TOP - EXCNT
      LPT(4) = LPT(5)
      CHRA = LPAREN
      SYM = NAME
      CALL mat_putid(SYN,ID)
      CALL mat_putid(ID,ANS)
      EXCNT = 0
      GOTO 50
!.......................................................................
!     MULTIPLE LHS
   40 CONTINUE
      LPT(5) = LPT(4)
      PTS = PT
      CALL mat_getsym()
   41 CONTINUE
      IF (SYM .NE. NAME) GOTO 43
      CALL mat_putid(ID,SYN)
      CALL mat_getsym()
      IF (SYM .EQ. GREAT) GOTO 42
      IF (SYM .EQ. COMMA) CALL mat_getsym()
      PT = PT+1
      LHS = LHS+1
      PSTK(PT) = 0
      CALL mat_putid(IDS(1,PT),ID)
      GOTO 41
   42 CONTINUE
      CALL mat_getsym()
      IF (SYM .EQ. EQUAL) GOTO 50
   43 CONTINUE
      LPT(4) = LPT(5)
      PT = PTS
      LHS = 1
      SYM = LESS
      CHRA = LPT(4)-1
      CHRA = LIN(CHRA)
      CALL mat_putid(ID,ANS)
      GOTO 50
!.......................................................................
!     MACRO STRING
   45 CONTINUE
      CALL mat_getsym()
      IF (DDT .EQ. 1) THEN
         MLINE='MACRO'
         CALL mat_appnum(REAL(PT),MLINE,ILEN,IERR)
         CALL mat_appnum(REAL(TOP),MLINE,ILEN,IERR)
      ENDIF
      IF (SYM.EQ.LESS .AND. CHRA.EQ.EOL) CALL mat_err(28)
      IF (ERR .GT. 0) GOTO 01
      PT = PT+1
      RSTK(PT) = 20
!     *CALL* EXPR
      GOTO 92
!.......................................................................
   46 CONTINUE
      PT = PT-1
      IF (SYM.NE.LESS .AND. SYM.NE.EOL) CALL mat_err(37)
      IF (ERR .GT. 0) GOTO 01
      IF (SYM .EQ. LESS) CALL mat_getsym()
      K = LPT(6)
      LIN(K+1) = LPT(1)
      LIN(K+2) = LPT(2)
      LIN(K+3) = LPT(6)
      LPT(1) = K + 4
!     TRANSFER STACK TO INPUT LINE
      K = LPT(1)
      L = LSTK(TOP)
      N = MSTK(TOP)*NSTK(TOP)
      DO J = 1, N
         LS = L + J-1
         LIN(K) = IDINT(STKR(LS))
         IF (LIN(K).LT.0 .OR. LIN(K).GE.IALF) CALL mat_err(37)
         IF (ERR .GT. 0) RETURN
         IF (K.LT.1024) K = K+1
         IF (K.EQ.1024) then
            WRITE(mline,47) K
            call journal(mline)
          endif
      enddo
   47 FORMAT(1X,'INPUT BUFFER LIMIT IS ',I4,' CHARACTERS.')
      TOP = TOP-1
      LIN(K) = EOL
      LPT(6) = K
      LPT(4) = LPT(1)
      LPT(3) = 0
      LPT(2) = 0
      LCT(1) = 0
      CHRA = BLANK
      PT = PT+1
      PSTK(PT) = LPT(1)
      RSTK(PT) = 21
!     *CALL* PARSE
      GOTO 15
!.......................................................................
   49 CONTINUE
      PT = PT-1
      IF (DDT .EQ. 1)then
         WRITE(mline,'('' MACEND '',2I4)') PT,TOP
         call journal(mline)
      endif
      K = LPT(1) - 4
      LPT(1) = LIN(K+1)
      LPT(4) = LIN(K+2)
      LPT(6) = LIN(K+3)
      CHRA = BLANK
      CALL mat_getsym()
      GOTO 80
!.......................................................................
!     LHS FINISHED, START RHS
   50 CONTINUE
      IF (SYM .EQ. EQUAL) CALL mat_getsym()
      PT = PT+1
      CALL mat_putid(IDS(1,PT),ID)
      PSTK(PT) = EXCNT
      RSTK(PT) = 2
!     *CALL* EXPR
      GOTO 92
   55 CONTINUE
      IF (SYM.EQ.SEMI .OR. SYM.EQ.COMMA .OR. SYM.EQ.EOL) GOTO 60
      IF (SYM.EQ.NAME .AND. mat_eqid(SYN,ELSE)) GOTO 60
      IF (SYM.EQ.NAME .AND. mat_eqid(SYN,ENND)) GOTO 60
      CALL mat_err(40)
      IF (ERR .GT. 0) GOTO 01
!
!     STORE RESULTS
   60 CONTINUE
      RHS = PSTK(PT)
      CALL mat_stackp(IDS(1,PT))
      IF (ERR .GT. 0) GOTO 01
      PT = PT-1
      LHS = LHS-1
      IF (LHS .GT. 0) GOTO 60
      GOTO 70
!.......................................................................
!
!     UPDATE AND POSSIBLY PRINT OPERATION COUNTS
   70 CONTINUE
      K = FLP(1)
      IF (K .NE. 0) STKR(VSIZE-3) = DFLOAT(K)
      STKR(VSIZE-2) = STKR(VSIZE-2) + DFLOAT(K)
      FLP(1) = 0
      IF (.NOT.(CHRA.EQ.COMMA .OR. (SYM.EQ.COMMA .AND. CHRA.EQ.EOL)))GOTO 80
      CALL mat_getsym()
      I5 = 10**5

      IF (K .EQ. 0) call journal('   no flops')
      IF (K .EQ. 1) call journal('    1 flop')
      IF (1.LT.K .AND. K.LT.100000)THEN
         WRITE(mline,'(1X,I5,'' flops'')') K
         call journal(mline)
      ENDIF
      IF (100000 .LE. K)then
         WRITE(mline,'(1x,i9,'' flops'')') K
         call journal(mline)
      endif
      GOTO 80
!.......................................................................
!
!     FINISH STATEMENT
   80 CONTINUE
      FIN = 0
      P = 0
      R = 0
      IF (PT .GT. 0) P = PSTK(PT)
      IF (PT .GT. 0) R = RSTK(PT)
      IF (DDT .EQ. 1)then
         WRITE(mline,'('' FINISH'',5I4)') PT,PTZ,P,R,LPT(1)
         call journal(mline)
      endif
      IF (SYM.EQ.COMMA .OR. SYM.EQ.SEMI) GOTO 15
      IF (R.EQ.21 .AND. P.EQ.LPT(1)) GOTO 49
      IF (PT .GT. PTZ) GOTO 91
      GOTO 10
!.......................................................................
!
!     SIMULATE RECURSION
   91 CONTINUE
      CALL mat_clause()
      IF (ERR .GT. 0) GOTO 01
      IF (PT .LE. PTZ) GOTO 15
      R = RSTK(PT)
      IF (R .EQ. 21) GOTO 49
      GOTO (99,99,92,92,92,99,99,99,99,99,99,99,15,15,99,99,99,99,99),R
!
   92 CONTINUE
      CALL mat_expr()
      IF (ERR .GT. 0) GOTO 01
      R = RSTK(PT)
      GOTO (35,55,91,91,91,93,93,99,99,94,94,99,99,99,99,99,99,94,94,46),R
!
   93 CONTINUE
      CALL mat_term()
      IF (ERR .GT. 0) GOTO 01
      R = RSTK(PT)
      GOTO (99,99,99,99,99,92,92,94,94,99,99,99,99,99,95,99,99,99,99),R
!
   94 CONTINUE
      CALL mat_factor()
      IF (ERR .GT. 0) GOTO 01
      R = RSTK(PT)
      GOTO (99,99,99,99,99,99,99,93,93,92,92,94,99,99,99,95,95,92,92),R
!.......................................................................
!
!     CALL ML_MATFNS BY RETURNING TO MAT88
   95 CONTINUE
      if(TOP.LT.1)then
         !call journal('*mat_parse* stack emptied',top)
      else
         IF (FIN.GT.0 .AND. MSTK(TOP).LT.0) CALL mat_err(14)
      endif
      IF (ERR .GT. 0) GOTO 01
      RETURN
!.......................................................................
!
   99 CONTINUE
      CALL mat_err(22)
      GOTO 01
END SUBROUTINE mat_parse
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_comand(id)

integer            :: id(4)
character(len=256) :: mline
integer            :: h(4)
integer,parameter  :: linelen=255
integer,save       :: LRECL
integer            :: cmd(4,17)
integer            :: ch
integer,save       :: cmdl=17
!                   0---------1---------2---------3---------4--------- 5---------6---------7-------
!                   012345678901234567890123456789012345678901234567890123456789012345678901234567
!                   0123456789abcdefghijklmnopqrstuvwxyz ();:+-*/\=.,'<>ABCDEFGHIJKLMNOPQRSTUVWXYZ
integer,parameter  :: a=10, a_up=52
integer,parameter  :: d=13, d_up=55
integer,parameter  :: e=14, e_up=56
integer,parameter  :: z=35, z_up=77

integer,parameter  :: semi=39
integer,parameter  :: comma=48
integer,parameter  :: blank=36
integer,parameter  :: name=1
integer,parameter  :: dot=47

integer            :: chr
integer            :: i
integer            :: ii
integer            :: istat
integer            :: j
integer            :: jj
integer            :: k
integer            :: l

!.......................................................................
!                         1         2         3         4         5
!       COUNT   01234567890123456789012345678901234567890123456789012
!               0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ ();:+-*/\=.,''<>
!
!       CLEAR ELSE  END   EXIT
!       FOR   HELP  IF    LONG
!       QUIT  SEMI
!       SHORT WHAT  WHILE
!       WHO   SH    LAFF  SHELL
      DATA CMD/                                                       &
     &  12,21,14,10, 14,21,28,14, 14,23,13,36, 14,33,18,29,           &
     &  15,24,27,36, 17,14,21,25, 18,15,36,36, 21,24,23,16,           &
     &  26,30,18,29, 28,14,22,18,                                     &
     &  28,17,24,27, 32,17,10,29, 32,17,18,21,                        &
     &  32,17,24,36, 28,17,36,36, 21,10,21,10, 28,17,14,21/
      DATA LRECL/LINELEN/
!
      IF (DDT .EQ. 1)call journal('COMAND')
      FUN = 0
      DO K = 1, CMDL
        IF (mat_eqid(ID,CMD(1,K))) GOTO 20
      enddo
      FIN = 0
      RETURN
!
   20 CONTINUE
      IF (CHRA.EQ.COMMA .OR. CHRA.EQ.SEMI .OR. CHRA.EQ.EOL) GOTO 22
      IF ((CHRA.LE.Z.OR.(CHRA.GE.a_up.AND.CHRA.LE.z_up)) .OR. K.EQ.6)GOTO 22  ! if alphanumeric or K=6
      CALL mat_err(16) ! improper command
      RETURN
!
   22 CONTINUE
      FIN = 1
!===================================================================================================================================
      COMAND : select case(k)
!===================================================================================================================================
      case(1) ! COMMAND::CLEAR
      IF ((CHRA.GE.A.AND.CHRA.LE.Z).or.(CHRA.GE.a_up.AND.CHRA.LE.z_up)) then ! alphameric character
         CALL mat_getsym()
         TOP = TOP+1
         MSTK(TOP) = 0
         NSTK(TOP) = 0
         RHS = 0
         CALL mat_stackp(SYN)
         IF (ERR .GT. 0) RETURN
         FIN = 1
      else
         BOT = LSIZE-3
      endif
!===================================================================================================================================
!     COMMAND::FOR, WHILE, IF, ELSE, END
   case(5)   !!   30 continue
      FIN = -11
      GOTO 99
   case(13)  !!   32 continue
      FIN = -12
      GOTO 99
   case(7)   !!   34 continue
      FIN = -13
      GOTO 99
   case(2)   !!   36 continue
      FIN = -14
      GOTO 99
   case(3)   !!   38 continue
      FIN = -15
      GOTO 99
!===================================================================================================================================
   case(4) ! COMMAND::EXIT
      IF (PT .GT. PTZ) FIN = -16
      IF (PT .GT. PTZ) exit COMAND
      K = IDINT(STKR(VSIZE-2))
      call journal('sc',' total flops ',k)

      ! for serendipity's sake
      ii=mat_urand(RAN(1))*9
      select case(ii)
      case(1); call journal(' adios')
      case(2); call journal(' adieu')
      case(3); call journal(' arrivederci')
      case(4); call journal(' au revior')
      case(5); call journal(' so long')
      case(6); call journal(' sayonara')
      case(7); call journal(' auf wiedersehen')
      case default
         call journal(' cheerio')
      end select

      FUN = 99
!===================================================================================================================================
      case(9) ! COMMAND::QUIT
      K = LPT(1) - 7
      IF (K .LE. 0) FUN = 99
      IF (K .LE. 0) exit COMAND
      CALL mat_files(-RIO,BUF)
      LPT(1) = LIN(K+1)
      LPT(4) = LIN(K+2)
      LPT(6) = LIN(K+3)
      PTZ = LIN(K+4)
      RIO = LIN(K+5)
      LCT(4) = LIN(K+6)
      CHRA = BLANK
      SYM = COMMA
      GOTO 99
!===================================================================================================================================
      case(16) ! COMMAND::LAFF
      call journal('QUIT SINGING AND GET BACK TO WORK.')
!===================================================================================================================================
      case(17) ! COMMAND::FOO
      call journal(' Your place or mine?')
!===================================================================================================================================
      case(11,8) ! COMMAND::SHORT, LONG
      if(k.eq.11)then
         FMT = 1
      else
         FMT = 2
      endif
      IF (CHRA.EQ.E .OR. CHRA.EQ.D .or. chra.eq.e_up .or. chr.eq.d_up ) FMT = FMT+2
      IF (CHRA .EQ. Z) FMT = 5
      IF (CHRA.EQ.E    .OR. CHRA.EQ.D    .OR. CHRA.EQ.Z   ) CALL mat_getsym()
      IF (CHRA.EQ.E_up .OR. CHRA.EQ.D_up .OR. CHRA.EQ.Z_up) CALL mat_getsym()
!===================================================================================================================================
      case(10) !     COMMAND::SEMI
      LCT(3) = 1 - LCT(3)
!===================================================================================================================================
      case(14) !     COMMAND::WHO
      call journal(' Your current variables are...')
      CALL mat_prntid(IDSTK(1,BOT),LSIZE-BOT+1)
      L = VSIZE-LSTK(BOT)+1
      WRITE(mline,161) L,VSIZE
  161 FORMAT(1X,'using ',I7,' out of ',I7,' elements.')
      call journal(mline)
!===================================================================================================================================
      case(12) !     COMMAND::WHAT
      call journal('The functions and commands are...')
      H(1) = 0
      CALL mat_funs(H)
      CALL mat_prntid(CMD,CMDL-2)
!===================================================================================================================================
      case(15) !     COMMAND::SH
                                   ! call system shell interactively or passing command
      IF (CHRA .eq. EOL )then      ! if next character on stack is end-of-line call interactive shell
          call execute_command_line('/bin/sh',cmdstat=istat) ! call shell interactively
      else                         ! there were characters after SH on the line
          call mat_buf2str(mline,buf(4),lrecl)                              ! pass ENTIRE line
          call execute_command_line(MLINE(:len_trim(mline)),cmdstat=istat)  ! call system shell
          CALL mat_getlin()                                                  ! start a new line because gave all of this one to shell
          if(istat.ne.0)then
             CALL JOURNAL('sc','*SH* RETURN=',ISTAT)
          endif
      endif
!===================================================================================================================================
      case(6) ! COMMAND::HELP
      IF (CHRA .EQ. EOL) THEN
         call journal('Type "help" followed by ...')
         call journal(' INTRO   (To get started)')
         call journal(' NEWS    (recent revisions)')
         H(1) = 0
         CALL mat_funs(H)
         CALL mat_prntid(CMD,CMDL-2)
         J = BLANK+2
         call journal(' ans   EDIT  FILE  FUN   MACRO')
         !-------------------------------------------------
         ! write ALFA(J) to ALFA(a_up-1) one string at a time
         INFINITE: do
            jj=j+16
            jj=min(jj,a_up-1)
            WRITE(MLINE,'(1X,17(A1,1X))')(CHAR(ALFA(I)),I=J,a_up-1)
            call journal(mline)
            IF(jj.ge.a_up-1)exit INFINITE
         enddo INFINITE
         !-------------------------------------------------
         exit COMAND
      ENDIF
!
      CALL mat_getsym()
      IF (SYM .NE. NAME) THEN
         IF (SYM .EQ. 0) SYM = DOT
         H(1) = ALFA(SYM+1)
         H(2) = ALFA(BLANK+1)
         H(3) = ALFA(BLANK+1)
         H(4) = ALFA(BLANK+1)
      ELSE
         DO I = 1, 4
           CH = SYN(I)
           H(I) = ALFA(CH+1)
         enddo
      ENDIF

84    CONTINUE
      IF(HIO .NE. 0) THEN
         READ(HIO,'(a)',END=89) mline   ! read line from help file
         call mat_str2buf(mline,buf,lrecl)  ! convert string to ADE array
         DO I = 1, 4                 ! look for match of 4 chars of topic in first 4 chars
            IF (H(I) .NE. BUF(I)) GOTO 84
         enddo
         call journal(' ')
   86    CONTINUE
         !-------------------------------------------------
         ! find last non-blank character in line
         K = LRECL + 1
   87    CONTINUE
         K = K - 1
         IF(K.LE.0) THEN  ! blank line
            K=1
         ELSEIF (BUF(K) .EQ. ALFA(BLANK+1)) THEN
            GOTO 87
         ENDIF
         !-------------------------------------------------
         call mat_buf2str(mline,buf,k)
         call journal(mline(1:k))
         READ(HIO,'(a)') mline
         call mat_str2buf(mline,buf,lrecl)
         IF (BUF(1) .EQ. ALFA(BLANK+1)) GOTO 86
         CALL mat_files(-HIO,BUF)
         exit COMAND
      ENDIF
!
   89 CONTINUE
      call mat_buf2str(mline,h,4)
      mline=' SORRY, NO HELP ON '//mline(1:4)
      call journal(mline)
      CALL mat_files(-HIO,BUF)
!===================================================================================================================================
      end select COMAND
      CALL mat_getsym()
   99 continue
end subroutine mat_comand
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_plot(lplot,x,y,n,p,k)

$@(#) M_matrix::mat_plot(3fp): Plot X vs. Y on LPLOT.  If K is nonzero, then P(1),...,P(K) are extra parameters

integer           :: lplot
doubleprecision   :: x(n)
doubleprecision   :: y(n)
doubleprecision   :: p(*)
integer           :: k

integer           :: lets(k)
character(len=k)  :: string
doubleprecision   :: xmin,ymin,xmax,ymax,dy,dx,y1,y0
character(len=79) :: pbuf                             ! work space for ascii plot
integer,parameter :: h=20,w=79                        ! h = height, w = width
integer           :: tlun
integer           :: ios
integer           :: ch
integer           :: n
integer           :: i
integer           :: j
integer           :: jmax
integer           :: l

!!      if (k .gt. 0) write(lplot,01) (p(i), i=1,k)
!!   01 FORMAT('Extra parameters',1000(f5.1,/))

   xmin = x(1)
   xmax = x(1)
   ymin = y(1)
   ymax = y(1)

   do i = 1, n
      xmin = dmin1(xmin,x(i))
      xmax = dmax1(xmax,x(i))
      ymin = dmin1(ymin,y(i))
      ymax = dmax1(ymax,y(i))
   enddo

   dx = xmax - xmin
   if (dx .eq. 0.0d0) dx = 1.0d0
   dy = ymax - ymin
   write(lplot,'(80x)')
   do l = 1, h
      pbuf(:)=' '  ! blank out the line
      y1 = ymin + (h-l+1)*dy/h
      y0 = ymin + (h-l)*dy/h
      jmax = 1
      do i = 1, n
         if (y(i) .gt. y1) cycle
         if (l.ne.h .and. y(i).le.y0) cycle
         j = 1 + (w-1)*(x(i) - xmin)/dx
         pbuf(j:j) = '*'
         jmax = max0(jmax,j)
      enddo
      write(lplot,'(1x,a)') pbuf(1:jmax)
   enddo

   ! set up the data file
   open(newunit=tlun,file='xy.dat')
   do i=1,n
      write(tlun,*)x(i),y(i)
   enddo
   flush(tlun)

   string=' '
   lets=0
   do i=1,k
      ch=p(i)
      if ((ch.ge.0) .and. (ch.lt.alflq)) then
         lets(i) = alfa(ch+1)
      endif
   enddo
   call mat_buf2str(string,lets,k)

   ! call the external program xy(1) converting the parameters to a string of options
   call journal('sc','xy xy.dat ',trim(string))
   call execute_command_line('xy xy.dat '//trim(string))
   close(unit=tlun,status='delete',iostat=ios)

end subroutine mat_plot
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn1()

$@(#) M_matrix::mat_matfn1(3fp): evaluate functions involving gaussian elimination

doubleprecision   :: dtr(2)
doubleprecision   :: dti(2)
doubleprecision   :: sr
doubleprecision   :: si
doubleprecision   :: rcond
doubleprecision   :: t
doubleprecision   :: t0
doubleprecision   :: t1
doubleprecision   :: eps
character(len=80) ::  mline
integer           :: i
integer           :: info
integer           :: j
integer           :: k
integer           :: ka
integer           :: kb
integer           :: l
integer           :: l2
integer           :: l3
integer           :: li
integer           :: lj
integer           :: lk
integer           :: ll
integer           :: ls
integer           :: lu
integer           :: m
integer           :: m2
integer           :: n
integer           :: n2
integer           :: nn
!
   IF (DDT .EQ. 1) call journal('sc','*MATFN1* ', FIN)
!
   L = LSTK(TOP)
   M = MSTK(TOP)
   N = NSTK(TOP)
!===================================================================================================================================
   select case(FIN)
!===================================================================================================================================
    case(-1) ! MATRIX RIGHT DIVISION, A/A2
      l2 = lstk(top+1)
      m2 = mstk(top+1)
      n2 = nstk(top+1)
      if (m2 .ne. n2) call mat_err(20)
      if (err .gt. 0) return
      if (m*n .eq. 1) goto 16
      if (n .ne. n2) call mat_err(11)
      if (err .gt. 0) return
      l3 = l2 + m2*n2
      err = l3+n2 - lstk(bot)
      if (err .gt. 0) call mat_err(17)
      if (err .gt. 0) return
      call ml_wgeco(stkr(l2),stki(l2),m2,n2,buf,rcond,stkr(l3),stki(l3))
      if (rcond .eq. 0.0d0) call mat_err(19)
      if (err .gt. 0) return
      t = mat_flop(1.0d0 + rcond)
      if (t.eq.1.0d0 .and. fun.ne.21)then
         call journal('WARNING:')
         call journal('MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.')
         WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
         call journal(mline)
      endif
      if (t.eq.1.0d0 .and. fun.eq.21)then
         call journal('WARNING')
         call journal('EIGENVECTORS ARE BADLY CONDITIONED.')
         WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
         call journal(mline)
      endif
      do i = 1, m
         do j = 1, n
            ls = l+i-1+(j-1)*m
            ll = l3+j-1
            stkr(ll) = stkr(ls)
            stki(ll) = -stki(ls)
         enddo
         call ml_wgesl(stkr(l2),stki(l2),m2,n2,buf,stkr(l3),stki(l3),1)
         do j = 1, n
            ll = l+i-1+(j-1)*m
            ls = l3+j-1
            stkr(ll) = stkr(ls)
            stki(ll) = -stki(ls)
         enddo
      enddo
      if (fun .ne. 21) goto 99
!
!     CHECK FOR IMAGINARY ROUNDOFF IN MATRIX FUNCTIONS
      sr = mat_wasum(n*n,stkr(l),stkr(l),1)
      si = mat_wasum(n*n,stki(l),stki(l),1)
      eps = stkr(vsize-4)
      t = eps*sr
      if (ddt .eq. 18)then
         WRITE(WTE,'('' SR,SI,EPS,T'',1P4D13.4)') SR,SI,EPS,T ! debug 18
      endif
      if (si .le. eps*sr) call mat_rset(n*n,0.0d0,stki(l),1)
      goto 99
!
16    continue
      sr = stkr(l)
      si = stki(l)
      n = n2
      m = n
      mstk(top) = n
      nstk(top) = n
      call mat_wcopy(n*n,stkr(l2),stki(l2),1,stkr(l),stki(l),1)
!===================================================================================================================================
    case(-2) ! MATRIX LEFT DIVISION A BACKSLASH A2
      l2 = lstk(top+1)
      m2 = mstk(top+1)
      n2 = nstk(top+1)
      if (m .ne. n) call mat_err(20)
      if (err .gt. 0) return
      if (m2*n2 .eq. 1) goto 26
      l3 = l2 + m2*n2
      err = l3+n - lstk(bot)
      if (err .gt. 0) call mat_err(17)
      if (err .gt. 0) return
      call ml_wgeco(stkr(l),stki(l),m,n,buf,rcond,stkr(l3),stki(l3))
      if (rcond .eq. 0.0d0) call mat_err(19)
      if (err .gt. 0) return
      t = mat_flop(1.0d0 + rcond)
      if (t .eq. 1.0d0) then
         call journal('WARNING:')
         call journal('MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.')
         WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
         call journal(mline)
      endif
      if (m2 .ne. n) call mat_err(12)
      if (err .gt. 0) return
      do j = 1, n2
         lj = l2+(j-1)*m2
         call ml_wgesl(stkr(l),stki(l),m,n,buf,stkr(lj),stki(lj),0)
      enddo
      nstk(top) = n2
      call mat_wcopy(m2*n2,stkr(l2),stki(l2),1,stkr(l),stki(l),1)
      goto 99
26    continue
      sr = stkr(l2)
      si = stki(l2)
!===================================================================================================================================
   end select
!===================================================================================================================================
   select case(FIN)
!===================================================================================================================================
    case(1) ! COMMAND::INV
      if (m .ne. n) call mat_err(20)
      if (err .gt. 0) return
      if (ddt .eq. 17) goto 32
      do j = 1, n
         do i = 1, n
            ls = l+i-1+(j-1)*n
            t0 = stkr(ls)
            t1 = mat_flop(1.0d0/(dfloat(i+j-1)))
            if (t0 .ne. t1) goto 32
         enddo
      enddo
      call mat_hilber(stkr(l),n,n)
      call mat_rset(n*n,0.0d0,stki(l),1)
      if (fin .lt. 0) call mat_wscal(n*n,sr,si,stkr(l),stki(l),1)
      goto 99
32    continue
      l3 = l + n*n
      err = l3+n - lstk(bot)
      if (err .gt. 0) call mat_err(17)
      if (err .gt. 0) return
      call ml_wgeco(stkr(l),stki(l),m,n,buf,rcond,stkr(l3),stki(l3))
      if (rcond .eq. 0.0d0) call mat_err(19)
      if (err .gt. 0) return
      t = mat_flop(1.0d0 + rcond)
      if (t .eq. 1.0d0) then
         call journal('warning:')
         call journal('matrix is close to singular or badly scaled.')
         write(mline,'(''results may be inaccurate. rcond='',1pd13.4)') rcond
         call journal(mline)
      endif
      call ml_wgedi(stkr(l),stki(l),m,n,buf,dtr,dti,stkr(l3),stki(l3),1)
      if (fin .lt. 0) call mat_wscal(n*n,sr,si,stkr(l),stki(l),1)
!===================================================================================================================================
    case (2) ! COMMAND::DET
      if (m .ne. n) call mat_err(20)
      if (err .gt. 0) return
      call ml_wgefa(stkr(l),stki(l),m,n,buf,info)
      call ml_wgedi(stkr(l),stki(l),m,n,buf,dtr,dti,sr,si,10)
      k = idint(dtr(2))
      ka = iabs(k)+2
      t = 1.0d0
      do i = 1, ka
         t = t/10.0d0
         if (t .eq. 0.0d0) goto 42
      enddo
      stkr(l) = dtr(1)*10.d0**k
      stki(l) = dti(1)*10.d0**k
      mstk(top) = 1
      nstk(top) = 1
      goto 99
42    continue
      if (dti(1) .eq. 0.0d0)then
         write(mline,43) dtr(1),k
43       format(' det =  ',f7.4,7h * 10**,i4)
         call journal(mline)
      else
         write(mline,44) dtr(1),dti(1),k
44       format(' det =  ',f7.4,' + ',f7.4,' i ',7h * 10**,i4)
         call journal(mline)
      endif
      stkr(l) = dtr(1)
      stki(l) = dti(1)
      stkr(l+1) = dtr(2)
      stki(l+1) = 0.0d0
      mstk(top) = 1
      nstk(top) = 2
!===================================================================================================================================
    case(3) ! COMMAND::RCOND
      if (m .ne. n) call mat_err(20)
      if (err .gt. 0) return
      l3 = l + n*n
      err = l3+n - lstk(bot)
      if (err .gt. 0) call mat_err(17)
      if (err .gt. 0) return
      call ml_wgeco(stkr(l),stki(l),m,n,buf,rcond,stkr(l3),stki(l3))
      stkr(l) = rcond
      stki(l) = 0.0d0
      mstk(top) = 1
      nstk(top) = 1
      if (lhs .ne. 1)then
         l = l + 1
         call mat_wcopy(n,stkr(l3),stki(l3),1,stkr(l),stki(l),1)
         top = top + 1
         lstk(top) = l
         mstk(top) = n
         nstk(top) = 1
      endif
!===================================================================================================================================
    case(4) ! COMMAND::LU
      if (m .ne. n) call mat_err(20)
      if (err .gt. 0) return
      call ml_wgefa(stkr(l),stki(l),m,n,buf,info)
      if (lhs .ne. 2) goto 99
      nn = n*n
      if (top+1 .ge. bot) call mat_err(18)
      if (err .gt. 0) return
      top = top+1
      lstk(top) = l + nn
      mstk(top) = n
      nstk(top) = n
      err = l+nn+nn - lstk(bot)
      if (err .gt. 0) call mat_err(17)
      if (err .gt. 0) return
      do kb = 1, n
         k = n+1-kb
         do i = 1, n
            ll = l+i-1+(k-1)*n
            lu = ll + nn
            if (i .le. k) stkr(lu) = stkr(ll)
            if (i .le. k) stki(lu) = stki(ll)
            if (i .gt. k) stkr(lu) = 0.0d0
            if (i .gt. k) stki(lu) = 0.0d0
            if (i .lt. k) stkr(ll) = 0.0d0
            if (i .lt. k) stki(ll) = 0.0d0
            if (i .eq. k) stkr(ll) = 1.0d0
            if (i .eq. k) stki(ll) = 0.0d0
            if (i .gt. k) stkr(ll) = -stkr(ll)
            if (i .gt. k) stki(ll) = -stki(ll)
         enddo
         i = buf(k)
         if (i .eq. k) cycle
         li = l+i-1+(k-1)*n
         lk = l+k-1+(k-1)*n
         call mat_wswap(n-k+1,stkr(li),stki(li),n,stkr(lk),stki(lk),n)
      enddo
!===================================================================================================================================
    case(5) ! COMMAND::HILBERT
      n = idint(stkr(l))
      mstk(top) = n
      nstk(top) = n
      call mat_hilber(stkr(l),n,n)
      call mat_rset(n*n,0.0d0,stki(l),1)
      if (fin .lt. 0) call mat_wscal(n*n,sr,si,stkr(l),stki(l),1)
!===================================================================================================================================
    case(6) ! COMMAND::CHOLESKY
      if (m .ne. n) call mat_err(20)
      if (err .gt. 0) return
      call mat_wpofa(stkr(l),stki(l),m,n,err)
      if (err .ne. 0) call mat_err(29)
      if (err .gt. 0) return
      do j = 1, n
         ll = l+j+(j-1)*m
         call mat_wset(m-j,0.0d0,0.0d0,stkr(ll),stki(ll),1)
      enddo
!===================================================================================================================================
    case(7) ! COMMAND::RREF
      if (rhs .ge. 2)then
         top = top-1
         l = lstk(top)
         if (mstk(top) .ne. m) call mat_err(5)
         if (err .gt. 0) return
         n = n + nstk(top)
      endif
      call mat_rref(stkr(l),stki(l),m,m,n,stkr(vsize-4))
      nstk(top) = n
!===================================================================================================================================
   end select
!
99 continue
end subroutine mat_matfn1
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_matfn2()
integer          :: i
integer          :: inc
integer          :: j
integer          :: job
integer          :: k
integer          :: l
integer          :: l1
integer          :: l2
integer          :: ld
integer          :: le
integer          :: lj
integer          :: ll
integer          :: ls
integer          :: lw
integer          :: m
integer          :: n
integer          :: nn
!
!     EVALUATE ELEMENTARY FUNCTIONS AND FUNCTIONS INVOLVING
!     EIGENVALUES AND EIGENVECTORS
!
      DOUBLEPRECISION TR,TI,SR,SI,POWR,POWI
      LOGICAL HERM,SCHUR,VECT,HESS
!
      IF (DDT .EQ. 1) call journal('sc','*MATFN2* ', FIN)
!
!     FUNCTIONS/FIN
!     **   SIN  COS ATAN  EXP  SQRT LOG
!      0    1    2    3    4    5    6
!    EIG  SCHU HESS POLY ROOT
!     11   12   13   14   15
!    ABS  ROUN REAL IMAG CONJ
!     21   22   23   24   25
      IF (FIN .NE. 0) GOTO 05
         L = LSTK(TOP+1)
         POWR = STKR(L)
         POWI = STKI(L)
   05 continue
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (FIN .GE. 11 .AND. FIN .LE. 13) GOTO 10
      IF (FIN .EQ. 14 .AND. (M.EQ.1 .OR. N.EQ.1)) GOTO 50
      IF (FIN .EQ. 14) GOTO 10
      IF (FIN .EQ. 15) GOTO 60
      IF (FIN .GT. 20) GOTO 40
      IF (M .EQ. 1 .OR. N .EQ. 1) GOTO 40
!===================================================================================================================================
!     EIGENVALUES AND VECTORS
   10 continue
      IF (M .NE. N) CALL mat_err(20)
      IF (ERR .GT. 0) RETURN
      SCHUR = FIN .EQ. 12
      HESS = FIN .EQ. 13
      VECT = LHS.EQ.2 .OR. FIN.LT.10
      NN = N*N
      L2 = L + NN
      LD = L2 + NN
      LE = LD + N
      LW = LE + N
      ERR = LW+N - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      CALL mat_wcopy(NN,STKR(L),STKI(L),1,STKR(L2),STKI(L2),1)
!
!     CHECK IF HERMITIAN
      HERM=.FALSE.
      DO J = 1, N
         DO I = 1, J
            LS = L+I-1+(J-1)*N
            LL = L+(I-1)*N+J-1
            HERM = STKR(LL).EQ.STKR(LS) .AND. STKI(LL).EQ.-STKI(LS)
            IF (.NOT. HERM) GOTO 30
         enddo
      enddo
!
!     HERMITIAN EIGENVALUE PROBLEM
      CALL mat_wset(NN,0.0D0,0.0D0,STKR(L),STKI(L),1)
      CALL mat_wset(N,1.0D0,0.0D0,STKR(L),STKI(L),N+1)
      CALL mat_wset(N,0.0D0,0.0D0,STKI(LD),STKI(LE),1)
      JOB = 0
      IF (VECT) JOB = 1
      CALL ML_HTRIDI(N,N,STKR(L2),STKI(L2),STKR(LD),STKR(LE),STKR(LE),STKR(LW))
      IF(.NOT.HESS)CALL ML_IMTQL2(N,N,STKR(LD),STKR(LE),STKR(L),ERR,JOB)
      IF (ERR .GT. 0) CALL mat_err(24)
      IF (ERR .GT. 0) RETURN
      IF (JOB .NE. 0) CALL ML_HTRIBK(N,N,STKR(L2),STKI(L2),STKR(LW),N,STKR(L),STKI(L))
      GOTO 31
!
!     NON-HERMITIAN EIGENVALUE PROBLEM
   30 continue
      CALL ML_CORTH(N,N,1,N,STKR(L2),STKI(L2),STKR(LW),STKI(LW))
      IF (.NOT.VECT .AND. HESS) GOTO 31
      JOB = 0
      IF (VECT) JOB = 2
      IF (VECT .AND. SCHUR) JOB = 1
      IF (HESS) JOB = 3
      CALL ML_COMQR3(N,N,1,N,STKR(LW),STKI(LW),STKR(L2),STKI(L2), STKR(LD),STKI(LD),STKR(L),STKI(L),ERR,JOB)
      IF (ERR .GT. 0) CALL mat_err(24)
      IF (ERR .GT. 0) RETURN
!
!     VECTORS
   31 continue
      IF (.NOT.VECT) GOTO 34
      IF (TOP+1 .GE. BOT) CALL mat_err(18)
      IF (ERR .GT. 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = L2
      MSTK(TOP) = N
      NSTK(TOP) = N
!
!     DIAGONAL OF VALUES OR CANONICAL FORMS
   34 continue
      IF (.NOT.VECT .AND. .NOT.SCHUR .AND. .NOT.HESS) GOTO 37
      DO J = 1, N
         LJ = L2+(J-1)*N
         IF (SCHUR .AND. (.NOT.HERM)) LJ = LJ+J
         IF (HESS .AND. (.NOT.HERM)) LJ = LJ+J+1
         LL = L2+J*N-LJ
         CALL mat_wset(LL,0.0D0,0.0D0,STKR(LJ),STKI(LJ),1)
      enddo
      IF (.NOT.HESS .OR. HERM) CALL mat_wcopy(N,STKR(LD),STKI(LD),1,STKR(L2),STKI(L2),N+1)
      LL = L2+1
      IF (HESS .AND. HERM)CALL mat_wcopy(N-1,STKR(LE+1),STKI(LE+1),1,STKR(LL),STKI(LL),N+1)
      LL = L2+N
      IF (HESS .AND. HERM)CALL mat_wcopy(N-1,STKR(LE+1),STKI(LE+1),1,STKR(LL),STKI(LL),N+1)
      IF (FIN .LT. 10) GOTO 42
      IF (VECT .OR. .NOT.(SCHUR.OR.HESS)) GOTO 99
      CALL mat_wcopy(NN,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      GOTO 99
!
!     VECTOR OF EIGENVALUES
   37 continue
      IF (FIN .EQ. 14) GOTO 52
      CALL mat_wcopy(N,STKR(LD),STKI(LD),1,STKR(L),STKI(L),1)
      NSTK(TOP) = 1
      GOTO 99
!===================================================================================================================================
!     ELEMENTARY FUNCTIONS
!     FOR MATRICES.. X,D = EIG(A), FUN(A) = X*FUN(D)/X
   40 continue
      INC = 1
      N = M*N
      L2 = L
      GOTO 44
   42 continue
      INC = N+1
   44 continue
      DO J = 1, N
        LS = L2+(J-1)*INC
        SR = STKR(LS)
        SI = STKI(LS)
        TI = 0.0D0
        IF (FIN .NE. 0) GOTO 45
          CALL mat_wlog(SR,SI,SR,SI)
          CALL mat_wmul(SR,SI,POWR,POWI,SR,SI)
          TR = DEXP(SR)*DCOS(SI)
          TI = DEXP(SR)*DSIN(SI)
   45   IF (FIN .EQ. 1) TR = DSIN(SR)*DCOSH(SI)
        IF (FIN .EQ. 1) TI = DCOS(SR)*DSINH(SI)
        IF (FIN .EQ. 2) TR = DCOS(SR)*DCOSH(SI)
        IF (FIN .EQ. 2) TI = (-DSIN(SR))*DSINH(SI)
        IF (FIN .EQ. 3) CALL mat_watan(SR,SI,TR,TI)
        IF (FIN .EQ. 4) TR = DEXP(SR)*DCOS(SI)
        IF (FIN .EQ. 4) TI = DEXP(SR)*DSIN(SI)
        IF (FIN .EQ. 5) CALL mat_wsqrt(SR,SI,TR,TI)
        IF (FIN .EQ. 6) CALL mat_wlog(SR,SI,TR,TI)
        IF (FIN .EQ. 21) TR = mat_pythag(SR,SI)
        IF (FIN .EQ. 22) TR = mat_round(SR)
        IF (FIN .EQ. 23) TR = SR
        IF (FIN .EQ. 24) TR = SI
        IF (FIN .EQ. 25) TR = SR
        IF (FIN .EQ. 25) TI = -SI
        IF (ERR .GT. 0) RETURN
        STKR(LS) = mat_flop(TR)
        STKI(LS) = 0.0D0
        IF (TI .NE. 0.0D0) STKI(LS) = mat_flop(TI)
      enddo
      IF (INC .EQ. 1) GOTO 99
      DO J = 1, N
        LS = L2+(J-1)*INC
        SR = STKR(LS)
        SI = STKI(LS)
        LS = L+(J-1)*N
        LL = L2+(J-1)*N
        CALL mat_wcopy(N,STKR(LS),STKI(LS),1,STKR(LL),STKI(LL),1)
        CALL mat_wscal(N,SR,SI,STKR(LS),STKI(LS),1)
      enddo
!     SIGNAL MATFN1 TO DIVIDE BY EIGENVECTORS
      FUN = 21
      FIN = -1
      TOP = TOP-1
      GOTO 99
!===================================================================================================================================
!     POLY
!     FORM POLYNOMIAL WITH GIVEN VECTOR AS ROOTS
   50 continue
      N = MAX0(M,N)
      LD = L+N+1
      CALL mat_wcopy(N,STKR(L),STKI(L),1,STKR(LD),STKI(LD),1)
!
!     FORM CHARACTERISTIC POLYNOMIAL
   52 continue
      CALL mat_wset(N+1,0.0D0,0.0D0,STKR(L),STKI(L),1)
      STKR(L) = 1.0D0
      DO J = 1, N
         CALL matX_waxpy(J,-STKR(LD),-STKI(LD),STKR(L),STKI(L),-1, STKR(L+1),STKI(L+1),-1)
         LD = LD+1
      enddo
      MSTK(TOP) = N+1
      NSTK(TOP) = 1
      GOTO 99
!===================================================================================================================================
!     ROOTS
   60 continue
      LL = L+M*N
      STKR(LL) = -1.0D0
      STKI(LL) = 0.0D0
      K = -1
   61 continue
      K = K+1
      L1 = L+K
      IF (DABS(STKR(L1))+DABS(STKI(L1)) .EQ. 0.0D0) GOTO 61
      N = MAX0(M*N - K-1, 0)
      IF (N .LE. 0) GOTO 65
      L2 = L1+N+1
      LW = L2+N*N
      ERR = LW+N - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      CALL mat_wset(N*N+N,0.0D0,0.0D0,STKR(L2),STKI(L2),1)
      DO J = 1, N
         LL = L2+J+(J-1)*N
         STKR(LL) = 1.0D0
         LS = L1+J
         LL = L2+(J-1)*N
         CALL mat_wdiv(-STKR(LS),-STKI(LS),STKR(L1),STKI(L1), STKR(LL),STKI(LL))
         IF (ERR .GT. 0) RETURN
      enddo
      CALL ML_COMQR3(N,N,1,N,STKR(LW),STKI(LW),STKR(L2),STKI(L2),STKR(L),STKI(L),TR,TI,ERR,0)
      IF (ERR .GT. 0) CALL mat_err(24)
      IF (ERR .GT. 0) RETURN
   65 continue
      MSTK(TOP) = N
      NSTK(TOP) = 1
      GOTO 99
!===================================================================================================================================
   99 continue
END SUBROUTINE mat_matfn2
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn3()

$@(#) M_matrix::mat_matfn3(3fp): evaluate functions involving singular value decomposition

integer         :: i
integer         :: j
integer         :: jb
integer         :: job
integer         :: k
integer         :: l
integer         :: l1
integer         :: l2
integer         :: ld
integer         :: li
integer         :: lj
integer         :: ll
integer         :: ls
integer         :: lu
integer         :: lv
integer         :: m
integer         :: mn
integer         :: n
logical         :: fro,inf
doubleprecision :: p,s,t,tol,eps
!
   if (ddt .eq. 1) call journal('sc','*MATFN3* ', FIN)
!
   if (fin.eq.1 .and. rhs.eq.2) top = top-1
   l = lstk(top)
   m = mstk(top)
   n = nstk(top)
   mn = m*n
   !      SVD PINV COND NORM RANK
   !        1    2    3    4    5
   FUN3: select case(fin)
!===================================================================================================================================
    case(3) ! COMMAND::COND
      ld = l + m*n
      l1 = ld + min0(m+1,n)
      l2 = l1 + n
      err = l2+min0(m,n) - lstk(bot)
      if (err .gt. 0) call mat_err(17)
      if (err .gt. 0) return
      call ml_wsvdc(stkr(l),stki(l),m,m,n,stkr(ld),stki(ld),stkr(l1),stki(l1),t,t,1,t,t,1,stkr(l2),stki(l2),0,err)
      if (err .ne. 0) call mat_err(24)
      if (err .gt. 0) return
      s = stkr(ld)
      ld = ld + min0(m,n) - 1
      t = stkr(ld)
      if (t .ne. 0.0d0) then
         stkr(l) = mat_flop(s/t)
         stki(l) = 0.0d0
         mstk(top) = 1
         nstk(top) = 1
      else
         call journal(' CONDITION IS INFINITE')
         mstk(top) = 0
      endif
!===================================================================================================================================
    case(4) ! command::norm
      p = 2.0d0
      inf = .false.
      if (rhs .eq. 2)then
         fro = idint(stkr(l)).eq.15 .and. mn.gt.1
         inf = idint(stkr(l)).eq.18 .and. mn.gt.1
         if (.not. fro) p = stkr(l)
         top = top-1
         l = lstk(top)
         m = mstk(top)
         n = nstk(top)
         mn = m*n
         if (fro) m = mn
         if (fro) n = 1
      endif
      if (m .gt. 1 .and. n .gt. 1) goto 40
      if (p .eq. 1.0d0) goto 36
      if (p .eq. 2.0d0) goto 38
      i = mat_iwamax(mn,stkr(l),stki(l),1) + l - 1
      s = dabs(stkr(i)) + dabs(stki(i))
      if (inf .or. s .eq. 0.0d0) goto 49
      t = 0.0d0
      do i = 1, mn
         ls = l+i-1
         t = mat_flop(t + (mat_pythag(stkr(ls),stki(ls))/s)**p)
      enddo
      if (p .ne. 0.0d0) p = 1.0d0/p
      s = mat_flop(s*t**p)
      GOTO 49
36    continue
      S = mat_wasum(MN,STKR(L),STKI(L),1)
      GOTO 49
38    continue
      S = mat_wnrm2(MN,STKR(L),STKI(L),1)
      GOTO 49
40    continue !     MATRIX NORM
      IF (INF) GOTO 43
      IF (P .EQ. 1.0D0) GOTO 46
      IF (P .NE. 2.0D0) CALL mat_err(23)
      IF (ERR .GT. 0) RETURN
      LD = L + M*N
      L1 = LD + MIN0(M+1,N)
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),0,ERR)
      IF (ERR .NE. 0) CALL mat_err(24)
      IF (ERR .GT. 0) RETURN
      S = STKR(LD)
      GOTO 49
43    continue
      S = 0.0D0
      DO I = 1, M
         LI = L+I-1
         T = mat_wasum(N,STKR(LI),STKI(LI),M)
         S = DMAX1(S,T)
      enddo
      GOTO 49
46    continue
      S = 0.0D0
      DO J = 1, N
         LJ = L+(J-1)*M
         T = mat_wasum(M,STKR(LJ),STKI(LJ),1)
         S = DMAX1(S,T)
      enddo
      GOTO 49
49    continue
      STKR(L) = S
      STKI(L) = 0.0D0
      MSTK(TOP) = 1
      NSTK(TOP) = 1
!===================================================================================================================================
    case(1) !     COMMAND::SVD
      IF (LHS .EQ. 3)then
         K = M
         IF (RHS .EQ. 2) K = MIN0(M,N)
         LU = L + M*N
         LD = LU + M*K
         LV = LD + K*N
         L1 = LV + N*N
         L2 = L1 + N
         ERR = L2+MIN0(M,N) - LSTK(BOT)
         IF (ERR .GT. 0) CALL mat_err(17)
         IF (ERR .GT. 0) RETURN
         JOB = 11
         IF (RHS .EQ. 2) JOB = 21
         CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),STKR(LU),STKI(LU),M,STKR(LV),STKI(LV), &
         &        N,STKR(L2),STKI(L2),JOB,ERR)
         DO JB = 1, N
            DO I = 1, K
               J = N+1-JB
               LL = LD+I-1+(J-1)*K
               IF (I.NE.J) STKR(LL) = 0.0D0
               STKI(LL) = 0.0D0
               LS = LD+I-1
               IF (I.EQ.J) STKR(LL) = STKR(LS)
               LS = L1+I-1
               IF (ERR.NE.0 .AND. I.EQ.J-1) STKR(LL) = STKR(LS)
            enddo
         enddo
         IF (ERR .NE. 0) CALL mat_err(24)
         ERR = 0
         CALL mat_wcopy(M*K+K*N+N*N,STKR(LU),STKI(LU),1,STKR(L),STKI(L),1)
         MSTK(TOP) = M
         NSTK(TOP) = K
         IF (TOP+1 .GE. BOT) CALL mat_err(18)
         IF (ERR .GT. 0) RETURN
         TOP = TOP+1
         LSTK(TOP) = L + M*K
         MSTK(TOP) = K
         NSTK(TOP) = N
         IF (TOP+1 .GE. BOT) CALL mat_err(18)
         IF (ERR .GT. 0) RETURN
         TOP = TOP+1
         LSTK(TOP) = L + M*K + K*N
         MSTK(TOP) = N
         NSTK(TOP) = N
      else
         LD = L + M*N
         L1 = LD + MIN0(M+1,N)
         L2 = L1 + N
         ERR = L2+MIN0(M,N) - LSTK(BOT)
         IF (ERR .GT. 0) CALL mat_err(17)
         IF (ERR .GT. 0) RETURN
         CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),T,T,1,T,T,1,STKR(L2),STKI(L2),0,ERR)
         IF (ERR .NE. 0) CALL mat_err(24)
         IF (ERR .GT. 0) RETURN
         K = MIN0(M,N)
         CALL mat_wcopy(K,STKR(LD),STKI(LD),1,STKR(L),STKI(L),1)
         MSTK(TOP) = K
         NSTK(TOP) = 1
      endif
!===================================================================================================================================
    case(2,5) ! COMMAND::PINV AND RANK
      TOL = -1.0D0
      IF (RHS .EQ. 2) then
         TOL = STKR(L)
         TOP = TOP-1
         L = LSTK(TOP)
         M = MSTK(TOP)
         N = NSTK(TOP)
      endif
      LU = L + M*N
      LD = LU + M*M
      IF (FIN .EQ. 5) LD = L + M*N
      LV = LD + M*N
      L1 = LV + N*N
      IF (FIN .EQ. 5) L1 = LD + N
      L2 = L1 + N
      ERR = L2+MIN0(M,N) - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      IF (FIN .EQ. 2) JOB = 11
      IF (FIN .EQ. 5) JOB = 0
      CALL ML_WSVDC(STKR(L),STKI(L),M,M,N,STKR(LD),STKI(LD),STKR(L1),STKI(L1),STKR(LU),STKI(LU),M,STKR(LV),STKI(LV), &
      &        N,STKR(L2),STKI(L2),JOB,ERR)
      IF (ERR .NE. 0) CALL mat_err(24)
      IF (ERR .GT. 0) RETURN
      EPS = STKR(VSIZE-4)
      IF (TOL .LT. 0.0D0) TOL = mat_flop(DFLOAT(MAX0(M,N))*EPS*STKR(LD))
      MN = MIN0(M,N)
      K = 0
      DO J = 1, MN
         LS = LD+J-1
         S = STKR(LS)
         IF (S .LE. TOL) exit
         K = J
         LL = LV+(J-1)*N
         IF (FIN .EQ. 2) CALL mat_wrscal(N,1.0D0/S,STKR(LL),STKI(LL),1)
      enddo
      if (fin .ne. 5) then
         do j = 1, m
            do i = 1, n
               ll = l+i-1+(j-1)*n
               l1 = lv+i-1
               l2 = lu+j-1
               stkr(ll) = mat_wdotcr(k,stkr(l2),stki(l2),m,stkr(l1),stki(l1),n)
               stki(ll) = mat_wdotci(k,stkr(l2),stki(l2),m,stkr(l1),stki(l1),n)
            enddo
         enddo
         mstk(top) = n
         nstk(top) = m
      else
         stkr(l) = dfloat(k)
         stki(l) = 0.0d0
         mstk(top) = 1
         nstk(top) = 1
      endif
!===================================================================================================================================
   end select FUN3
!
end subroutine mat_matfn3
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_matfn4()

$@(#) M_matrix::mat_matfn4(3fp): evaluate functions involving qr decomposition (least squares)

integer           :: info
integer           :: j
integer           :: jb
integer           :: job
integer           :: k
integer           :: l
integer           :: l2
integer           :: l3
integer           :: l4
integer           :: le
integer           :: ll
integer           :: ls
integer           :: m
integer           :: m2
integer           :: mm
integer           :: mn
integer           :: n
integer           :: n2
character(len=81) ::  mline
DOUBLEPRECISION   :: T,TOL,EPS
INTEGER,parameter :: QUOTE= 49
!
      IF (DDT .EQ. 1) call journal('sc','*MATFN4* ', FIN)
!
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)
      IF (FIN .EQ. -1) GOTO 10
      IF (FIN .EQ. -2) GOTO 20
      GOTO 40
!
!     RECTANGULAR MATRIX RIGHT DIVISION, A/A2
   10 continue
      L2 = LSTK(TOP+1)
      M2 = MSTK(TOP+1)
      N2 = NSTK(TOP+1)
      TOP = TOP + 1
      IF (N.GT.1 .AND. N.NE.N2) CALL mat_err(11)
      IF (ERR .GT. 0) RETURN
      CALL mat_stack1(QUOTE)
      IF (ERR .GT. 0) RETURN
      LL = L2+M2*N2
      CALL mat_wcopy(M*N,STKR(L),STKI(L),1,STKR(LL),STKI(LL),1)
      CALL mat_wcopy(M*N+M2*N2,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      LSTK(TOP) = L+M2*N2
      MSTK(TOP) = M
      NSTK(TOP) = N
      CALL mat_stack1(QUOTE)
      IF (ERR .GT. 0) RETURN
      TOP = TOP - 1
      M = N2
      N = M2
      GOTO 20
!
!     RECTANGULAR MATRIX LEFT DIVISION A BACKSLASH A2
!
   20 continue
      L2 = LSTK(TOP+1)
      M2 = MSTK(TOP+1)
      N2 = NSTK(TOP+1)
      IF (M2*N2 .GT. 1) GOTO 21
        M2 = M
        N2 = M
        ERR = L2+M*M - LSTK(BOT)
        IF (ERR .GT. 0) CALL mat_err(17)
        IF (ERR .GT. 0) RETURN
        CALL mat_wset(M*M-1,0.0D0,0.0D0,STKR(L2+1),STKI(L2+1),1)
        CALL mat_wcopy(M,STKR(L2),STKI(L2),0,STKR(L2),STKI(L2),M+1)
   21 continue
      IF (M2 .NE. M) CALL mat_err(12)
      IF (ERR .GT. 0) RETURN
      L3 = L2 + MAX0(M,N)*N2
      L4 = L3 + N
      ERR = L4 + N - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      IF (M .GT. N) GOTO 23
      DO JB = 1, N2
        J = N+1-JB
        LS = L2 + (J-1)*M
        LL = L2 + (J-1)*N
        CALL mat_wcopy(M,STKR(LS),STKI(LS),-1,STKR(LL),STKI(LL),-1)
      enddo
   23 continue
      DO J = 1, N
        BUF(J) = 0
      enddo
      CALL ML_WQRDC(STKR(L),STKI(L),M,M,N,STKR(L4),STKI(L4),BUF,STKR(L3),STKI(L3),1)
      K = 0
      EPS = STKR(VSIZE-4)
      T = DABS(STKR(L))+DABS(STKI(L))
      TOL = mat_flop(DFLOAT(MAX0(M,N))*EPS*T)
      MN = MIN0(M,N)
      DO J = 1, MN
        LS = L+J-1+(J-1)*M
        T = DABS(STKR(LS)) + DABS(STKI(LS))
        IF (T .GT. TOL) K = J
      enddo
      IF (K .LT. MN) then
         WRITE(mline,'('' RANK DEFICIENT,  RANK ='',I4,'',  TOL ='',1PD13.4)') K,TOL
         call journal(mline)
      endif
      MN = MAX0(M,N)
      DO J = 1, N2
        LS = L2+(J-1)*MN
        CALL ML_WQRSL(STKR(L),STKI(L),M,M,K,STKR(L4),STKI(L4),STKR(LS),STKI(LS),T,T,STKR(LS),STKI(LS),STKR(LS), &
       & STKI(LS),T,T,T,T,100,INFO)
        LL = LS+K
        CALL mat_wset(N-K,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
      enddo
      DO J = 1, N
        BUF(J) = -BUF(J)
      enddo
      DO J = 1, N
        IF (BUF(J) .GT. 0) cycle
        K = -BUF(J)
        BUF(J) = K
   33   CONTINUE
          IF (K .EQ. J) cycle
          LS = L2+J-1
          LL = L2+K-1
          CALL mat_wswap(N2,STKR(LS),STKI(LS),MN,STKR(LL),STKI(LL),MN)
          BUF(K) = -BUF(K)
          K = BUF(K)
          GOTO 33
      enddo
      DO J = 1, N2
        LS = L2+(J-1)*MN
        LL = L+(J-1)*N
        CALL mat_wcopy(N,STKR(LS),STKI(LS),1,STKR(LL),STKI(LL),1)
      enddo
      MSTK(TOP) = N
      NSTK(TOP) = N2
      IF (FIN .EQ. -1) CALL mat_stack1(QUOTE)
      IF (ERR .GT. 0) RETURN
      GOTO 99
!
!     QR
!
   40 continue
      MM = MAX0(M,N)
      LS = L + MM*MM
      IF (LHS.EQ.1 .AND. FIN.EQ.1) LS = L
      LE = LS + M*N
      L4 = LE + MM
      ERR = L4+MM - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
      IF (LS.NE.L) CALL mat_wcopy(M*N,STKR(L),STKI(L),1,STKR(LS),STKI(LS),1)
      JOB = 1
      IF (LHS.LT.3) JOB = 0
      DO J = 1, N
        BUF(J) = 0
      enddo
      CALL ML_WQRDC(STKR(LS),STKI(LS),M,M,N,STKR(L4),STKI(L4),BUF,STKR(LE),STKI(LE),JOB)
      IF (LHS.EQ.1 .AND. FIN.EQ.1) GOTO 99
      CALL mat_wset(M*M,0.0D0,0.0D0,STKR(L),STKI(L),1)
      CALL mat_wset(M,1.0D0,0.0D0,STKR(L),STKI(L),M+1)
      DO J = 1, M
        LL = L+(J-1)*M
        CALL ML_WQRSL(STKR(LS),STKI(LS),M,M,N,STKR(L4),STKI(L4),   &
     &             STKR(LL),STKI(LL),STKR(LL),STKI(LL),T,T,        &
     &             T,T,T,T,T,T,10000,INFO)
      enddo
      IF (FIN .EQ. 2) GOTO 99
      NSTK(TOP) = M
      DO J = 1, N
        LL = LS+J+(J-1)*M
        CALL mat_wset(M-J,0.0D0,0.0D0,STKR(LL),STKI(LL),1)
      enddo
      IF (TOP+1 .GE. BOT) CALL mat_err(18)
      IF (ERR .GT. 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = LS
      MSTK(TOP) = M
      NSTK(TOP) = N
      IF (LHS .EQ. 2) GOTO 99
      CALL mat_wset(N*N,0.0D0,0.0D0,STKR(LE),STKI(LE),1)
      DO J = 1, N
        LL = LE+BUF(J)-1+(J-1)*N
        STKR(LL) = 1.0D0
      enddo
      IF (TOP+1 .GE. BOT) CALL mat_err(18)
      IF (ERR .GT. 0) RETURN
      TOP = TOP+1
      LSTK(TOP) = LE
      MSTK(TOP) = N
      NSTK(TOP) = N
      GOTO 99
!
   99 continue
END SUBROUTINE mat_matfn4
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn5()

$@(#) M_matrix::mat_matfn5(3fp):file handling and other I/O

character(len=256)  :: mline
character(len=256)  :: errmsg
character(len=1024) :: name
character(len=1)    :: ch_char
integer             :: temp_lun
integer             :: ios

integer,save        :: flag=0
integer,save        :: blank=36
integer,save        :: plus=41
integer,save        :: minus=42
integer,save        :: quote=49
integer,save        :: semi=39
integer,save        :: lrat=5
integer,save        :: mrat=100
integer             :: ch,top2,ch1(1)
integer             :: id(4)
doubleprecision     :: eps,b,s,t,tdum(2)
logical             :: text
integer             :: i
integer             :: img
integer             :: j
integer             :: job
integer             :: k
integer             :: l
integer             :: l2
integer             :: ll
integer             :: ls
integer             :: lun
integer             :: lunit
integer             :: lw
integer             :: lx
integer             :: ly
integer             :: m
integer             :: mn
integer             :: n
!
      IF (DDT .EQ. 1) call journal('sc','*MATFN5* ',FIN)
!     FUNCTIONS/FIN
!     EXEC SAVE LOAD PRIN DIAR DISP BASE LINE CHAR PLOT RAT  DEBU DOC
!      1    2    3    4    5    6    7    8    9   10   11   12   13
      L = LSTK(TOP)
      M = MSTK(TOP)
      N = NSTK(TOP)

      select case(fin)
      case(:5,13)
         ! CONVERT FILE NAME
         MN = M*N
         FLAG = 3
         IF (SYM .EQ. SEMI) FLAG = 0
         IF (RHS .GE. 2) THEN
            FLAG = IDINT(STKR(L))
            TOP2 = TOP
            TOP = TOP-1
            L = LSTK(TOP)
            MN = MSTK(TOP)*NSTK(TOP)
         ENDIF
         LUN = -1
         IF (MN.EQ.1 .AND. STKR(L).LT.10.0D0) LUN = IDINT(STKR(L))
         IF (LUN .LT. 0) THEN
             DO J = 1, 32
                LS = L+J-1
                IF (J .LE. MN) CH = IDINT(STKR(LS))
                IF (J .GT. MN) CH = BLANK
                IF (CH.LT.0 .OR. CH.GE.alflq) CALL mat_err(38)
                IF (ERR .GT. 0) RETURN
                IF (CASE .EQ. 0) BUF(J) = ALFA(CH+1)
                IF (CASE .EQ. 1) BUF(J) = ALFB(CH+1)
             enddo
         ENDIF
      case(6:12)
      case default
      end select
!===================================================================================================================================
      FUN5 : select case(fin)
!===================================================================================================================================
      case(1) !     COMMAND::EXEC
      IF (LUN .EQ. 0) THEN
!     EXEC(0)
         RIO = RTE
         ERR = 99
      else
         K = LPT(6)
         LIN(K+1) = LPT(1)
         LIN(K+2) = LPT(3)
         LIN(K+3) = LPT(6)
         LIN(K+4) = PTZ
         LIN(K+5) = RIO
         LIN(K+6) = LCT(4)
         LPT(1) = K + 7
         LCT(4) = FLAG
         PTZ = PT - 4
         IF (RIO .EQ. RTE) RIO = 12
         RIO = RIO + 1
         IF (LUN .GT. 0) RIO = LUN
         IF (LUN .LT. 0) CALL mat_files(RIO,BUF)
         IF (FLAG .GE. 4)call journal(' PAUSE MODE. ENTER BLANK LINES.')
         SYM = EOL
         MSTK(TOP) = 0
      endif
!===================================================================================================================================
      case(4) ! COMMAND::PRINT
      K = WTE
      WTE = LUN
      IF (LUN .LT. 0) WTE = 7
      IF (LUN .LT. 0) CALL mat_files(WTE,BUF)

      L = LCT(2)
      LCT(2) = 9999
      IF (RHS .GT. 1) CALL mat_print(SYN,TOP2)
      LCT(2) = L

      WTE = K
      MSTK(TOP) = 0
!===================================================================================================================================
      case(5) ! COMMAND::DIARY
      IF (LUN < 0) CALL mat_files(8,BUF)
      MSTK(TOP) = 0
!===================================================================================================================================
      case(2) ! COMMAND::SAVE
      IF (LUN .LT. 0) LUNIT = 1
      IF (LUN .LT. 0) CALL mat_files(LUNIT,BUF)
      IF (LUN .GT. 0) LUNIT = LUN
      K = LSIZE-4
      IF (K .LT. BOT) K = LSIZE
      IF (RHS .EQ. 2) K = TOP2
      IF (RHS .EQ. 2) CALL mat_putid(IDSTK(1,K),SYN)
   32 CONTINUE
      L = LSTK(K)
      M = MSTK(K)
      N = NSTK(K)
      DO I = 1, 4
         J = IDSTK(I,K)+1
         BUF(I) = ALFA(J)
      enddo
      IMG = 0
      IF (mat_wasum(M*N,STKI(L),STKI(L),1) .NE. 0.0D0) IMG = 1
      IF(FE .EQ. 0)CALL mat_savlod(LUNIT,BUF,M,N,IMG,0,STKR(L),STKI(L))
      K = K-1
      IF (K .GE. BOT) GOTO 32
      CALL mat_files(-LUNIT,BUF)
      MSTK(TOP) = 0
!===================================================================================================================================
      case(3) ! COMMAND::LOAD
      IF (LUN .LT. 0) LUNIT = 2
      IF (LUN .LT. 0) CALL mat_files(LUNIT,BUF) ! open the unit
      IF (LUN .GT. 0) LUNIT = LUN
   36 CONTINUE
      JOB = LSTK(BOT) - L
      IF(FE .EQ. 0)CALL mat_savlod(LUNIT,ID,MSTK(TOP),NSTK(TOP),IMG,JOB,STKR(L),STKI(L))
      MN = MSTK(TOP)*NSTK(TOP)
      IF (MN .EQ. 0) GOTO 39
      IF (IMG .EQ. 0) CALL mat_rset(MN,0.0D0,STKI(L),1)
      DO I = 1, 4
         J = 0
   37    CONTINUE
         J = J+1
         IF (ID(I).NE.ALFA(J) .AND. J.LE.BLANK) GOTO 37
         ID(I) = J-1
      enddo
      SYM = SEMI
      RHS = 0
      CALL mat_stackp(ID)
      TOP = TOP + 1
      GOTO 36

   39 CONTINUE
      CALL mat_files(-LUNIT,BUF) ! close unit
      MSTK(TOP) = 0
!===================================================================================================================================
      case(11) !     COMMAND::RAT
      if (rhs .ne. 2) then
         mn = m*n
         l2 = l
         if (lhs .eq. 2) l2 = l + mn
         lw = l2 + mn
         err = lw + lrat - lstk(bot)
         if (err .gt. 0) call mat_err(17)
         if (err .gt. 0) return
         if (lhs .eq. 2) top = top + 1
         lstk(top) = l2
         mstk(top) = m
         nstk(top) = n
         call mat_rset(lhs*mn,0.0d0,stki(l),1)
         do i = 1, mn
            call mat_rat(stkr(l),lrat,mrat,s,t,stkr(lw))
            stkr(l) = s
            stkr(l2) = t
            if (lhs .eq. 1) stkr(l) = mat_flop(s/t)
            l = l + 1
            l2 = l2 + 1
         enddo
      else
         mrat = idint(stkr(l))
         lrat = idint(stkr(l-1))
         top = top - 1
         mstk(top) = 0
      endif
!===================================================================================================================================
      case(9) !     COMMAND::CHAR
      K = IABS(IDINT(STKR(L)))
      IF (M*N.NE.1 .OR. K.GE.alflq) CALL mat_err(36)
      IF (ERR .GT. 0) exit FUN5
      CH = ALFA(K+1)
      IF (STKR(L) .LT. 0.0D0) CH = ALFB(K+1)
      WRITE(mline,'('' REPLACE CHARACTER '',A1)') CHAR(CH)
      call journal(mline)
      READ(RTE,'(A1)') CH_CHAR
      call mat_str2buf(ch_char,ch1,1); ch=ch1(1)
      IF (STKR(L) .GE. 0.0D0) ALFA(K+1) = CH
      IF (STKR(L) .LT. 0.0D0) ALFB(K+1) = CH
      MSTK(TOP) = 0
!===================================================================================================================================
      case(6,7) !     COMMAND::DISP
60    continue
      call journal(' ')
      if (FIN.eq.7)goto 65
      IF (RHS .EQ. 2) GOTO 65
      MN = M*N
      TEXT = .TRUE.
      DO I = 1, MN
        LS = L+I-1
        CH = IDINT(STKR(LS))
        TEXT = TEXT .AND. (CH.GE.0) .AND. (CH.LT.alflq)
        TEXT = TEXT .AND. (DFLOAT(CH).EQ.STKR(LS))
      enddo

      DO I = 1, M
         DO J = 1, N
           LS = L+I-1+(J-1)*M
           IF (STKR(LS) .EQ. 0.0D0) CH = BLANK
           IF (STKR(LS) .GT. 0.0D0) CH = PLUS
           IF (STKR(LS) .LT. 0.0D0) CH = MINUS
           IF (TEXT) CH = IDINT(STKR(LS))
           BUF(J) = ALFA(CH+1)
         enddo
         call mat_buf2str(mline,buf,n)
         call journal(mline)
      enddo
      MSTK(TOP) = 0
      exit FUN5
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
!     COMMAND::BASE
   65 CONTINUE
      IF (RHS .NE. 2) CALL mat_err(39)
      IF (STKR(L) .LE. 1.0D0) CALL mat_err(36)
      IF (ERR .GT. 0) exit FUN5
      B = STKR(L)
      L2 = L
      TOP = TOP-1
      RHS = 1
      L = LSTK(TOP)
      M = MSTK(TOP)*NSTK(TOP)
      EPS = STKR(VSIZE-4)
      DO I = 1, M
         LS = L2+(I-1)*N
         LL = L+I-1
         CALL mat_base(STKR(LL),B,EPS,STKR(LS),N)
      enddo
      CALL mat_rset(M*N,0.0D0,STKI(L2),1)
      CALL mat_wcopy(M*N,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
      MSTK(TOP) = N
      NSTK(TOP) = M
      CALL mat_stack1(QUOTE)
      IF (FIN .EQ. 6) GOTO 60
!===================================================================================================================================
      case(8)
!     COMMAND::LINES
      LCT(2) = IDINT(STKR(L))
      MSTK(TOP) = 0
!===================================================================================================================================
      case(10) !     COMMAND::PLOT
      IF (RHS .GE. 2) GOTO 82
      N = M*N
      DO I = 1, N
         LL = L+I-1
         STKI(LL) = DFLOAT(I)
      enddo
      CALL mat_plot(WTE,STKI(L),STKR(L),N,TDUM,0)
      MSTK(TOP) = 0
      exit FUN5
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

   82 continue
      IF (RHS .EQ. 2) K = 0
      IF (RHS .EQ. 3) K = M*N
      IF (RHS .GT. 3) K = RHS - 2
      TOP = TOP - (RHS - 1)
      N = MSTK(TOP)*NSTK(TOP)
      IF (MSTK(TOP+1)*NSTK(TOP+1) .NE. N) CALL mat_err(5)
      IF (ERR .GT. 0) exit FUN5
      LX = LSTK(TOP)
      LY = LSTK(TOP+1)
      IF (RHS .GT. 3) L = LSTK(TOP+2)
      CALL mat_plot(WTE,STKR(LX),STKR(LY),N,STKR(L),K)
      MSTK(TOP) = 0
!===================================================================================================================================
      case(12) !     COMMAND::DEBUG
      DDT = IDINT(STKR(L))
      call journal('sc',' DEBUG ',DDT)
      MSTK(TOP) = 0
!===================================================================================================================================
      case(13) !     COMMAND::DOC
      call mat_buf2str(name,buf,256)
         open(newunit=temp_lun,file=name,status='new',iostat=ios,iomsg=errmsg) ! open help file
         if(ios.eq.0)then
            call mat_make_manual(temp_lun)
            call mat_make_help(temp_lun)
            close(unit=-lunit,iostat=ios)
            call journal('sc','*doc* user guide including all help text in the Appendix is on file',trim(name) )
         else
            call journal(trim(errmsg))
         endif
      MSTK(TOP) = 0
!===================================================================================================================================
      end select FUN5
!===================================================================================================================================
end subroutine mat_matfn5
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_stackg(ID)

$@(#) M_matrix::mat_stackg(3fp): get variables from storage

integer       :: id(4)
integer       :: i
integer       :: j
integer       :: k
integer       :: l
integer       :: l2
integer       :: l3
integer       :: li
integer       :: lj
integer       :: lk
integer       :: ll
integer       :: ls
integer       :: m
integer       :: mk
integer       :: mn
integer       :: mnk
integer       :: n
      IF (DDT .EQ. 1)then
         call journal('sc','STACKG(1)=',ID(1))
         call journal('sc','STACKG(2)=',ID(2))
         call journal('sc','STACKG(3)=',ID(3))
         call journal('sc','STACKG(4)=',ID(4))
      endif
      CALL mat_putid(IDSTK(1,BOT-1), ID)
      K = LSIZE+1
!===================================================================================================================================
   10 continue
      K = K-1
      IF (.NOT.mat_eqid(IDSTK(1,K), ID)) GOTO 10
      IF (K .GE. LSIZE-1 .AND. RHS .GT. 0) GOTO 98
      IF (K .EQ. BOT-1) GOTO 98
      LK = LSTK(K)
      IF (RHS .EQ. 1) GOTO 40
      IF (RHS .EQ. 2) GOTO 60
      IF (RHS .GT. 2) CALL mat_err(21)
      IF (ERR .GT. 0) RETURN
      L = 1
      IF (TOP .GT. 0) L = LSTK(TOP) + MSTK(TOP)*NSTK(TOP)
      IF (TOP+1 .GE. BOT) CALL mat_err(18)
      IF (ERR .GT. 0) RETURN
      TOP = TOP+1
!
!     LOAD VARIABLE TO TOP OF STACK
      LSTK(TOP) = L
      MSTK(TOP) = MSTK(K)
      NSTK(TOP) = NSTK(K)
      MN = MSTK(K)*NSTK(K)
      ERR = L+MN - LSTK(BOT)
      IF (ERR .GT. 0) CALL mat_err(17)
      IF (ERR .GT. 0) RETURN
!     IF RAND, MATFN6 GENERATES RANDOM NUMBER
      IF (K .EQ. LSIZE) GOTO 97
      CALL mat_wcopy(MN,STKR(LK),STKI(LK),1,STKR(L),STKI(L),1)
      GOTO 99
!===================================================================================================================================
!     VECT(ARG)
   40 continue
      IF (MSTK(TOP) .EQ. 0) GOTO 99
      L = LSTK(TOP)
      MN = MSTK(TOP)*NSTK(TOP)
      MNK = MSTK(K)*NSTK(K)
      IF (MSTK(TOP) .LT. 0) MN = MNK
      DO I = 1, MN
        LL = L+I-1
        LS = LK+I-1
        IF (MSTK(TOP) .GT. 0) LS = LK + IDINT(STKR(LL)) - 1
        IF (LS .LT. LK .OR. LS .GE. LK+MNK) CALL mat_err(21)
        IF (ERR .GT. 0) RETURN
        STKR(LL) = STKR(LS)
        STKI(LL) = STKI(LS)
      enddo
      MSTK(TOP) = 1
      NSTK(TOP) = 1
      IF (MSTK(K) .GT. 1) MSTK(TOP) = MN
      IF (MSTK(K) .EQ. 1) NSTK(TOP) = MN
      GOTO 99
!===================================================================================================================================
!     MATRIX(ARG,ARG)
   60 continue
      TOP = TOP-1
      L = LSTK(TOP)
      IF (MSTK(TOP+1) .EQ. 0) MSTK(TOP) = 0
      IF (MSTK(TOP) .EQ. 0) GOTO 99
      L2 = LSTK(TOP+1)
      M = MSTK(TOP)*NSTK(TOP)
      IF (MSTK(TOP) .LT. 0) M = MSTK(K)
      N = MSTK(TOP+1)*NSTK(TOP+1)
      IF (MSTK(TOP+1) .LT. 0) N = NSTK(K)
      L3 = L2 + N
      MK = MSTK(K)
      MNK = MSTK(K)*NSTK(K)
      DO J = 1, N
         DO I = 1, M
           LI = L+I-1
           IF (MSTK(TOP) .GT. 0) LI = L + IDINT(STKR(LI)) - 1
           LJ = L2+J-1
           IF (MSTK(TOP+1) .GT. 0) LJ = L2 + IDINT(STKR(LJ)) - 1
           LS = LK + LI-L + (LJ-L2)*MK
           IF (LS.LT.LK .OR. LS.GE.LK+MNK) CALL mat_err(21)
           IF (ERR .GT. 0) RETURN
           LL = L3 + I-1 + (J-1)*M
           STKR(LL) = STKR(LS)
           STKI(LL) = STKI(LS)
         enddo
      enddo
      MN = M*N
      CALL mat_wcopy(MN,STKR(L3),STKI(L3),1,STKR(L),STKI(L),1)
      MSTK(TOP) = M
      NSTK(TOP) = N
      GOTO 99
!===================================================================================================================================
   97 continue
      FIN = 7
      FUN = 6
      RETURN
!===================================================================================================================================
   98 continue
      FIN = 0
      RETURN
!===================================================================================================================================
   99 continue
      FIN = -1
      FUN = 0
!===================================================================================================================================
END SUBROUTINE mat_stackg
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_stack2(OP)

$@(#) M_matrix::ml_stackp(3fp): binary and ternary operations

INTEGER           :: OP
DOUBLEPRECISION   :: SR,SI,E1,ST,E2

integer,parameter :: plus=41
integer,parameter :: MINUS=42
integer,parameter :: STAR=43
integer,parameter :: DSTAR=54
integer,parameter :: SLASH=44
integer,parameter :: BSLASH=45
integer,parameter :: DOT=47
integer,parameter :: COLON=40

integer           ::  i
integer           ::  j
integer           ::  k
integer           ::  k1
integer           ::  k2
integer           ::  kexp
integer           ::  l
integer           ::  l1
integer           ::  l2
integer           ::  l3
integer           ::  ll
integer           ::  ls
integer           ::  m
integer           ::  m2
integer           ::  mn
integer           ::  n
integer           ::  n2
integer           ::  nexp

   IF (DDT .EQ. 1) call journal('sc',',STACK2 ',OP)
   L2 = LSTK(TOP)
   M2 = MSTK(TOP)
   N2 = NSTK(TOP)
   TOP = TOP-1
   L = LSTK(TOP)
   M = MSTK(TOP)
   N = NSTK(TOP)
   FUN = 0
   IF (OP .EQ. PLUS) GOTO 01
   IF (OP .EQ. MINUS) GOTO 03
   IF (OP .EQ. STAR) GOTO 05
   IF (OP .EQ. DSTAR) GOTO 30
   IF (OP .EQ. SLASH) GOTO 20
   IF (OP .EQ. BSLASH) GOTO 25
   IF (OP .EQ. COLON) GOTO 60
   IF (OP .GT. 2*DOT) GOTO 80
   IF (OP .GT. DOT) GOTO 70
!
!     ADDITION
01 IF (M .LT. 0) GOTO 50
   IF (M2 .LT. 0) GOTO 52
   IF (M .NE. M2) CALL mat_err(8)
   IF (ERR .GT. 0) RETURN
   IF (N .NE. N2) CALL mat_err(8)
   IF (ERR .GT. 0) RETURN
   CALL matX_waxpy(M*N,1.0D0,0.0D0,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
   GOTO 99
!
!     SUBTRACTION
03 IF (M .LT. 0) GOTO 54
   IF (M2 .LT. 0) GOTO 56
   IF (M .NE. M2) CALL mat_err(9)
   IF (ERR .GT. 0) RETURN
   IF (N .NE. N2) CALL mat_err(9)
   IF (ERR .GT. 0) RETURN
   CALL matX_waxpy(M*N,-1.0D0,0.0D0,STKR(L2),STKI(L2),1,STKR(L),STKI(L),1)
   GOTO 99
!
!     MULTIPLICATION
05 continue
   IF (M2*M2*N2 .EQ. 1) GOTO 10
   IF (M*N .EQ. 1) GOTO 11
   IF (M2*N2 .EQ. 1) GOTO 10
   IF (N .NE. M2) CALL mat_err(10)
   IF (ERR .GT. 0) RETURN
   MN = M*N2
   LL = L + MN
   ERR = LL+M*N+M2*N2 - LSTK(BOT)
   IF (ERR .GT. 0) CALL mat_err(17)
   IF (ERR .GT. 0) RETURN
   CALL mat_wcopy(M*N+M2*N2,STKR(L),STKI(L),-1,STKR(LL),STKI(LL),-1)
   DO J = 1, N2
      DO I = 1, M
         K1 = L + MN + (I-1)
         K2 = L2 + MN + (J-1)*M2
         K = L + (I-1) + (J-1)*M
         STKR(K) = mat_wdotur(N,STKR(K1),STKI(K1),M,STKR(K2),STKI(K2),1)
         STKI(K) = mat_wdotui(N,STKR(K1),STKI(K1),M,STKR(K2),STKI(K2),1)
      enddo
   enddo
   NSTK(TOP) = N2
   GOTO 99
!
!     MULTIPLICATION BY SCALAR
10 continue
   SR = STKR(L2)
   SI = STKI(L2)
   L1 = L
   GOTO 13
11 continue
   SR = STKR(L)
   SI = STKI(L)
   L1 = L+1
   MSTK(TOP) = M2
   NSTK(TOP) = N2
13 continue
   MN = MSTK(TOP)*NSTK(TOP)
   CALL mat_wscal(MN,SR,SI,STKR(L1),STKI(L1),1)
   IF (L1.NE.L) CALL mat_wcopy(MN,STKR(L1),STKI(L1),1,STKR(L),STKI(L),1)
   GOTO 99
!
!     RIGHT DIVISION
20 continue
   IF (M2*N2 .EQ. 1) GOTO 21
   IF (M2 .EQ. N2) FUN = 1
   IF (M2 .NE. N2) FUN = 4
   FIN = -1
   RHS = 2
   GOTO 99
21 continue
   SR = STKR(L2)
   SI = STKI(L2)
   MN = M*N
   DO I = 1, MN
      LL = L+I-1
      CALL mat_wdiv(STKR(LL),STKI(LL),SR,SI,STKR(LL),STKI(LL))
      IF (ERR .GT. 0) RETURN
   enddo
   GOTO 99
!
!     LEFT DIVISION
25 continue
   IF (M*N .EQ. 1) GOTO 26
   IF (M .EQ. N) FUN = 1
   IF (M .NE. N) FUN = 4
   FIN = -2
   RHS = 2
   GOTO 99
26 continue
   SR = STKR(L)
   SI = STKI(L)
   MSTK(TOP) = M2
   NSTK(TOP) = N2
   MN = M2*N2
   DO I = 1, MN
      LL = L+I-1
      CALL mat_wdiv(STKR(LL+1),STKI(LL+1),SR,SI,STKR(LL),STKI(LL))
      IF (ERR .GT. 0) RETURN
   enddo
   GOTO 99
!
!     POWER
30 continue
   IF (M2*N2 .NE. 1) CALL mat_err(30)
   IF (ERR .GT. 0) RETURN
   IF (M .NE. N) CALL mat_err(20)
   IF (ERR .GT. 0) RETURN
   NEXP = IDINT(STKR(L2))
   IF (STKR(L2) .NE. DFLOAT(NEXP)) GOTO 39
   IF (STKI(L2) .NE. 0.0D0) GOTO 39
   IF (NEXP .LT. 2) GOTO 39
   MN = M*N
   ERR = L2+MN+N - LSTK(BOT)
   IF (ERR .GT. 0) CALL mat_err(17)
   IF (ERR .GT. 0) RETURN
   CALL mat_wcopy(MN,STKR(L),STKI(L),1,STKR(L2),STKI(L2),1)
   L3 = L2+MN
   DO KEXP = 2, NEXP
      DO J = 1, N
         LS = L+(J-1)*N
         CALL mat_wcopy(N,STKR(LS),STKI(LS),1,STKR(L3),STKI(L3),1)
         DO I = 1, N
            LS = L2+I-1
            LL = L+I-1+(J-1)*N
            STKR(LL)=mat_wdotur(N,STKR(LS),STKI(LS),N,STKR(L3),STKI(L3),1)
            STKI(LL)=mat_wdotui(N,STKR(LS),STKI(LS),N,STKR(L3),STKI(L3),1)
         enddo
      enddo
   enddo
   GOTO 99
!
!     NONINTEGER OR NONPOSITIVE POWER, USE EIGENVECTORS
39 continue
   FUN = 2
   FIN = 0
   GOTO 99
!
!     ADD OR SUBTRACT SCALAR
50 continue
   IF (M2 .NE. N2) CALL mat_err(8)
   IF (ERR .GT. 0) RETURN
   M = M2
   N = N2
   MSTK(TOP) = M
   NSTK(TOP) = N
   SR = STKR(L)
   SI = STKI(L)
   CALL mat_wcopy(M*N,STKR(L+1),STKI(L+1),1,STKR(L),STKI(L),1)
   GOTO 58
52 continue
   IF (M .NE. N) CALL mat_err(8)
   IF (ERR .GT. 0) RETURN
   SR = STKR(L2)
   SI = STKI(L2)
   GOTO 58
54 continue
   IF (M2 .NE. N2) CALL mat_err(9)
   IF (ERR .GT. 0) RETURN
   M = M2
   N = N2
   MSTK(TOP) = M
   NSTK(TOP) = N
   SR = STKR(L)
   SI = STKI(L)
   CALL mat_wcopy(M*N,STKR(L+1),STKI(L+1),1,STKR(L),STKI(L),1)
   CALL mat_wrscal(M*N,-1.0D0,STKR(L),STKI(L),1)
   GOTO 58
56 continue
   IF (M .NE. N) CALL mat_err(9)
   IF (ERR .GT. 0) RETURN
   SR = -STKR(L2)
   SI = -STKI(L2)
   GOTO 58
58 continue
   DO I = 1, N
      LL = L + (I-1)*(N+1)
      STKR(LL) = mat_flop(STKR(LL)+SR)
      STKI(LL) = mat_flop(STKI(LL)+SI)
   enddo
   GOTO 99
!
!     COLON
60 continue
   E2 = STKR(L2)
   ST = 1.0D0
   N = 0
   IF (RHS .LT. 3) GOTO 61
   ST = STKR(L)
   TOP = TOP-1
   L = LSTK(TOP)
   IF (ST .EQ. 0.0D0) GOTO 63
61 continue
   E1 = STKR(L)
!     CHECK FOR CLAUSE
   IF (RSTK(PT) .EQ. 3) GOTO 64
   ERR = L + MAX0(3,IDINT((E2-E1)/ST)) - LSTK(BOT)
   IF (ERR .GT. 0) CALL mat_err(17)
   IF (ERR .GT. 0) RETURN
62 continue
   IF (ST .GT. 0.0D0 .AND. STKR(L) .GT. E2) GOTO 63
   IF (ST .LT. 0.0D0 .AND. STKR(L) .LT. E2) GOTO 63
   N = N+1
   L = L+1
   STKR(L) = E1 + DFLOAT(N)*ST
   STKI(L) = 0.0D0
   GOTO 62
63 continue
   NSTK(TOP) = N
   MSTK(TOP) = 1
   IF (N .EQ. 0) MSTK(TOP) = 0
   GOTO 99
!
!     FOR CLAUSE
64 continue
   STKR(L) = E1
   STKR(L+1) = ST
   STKR(L+2) = E2
   MSTK(TOP) = -3
   NSTK(TOP) = -1
   GOTO 99
!
!     ELEMENTWISE OPERATIONS
70 continue
   OP = OP - DOT
   IF (M.NE.M2 .OR. N.NE.N2) CALL mat_err(10)
   IF (ERR .GT. 0) RETURN
   MN = M*N
   DO I = 1, MN
      J = L+I-1
      K = L2+I-1
      IF (OP .EQ. STAR)CALL mat_wmul(STKR(J),STKI(J),STKR(K),STKI(K),STKR(J),STKI(J))
      IF (OP .EQ. SLASH)CALL mat_wdiv(STKR(J),STKI(J),STKR(K),STKI(K),STKR(J),STKI(J))
      IF (OP .EQ. BSLASH)CALL mat_wdiv(STKR(K),STKI(K),STKR(J),STKI(J),STKR(J),STKI(J))
      IF (ERR .GT. 0) RETURN
   enddo
   GOTO 99
!
!     KRONECKER
80 continue
   FIN = OP - 2*DOT - STAR + 11
   FUN = 6
   TOP = TOP + 1
   RHS = 2
   GOTO 99
!
99 continue
END SUBROUTINE mat_stack2
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getlin() ! get a new input line
use m_history,only : redo

character(len=1024) :: mline

integer,parameter   :: linelen=255
INTEGER,save        :: LRECL=linelen
integer,parameter   :: SLASH=44
integer,parameter   :: BSLASH=45
integer,parameter   :: DOT=47
integer,parameter   :: BLANK=36
integer,parameter   :: RETU(4)=[26,30,18,29]
integer             :: i
integer             :: j
integer             :: k
integer             :: l
integer             :: n
!.......................................................................
   10 CONTINUE
      L = LPT(1)
!.......................................................................
   11 CONTINUE
      DO J = 1, LRECL            ! blank out buffer before reading it
         BUF(J) = ALFA(BLANK+1)
      enddo
!.......................................................................
      N = LRECL+1
!     get line of input
      IF(ISTRINGQ.GT.0)THEN                  ! read from string instead of file
         CALL REDO(stringq,'.')              ! This is a no-op except for storing the line into the input history
         call mat_str2buf(stringq,buf,lrecl)     ! read input line from MAT88 call string
         call journal('c',stringq)           ! write as a comment
         IF(INITQ.EQ.2)THEN                  ! terminate after processing STRINGQ
            ISTRINGQ=4
            STRINGQ='quit'
         ELSE                                ! go to normal MAT88 mode after processing STRINGQ
            ISTRINGQ=0
         ENDIF
      ELSE
         mline(:)=' '

         READ(RIO,'(A)',END=50,ERR=15) mline ! read input line from file
         CALL REDO(mline,'.')  ! pass line to REDO(3f). This is a no-op except for storing the line into the input history
                               ! (unless the input line is the "r" command)

         if(RIO.eq.5)then
            call journal('t',mline)          ! reading from standard input, so copy to trail file
         else
            call journal('c',mline)          ! reading from an exec() command, so write as a comment
         endif
         if(mline(1:1).eq.'#')goto 11        ! ignore lines with a # in column 1
         call mat_str2buf(mline,buf,lrecl)       ! read input line from file
      ENDIF
!.......................................................................
   15 CONTINUE
      N = N-1
      IF(N.LT.1)THEN
         N=1
      else IF (BUF(N) .EQ. ALFA(BLANK+1))then
         GOTO 15 ! trim off trailing spaces
      endif
!.......................................................................
      IF (MOD(LCT(4),2) .EQ. 1) then
              call mat_buf2str(mline,buf,n) ! convert ADE buffer to character
              call journal('s',mline) ! just to standard output
      endif
!.......................................................................
      DO J = 1, N
         DO K = 1, alflq  ! make sure this letter is in set of MAT88 characters and get it's MAT88 number
           IF (BUF(J).EQ.ALFA(K) .OR. BUF(J).EQ.ALFB(K)) GOTO 30
         enddo
         call journal('sc','UNKNOWN CHARACTER AT COLUMN ',J) ! this is not a known character
         K = EOL+1
         IF (K .GT. EOL) GOTO 10   ! UNKNOWN CHARACTER , K NOT CHANGED. get new line
         IF (K .EQ. EOL) GOTO 45
         IF (K .EQ. -1) L = L-1
         IF (K .LE. 0) cycle
!
   30    CONTINUE
         K = K-1   ! K is index into ALF*, should be in range 0 to 51
         IF (K.EQ.SLASH .AND. BUF(J+1).EQ.BUF(J)) GOTO 45  ! if // rest is comment
         IF (K.EQ.DOT .AND. BUF(J+1).EQ.BUF(J)) GOTO 11    ! if .. line continuation
         IF (K.EQ.BSLASH .AND. N.EQ.1) GOTO 60             ! if \ in column 1
         LIN(L) = K
         IF (L.LT.1024) L = L+1
         IF (L.EQ.1024) call journal('sc','input buffer limit exceeded=',L)
      enddo
!.......................................................................
   45 CONTINUE      ! line is ready, reset line pointers
      LIN(L) = EOL
      LPT(6) = L
      LPT(4) = LPT(1)
      LPT(3) = 0
      LPT(2) = 0
      LCT(1) = 0
      CALL mat_getch() ! load first character onto CHRA
      RETURN
!.......................................................................
   50 CONTINUE ! hit end of file
      CALL mat_putid(LIN(L),RETU) ! store RETU onto LIN(L) to simulate RETURN command
      L = L + 4
      GOTO 45
!.......................................................................
   60 CONTINUE
      N = LPT(6) - LPT(1)
      DO I = 1, N
         J = L+I-1
         K = LIN(J)
         BUF(I) = ALFA(K+1)
         IF (CASE.EQ.1 .AND. K.LT.36) BUF(I) = ALFB(K+1)
      enddo    ! edit command history
      !!CALL ML_EDIT(BUF,N)
      !!N = N + 1
      GOTO 15
!.......................................................................
end subroutine mat_getlin
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_clause()
character(len=256) :: mline
DOUBLEPRECISION    :: E1,E2
INTEGER            :: OP
integer,parameter  :: NAME=1
integer            :: r
integer,parameter  :: SEMI=39
integer,parameter  :: EQUAL=46
integer,parameter  :: BLANK=36
integer,parameter  :: COMMA=48
integer,parameter  :: LESS=50
integer,parameter  :: GREAT=51
integer,parameter  :: FOR(4)=[15,24,27,36]
integer,parameter  :: WHILE(4)=[32,17,18,21]
integer,parameter  :: IFF(4)=[18,15,36,36]
integer,parameter  :: ELSE(4)=[14,21,28,14]
integer,parameter  :: ENND(4)=[14,23,13,36]
integer,parameter  :: DO(4)=[13,24,36,36]
integer,parameter  :: THENN(4)=[29,17,14,23]
integer            :: i
integer            :: j
integer            :: kount
integer            :: l
integer            :: l2
integer            :: lj
integer            :: m
integer            :: n

   R = -FIN-10
   FIN = 0
   IF (DDT .EQ. 1)then
      WRITE(mline,'('' CLAUSE '',3I4)') PT,RSTK(PT),R
      call journal(mline)
   endif
   IF (R.LT.1 .OR. R.GT.6) GOTO 01
   GOTO (02,30,30,80,99,90),R
01 continue
   R = RSTK(PT)
   GOTO (99,99,05,40,45,99,99,99,99,99,99,99,15,55,99,99,99),R
   call journal('*mat_clause* -- internal error')
   goto 99
!.......................................................................
!     FOR
!
02 continue
   CALL mat_getsym()
   IF (SYM .NE. NAME) CALL mat_err(34) ! improper for clause
   IF (ERR .GT. 0) RETURN
   PT = PT+2
   CALL mat_putid(IDS(1,PT),SYN)
   CALL mat_getsym()
   IF (SYM .NE. EQUAL) CALL mat_err(34) ! improper for clause
   IF (ERR .GT. 0) RETURN
   CALL mat_getsym()
   RSTK(PT) = 3
!     *CALL* EXPR
   RETURN
05 continue
   PSTK(PT-1) = 0
   PSTK(PT) = LPT(4) - 1
   IF (mat_eqid(SYN,DO)) SYM = SEMI
   IF (SYM .EQ. COMMA) SYM = SEMI
   IF (SYM .NE. SEMI) CALL mat_err(34) ! improper for clause
   IF (ERR .GT. 0) RETURN
10 continue
   J = PSTK(PT-1)
   LPT(4) = PSTK(PT)
   SYM = SEMI
   CHRA = BLANK
   J = J+1
   L = LSTK(TOP)
   M = MSTK(TOP)
   N = NSTK(TOP)
   LJ = L+(J-1)*M
   L2 = L + M*N
   IF (M .NE. -3) GOTO 12
   LJ = L+3
   L2 = LJ
   STKR(LJ) = STKR(L) + DFLOAT(J-1)*STKR(L+1)
   STKI(LJ) = 0.0d0
   IF (STKR(L+1).GT.0.0D0 .AND. STKR(LJ).GT.STKR(L+2)) GOTO 20
   IF (STKR(L+1).LT.0.0D0 .AND. STKR(LJ).LT.STKR(L+2)) GOTO 20
   M = 1
   N = J
12 continue
   IF (J .GT. N) GOTO 20
   IF (TOP+1 .GE. BOT) CALL mat_err(18) ! too many names
   IF (ERR .GT. 0) RETURN
   TOP = TOP+1
   LSTK(TOP) = L2
   MSTK(TOP) = M
   NSTK(TOP) = 1
   ERR = L2+M - LSTK(BOT)
   IF (ERR .GT. 0) CALL mat_err(17)   ! too much memory required
   IF (ERR .GT. 0) RETURN
   CALL mat_wcopy(M,STKR(LJ),STKI(LJ),1,STKR(L2),STKI(L2),1)
   RHS = 0
   CALL mat_stackp(IDS(1,PT))
   IF (ERR .GT. 0) RETURN
   PSTK(PT-1) = J
   PSTK(PT) = LPT(4)
   RSTK(PT) = 13
!     *CALL* PARSE
   RETURN
15 continue
   GOTO 10
20 continue
   MSTK(TOP) = 0
   NSTK(TOP) = 0
   RHS = 0
   CALL mat_stackp(IDS(1,PT))
   IF (ERR .GT. 0) RETURN
   PT = PT-2
   GOTO 80
!.......................................................................
!
!     WHILE OR IF
!
30 continue
   PT = PT+1
   CALL mat_putid(IDS(1,PT),SYN)
   PSTK(PT) = LPT(4)-1
35 continue
   LPT(4) = PSTK(PT)
   CHRA = BLANK
   CALL mat_getsym()
   RSTK(PT) = 4
!     *CALL* EXPR
   RETURN
40 continue
   IF (SYM.NE.EQUAL .AND. SYM.NE.LESS .AND. SYM.NE.GREAT)CALL mat_err(35)    ! improper WHILE or IF clause
   IF (ERR .GT. 0) RETURN
   OP = SYM
   CALL mat_getsym()
   IF (SYM.EQ.EQUAL .OR. SYM.EQ.GREAT) OP = OP + SYM
   IF (OP .GT. GREAT) CALL mat_getsym()
   PSTK(PT) = 256*PSTK(PT) + OP
   RSTK(PT) = 5
!     *CALL* EXPR
   RETURN
45 continue
   OP = MOD(PSTK(PT),256)
   PSTK(PT) = PSTK(PT)/256
   L = LSTK(TOP-1)
   E1 = STKR(L)
   L = LSTK(TOP)
   E2 = STKR(L)
   TOP = TOP - 2
   IF (mat_eqid(SYN,DO) .OR. mat_eqid(SYN,THENN)) SYM = SEMI
   IF (SYM .EQ. COMMA) SYM = SEMI
   IF (SYM .NE. SEMI) CALL mat_err(35) ! improper WHILE or IF clause
   IF (ERR .GT. 0) RETURN
   IF (OP.EQ.EQUAL         .AND. E1.EQ.E2) GOTO 50
   IF (OP.EQ.LESS          .AND. E1.LT.E2) GOTO 50
   IF (OP.EQ.GREAT         .AND. E1.GT.E2) GOTO 50
   IF (OP.EQ.(LESS+EQUAL)  .AND. E1.LE.E2) GOTO 50
   IF (OP.EQ.(GREAT+EQUAL) .AND. E1.GE.E2) GOTO 50
   IF (OP.EQ.(LESS+GREAT)  .AND. E1.NE.E2) GOTO 50
   PT = PT-1
   GOTO 80
50 continue
   RSTK(PT) = 14
!     *CALL* PARSE
   RETURN
55 continue
   IF (mat_eqid(IDS(1,PT),WHILE)) GOTO 35
   PT = PT-1
   IF (mat_eqid(SYN,ELSE)) GOTO 80
   RETURN
!.......................................................................
!
!     SEARCH FOR MATCHING END OR ELSE
80 continue
   KOUNT = 0
   CALL mat_getsym()
82 continue
   IF (SYM .EQ. EOL) RETURN
   IF (SYM .NE. NAME) GOTO 83
   IF (mat_eqid(SYN,ENND) .AND. KOUNT.EQ.0) RETURN
   IF (mat_eqid(SYN,ELSE) .AND. KOUNT.EQ.0) RETURN
   IF (mat_eqid(SYN,ENND) .OR. mat_eqid(SYN,ELSE))KOUNT = KOUNT-1
   IF (mat_eqid(SYN,FOR) .OR. mat_eqid(SYN,WHILE).OR.mat_eqid(SYN,IFF)) KOUNT = KOUNT+1
83 continue
   CALL mat_getsym()
   GOTO 82
!.......................................................................
!
!     EXIT FROM LOOP
90 continue
   IF (DDT .EQ. 1)then
      WRITE(mline,'('' EXIT '',10I4)') (RSTK(I),I=1,PT)
      call journal(mline)
   endif
   IF (RSTK(PT) .EQ. 14) PT = PT-1
   IF (PT .LE. PTZ) RETURN
   IF (RSTK(PT) .EQ. 14) PT = PT-1
   IF (PT-1 .LE. PTZ) RETURN
   IF (RSTK(PT) .EQ. 13) TOP = TOP-1
   IF (RSTK(PT) .EQ. 13) PT = PT-2
   GOTO 80
!.......................................................................
!
99 continue
   CALL mat_err(22)    ! recursion difficulties
   IF (ERR .GT. 0) RETURN
END SUBROUTINE mat_clause
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rat(x,len,maxd,a,b,d)

$@(#) M_matrix::mat_rat(3fp): A/B = continued fraction approximation to X using  len  terms each less than MAXD

integer         :: len,maxd
doubleprecision :: x,a,b,d(len)
doubleprecision :: s,t,z
integer         :: i
integer         :: ib
integer         :: k
   z = x
   k=0  ! preset to illegal value
   if(len.lt.1)then
      call journal('*mat_rat* internal error -- len<1')
      return
   endif
   do i = 1, len
      k = i
      d(k) = mat_round(z)
      z = z - d(k)
      if (dabs(z)*dfloat(maxd) .le. 1.0d0) exit
      z = 1.0d0/z
   enddo
   t = d(k)
   s = 1.0d0
   if (k .ge. 2) then
      do ib = 2, k
         i = k+1-ib
         z = t
         t = d(i)*t + s
         s = z
      enddo
   endif
   if (s .lt. 0.0d0) t = -t
   if (s .lt. 0.0d0) s = -s
   if (ddt .eq. 27)then
      write(wte,50) x,t,s,(d(i),i=1,k) ! debug 27
50    format(/1x,1pd23.15,0pf8.0,' /',f8.0,4x,6f5.0/(1x,45x,6f5.0))
   endif
   a = t
   b = s
end subroutine mat_rat
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_expr()
character(len=80) :: mline
integer           :: r
integer           :: sign
integer,parameter :: COLON=40
integer,parameter :: BLANK=36
integer,parameter :: PLUS=41
integer,parameter :: MINUS=42
integer,parameter :: NAME=1
integer,parameter :: EYE(4)=[14,34,14,36]
integer           :: kount
integer           :: ls
integer           :: op

   if (ddt .eq. 1) then
      write(mline,'('' EXPR '',2I4)') pt,rstk(pt)
      call journal(mline)
   endif
   r = rstk(pt)
!===================================================================================================================================
   GOTO (01,01,01,01,01,05,25,99,99,01,01,99,99,99,99,99,99,01,01,01),R
!===================================================================================================================================
01 continue
   if (sym .eq. colon) call mat_putid(syn,eye)
   if (sym .eq. colon) sym = name
   kount = 1
02 continue
   sign = plus
   if (sym .eq. minus) sign = minus
   if (sym.eq.plus .or. sym.eq.minus) call mat_getsym()
   pt = pt+1
   if (pt .gt. psize-1) call mat_err(26) ! too complicated (stack overflow)
   if (err .gt. 0) return
   pstk(pt) = sign + 256*kount
   rstk(pt) = 6
!     *call* term
   return
05 continue
   sign = mod(pstk(pt),256)
   kount = pstk(pt)/256
   pt = pt-1
   if (sign .eq. minus) call mat_stack1(minus)
   if (err .gt. 0) return
10 continue
   if (sym.eq.plus .or. sym.eq.minus) goto 20
   goto 50
20 continue
   if (rstk(pt) .ne. 10) goto 21
!     blank is delimiter inside angle brackets
   ls = lpt(3) - 2
   if (lin(ls) .eq. blank) goto 50
21 continue
   op = sym
   call mat_getsym()
   pt = pt+1
   pstk(pt) = op + 256*kount
   rstk(pt) = 7
!     *call* term
   return
25 continue
   op = mod(pstk(pt),256)
   kount = pstk(pt)/256
   pt = pt-1
   call mat_stack2(op)
   if (err .gt. 0) return
   goto 10
50 continue
   if (sym .ne. colon) goto 60
   call mat_getsym()
   kount = kount+1
   goto 02
60 continue
   if (kount .gt. 3) call mat_err(33)  ! too many colons
   if (err .gt. 0) return
   rhs = kount
   if (kount .gt. 1) call mat_stack2(colon)
   if (err .gt. 0) return
   return
99 continue
   call mat_err(22)     ! recursion difficulties
   if (err .gt. 0) return
end subroutine mat_expr
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_factor()
character(len=80) :: mline
INTEGER           :: R
INTEGER           :: ID(4)
INTEGER           :: EXCNT
integer,parameter :: DSTAR=54
integer,parameter :: SEMI=39
integer,parameter :: BLANK=36
integer,parameter :: STAR=43
integer,parameter :: COMMA=48
integer,parameter :: LPAREN=37
integer,parameter :: RPAREN=38
integer,parameter :: LESS=50
integer,parameter :: GREAT=51
integer,parameter :: QUOTE=49
integer,parameter :: NUM=0
integer,parameter :: NAME=1
integer           :: i
integer           :: j
integer           :: k
integer           :: l
integer           :: ln
integer           :: ls
integer           :: n

   IF (DDT .EQ. 1) then
      WRITE(mline,'('' FACTOR '',3I4)') PT,RSTK(PT),SYM
      call journal(mline)
   endif
   R = RSTK(PT)
   GOTO (99,99,99,99,99,99,99,01,01,25,45,65,99,99,99,55,75,32,37),R
01 CONTINUE
   IF (SYM.EQ.NUM .OR. SYM.EQ.QUOTE .OR.  SYM.EQ.LESS) GOTO 10
   IF (SYM .EQ. GREAT) GOTO 30
   EXCNT = 0
   IF (SYM .EQ. NAME) GOTO 40
   ID(1) = BLANK
   IF (SYM .EQ. LPAREN) GOTO 42
   CALL mat_err(2)
   IF (ERR .GT. 0) RETURN
!
!     PUT SOMETHING ON THE STACK
10 CONTINUE
   L = 1
   IF (TOP .GT. 0) L = LSTK(TOP) + MSTK(TOP)*NSTK(TOP)
   IF (TOP+1 .GE. BOT) CALL mat_err(18)
   IF (ERR .GT. 0) RETURN
   TOP = TOP+1
   LSTK(TOP) = L
   IF (SYM .EQ. QUOTE) GOTO 15
   IF (SYM .EQ. LESS) GOTO 20
!
!     SINGLE NUMBER, GETSYM STORED IT IN STKI
   MSTK(TOP) = 1
   NSTK(TOP) = 1
   STKR(L) = STKI(VSIZE)
   STKI(L) = 0.0D0
   CALL mat_getsym()
   GOTO 60
!
!     STRING
15 CONTINUE
   N = 0
   LPT(4) = LPT(3)
   CALL mat_getch()  ! get next character
16 CONTINUE
   IF (CHRA .EQ. QUOTE) GOTO 18
17 CONTINUE
   LN = L+N
   IF (CHRA .EQ. EOL) CALL mat_err(31)
   IF (ERR .GT. 0) RETURN
   STKR(LN) = DFLOAT(CHRA)
   STKI(LN) = 0.0D0
   N = N+1
   CALL mat_getch()  ! get next character
   GOTO 16
18 CONTINUE
   CALL mat_getch()  ! get next character
   IF (CHRA .EQ. QUOTE) GOTO 17
   IF (N .LE. 0) CALL mat_err(31)
   IF (ERR .GT. 0) RETURN
   MSTK(TOP) = 1
   NSTK(TOP) = N
   CALL mat_getsym()
   GOTO 60
!
!     EXPLICIT MATRIX
20 CONTINUE
   MSTK(TOP) = 0
   NSTK(TOP) = 0
21 CONTINUE
   TOP = TOP + 1
   LSTK(TOP) = LSTK(TOP-1) + MSTK(TOP-1)*NSTK(TOP-1)
   MSTK(TOP) = 0
   NSTK(TOP) = 0
   CALL mat_getsym()
22 CONTINUE
   IF (SYM.EQ.SEMI .OR. SYM.EQ.GREAT .OR. SYM.EQ.EOL) GOTO 27
   IF (SYM .EQ. COMMA) CALL mat_getsym()
   PT = PT+1
   RSTK(PT) = 10
!     *CALL* EXPR
   RETURN
25 CONTINUE
   PT = PT-1
   TOP = TOP - 1
   IF (MSTK(TOP) .EQ. 0) MSTK(TOP) = MSTK(TOP+1)
   IF (MSTK(TOP) .NE. MSTK(TOP+1)) CALL mat_err(5)
   IF (ERR .GT. 0) RETURN
   NSTK(TOP) = NSTK(TOP) + NSTK(TOP+1)
   GOTO 22
27 CONTINUE
   IF (SYM.EQ.SEMI .AND. CHRA.EQ.EOL) CALL mat_getsym()
   CALL mat_stack1(QUOTE)
   IF (ERR .GT. 0) RETURN
   TOP = TOP - 1
   IF (MSTK(TOP) .EQ. 0) MSTK(TOP) = MSTK(TOP+1)
   IF (MSTK(TOP).NE.MSTK(TOP+1).AND.MSTK(TOP+1).GT.0)CALL mat_err(6)
   IF (ERR .GT. 0) RETURN
   NSTK(TOP) = NSTK(TOP) + NSTK(TOP+1)
   IF (SYM .EQ. EOL) CALL mat_getlin()
   IF (SYM .NE. GREAT) GOTO 21
   CALL mat_stack1(QUOTE)
   IF (ERR .GT. 0) RETURN
   CALL mat_getsym()
   GOTO 60
!
!     MACRO STRING
30 CONTINUE
   CALL mat_getsym()
   IF (SYM.EQ.LESS .AND. CHRA.EQ.EOL) CALL mat_err(28)
   IF (ERR .GT. 0) RETURN
   PT = PT+1
   RSTK(PT) = 18
!     *CALL* EXPR
   RETURN
32 CONTINUE
   PT = PT-1
   IF (SYM.NE.LESS .AND. SYM.NE.EOL) CALL mat_err(37)
   IF (ERR .GT. 0) RETURN
   IF (SYM .EQ. LESS) CALL mat_getsym()
   K = LPT(6)
   LIN(K+1) = LPT(1)
   LIN(K+2) = LPT(2)
   LIN(K+3) = LPT(6)
   LPT(1) = K + 4
!     TRANSFER STACK TO INPUT LINE
   K = LPT(1)
   L = LSTK(TOP)
   N = MSTK(TOP)*NSTK(TOP)
   DO J = 1, N
      LS = L + J-1
      LIN(K) = IDINT(STKR(LS))
      IF (LIN(K).LT.0 .OR. LIN(K).GE.IALF) CALL mat_err(37)
      IF (ERR .GT. 0) RETURN
      IF (K.LT.1024) K = K+1
      IF (K.EQ.1024)call journal('sc','INPUT BUFFER CHAR LIMIT EXCEEDED=',K)
   enddo
   TOP = TOP-1
   LIN(K) = EOL
   LPT(6) = K
   LPT(4) = LPT(1)
   LPT(3) = 0
   LPT(2) = 0
   LCT(1) = 0
   CHRA = BLANK
   CALL mat_getsym()
   PT = PT+1
   RSTK(PT) = 19
!     *CALL* EXPR
   RETURN
37 CONTINUE
   PT = PT-1
   K = LPT(1) - 4
   LPT(1) = LIN(K+1)
   LPT(4) = LIN(K+2)
   LPT(6) = LIN(K+3)
   CHRA = BLANK
   CALL mat_getsym()
   GOTO 60
!
!     FUNCTION OR MATRIX ELEMENT
40 CONTINUE
   CALL mat_putid(ID,SYN)
   CALL mat_getsym()
   IF (SYM .EQ. LPAREN) GOTO 42
   RHS = 0
   CALL mat_funs(ID)
   IF (FIN .NE. 0) CALL mat_err(25)
   IF (ERR .GT. 0) RETURN
   CALL mat_stackg(ID)
   IF (ERR .GT. 0) RETURN
   IF (FIN .EQ. 7) GOTO 50
   IF (FIN .EQ. 0) CALL mat_putid(IDS(1,PT+1),ID)
   IF (FIN .EQ. 0) CALL mat_err(4)
   IF (ERR .GT. 0) RETURN
   GOTO 60
!
42 CONTINUE
   CALL mat_getsym()
   EXCNT = EXCNT+1
   PT = PT+1
   PSTK(PT) = EXCNT
   CALL mat_putid(IDS(1,PT),ID)
   RSTK(PT) = 11
!     *CALL* EXPR
   RETURN
!.......................................................................
45 CONTINUE
   CALL mat_putid(ID,IDS(1,PT))
   EXCNT = PSTK(PT)
   PT = PT-1
   IF (SYM .EQ. COMMA) GOTO 42
   IF (SYM .NE. RPAREN) CALL mat_err(3)
   IF (ERR .GT. 0) RETURN
   IF (SYM .EQ. RPAREN) CALL mat_getsym()
   IF (ID(1) .EQ. BLANK) GOTO 60
   RHS = EXCNT
   CALL mat_stackg(ID)
   IF (ERR .GT. 0) RETURN
   IF (FIN .EQ. 0) CALL mat_funs(ID)
   IF (FIN .EQ. 0) CALL mat_err(4)
   IF (ERR .GT. 0) RETURN
!
!     EVALUATE MATRIX FUNCTION
50 CONTINUE
   PT = PT+1
   RSTK(PT) = 16
!     *CALL* MATFN
   RETURN
55 CONTINUE
   PT = PT-1
   GOTO 60
!
!     CHECK FOR QUOTE (TRANSPOSE) AND ** (POWER)
60 CONTINUE
   IF (SYM .NE. QUOTE) GOTO 62
   I = LPT(3) - 2
   IF (LIN(I) .EQ. BLANK) GOTO 90
   CALL mat_stack1(QUOTE)
   IF (ERR .GT. 0) RETURN
   CALL mat_getsym()
62 CONTINUE
   IF (SYM.NE.STAR .OR. CHRA.NE.STAR) GOTO 90
   CALL mat_getsym()
   CALL mat_getsym()
   PT = PT+1
   RSTK(PT) = 12
!     *CALL* FACTOR
   GOTO 01
65 CONTINUE
   PT = PT-1
   CALL mat_stack2(DSTAR)
   IF (ERR .GT. 0) RETURN
   IF (FUN .NE. 2) GOTO 90
!     MATRIX POWER, USE EIGENVECTORS
   PT = PT+1
   RSTK(PT) = 17
!     *CALL* MATFN
   RETURN
75 CONTINUE
   PT = PT-1
90 CONTINUE
   RETURN
99 CONTINUE
   CALL mat_err(22)
   IF (ERR .GT. 0) RETURN
END SUBROUTINE mat_factor
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_term()

character(len=256) ::  mline
INTEGER            :: R
INTEGER            :: OP
integer,parameter  :: BSLASH=45
integer,parameter  :: STAR=43
integer,parameter  :: SLASH=44
integer,parameter  :: DOT=47
integer            :: ierr
integer            :: ilen

   IF (DDT .EQ. 1) then
      mline='TERM '
      call mat_appnum(real(pt),mline,ilen,ierr)
      call mat_appnum(real(rstk(pt)),mline,ilen,ierr)
      call journal(mline)
   endif
   R = RSTK(PT)
   GOTO (99,99,99,99,99, 1, 1, 5,25,99,99,99,99,99,35,99,99,99,99),R
1  continue
   PT = PT+1
   RSTK(PT) = 8
!     *CALL* FACTOR
   RETURN
!.......................................................................
5  CONTINUE
   PT = PT-1
10 CONTINUE
   OP = 0
   IF (SYM .EQ. DOT) OP = DOT
   IF (SYM .EQ. DOT) CALL mat_getsym
   IF (SYM.EQ.STAR .OR. SYM.EQ.SLASH .OR. SYM.EQ.BSLASH) GOTO 20
   RETURN
!.......................................................................
20 CONTINUE
   OP = OP + SYM
   CALL mat_getsym()
   IF (SYM .EQ. DOT) OP = OP + SYM
   IF (SYM .EQ. DOT) CALL mat_getsym()
   PT = PT+1
   PSTK(PT) = OP
   RSTK(PT) = 9
!     *CALL* FACTOR
   RETURN
!.......................................................................
25 CONTINUE
   OP = PSTK(PT)
   PT = PT-1
   CALL mat_stack2(OP)
   IF (ERR .GT. 0) RETURN
!     SOME BINARY OPS DONE IN MATFNS
   IF (FUN .EQ. 0) GOTO 10
   PT = PT+1
   RSTK(PT) = 15
!     *CALL* MATFN
   RETURN
!.......................................................................
35 CONTINUE
   PT = PT-1
   GOTO 10
!.......................................................................
99 CONTINUE
   CALL mat_err(22)
   IF (ERR .GT. 0) RETURN
!.......................................................................
END SUBROUTINE mat_term
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_savlod(LSAVE,ID,M,N,IMG,JOB,XREAL,XIMAG)

integer                      :: lsave
integer                      :: id(4)
integer                      :: m
integer                      :: n
integer                      :: img
integer                      :: job
doubleprecision              :: xreal(*)
doubleprecision              :: ximag(*)
character(len=4)             :: cid
integer                      :: i,j,k,l

$@(#) M_matrix::mat_savlod(3fp): read next variable from a "save" file or write next variable to it

      ! should report I/O errors (disk full, unwritable, ....)
!
!     IMPLEMENT SAVE AND LOAD
!     LSAVE = LOGICAL UNIT NUMBER
!     ID = NAME, FORMAT 4A1
!     M, N = DIMENSIONS
!     IMG = NONZERO IF XIMAG IS NONZERO
!           RETURNED ON A LOAD
!     JOB = 0     FOR SAVE
!         = SPACE AVAILABLE FOR LOAD
!     XREAL, XIMAG = REAL AND OPTIONAL IMAGINARY PARTS
!.......................................................................
      IF (JOB .LE. 0) THEN   ! save
         call mat_buf2str(cid,id,4) ! convert ID to a character string
         WRITE(LSAVE,101) CID,M,N,IMG
         DO J = 1, N
            K = (J-1)*M+1
            L = J*M
            WRITE(LSAVE,102) (XREAL(I),I=K,L)                 ! real
            IF (IMG .NE. 0) WRITE(LSAVE,102) (XIMAG(I),I=K,L) ! imaginary
         enddo
!.......................................................................
      ELSE                   ! load
         READ(LSAVE,101,END=30) cid,M,N,IMG
         call mat_str2buf(cid,id,4) ! convert character string to and ID
         IF (M*N .GT. JOB) GOTO 30
         DO J = 1, N
            K = (J-1)*M+1
            L = J*M
            READ(LSAVE,102,END=30) (XREAL(I),I=K,L)   ! real
            IF (IMG .NE. 0) READ(LSAVE,102,END=30) (XIMAG(I),I=K,L) !imaginary
         enddo
      ENDIF
!.......................................................................
      RETURN
!.......................................................................
!     END OF FILE
   30 CONTINUE
      M = 0
      N = 0
!.......................................................................
!     SYSTEM DEPENDENT FORMATS
  101 FORMAT(A4,3I4)  ! ID, MxN dimensions of ID, IMAGINARY OR REAL FLAG
  102 FORMAT(4Z18)    ! format for data
      END SUBROUTINE mat_savlod
!==================================================================================================================================!
! INSERT HERE JSU
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT ! -file mat_urand.3.man
NAME
   mat_urand(3f) - [] uniform random number generator

SYNOPSIS
  doubleprecision function mat_urand(iy)

   integer :: iy

DESCRIPTION
   mat_urand(3f) is a uniform random number generator based on theory and
   suggestions given in D.E. Knuth (1969), Vol 2. The integer IY should
   be initialized to an arbitrary integer prior to the first call to
   mat_urand(3f). The calling program should not alter the value of IY
   between subsequent calls to mat_urand(3f). Values of mat_urand(3f) will
   be returned in the interval (0,1).

OPTIONS

   IY seed for generating a sequence.

EXAMPLE
$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
doubleprecision function mat_urand(iy)
integer              :: iy
integer,save         :: ia
integer,save         :: ic
integer,save         :: itwo=2
integer,save         :: m2=0
integer              :: m
integer,save         :: mic
doubleprecision      :: halfm
doubleprecision,save :: s
doubleprecision      :: datan
doubleprecision      :: dsqrt
!-----------------------------------------------------------------------
   if (m2 .eq. 0) then                                  !  IF FIRST ENTRY, COMPUTE MACHINE INTEGER WORD LENGTH
      m = 1
      INFINITE : do
         m2 = m
         m = itwo*m2
         if (m .le. m2) exit INFINITE
      enddo INFINITE
      halfm = m2
      ia = 8*idint(halfm*datan(1.d0)/8.d0) + 5          !  COMPUTE MULTIPLIER AND INCREMENT FOR LINEAR CONGRUENTIAL METHOD
      ic = 2*idint(halfm*(0.5d0-dsqrt(3.d0)/6.d0)) + 1
      mic = (m2 - ic) + m2
      s = 0.5d0/halfm                                   !  S IS THE SCALE FACTOR FOR CONVERTING TO FLOATING POINT
   endif
!  COMPUTE NEXT RANDOM NUMBER
   iy = iy*ia
!  THE FOLLOWING STATEMENT IS FOR COMPUTERS WHICH DO NOT ALLOW INTEGER OVERFLOW ON ADDITION
   if (iy .gt. mic) iy = (iy - m2) - m2
   iy = iy + ic
!  THE FOLLOWING STATEMENT IS FOR COMPUTERS WHERE THE WORD LENGTH FOR ADDITION IS GREATER THAN FOR MULTIPLICATION
   if (iy/2 .gt. m2) iy = (iy - m2) - m2
!  THE FOLLOWING STATEMENT IS FOR COMPUTERS WHERE INTEGER OVERFLOW AFFECTS THE SIGN BIT
   if (iy .lt. 0) iy = (iy + m2) + m2
   mat_urand = dfloat(iy)*s
end function mat_urand
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wnrm2(n,xr,xi,incx)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: s
integer         :: ix
integer         :: i
   !     norm2(x)
   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      do i = 1, n
         s = mat_pythag(s,xr(ix))
         s = mat_pythag(s,xi(ix))
         ix = ix + incx
      enddo
   endif
   mat_wnrm2 = s
   end function mat_wnrm2
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wasum(n,xr,xi,incx)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: s
integer         :: ix
integer         :: i

   !     norm1(x)
   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      do i = 1, n
         s = mat_flop(s + dabs(xr(ix)) + dabs(xi(ix)))
         ix = ix + incx
      enddo
   endif
   mat_wasum = s
end function mat_wasum
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotui(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy
doubleprecision :: s
integer         :: ix
integer         :: iy
integer         :: i
   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         s = s + xr(ix)*yi(iy) + xi(ix)*yr(iy)
         if (s .ne. 0.0d0) s = mat_flop(s)
         ix = ix + incx
         iy = iy + incy
      enddo
   endif
   mat_wdotui = s
end function mat_wdotui
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotcr(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

doubleprecision :: s
integer         :: ix
integer         :: iy
integer         :: i

   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         s = mat_flop(s + xr(ix)*yr(iy) + xi(ix)*yi(iy))
         ix = ix + incx
         iy = iy + incy
      enddo
   endif
   mat_wdotcr = s
end function mat_wdotcr
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotci(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

integer         :: ix
integer         :: iy
integer         :: i
doubleprecision :: s

   s = 0.0d0

   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1

      do i = 1, n
         s = s + xr(ix)*yi(iy) - xi(ix)*yr(iy)
         if (s .ne. 0.0d0) s = mat_flop(s)
         ix = ix + incx
         iy = iy + incy
      enddo

   endif

   mat_wdotci = s
end function mat_wdotci
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
integer function mat_iwamax(n,xr,xi,incx)

$@(#) M_matrix::mat_iwamax(3fp):index of norminf(x)

integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: s
doubleprecision :: p
integer         :: i, k
integer         :: ix

   k = 0
   if (n .gt. 0) then
      k = 1
      s = 0.0d0
      ix = 1
      do i = 1, n
         p = dabs(xr(ix)) + dabs(xi(ix))
         if (p .gt. s) k = i
         if (p .gt. s) s = p
         ix = ix + incx
      enddo
   endif
   mat_iwamax = k
end function mat_iwamax
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
$BLOCK COMMENT ! -file mat_flop.3m_matrix.man
NAME
   mat_flop(3fp) - [M_matrix] count and possibly chop each floating point operation
SYNOPSIS
DESCRIPTION
   Count and possibly chop each floating point operation.

   SYSTEM DEPENDENT FUNCTION
OPTIONS

NOTES
   FLP(1)  IS FLOP COUNTER
   FLP(2)  IS NUMBER OF PLACES TO BE CHOPPED

$BLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
doubleprecision function mat_flop(x)
doubleprecision,intent(in) :: x
doubleprecision            :: mask(14),xx,mm
integer                    :: k
logical                    :: lx(2),lm(2)
equivalence (lx(1),xx),(lm(1),mm)
equivalence (mask(1),mas(1,1))
real,save                  :: mas(2,14)=reshape([ &
   & transfer(Z'ffffffff',0.0),transfer(Z'fff0ffff',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'ff00ffff',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'f000ffff',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'0000ffff',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'0000fff0',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'0000ff00',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'0000f000',0.0),     &
   & transfer(Z'ffffffff',0.0),transfer(Z'00000000',0.0),     &
   & transfer(Z'fff0ffff',0.0),transfer(Z'00000000',0.0),     &
   & transfer(Z'ff00ffff',0.0),transfer(Z'00000000',0.0),     &
   & transfer(Z'f000ffff',0.0),transfer(Z'00000000',0.0),     &
   & transfer(Z'0000ffff',0.0),transfer(Z'00000000',0.0),     &
   & transfer(Z'0000fff0',0.0),transfer(Z'00000000',0.0),     &
   & transfer(Z'0000ff80',0.0),transfer(Z'00000000',0.0)],shape(mas))

   flp(1) = flp(1) + 1
   k = flp(2)

   select case(k)
   case(:0)
      mat_flop = x
   case(1:15)
      mat_flop = 0.0d0
   case default
      xx = x
      mm = mask(k)
      lx(1) = lx(1) .and. lm(1)
      lx(2) = lx(2) .and. lm(2)
      mat_flop = xx
   end select

end function mat_flop
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
logical function mat_eqid(x,y)

!     check for equality of two names

integer,intent(in) :: x(4)
integer,intent(in) :: y(4)

integer            :: i

   mat_eqid = .true.

   do i = 1, 4
      mat_eqid = mat_eqid .and. (x(i).eq.y(i))
   enddo

end function mat_eqid
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_round(x)
doubleprecision      :: x,y,z,e
doubleprecision,save :: h=1.0d9
      z = dabs(x)
      y = z + 1.0d0
      if (y .eq. z) goto 40
      y = 0.0d0
      e = h
   10 continue
      if (e .ge. z) goto 20
         e = 2.0d0*e
         goto 10
   20 continue
      if (e .le. h) goto 30
         if (e .le. z) y = y + e
         if (e .le. z) z = z - e
         e = e/2.0d0
         goto 20
   30 continue
      z = idint(z + 0.5d0)
      y = y + z
      if (x .lt. 0.0d0) y = -y
      mat_round = y
      return
   40 continue
      mat_round = x
end function mat_round
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_make_help(io)
integer,intent(in) :: io
$BLOCK WRITE
INTRO Welcome to MAT88.

       #-------------------#--------------------------------------------#
       | HELP Sections     | Available Topics                           |
       #-------------------#--------------------------------------------#
       | Documentation     |   help    NEWS   what                      |
       #-------------------#--------------------------------------------#
       | Syntax            |      <       >      (      )      =      . |
       |                   |      ,       ;   semi      \      /      ' |
       |                   |      +       -      *      :               |
       #-------------------#--------------------------------------------#
       | Variables         |    ans   clear    who                      |
       #-------------------#--------------------------------------------#
       | Macros            |  macro                                     |
       #-------------------#--------------------------------------------#
       | Basic Functions   |    FUN    atan    cos    exp    log    sin |
       |                   |   sqrt    abs   round   real   imag  conjg |
       #-------------------#--------------------------------------------#
       | High Level        |           chop   cond  conjg    det   diag |
       | Functions         |    eig     eye   hess   hilb           inv |
       |                   |   kron      lu  magic   ones   orth   pinv |
       |                   |   poly    prod     qr   rand   rank  rcond |
       |                   |    rat           rref  roots         schur |
       |                   |   size     sum    svd   tril   triu   user |
       #-------------------#--------------------------------------------#
       | Flow Control      |   else     end     if    for  while   exit |
       |                   |   quit                                     |
       #-------------------#--------------------------------------------#
       | Accessing Files   |   FILE   diary   exec   load  print   save |
       #-------------------#--------------------------------------------#
       | Output Options    |  lines    long  short   disp   plot        |
       #-------------------#--------------------------------------------#
       | Performance Info. |  flops    flps                             |
       #-------------------#--------------------------------------------#
       | Miscellaneous     |   char    EDIT  debug    eps     sh        |
       #----------------------------------------------------------------#
      Here are a few sample statements:

       A = <1 2; 3 4>
       b = <5 6>'
       x = A\b
       <V,D> = eig(A),  norm(A-V*D/V)
       help \ , help eig
       exec('demo',7)

      For more information, generate the MAT88 Users' Guide
      using

        doc('manual.txt')
================================================================================
DOCUMENTATION

help  HELP gives assistance.
      HELP HELP obviously prints this message.
      To see all the HELP messages, generate the manual
      using "doc('help.txt')".

NEWS  MAT88 NEWS dated May, 1981.

      This is a port of the Argonne National Lab. FORTRAN 77 MATLAB
      routine circa 1981. This port is intended to be used primarily
      by families of FORTRAN programs that wish to add a consistent
      interactive "calculator" mode.

what  Lists commands and functions currently available.

sh    Starts the command shell interactively.
      If any characters follow the remainder of the line (restricted to
      the MAT88 character set) is passed to the sh shell.
================================================================================
SYNTAX

<     < > Brackets used in forming vectors and matrices.
      <6.9 9.64 SQRT(-1)> is a vector with three elements
      separated by blanks. <1+I 2-I 3> and <1 +I 2 -I 3> are not
      the same. The first has three elements, the second has five.
      <11 12 13; 21 22 23> is a 2 by 3 matrix. The semicolon ends
      the first row.

      Vectors and matrices can be used inside < > brackets.
      <A B; C> is allowed if the number of rows of A equals
      the number of rows of B and the number of columns of A
      plus the number of columns of B equals the number of
      columns of C. This rule generalizes in a hopefully
      obvious way to allow fairly complicated constructions.

      A = < > stores an empty matrix in A, thereby removing it
      from the list of current variables.

      For the use of < and > on the left of the = in multiple
      assignment statements, see LU, EIG, SVD and so on.

      In WHILE and IF clauses, <> means less than or greater
      than, i.e. not equal, < means less than, > means greater
      than, <= means less than or equal, >= means greater than or
      equal.

      For the use of > and < to delineate macros, see MACRO.

>     See < . Also see MACRO.

(     ( ) Used to indicate precedence in arithmetic expressions
      in the usualway. Used to enclose arguments of functions
      in the usual way. Used to enclose subscripts of vectors
      and matrices in a manner somewhat more general than the
      usual way. If X and V are vectors, then X(V) is
      <X(V(1)), X(V(2)), ..., X(V(N))>. The components of V
      are rounded to nearest integers and used as subscripts. An
      error occurs if any such subscript is less than 1 or
      greater than the dimension of X. Some examples:

         X(3) is the third element of X .
         X(<1 2 3>) is the first three elements of X. So is
         X(<SQRT(2), SQRT(3), 4*ATAN(1)>) .
         If X has N components, X(N:-1:1) reverses them.

      The same indirect subscripting is used in matrices. If V
      has M components and W has N components, then A(V,W)
      is the M by N matrix formed from the elements of A whose
      subscripts are the elements of V and W. For example...
      A(<1,5>,:) = A(<5,1>,:) interchanges rows 1 and 5 of A.

)     See ( .

=     Used in assignment statements and to mean equality in WHILE
      and IF clauses.

.     Decimal point. 314/100, 3.14 and .314E1 are all the
      same.

      Element-by-element multiplicative operations are obtained
      using .* , ./ , or .\ . For example, C = A ./ B is the
      matrix with elements c(i,j) = a(i,j)/b(i,j) .

      Kronecker tensor products and quotients are obtained with
      .*. , ./. and .\. . See KRON.

      Two or more points at the end of the line indicate
      continuation. The total line length limit is 1024
      characters.

,     Used to separate matrix subscripts and function arguments.
      Used at the end of FOR, WHILE and IF clauses. Used to
      separate statements in multi-statement lines. In this
      situation, it may be replaced by a semicolon to suppress
      printing.

;     Used inside brackets to end rows.

      Used after an expression or statement to suppress printing.
      See SEMI.

\     Backslash or matrix left division. A\B is roughly the
      same as INV(A)*B, except it is computed in a different
      way. If A is an N by N matrix and B is a column vector
      with N components, or a matrix with several such columns,
      then X = A\B is the solution to the equation A*X = B
      computed by Gaussian elimination. A warning message is
      printed if A is badly scaled or nearly singular.
      A\EYE produces the inverse of A .

      If A is an M by N matrix with M < or > N and B is a
      column vector with M components, or a matrix with several
      such columns, then X = A\B is the solution in the least
      squares sense to the under- or overdetermined system of
      equations A*X = B. The effective rank, K, of A is
      determined from the QR decomposition with pivoting. A
      solution X is computed which has at most K nonzero
      components per column. If K < N this will usually not be
      the same solution as PINV(A)*B .
      A\EYE produces a generalized inverse of A.

      If A and B have the same dimensions, then A .\ B has
      elements a(i,j)\b(i,j) .

      Also, see EDIT.

/     Slash or matrix right division. B/A is roughly the same
      as B*INV(A) . More precisely, B/A = (A'\B')' . See \ .

      IF A and B have the same dimensions, then A ./ B has
      elements a(i,j)/b(i,j) .

      Two or more slashes together on a line indicate a logical
      end of line. Any following text is ignored.

'     Transpose. X' is the complex conjugate transpose of X .
      Quote. 'ANY TEXT' is a vector whose components are the
      MAT88 internal codes for the characters. A quote within
      the text is indicated by two quotes. See DISP and FILE .

+     Addition. X + Y . X and Y must have the same dimensions.

-     Subtraction. X - Y . X and Y must have the same
      dimensions.

*     Matrix multiplication, X*Y . Any scalar (1 by 1 matrix)
      may multiply anything. Otherwise, the number of columns of
      X must equal the number of rows of Y .

      Element-by-element multiplication is obtained with X .* Y .

      The Kronecker tensor product is denoted by X .*. Y .

      Powers. X**p is X to the p power. p must be a
      scalar. If X is a matrix, see FUN .

:     Colon. Used in subscripts, FOR iterations and possibly
      elsewhere.

         J:K  is the same as  <J, J+1, ..., K>
         J:K  is empty if  J > K .
         J:I:K  is the same as  <J, J+I, J+2I, ..., K>
         J:I:K  is empty if  I > 0 and J > K or if I < 0 and J < K .

      The colon notation can be used to pick out selected rows,
      columns and elements of vectors and matrices.

         A(:) is all the elements of A, regarded as a single column.
         A(:,J)  is the J-th column of A
         A(J:K)  is A(J),A(J+1),...,A(K)
         A(:,J:K)  is A(:,J),A(:,J+1),...,A(:,K) and so on.

      For the use of the colon in the FOR statement, See FOR .

semi  SEMI toggles the action of semicolons at the end of lines.
      It will make semicolons cause rather than suppress printing.
      A second SEMI restores the initial interpretation.
================================================================================
VARIABLES

ans   Variable created automatically when expressions are not
      assigned to anything else.

clear  Erases all variables, except EPS, FLOP, EYE and RAND.
       X = <> erases only variable X . So does CLEAR X .

who   Lists current variables.
================================================================================
MACROS

MACRO  The macro facility involves text and inward pointing angle
       brackets. If STRING is the source text for any MAT88
       expression or statement, then

             t = 'STRING';
       encodes the text as a vector of integers and stores that
       vector in t. DISP(t) will print the text and

             >t<
       causes the text to be interpreted, either as a statement or
       as a factor in an expression. For example

             t = '1/(i+j-1)';
             disp(t)
             for i = 1:n, for j = 1:n, a(i,j) = >t<;

       generates the Hilbert matrix of order n.
       Another example showing indexed text,

             S = <'x = 3            '
                  'y = 4            '
                  'z = sqrt(x*x+y*y)'>
             for k = 1:3, >S(k,:)<

       It is necessary that the strings making up the "rows" of
       the "matrix" S have the same lengths.

================================================================================
BASIC FUNCTIONS

FUN   For matrix arguments X , the functions SIN, COS, ATAN,
      SQRT, LOG, EXP and X**p are computed using eigenvalues D
      and eigenvectors V . If <V,D> = EIG(X) then f(X) =
      V*f(D)/V . This method may give inaccurate results if V
      is badly conditioned. Some idea of the accuracy can be
      obtained by comparing X**1 with X .
      For vector arguments, the function is applied to each
      component.

atan  ATAN(X) is the arctangent of X . See FUN .

cos   COS(X) is the cosine of X . See FUN .

exp   EXP(X) is the exponential of X , e to the X . See FUN.

log   LOG(X) is the natural logarithm of X. See FUN.
      Complex results are produced if X is not positive, or has
      nonpositive eigenvalues.

sin   SIN(X) is the sine of X. See FUN.


sqrt  SQRT(X) is the square root of X. See FUN. Complex
      results are produced if X is not positive, or has
      nonpositive eigenvalues.

================================================================================
HIGH LEVEL FUNCTIONS

abs   ABS(X) is the absolute value, or complex modulus, of the
      elements of X .

base  BASE(X,B) is a vector containing the base B representation
      of X. This is often used in conjunction with DISPLAY.
      DISPLAY(X,B) is the same as DISPLAY(BASE(X,B)). For
      example, DISP(4*ATAN(1),16) prints the hexadecimal
      representation of pi.

chol  Cholesky factorization. CHOL(X) uses only the diagonal
      and upper triangle of X. The lower triangular is assumed
      to be the (complex conjugate) transpose of the upper. If
      X is positive definite, then R = CHOL(X) produces an
      upper triangular R so that R'*R = X . If X is not
      positive definite, an error message is printed.

chop  Truncate arithmetic. CHOP(P) causes P places to be chopped
      off after each arithmetic operation in subsequent
      computations. This means P hexadecimal digits on some
      computers and P octal digits on others. CHOP(0) restores
      full precision.

cond  Condition number in 2-norm. COND(X) is the ratio of the
      largest singular value of X to the smallest.

conjg  CONJG(X) is the complex conjugate of X .

det   DET(X) is the determinant of the square matrix X .

diag  If V is a row or column vector with N components,
      DIAG(V,K) is a square matrix of order N+ABS(K) with the
      elements of V on the K-th diagonal. K = 0 is the main
      diagonal, K > 0 is above the main diagonal and K < 0 is
      below the main diagonal. DIAG(V) simply puts V on the
      main diagonal.
      eg. DIAG(-M:M) + DIAG(ONES(2*M,1),1) + DIAG(ONES(2*M,1),-1)
      produces a tridiagonal matrix of order 2*M+1 .
      If X is a matrix, DIAG(X,K) is a column vector formed
      from the elements of the K-th diagonal of X.
      DIAG(X) is the main diagonal of X.
      DIAG(DIAG(X)) is a diagonal matrix .

eig   Eigenvalues and eigenvectors.
      EIG(X) is a vector containing the eigenvalues of a square
      matrix X.
      <V,D> = EIG(X) produces a diagonal matrix D of
      eigenvalues and a full matrix V whose columns are the
      corresponding eigenvectors so that X*V = V*D .

eye   Identity matrix. EYE(N) is the N by N identity matrix.
      EYE(M,N) is an M by N matrix with 1's on the diagonal and
      zeros elsewhere. EYE(A) is the same size as A. EYE
      with no arguments is an identity matrix of whatever order
      is appropriate in the context. For example A + 3*EYE
      adds 3 to each diagonal element of A.

hess  Hessenberg form. The Hessenberg form of a matrix is zero
      below the first subdiagonal. If the matrix is symmetric or
      Hermitian, the form is tridiagonal. <P,H> = HESS(A)
      produces a unitary matrix P and a Hessenberg matrix H so
      that A = P*H*P'. By itself, HESS(A) returns H.

hilb  Inverse Hilbert matrix. HILB(N) is the inverse of the N
      by N  matrix with elements 1/(i+j-1), which is a famous
      example of a badly conditioned matrix. The result is exact
      for N less than about 15, depending upon the computer.

imag  IMAG(X) is the imaginary part of X .

inv   INV(X) is the inverse of the square matrix X . A warning
      message is printed if X is badly scaled or nearly
      singular.

kron  KRON(X,Y) is the Kronecker tensor product of X and Y. It
      is also denoted by X .*. Y . The result is a large matrix
      formed by taking all possible products between the elements
      of X and those of Y . For example, if X is 2 by 3, then
      X .*. Y is

            < x(1,1)*Y  x(1,2)*Y  x(1,3)*Y
              x(2,1)*Y  x(2,2)*Y  x(2,3)*Y >

      The five-point discrete Laplacian for an n-by-n grid can be
      generated by

            T = diag(ones(n-1,1),1);  T = T + T';  I = EYE(T);
            A = T.*.I + I.*.T - 4*EYE;

      Just in case they might be useful, MAT88 includes
      constructions called Kronecker tensor quotients, denoted by
      X ./. Y and X .\. Y . They are obtained by replacing the
      elementwise multiplications in X .*. Y with divisions.

lu    Factors from Gaussian elimination. <L,U> = LU(X) stores a
      upper triangular matrix in U and a 'psychologically lower
      triangular matrix', i.e. a product of lower triangular and
      permutation matrices, in L , so that X = L*U . By itself,
      LU(X) returns the output from CGEFA .

magic  Magic square. MAGIC(N) is an N by N matrix constructed
       from the integers 1 through N**2 with equal row and column
       sums.

norm  For matrices..

       NORM(X)  is the largest singular value of X .
       NORM(X,1)  is the 1-norm of X .
       NORM(X,2)  is the same as NORM(X) .
       NORM(X,'INF')  is the infinity norm of X .
       NORM(X,'FRO')  is the F-norm, i.e. SQRT(SUM(DIAG(X'*X))) .

      For vectors..

       NORM(V,P) = (SUM(V(I)**P))**(1/P) .
       NORM(V) = NORM(V,2) .
       NORM(V,'INF') = MAX(ABS(V(I))) .

ones  All ones. ONES(N) is an N by N matrix of ones. ONES(M,N)
      is an M by N matrix of ones . ONES(A) is the same size as
      A and all ones .

orth  Orthogonalization. Q = ORTH(X) is a matrix with
      orthonormal columns, i.e. Q'*Q = EYE, which span the same
      space as the columns of X .

pinv  Pseudoinverse.

      X = PINV(A) produces a matrix X of the same dimensions as A'
      so that A*X*A = A , X*A*X = X and AX and XA are Hermitian . The
      computation is based on SVD(A) and any singular values less
      than a tolerance are treated as zero. The default tolerance is
      NORM(size(A),'inf')*NORM(A)*EPS. This tolerance may be overridden
      with X = PINV(A,tol). See RANK.

poly  Characteristic polynomial.

      If A is an N by N matrix, POLY(A) is a column vector with
      N+1 elements which are the coefficients of the characteristic
      polynomial, DET(lambda*EYE - A) .

      If V is a vector, POLY(V) is a vector whose elements are the
      coefficients of the polynomial whose roots are the elements of V
      . For vectors, ROOTS and POLY are inverse functions of each other,
      up to ordering, scaling, and roundoff error.

      ROOTS(POLY(1:20)) generates Wilkinson's famous example.

prod  PROD(X) is the product of all the elements of X .

qr    Orthogonal-triangular decomposition.
      <Q,R> = QR(X) produces an upper triangular matrix R of
      the same dimension as X and a unitary matrix Q so that
      X = Q*R .

      <Q,R,E> = QR(X) produces a permutation matrix E, an
      upper triangular R with decreasing diagonal elements and
      a unitary Q so that X*E = Q*R .
      By itself, QR(X) returns the output of CQRDC. TRIU(QR(X))
      is R .

rand  Random numbers and matrices. RAND(N) is an N by N matrix
      with random entries. RAND(M,N) is an M by N matrix with
      random entries. RAND(A) is the same size as A. RAND
      with no arguments is a scalar whose value changes each time
      it is referenced.

      Ordinarily, random numbers are uniformly distributed in
      the interval (0.0,1.0). RAND('NORMAL') switches to a
      normal distribution with mean 0.0 and variance 1.0.
      RAND('UNIFORM') switches back to the uniform distribution.
      RAND('SEED') returns the current value of the seed for the
      generator. RAND('SEED',n) sets the seed to n.
      RAND('SEED',0) resets the seed to 0, its value when MAT88
      is first entered.

rank  Rank. K = RANK(X) is the number of singular values of X
      that are larger than NORM(size(X),'inf')*NORM(X)*EPS.
      K = RANK(X,tol) is the number of singular values of X that
      are larger than tol.

rcond  RCOND(X) is an estimate for the reciprocal of the
       condition of X in the 1-norm obtained by the LINPACK
       condition estimator. If X is well conditioned, RCOND(X)
       is near 1.0. If X is badly conditioned, RCOND(X) is
       near 0.0.
       <R, Z> = RCOND(A) sets R to RCOND(A) and also produces a
       vector Z so that

                 NORM(A*Z,1) = R*NORM(A,1)*NORM(Z,1)

       So, if RCOND(A) is small, then Z is an approximate null
       vector.

rat   An experimental function which attempts to remove the
      roundoff error from results that should be "simple"
      rational numbers.
      RAT(X) approximates each element of X by a continued
      fraction of the form

                a/b = d1 + 1/(d2 + 1/(d3 + ... + 1/dk))

      with k <= len, integer di and abs(di) <= max . The default
      values of the parameters are len = 5 and max = 100.
      RAT(len,max) changes the default values. Increasing either
      len or max increases the number of possible fractions.
      <A,B> = RAT(X) produces integer matrices A and B so that

                A ./ B  =  RAT(X)

      Some examples:

            long
            T = hilb(6), X = inv(T)
            <A,B> = rat(X)
            H = A ./ B, S = inv(H)

            short e
            d = 1:8,  e = ones(d),  A = abs(d'*e - e'*d)
            X = inv(A)
            rat(X)
            display(ans)

real  REAL(X) is the real part of X.

rref  RREF(A) is the reduced row echelon form of the rectangular
      matrix. RREF(A,B) is the same as RREF(<A,B>) .

roots  Find polynomial roots. ROOTS(C) computes the roots of the
       polynomial whose coefficients are the elements of the
       vector C . If C has N+1 components, the polynomial is
       C(1)*X**N + ... + C(N)*X + C(N+1) . See POLY.

round  ROUND(X) rounds the elements of X to the nearest integers.

schur  Schur decomposition. <U,T> = SCHUR(X) produces an upper
       triangular matrix T , with the eigenvalues of X on the
       diagonal, and a unitary matrix U so that X = U*T*U' and
       U'*U = EYE . By itself, SCHUR(X) returns T .

size  If X is an M by N matrix, then size(X) is <M, N> .
      Can also be used with a multiple assignment,
            <M, N> = size(X) .

sum   SUM(X) is the sum of all the elements of X.
      SUM(DIAG(X)) is the trace of X.

svd   Singular value decomposition. <U,S,V> = SVD(X) produces a
      diagonal matrix S , of the same dimension as X and with
      nonnegative diagonal elements in decreasing order, and
      unitary matrices U and V so that X = U*S*V' .
      By itself, SVD(X) returns a vector containing the singular
      values.
      <U,S,V> = SVD(X,0) produces the "economy size"
      decomposition. If X is m by n with m > n, then only the
      first n columns of U are computed and S is n by n .

tril  Lower triangle. TRIL(X) is the lower triangular part of X.
      TRIL(X,K) is the elements on and below the K-th diagonal of
      X. K = 0 is the main diagonal, K > 0 is above the main
      diagonal and K < 0 is below the main diagonal.

triu  Upper triangle. TRIU(X) is the upper triangular part of X.
      TRIU(X,K) is the elements on and above the K-th diagonal of
      X. K = 0 is the main diagonal, K > 0 is above the main
      diagonal and K < 0 is below the main diagonal.

user  Allows personal Fortran subroutines to be linked into
      MAT88. The subroutine should have the heading

               SUBROUTINE USER(A,M,N,S,T)
               REAL or DOUBLEPRECISION A(M,N),S,T

      The MAT88 statement Y = USER(X,s,t) results in a call to
      the subroutine with a copy of the matrix X stored in the
      argument A , its column and row dimensions in M and N ,
      and the scalar parameters s and t stored in S and T
      . If s and t are omitted, they are set to 0.0 . After
      the return, A is stored in Y . The dimensions M and
      N may be reset within the subroutine. The statement Y =
      USER(K) results in a call with M = 1, N = 1 and A(1,1) =
      FLOAT(K) . After the subroutine has been written, it must
      be compiled and linked to the MAT88 object code within the
      local operating system.

================================================================================
FLOW CONTROL

else  Used with IF.

end   Terminates the scope of FOR, WHILE and IF statements.
      Without END's, FOR and WHILE repeat all statements up to
      the end of the line. Each END is paired with the closest
      previous unpaired FOR or WHILE and serves to terminate its
      scope. The line

         FOR I=1:N, FOR J=1:N, A(I,J)=1/(I+J-1); A

      would cause A to be printed N**2 times, once for each new
      element. On the other hand, the line

         FOR I=1:N, FOR J=1:N, A(I,J)=1/(I+J-1); END, END, A

      will lead to only the final printing of A.
      Similar considerations apply to WHILE.
      EXIT terminates execution of loops or of MAT88 itself.

if    Conditionally execute statements

      SIMPLE FORM
       Enter

         if expression rop expression, statements

      where rop is =, <, >, <=, >=, o <> (not equal). The
      statements are executed once if the indicated comparison
      between the real parts of the first components of the two
      expressions is true, otherwise the statements are skipped.

      EXAMPLE
        Enter

         if abs(i-j) = 1, a(i,j) = -1;

      More complicated forms use END in the same way it is used
      with FOR and WHILE and use ELSE as an abbreviation for END,

         if expression not rop expression

      EXAMPLE
        Enter

         for i = 1:n, for j = 1:n, ...
            if i = j, a(i,j) = 2; else if abs(i-j) = 1, a(i,j) = -1; ...
            else a(i,j) = 0;

      An easier way to accomplish the same thing is

         a = 2*eye(n);
         for i = 1:n-1, a(i,i+1) = -1; a(i+1,i) = -1;

for   Repeat statements a specific number of times.

         FOR variable = expr, statement, ..., statement, END

      The END at the end of a line may be omitted. The comma before the
      END may also be omitted. The columns of the expression are stored
      one at a time in the variable and then the following statements,
      up to the END, are executed.  The expression is often of the form
      X:Y, in which case its columns are simply scalars. Some examples
      (assume N has already been assigned a value).

       FOR I = 1:N, FOR J = 1:N, A(I,J) = 1/(I+J-1);
       FOR J = 2:N-1, A(J,J) = J; END; A
       FOR S = 1.0: -0.1: 0.0, ... steps S with increments of -0.1 .
       FOR E = EYE(N), ... sets E to the unit N-vectors.
       FOR V = A, ... has the same effect as
       FOR J = 1:N, V = A(:,J); ... except J is also set here.

while  Repeat statements an indefinite number of times.

          WHILE expr rop expr, statement, ..., statement, END

       where rop is =, <, >, <=, >=, or <> (not equal). The END
       at the end of a line may be omitted. The comma before the
       END may also be omitted. The commas may be replaced by
       semicolons to avoid printing. The statements are
       repeatedly executed as long as the indicated comparison
       between the real parts of the first components of the two
       expressions is true.

       EXAMPLE
       (assume a matrix A is already defined).

        E = 0*A; F = E + EYE; N = 1;
        WHILE NORM(E+F-E,1) > 0, E = E + F; F = A*F/N; N = N + 1;
        E

exit  Causes termination of a FOR or WHILE loop.
      If not in a loop, terminates execution of MAT88.
      Also see QUIT.

quit  From the terminal, causes return to the operating system
      or other program which invoked MAT88. From inside an
      EXEC, causes return to the invoking EXEC, or to the
      terminal.

================================================================================
ACCESSING FILES

FILE  The EXEC, SAVE, LOAD, DIARY, and PRINT functions access
      files. The 'file' parameter takes different forms for
      different operating systems. On most systems, 'file' may
      be a string of up to 1024 characters in quotes. For example,
      SAVE('A') or EXEC('MAT88/demo.exec') . The string will be
      used as the name of a file in the local operating system.
      On all systems, 'file' may be a positive integer k less
      than 10 which will be used as a FORTRAN logical unit
      number. Some systems then automatically access a file with
      a name like FORT.k or FORk.DAT. Other systems require a
      file with a name like FT0kF001 to be assigne to unit k
      before MAT88 is executed. Check your local installation
      for details.

      The filename must be composed of recognized characters. See
      CHAR.

      Also see QUIT and EXIT.

exec  EXEC('file',k) obtains subsequent MAT88 input from an
      external file. The printing of input is controlled by the
      optional parameter k .
      If k = 1 , the input is echoed.
      If k = 2 , the MAT88 prompt <> is printed.
      If k = 4 , MAT88 pauses before each prompt and waits for a
      null line to continue.
      If k = 0 , there is no echo, prompt or pause. This is the
      default if the exec command is followed by a semicolon.
      If k = 7 , there will be echos, prompts and pauses. This is
      useful for demonstrations on video terminals.
      If k = 3 , there will be echos and prompts, but no pauses.
      This is the the default if the exec command is not followed
      by a semicolon.
      EXEC(0) causes subsequent input to be obtained from the
      terminal. An end-of-file has the same effect.
      EXEC's may be nested, i.e. the text in the file may contain
      EXEC of another file. EXEC's may also be driven by FOR and
      WHILE loops.

load  LOAD('file') retrieves all the variables from the file .
      See FILE and SAVE for more details. To prepare your own
      file for LOADing, change the READs to WRITEs in the code
      given under SAVE.

print  PRINT('file',X) prints X on the file using the current
       format determined by SHORT, LONG Z, etc. See FILE.

doc   DOC('file') stores the user guide and all the help text
      (as an Appendix) in the specified file if the file does not
      already exist.

save  SAVE('file') stores all the current variables in a file.
      SAVE('file',X) saves only X . See FILE .
      The variables may be retrieved later by LOAD('file') or by
      your own program using the following code for each matrix.
      The lines involving XIMAG may be eliminated if everything
      is known to be real.

            ! attach lunit to 'file', then ...
            REAL or DOUBLEPRECISION XREAL(MMAX,NMAX)
            REAL or DOUBLEPRECISION XIMAG(MMAX,NMAX)
            READ(lunit,101) ID,M,N,IMG
            DO J = 1, N
               READ(lunit,102) (XREAL(I,J), I=1,M)
               IF (IMG .NE. 0) READ(lunit,102) (XIMAG(I,J),I=1,M)
            enddo

      The formats used are system dependent. The following are
      typical. See SUBROUTINE mat_savlod in your local
      implementation of MAT88.

        101 FORMAT(4A1,3I4)
        102 FORMAT(4Z18)
        102 FORMAT(4O20)
        102 FORMAT(4D25.18)

================================================================================
OUTPUT OPTIONS
      ( Also see FILE (EXEC, LOAD, PRINT, SAVE ))

lines  An internal count is kept of the number of lines of output
       since the last input. Whenever this count approaches a
       limit, the user is asked whether or not to suppress
       printing until the next input. Initially the limit is 25.
       LINES(N) resets the limit to N .

long  Determine output format. All computations are done in
      complex arithmetic and double precision if it is available.
      SHORT and LONG merely switch between different output
      formats.

       SHORT    Scaled fixed point format with about 5 digits.
       LONG     Scaled fixed point format with about 15 digits.
       SHORT E  Floating point format with about 5 digits.
       LONG E   Floating point format with about 15 digits.
       LONG Z   System dependent format, often hexadecimal.

short  See LONG .

diary  DIARY('file') causes a copy of all subsequent terminal input and
       most of the resulting output to be written on the file. DIARY(0)
       turns it off. See FILE.

disp  DISPLAY(X) prints X in a compact format.

      If a base is specified the values are printed as numeric
      values in the specified base.

           disp(0:10,10 ) // display values in base 10
           disp(0:10,16 ) // display values as hexadecimal values
           disp(0:10,0 ) // display values as binary numbers

      If no base is specified and all the
      elements of X are integers between 0 and 77, then X is
      interpreted as MAT88 text and printed accordingly.

         <>disp('the analysis is complete')
           the analysis is complete
         disp(0:77) // print the default MAT88 character set

      Otherwise, + , - and blank are printed for positive,
      negative and zero elements.

      Imaginary parts are ignored.

      Note that DISP(X,B) is the same as DISP(BASE(X,B)) except
      it forces DISP to display numeric values.


plot  PLOT(X,Y) produces a plot of the elements of Y against
      those of X. PLOT(Y) is the same as PLOT(1:n,Y) where n is
      the number of elements in Y. PLOT(X,Y,P) or
      PLOT(X,Y,p1,...,pk) passes the optional parameter vector P
      or scalars p1 through pk to the plot routine. The default
      plot routine is a crude printer-plot. This version writes
      the data as a simple X Y table into a scratch file called
      "scratch.dat" and then calls the command

        xy scratch.dat [options]

      Hopefully, you have the command xy(1) in your search path.
      If not, you can make one by creating a script that calls
      a plotting utility.


         t = 0:50;
         plot( t.*cos(t), t.*sin(t) )
         opts=' -m 1 -title test plot -d pdf'
         plot( t.*cos(t), t.*sin(t),opts)

================================================================================
PERFORMANCE INFORMATION

flops  Count of floating point operations.
       FLOPS is a permanently defined row vector with two
       elements. FLOPS(1) is the number of floating point
       operations counted during the previous statement. FLOPS(2)
       is a cumulative total. FLOPS can be used in the same way
       as any other vector. FLOPS(2) = 0 resets the cumulative
       total. In addition, FLOPS(1) will be printed whenever a
       statement is terminated by an extra comma. For example,

         X = INV(A);,

       or

         COND(A), (as the last statement on the line).

       HELP FLPS gives more details.

flps   More detail on FLOPS.
       It is not feasible to count absolutely all floating point
       operations, but most of the important ones are counted.
       Each multiply and add in a real vector operation such as a
       dot product or a 'saxpy' counts one flop. Each multiply
       and add in a complex vector operation counts two flops.
       Other additions, subtractions and multiplications count one
       flop each if the result is real and two flops if it is not.
       Real divisions count one and complex divisions count two.
       Elementary functions count one if real and two if complex.
       Some examples. If A and B are real N by N matrices, then

        A + B  counts N**2 flops,
        A*B    counts N**3 flops,
        A**100 counts 99*N**3 flops,
        LU(A)  counts roughly (1/3)*N**3 flops.
================================================================================
MISCELLANEOUS

char  CHAR(K) requests an input line containing a single
      character to replace MAT88 character number K in the
      following table. For example, CHAR(45) replaces backslash.
      CHAR(-K) replaces the alternate character number K. By default
      the character set is:

                K  character alternate name
              0 - 9   0 - 9    0 - 9   digits
             10 - 35  A - Z    A - Z   letters
               36                      blank
               37       (        {     lparen
               38       )        }     rparen
               39       ;        ;     semi
               40       :        |     colon
               41       +        +     plus
               42       -        -     minus
               43       *        *     star
               44       /        /     slash
               45       \        $     backslash
               46       =        =     equal
               47       .        @     dot
               48       ,        ,     comma
               49       '        "     quote
               50       <        [     less
               51       >        ]     great
             52 - 77  a - z    a - z   letters

      unused: `~!#%^&_?

EDIT
      A command line consisting of a single period (".") will cause a
      small line-based editor to be called (very similar to the CDC NOS
      editor "xedit") with a copy of the previous input lines. When the
      editor returns control to MAT88, it will execute the edited command
      (by default).

      In editor mode the command to be edited is shifted over one and the
      first character of input determines the edit mode. The letter "c"
      begins a string change (ie. "c/oldstring/newstring/").  The "l"
      command lists the lines. A number goes to that command line as
      listed by the "l" command. If the change command begins with a
      space a letter replaces the one above it with the exception of
      the special characters # (delete) & (blank out) and ^ (insert the
      following string here).

      An editing loop is entered until a carriage return on an empty
      line is entered to accept the new line or a period is entered to
      cancel the editing.

      For example, if you had entered a line such as:

         <M,N>=size(A);for I = 1:M, for J = 1:N, A(I,J) = A(I,J)+3.6;

      Then to repeat the command changing "3.6" to "5.1" enter

         .
      the previous command is then displayed. Now enter

         c/3.6/5.1

      and then enter a carriage return and the edited line will be
      executed.

      The first command can appear on the same line if the line starts
      with ". " (a period followed by a space). For example

         . /rand

      would take you into edit mode on the last command containing the
      string "rand"

      Enter "?" in edit mode to display further help on editor mode.

eps   Floating point relative accuracy. A permanent variable
      whose value is initially the distance from 1.0 to the next largest
      floating point number. The value is changed by CHOP, and other
      values may be assigned. EPS is used as a default tolerance by PINV
      and RANK.

laff  A placeholder for a new command.

debug  DEBU(1) turns on verbose low-level debugging for the developer,
       DEBU(0) turns it back off.

================================================================================
$BLOCK
end subroutine mat_make_help
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_make_manual(io)
integer,intent(in) :: io
$BLOCK WRITE
6/24/81

                       MAT88 Users' Guide
                            May, 1981
                            Dec, 2018

                 Based on the MATLAB package by

                           Cleve Moler
                 Department of Computer Science
                    University of New Mexico


          ABSTRACT. MAT88 is an interactive computer procedure
          that serves as a convenient "laboratory" for
          computations involving matrices. It provides easy
          access to matrix software developed by the LINPACK and
          EISPACK projects. The program is written in Fortran
          and is designed to be readily installed under any
          operating system which permits interactive execution of
          Fortran programs.


                            CONTENTS

          1.  Elementary operations
          2.  MAT88 functions
          3.  Rows, columns and submatrices
          4.  FOR, WHILE and IF
          5.  Commands, text, files and macros
          6.  Census example
          7.  Partial differential equation
          8.  Eigenvalue sensitivity example
          9.  Syntax diagrams
         10.  The parser-interpreter
         11.  The numerical algorithms
         12.  FLOP and CHOP
         13.  Communicating with other programs
         Appendix.  The HELP file

6/24/81

   MAT88 is an interactive computer program that serves as a convenient
   "laboratory" for computations involving matrices. It provides easy
   access to matrix software developed by the LINPACK and EISPACK
   projects [1-3]. The capabilities range from standard tasks such
   as solving simultaneous linear equations and inverting matrices,
   through symmetric and nonsymmetric eigenvalue problems, to fairly
   sophisticated matrix tools such as the singular value decomposition.

   It is expected that one of MAT88's primary uses will be in the
   classroom. It should be useful in introductory courses in applied
   linear algebra, as well as more advanced courses in numerical
   analysis, matrix theory, statistics and applications of matrices
   to other disciplines. In nonacademic settings, MAT88 can serve as a
   "desk calculator" for the quick solution of small problems involving
   matrices.

   The program is written in Fortran and is designed to be readily
   installed under any operating system which permits interactive
   execution of Fortran programs. The resources required are fairly
   modest. There are less than 7000 lines of Fortran source code,
   including the LINPACK and EISPACK subroutines used. With proper use
   of overlays, it is possible run the system on a minicomputer with
   only 32K bytes of memory.

   The size of the matrices that can be handled in MAT88 depends upon the
   amount of storage that is set aside when the system is compiled on a
   particular machine. We have found that an allocation of 5000 words
   for matrix elements is usually quite satisfactory. This provides
   room for several 20 by 20 matrices, for example. One implementation
   on a virtual memory system provides 100,000 elements. Since most of
   the algorithms used access memory in a sequential fashion, the large
   amount of allocated storage causes no difficulties.

   In some ways, MAT88 resembles SPEAKEASY [4] and, to a lesser extent,
   APL. All are interactive terminal languages that ordinarily accept
   single-line commands or statements, process them immediately, and print
   the results. All have arrays or matrices as principal data types. But
   for MAT88, the matrix is the only data type (although scalars, vectors
   and text are special cases), the underlying system is portable and
   requires fewer resources, and the supporting subroutines are more
   powerful and, in some cases, have better numerical properties.

   Together, LINPACK and EISPACK represent the state of the art in
   software for matrix computation. EISPACK is a package of over 70
   Fortran subroutines for various matrix eigenvalue computations that are
   based for the most part on Algol procedures published by Wilkinson,
   Reinsch and their colleagues [5]. LINPACK is a package of 40 Fortran
   subroutines (in each of four data types) for solving and analyzing
   simultaneous linear equations and related matrix problems. Since MAT88
   is not primarily concerned with either execution time efficiency or
   storage savings, it ignores most of the special matrix properties that
   LINPACK and EISPACK subroutines use to advantage. Consequently, only
   8 subroutines from LINPACK and 5 from EISPACK are actually involved.

   In more advanced applications, MAT88 can be used in conjunction with
   other programs in several ways. It is possible to define new MAT88
   functions and add them to the system. With most operating systems,
   it is possible to use the local file system to pass matrices between
   MAT88 and other programs. MAT88 command and statement input can be
   obtained from a local file instead of from the terminal. The most
   power and flexibility is obtained by using MAT88 as a subroutine
   which is called by other programs.

   This document first gives an overview of MAT88 from the user's
   point of view. Several extended examples involving data fitting,
   partial differential equations, eigenvalue sensitivity and other
   topics are included. A formal definition of the MAT88 language and
   an brief description of the parser and interpreter are given. The
   system was designed and programmed using techniques described by
   Wirth [6], implemented in nonrecursive, portable Fortran. There is
   a brief discussion of some of the matrix algorithms and of their
   numerical properties. The final section describes how MAT88 can be
   used with other programs. The appendix includes the HELP documentation
   available on-line.


1.  ELEMENTARY OPERATIONS


   MAT88 works with essentially only one kind of object, a
   rectangular matrix with complex elements. If the imaginary parts
   of the elements are all zero, they are not printed, but they
   still occupy storage. In some situations, special meaning is
   attached to 1 by 1 matrices, that is scalars, and to 1 by n and m
   by 1 matrices, that is row and column vectors.

   Matrices can be introduced into MAT88 in four different
   ways:

           --  Explicit list of elements,
           --  Use of FOR and WHILE statements,
           --  Read from an external file,
           --  Execute an external Fortran program.

   The explicit list is surrounded by angle brackets, '<' and '>', and
   uses the semicolon ';' to indicate the ends of the rows. For example,
   the input line

      A = <1 2 3; 4 5 6; 7 8 9>

   will result in the output

      A     =

          1.    2.   3.
          4.    5.   6.
          7.    8.   9.

   The matrix A will be saved for later use. The individual
   elements are separated by commas or blanks and can be any MAT88
   expressions, for example

      x = < -1.3, 4/5, 4*atan(1) >

   results in

      X     =

        -1.3000   0.8000   3.1416

   The elementary functions available include sqrt, log, exp, sin,
   cos, atan, abs, round, real, imag, and conjg.

   Large matrices can be spread across several input lines,
   with the carriage returns replacing the semicolons. The above
   matrix could also have been produced by

      A = < 1 2 3
            4 5 6
            7 8 9 >


   Matrices can be input from the local file system. Say a
   file named 'xyz' contains five lines of text,

      A = <
      1 2 3
      4 5 6
      7 8 9
      >;

   then the MAT88 statement EXEC('xyz') reads the matrix and
   assigns it to A .

   The FOR statement allows the generation of matrices whose
   elements are given by simple formulas. Our example matrix A
   could also have been produced by

      for i = 1:3, for j = 1:3, a(i,j) = 3*(i-1)+j;

   The semicolon at the end of the line suppresses the printing,
   which in this case would have been nine versions of A with
   changing elements.

   Several statements may be given on a line, separated by
   semicolons or commas.

   Two consecutive periods anywhere on a line indicate
   continuation. The periods and any following characters are
   deleted, then another line is input and concatenated onto the
   previous line.

   Two consecutive slashes anywhere on a line cause the
   remainder of the line to be ignored. This is useful for
   inserting comments.

   Names of variables are formed by a letter, followed by any
   number of letters and digits, but only the first 4 characters are
   remembered.

   The special character prime (') is used to denote the
   transpose of a matrix, so

      x = x'

   changes the row vector above into the column vector

      X     =

        -1.3000
         0.8000
         3.1416


   Individual matrix elements may be referenced by enclosing
   their subscripts in parentheses. When any element is changed,
   the entire matrix is reprinted. For example, using the above
   matrix,

      a(3,3) = a(1,3) + a(3,1)

   results in

      A     =

          1.    2.    3.
          4.    5.    6.
          7.    8.   10.

   Addition, subtraction and multiplication of matrices are
   denoted by +, -, and * . The operations are performed whenever
   the matrices have the proper dimensions. For example, with the
   above A and x, the expressions A + x and x*A are incorrect
   because A is 3 by 3 and x is now 3 by 1. However,

      b = A*x

   is correct and results in the output

      B     =

         9.7248
        17.6496
        28.7159

   Note that both upper and lower case letters are allowed for input
   (on those systems which have both).

   There are two "matrix division" symbols in MAT88, \ and / .
   (If your terminal does not have a backslash, use $ instead, or
   see CHAR.) If A and B are matrices, then A\B and B/A correspond
   formally to left and right multiplication of B by the inverse of
   A, that is inv(A)*B and B*inv(A), but the result is obtained
   directly without the computation of the inverse. In the scalar
   case, 3\1 and 1/3 have the same value, namely one-third. In
   general, A\B denotes the solution X to the equation A*X = B and
   B/A denotes the solution to X*A = B.

   Left division, A\B, is defined whenever B has as many rows
   as A. If A is square, it is factored using Gaussian
   elimination. The factors are used to solve the equations
   A*X(:,j) = B(:,j) where B(:,j) denotes the j-th column of B. The
   result is a matrix X with the same dimensions as B. If A is
   nearly singular (according to the LINPACK condition estimator,
   RCOND), a warning message is printed. If A is not square, it is
   factored using Householder orthogonalization with column
   pivoting. The factors are used to solve the under- or
   overdetermined equations in a least squares sense. The result is
   an m by n matrix X where m is the number of columns of A and n is
   the number of columns of B . Each column of X has at most k
   nonzero components, where k is the effective rank of A .

   Right division, B/A, can be defined in terms of left
   division by B/A = (A'\B')'.

   For example, since our vector b was computed as A*x, the
   statement

      y = A\b

   results in

      Y     =

        -1.3000
         0.8000
         3.1416

   Of course, y is not exactly equal to x because of the
   roundoff errors involved in both A*x and A\b , but we are not
   printing enough digits to see the difference. The result of the
   statement

      e = x - y

   depends upon the particular computer being used. In one case it
   produces

      E     =

         1.0e-15 *

           .3053
          -.2498
           .0000

   The quantity 1.0e-15 is a scale factor which multiplies all the
   components which follow. Thus our vectors x and y actually
   agree to about 15 decimal places on this computer.

   It is also possible to obtain element-by-element
   multiplicative operations. If A and B have the same dimensions,
   then A .* B denotes the matrix whose elements are simply the
   products of the individual elements of A and B . The expressions
   A ./ B and A .\ B give the quotients of the individual elements.

   There are several possible output formats. The statement

      long, x

   results in

      X     =

         -1.300000000000000
           .800000000000000
          3.141592653589793

   The statement

      short

   restores the original format.

   The expression A**p means A to the p-th power. It is
   defined if A is a square matrix and p is a scalar. If p is an
   integer greater than one, the power is computed by repeated
   multiplication. For other values of p the calculation involves
   the eigenvalues and eigenvectors of A.

   Previously defined matrices and matrix expressions can be
   used inside brackets to generate larger matrices, for example

      C = <A, b; <4 2 0>*x, x'>

   results in

      C     =

         1.0000   2.0000   3.0000   9.7248
         4.0000   5.0000   6.0000  17.6496
         7.0000   8.0000  10.0000  28.7159
        -3.6000  -1.3000   0.8000   3.1416

   There are four predefined variables, EPS, FLOP, RAND and
   EYE. The variable EPS is used as a tolerance is determining such
   things as near singularity and rank. Its initial value is the
   distance from 1.0 to the next largest floating point number on
   the particular computer being used. The user may reset this to
   any other value, including zero. EPS is changed by CHOP, which is
   described in section 12.

   The value of RAND is a random variable, with a choice of a
   uniform or a normal distribution.

   The name EYE is used in place of I to denote identity
   matrices because I is often used as a subscript or as sqrt(-1).
   The dimensions of EYE are determined by context. For example,

      B = A + 3*EYE

   adds 3 to the diagonal elements of A and

      X = EYE/A

   is one of several ways in MAT88 to invert a matrix.

   FLOP provides a count of the number of floating point
   operations, or "flops", required for each calculation.

   A statement may consist of an expression alone, in which
   case a variable named ANS is created and the result stored in ANS
   for possible future use. Thus

      A\A - EYE

   is the same as

      ANS = A\A - EYE

   (Roundoff error usually causes this result to be a matrix of
   "small" numbers, rather than all zeros.)

   All computations are done using either single or double
   precision real arithmetic, whichever is appropriate for the
   particular computer. There is no mixed-precision arithmetic.
   The Fortran COMPLEX data type is not used because many systems
   create unnecessary underflows and overflows with complex
   operations and because some systems do not allow double precision
   complex arithmetic.

2.  MAT88 FUNCTIONS

   Much of MAT88's computational power comes from the various
   matrix functions available. The current list includes:

      inv(A)          - Inverse.
      det(A)          - Determinant.
      cond(A)         - Condition number.
      rcond(A)        - A measure of nearness to singularity.
      eig(A)          - Eigenvalues and eigenvectors.
      schur(A)        - Schur triangular form.
      hess(A)         - Hessenberg or tridiagonal form.
      poly(A)         - Characteristic polynomial.
      svd(A)          - Singular value decomposition.
      pinv(A,eps)     - Pseudoinverse with optional tolerance.
      rank(A,eps)     - Matrix rank with optional tolerance.
      lu(A)           - Factors from Gaussian elimination.
      chol(A)         - Factor from Cholesky factorization.
      qr(A)           - Factors from Householder orthogonalization.
      rref(A)         - Reduced row echelon form.
      orth(A)         - Orthogonal vectors spanning range of A.
      exp(A)          - e to the A.
      log(A)          - Natural logarithm.
      sqrt(A)         - Square root.
      sin(A)          - Trigonometric sine.
      cos(A)          - Cosine.
      atan(A)         - Arctangent.
      round(A)        - Round the elements to nearest integers.
      abs(A)          - Absolute value of the elements.
      real(A)         - Real parts of the elements.
      imag(A)         - Imaginary parts of the elements.
      conjg(A)        - Complex conjugate.
      sum(A)          - Sum of the elements.
      prod(A)         - Product of the elements.
      diag(A)         - Extract or create diagonal matrices.
      tril(A)         - Lower triangular part of A.
      triu(A)         - Upper triangular part of A.
      norm(A,p)       - Norm with p = 1, 2 or 'Infinity'.
      eye(m,n)        - Portion of identity matrix.
      rand(m,n)       - Matrix with random elements.
      ones(m,n)       - Matrix of all ones.
      magic(n)        - Interesting test matrices.
      hilbert(n)      - Inverse Hilbert matrices.
      roots(C)        - Roots of polynomial with coefficients C.
      display(A,p)    - Print base p representation of A.
      kron(A,B)       - Kronecker tensor product of A and B.
      plot(X,Y)       - Plot Y as a function of X .
      rat(A)          - Find "simple" rational approximation to A.
      user(A)         - Function defined by external program.

   Some of these functions have different interpretations when
   the argument is a matrix or a vector and some of them have
   additional optional arguments. Details are given in the HELP
   document in the appendix.

   Several of these functions can be used in a generalized
   assignment statement with two or three variables on the left hand
   side. For example

      <X,D> = EIG(A)

   stores the eigenvectors of A in the matrix X and a diagonal
   matrix containing the eigenvalues in the matrix D. The statement

      EIG(A)

   simply computes the eigenvalues and stores them in ANS.

   Future versions of MAT88 will probably include additional
   functions, since they can easily be added to the system.


3.  ROWS, COLUMNS AND SUBMATRICES

   Individual elements of a matrix can be accessed by giving
   their subscripts in parentheses, eg. A(1,2), x(i), TAB(ind(k)+1).
   An expression used as a subscript is rounded to the nearest
   integer.

   Individual rows and columns can be accessed using a colon
   ':' (or a '|') for the free subscript. For example, A(1,:) is the
   first row of A and A(:,j) is the j-th column. Thus

      A(i,:) = A(i,:) + c*A(k,:)

   adds c times the k-th row of A to the i-th row.

   The colon is used in several other ways in MAT88, but all
   of the uses are based on the following definition.

      j:k    is the same as  <j, j+1, ..., k>
      j:k    is empty if  j > k .
      j:i:k  is the same as  <j, j+i, j+2i, ..., k>
      j:i:k  is empty if  i > 0 and j > k or if i < 0 and j < k .

   The colon is usually used with integers, but it is possible to
   use arbitrary real scalars as well. Thus

      1:4  is the same as  <1, 2, 3, 4>
      0: 0.1: 0.5 is the same as <0.0, 0.1, 0.2, 0.3, 0.4, 0.5>

   In general, a subscript can be a vector. If X and V are
   vectors, then X(V) is <X(V(1)), X(V(2)), ..., X(V(n))> . This can
   also be used with matrices. If V has m components and W has n
   components, then A(V,W) is the m by n matrix formed from the
   elements of A whose subscripts are the elements of V and W.
   Combinations of the colon notation and the indirect subscripting
   allow manipulation of various submatrices. For example,

      A(<1,5>,:) = A(<5,1>,:)  interchanges rows 1 and 5 of A.
      A(2:k,1:n)  is the submatrix formed from rows 2 through k
         and columns 1 through n of A .
      A(:,<3 1 2>)  is a permutation of the first three columns.

   The notation A(:) has a special meaning. On the right hand
   side of an assignment statement, it denotes all the elements of
   A, regarded as a single column. When an expression is assigned
   to A(:), the current dimensions of A, rather than of the
   expression, are used.

4.  FOR, WHILE AND IF

   The FOR clause allows statements to be repeated a specific
   number of times. The general form is

      FOR variable = expr, statement, ..., statement, END

   The END and the comma before it may be omitted. In general, the
   expression may be a matrix, in which case the columns are stored
   one at a time in the variable and the following statements, up to
   the END or the end of the line, are executed. The expression is
   often of the form j:k, and its "columns" are simply the scalars
   from j to k. Some examples (assume n has already been assigned a
   value):

      for i = 1:n, for j = 1:n, A(i,j) = 1/(i+j-1);

   generates the Hilbert matrix.

      for j = 2:n-1, for i = j:n-1, ...
         A(i,j) = 0; end; A(j,j) = j; end; A

   changes all but the "outer edge" of the lower triangle and then
   prints the final matrix.

      for h = 1.0: -0.1: -1.0, (<h, cos(pi*h)>)

   prints a table of cosines.

      <X,D> = EIG(A); for v = X, v, A*v

   displays eigenvectors, one at a time.

        The WHILE clause allows statements to be repeated an
   indefinite number of times. The general form is

      WHILE expr relop expr,   statement,..., statement, END

   where relop is =, <, >, <=, >=, or <> (not equal). The
   statements are repeatedly executed as long as the indicated
   comparison between the real parts of the first components of the
   two expressions is true. Here are two examples. (Exercise for
   the reader: What do these segments do?)

      eps = 1;
      while 1 + eps > 1, eps = eps/2;
      eps = 2*eps

      E = 0*A;  F = E + EYE; n = 1;
      while NORM(E+F-E,1) > 0, E = E + F; F = A*F/n; n = n + 1;
      E

   The IF clause allows conditional execution of statements.
   The general form is

      IF expr relop expr,  statement, ..., statement,
         ELSE statement, ..., statement

   The first group of statements are executed if the relation is
   true and the second group are executed if the relation is false.
   The ELSE and the statements following it may be omitted. For
   example,

      if abs(i-j) = 2, A(i,j) = 0;

5.  COMMANDS, TEXT, FILES AND MACROS.


   MAT88 has several commands which control the output format
   and the overall execution of the system.

   The HELP command allows on-line access to short portions of
   text describing various operations, functions and special
   characters. The entire HELP document is reproduced in an
   appendix.

   Results are usually printed in a scaled fixed point format
   that shows 4 or 5 significant figures. The commands SHORT, LONG,
   SHORT E, LONG E and LONG Z alter the output format, but do not
   alter the precision of the computations or the internal storage.

   The WHO and WHAT commands provide information about the
   functions and variables that are currently defined.

   The CLEAR command erases all variables, except EPS, FLOP,
   RAND and EYE. The statement A = <> indicates that a "0 by 0"
   matrix is to be stored in A. This causes A to be erased so that
   its storage can be used for other variables.

   The QUIT and EXIT commands cause return to the underlying
   operating system through the Fortran RETURN statement.

   MAT88 has a limited facility for handling text. Any string
   of characters delineated by quotes (with two quotes used to allow
   one quote within the string) is saved as a vector of integer
   values with '1' = 1, 'A' = 10, ' ' = 36, etc. (The complete list
   is in the appendix under CHAR.) For example

      '2*A + 3'  is the same as  <2 43 10 36 41 36 3>

   It is possible, though seldom very meaningful, to use such
   strings in matrix operations. More frequently, the text is used
   as a special argument to various functions.

      NORM(A,'inf')    computes the infinity norm of A .
      DISPLAY(T)       prints the text stored in T .
      EXEC('file')     obtains MAT88 input from an external file.
      SAVE('file')     stores all the current variables in a file.
      LOAD('file')     retrieves all the variables from a file.
      PRINT('file',X)  prints X on a file.
      DIARY('file')    makes a copy of the complete MAT88 session.

   The text can also be used in a limited string substitution
   macro facility. If a variable, say T, contains the source text
   for a MAT88 statement or expression, then the construction

      > T <

   causes T to be executed or evaluated. For example

      T = '2*A + 3';
      S = 'B = >T< + 5'
      A = 4;
      > S <

   produces

      B     =

         16.

   Some other examples are given under MACRO in the appendix. This
   facility is useful for fairly short statements and expressions.
   More complicated MAT88 "programs" should use the EXEC facility.

   The operations which access external files cannot be handled
   in a completely machine-independent manner by portable Fortran
   code. It is necessary for each particular installation to
   provide a subroutine which associates external text files with
   Fortran logical unit numbers.


6.  CENSUS EXAMPLE

   Our first extended example involves predicting the
   population of the United States in 1980 using extrapolation of
   various fits to the census data from 1900 through 1970. There
   are eight observations, so we begin with the MAT88 statement

      n = 8

   The values of the dependent variable, the population in millions,
   can be entered with

      y = < 75.995   91.972  105.711  123.203   ...
           131.669  150.697  179.323  203.212>'

   In order to produce a reasonably scaled matrix, the independent
   variable, time, is transformed from the interval [1900,1970] to
   [-1.00,0.75]. This can be accomplished directly with

      t = -1.0:0.25:0.75

   or in a fancier, but perhaps clearer, way with

      t = 1900:10:1970;   t = (t - 1940*ones(t))/40

   Either of these is equivalent to

      t = <-1 -.75 -.50 -.25 0 .25 .50 .75>

   The interpolating polynomial of degree n-1 involves an
   Vandermonde matrix of order n with elements that might be
   generated by

      for i = 1:n, for j = 1:n, a(i,j) = t(i)**(j-1);

   However, this results in an error caused by 0**0 when i = 5 and
   j = 1 . The preferable approach is

      A = ones(n,n);
      for i = 1:n, for j = 2:n, a(i,j) = t(i)*a(i,j-1);

   Now the statement

      cond(A)

   produces the output

      ANS   =

         1.1819E+03

   which indicates that transformation of the time variable has
   resulted in a reasonably well conditioned matrix.

        The statement

      c = A\y

   results in

      C     =

        131.6690
         41.0406
        103.5396
        262.4535
       -326.0658
       -662.0814
        341.9022
        533.6373

   These are the coefficients in the interpolating polynomial

         n-1

         c  + c t + ... + c t
          1    2           n

   Our transformation of the time variable has resulted in t = 1
   corresponding to the year 1980. Consequently, the extrapolated
   population is simply the sum of the coefficients. This can be
   computed by

      p = sum(c)

   The result is

      P     =

        426.0950

   which indicates a 1980 population of over 426 million. Clearly,
   using the seventh degree interpolating polynomial to extrapolate
   even a fairly short distance beyond the end of the data interval
   is not a good idea.

   The coefficients in least squares fits by polynomials of
   lower degree can be computed using fewer than n columns of the
   matrix.

      for k = 1:n, c = A(:,1:k)\y,  p = sum(c)

   would produce the coefficients of these fits, as well as the
   resulting extrapolated population. If we do not want to print
   all the coefficients, we can simply generate a small table of
   populations predicted by polynomials of degrees zero through
   seven. We also compute the maximum deviation between the fitted
   and observed values.

      for k = 1:n, X = A(:,1:k);  c = X\y;  ...
         d(k) = k-1;  p(k) = sum(c);  e(k) = norm(X*c-y,'inf');
      <d, p, e>

   The resulting output is

         0   132.7227  70.4892
         1   211.5101   9.8079
         2   227.7744   5.0354
         3   241.9574   3.8941
         4   234.2814   4.0643
         5   189.7310   2.5066
         6   118.3025   1.6741
         7   426.0950   0.0000

   The zeroth degree fit, 132.7 million, is the result of fitting a
   constant to the data and is simply the average. The results
   obtained with polynomials of degree one through four all appear
   reasonable. The maximum deviation of the degree four fit is
   slightly greater than the degree three, even though the sum of
   the squares of the deviations is less. The coefficients of the
   highest powers in the fits of degree five and six turn out to be
   negative and the predicted populations of less than 200 million
   are probably unrealistic. The hopefully absurd prediction of the
   interpolating polynomial concludes the table.

   We wish to emphasize that roundoff errors are not
   significant here. Nearly identical results would be obtained on
   other computers, or with other algorithms. The results simply
   indicate the difficulties associated with extrapolation of
   polynomial fits of even modest degree.

   A stabilized fit by a seventh degree polynomial can be
   obtained using the pseudoinverse, but it requires a fairly
   delicate choice of a tolerance. The statement

      s = svd(A)

   produces the singular values

      S     =

         3.4594
         2.2121
         1.0915
         0.4879
         0.1759
         0.0617
         0.0134
         0.0029

   We see that the last three singular values are less than 0.1 ,
   consequently, A can be approximately by a matrix of rank five
   with an error less than 0.1 . The Moore-Penrose pseudoinverse of
   this rank five matrix is obtained from the singular value
   decomposition with the following statements

      c = pinv(A,0.1)*y, p = sum(c), e = norm(a*c-y,'inf')

   The output is

      C     =

       134.7972
        67.5055
        23.5523
         9.2834
         3.0174
         2.6503
        -2.8808
         3.2467

      P     =

       241.1720

      E     =

         3.9469

   The resulting seventh degree polynomial has coefficients which
   are much smaller than those of the interpolating polynomial given
   earlier. The predicted population and the maximum deviation are
   reasonable. Any choice of the tolerance between the fifth and
   sixth singular values would produce the same results, but choices
   outside this range result in pseudoinverses of different rank and
   do not work as well.

   The one term exponential approximation

        y(t) = k exp(pt)

   can be transformed into a linear approximation by taking
   logarithms.

        log(y(t)) = log k + pt

                  = c  + c t
                     1    2

   The following segment makes use of the fact that a function of a
   vector is the function applied to the individual components.

      X = A(:,1:2);
      c = X\log(y)
      p = exp(sum(c))
      e = norm(exp(X*c)-y,'inf')

   The resulting output is

      C     =

         4.9083
         0.5407

      P     =

       232.5134

      E     =

         4.9141

   The predicted population and maximum deviation appear
   satisfactory and indicate that the exponential model is a
   reasonable one to consider.

   As a curiousity, we return to the degree six polynomial.
   Since the coefficient of the high order term is negative and the
   value of the polynomial at t = 1 is positive, it must have a root
   at some value of t greater than one. The statements

      X = A(:,1:7);
      c = X\y;
      c = c(7:-1:1);  //reverse the order of the coefficients
      z = roots(c)

   produce

      Z     =

         1.1023-  0.0000*i
         0.3021+  0.7293*i
        -0.8790+  0.6536*i
        -1.2939-  0.0000*i
        -0.8790-  0.6536*i
         0.3021-  0.7293*i

   There is only one real, positive root. The corresponding time on
   the original scale is

      1940 + 40*real(z(1))

        =  1984.091

   We conclude that the United States population should become zero
   early in February of 1984.

7. PARTIAL DIFFERENTIAL EQUATION EXAMPLE

   Our second extended example is a boundary value problem for
   Laplace's equation. The underlying physical problem involves the
   conductivity of a medium with cylindrical inclusions and is
   considered by Keller and Sachs [7].

        Find a function  u(x,y)  satisfying Laplace's equation

                  u   + u   = 0
                   xx    yy

   The domain is a unit square with a quarter circle of radius rho
   removed from one corner. There are Neumann conditions on the top
   and bottom edges and Dirichlet conditions on the remainder of the
   boundary.


                            u  = 0
                             n

                        -------------
                       |             .
                       |             .
                       |              .
                       |               .  u = 1
                       |                 .
                       |                    .
                       |                       .
                u = 0  |                        |
                       |                        |
                       |                        |
                       |                        |  u = 1
                       |                        |
                       |                        |
                       |                        |
                        ------------------------

                                 u  = 0
                                  n


   The effective conductivity of an medium is then given by the
   integral along the left edge,

                               1
                    sigma = integral  u (0,y) dy
                              0        n

   It is of interest to study the relation between the radius rho
   and the conductivity sigma. In particular, as rho approaches
   one, sigma becomes infinite.

   Keller and Sachs use a finite difference approximation. The
   following technique makes use of the fact that the equation is
   actually Laplace's equation and leads to a much smaller matrix
   problem to solve.

        Consider an approximate solution of the form

                    n      2j-1
              u =  sum  c r    cos(2j-1)t
                   j=1   j

   where r,t are polar coordinates (t is theta). The coefficients
   are to be determined. For any set of coefficients, this function
   already satisfies the differential equation because the basis
   functions are harmonic; it satisfies the normal derivative
   boundary condition on the bottom edge of the domain because we
   used cos t in preference to sin t ; and it satisfies the
   boundary condition on the left edge of the domain because we use
   only odd multiples of t .

   The computational task is to find coefficients so that the
   boundary conditions on the remaining edges are satisfied as well
   as possible. To accomplish this, pick m points (r,t) on the
   remaining edges. It is desirable to have m > n and in practice
   we usually choose m to be two or three times as large as n .
   Typical values of n are 10 or 20 and of m are 20 to 60. An
   m by n matrix A is generated. The i,j element is the j-th
   basis function, or its normal derivative, evaluated at the i-th
   boundary point. A right hand side with m components is also
   generated. In this example, the elements of the right hand side
   are either zero or one. The coefficients are then found by
   solving the overdetermined set of equations

               Ac = b

   in a least squares sense.

   Once the coefficients have been determined, the approximate
   solution is defined everywhere on the domain. It is then
   possible to compute the effective conductivity sigma . In fact,
   a very simple formula results,

                        n       j-1
              sigma =  sum  (-1)   c
                       j=1          j

   To use MAT88 for this problem, the following "program" is
   first stored in the local computer file system, say under the
   name "PDE".

      //Conductivity example.
      //Parameters ---
         rho       //radius of cylindrical inclusion
         n         //number of terms in solution
         m         //number of boundary points
      //initialize operation counter
         flop = <0 0>;
      //initialize variables
         m1 = round(m/3);   //number of points on each straight edge
         m2 = m - m1;       //number of points with Dirichlet conditions
         pi = 4*atan(1);
      //generate points in Cartesian coordinates
         //right hand edge
         for i = 1:m1, x(i) = 1; y(i) = (1-rho)*(i-1)/(m1-1);
         //top edge
         for i = m2+1:m, x(i) = (1-rho)*(m-i)/(m-m2-1); y(i) = 1;
         //circular edge
         for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); ...
            x(i) = 1-rho*sin(t);  y(i) = 1-rho*cos(t);
      //convert to polar coordinates
         for i = 1:m-1, th(i) = atan(y(i)/x(i));  ...
            r(i) = sqrt(x(i)**2+y(i)**2);
         th(m) = pi/2;  r(m) = 1;
      //generate matrix
         //Dirichlet conditions
         for i = 1:m2, for j = 1:n, k = 2*j-1; ...
            a(i,j) = r(i)**k*cos(k*th(i));
         //Neumann conditions
         for i = m2+1:m, for j = 1:n, k = 2*j-1; ...
            a(i,j) = k*r(i)**(k-1)*sin((k-1)*th(i));
      //generate right hand side
         for i = 1:m2, b(i) = 1;
         for i = m2+1:m, b(i) = 0;
      //solve for coefficients
         c = A\b
      //compute effective conductivity
         c(2:2:n) = -c(2:2:n);
         sigma = sum(c)
      //output total operation count
         ops = flop(2)

   The program can be used within MAT88 by setting the three
   parameters and then accessing the file. For example,

      rho = .9;
      n = 15;
      m = 30;
      exec('PDE')

   The resulting output is

      RHO   =

         .9000

      N     =

       15.

      M     =

       30.

      C     =

         2.2275
        -2.2724
         1.1448
         0.1455
        -0.1678
        -0.0005
        -0.3785
         0.2299
         0.3228
        -0.2242
        -0.1311
         0.0924
         0.0310
        -0.0154
        -0.0038

      SIGM  =

         5.0895

      OPS   =

         16204.

   A total of 16204 floating point operations were necessary to
   set up the matrix, solve for the coefficients and compute the
   conductivity. The operation count is roughly proportional to
   m*n**2. The results obtained for sigma as a function of rho by
   this approach are essentially the same as those obtained by the
   finite difference technique of Keller and Sachs, but the
   computational effort involved is much less.

8.  EIGENVALUE SENSITIVITY EXAMPLE

   In this example, we construct a matrix whose eigenvalues are
   moderately sensitive to perturbations and then analyze that
   sensitivity. We begin with the statement

      B = <3 0 7; 0 2 0; 0 0 1>

   which produces

      B     =

          3.    0.    7.
          0.    2.    0.
          0.    0.    1.

   Obviously, the eigenvalues of B are 1, 2 and 3 . Moreover,
   since B is not symmetric, these eigenvalues are slightly
   sensitive to perturbation. (The value b(1,3) = 7 was chosen so
   that the elements of the matrix A below are less than 1000.)

   We now generate a similarity transformation to disguise the
   eigenvalues and make them more sensitive.

      L = <1 0 0; 2 1 0; -3 4 1>, M = L\L'

      L     =

          1.    0.    0.
          2.    1.    0.
         -3.    4.    1.

      M     =

          1.0000    2.0000   -3.0000
         -2.0000   -3.0000   10.0000
         11.0000   18.0000  -48.0000

   The matrix M has determinant equal to 1 and is moderately badly
   conditioned. The similarity transformation is

      A = M*B/M

      A     =

        -64.0000   82.0000   21.0000
        144.0000 -178.0000  -46.0000
       -771.0000  962.0000  248.0000

   Because det(M) = 1 , the elements of A would be exact integers
   if there were no roundoff. So,

      A = round(A)

      A     =

        -64.   82.   21.
        144. -178.  -46.
       -771.  962.  248.


   This, then, is our test matrix. We can now forget how it
   was generated and analyze its eigenvalues.

      <X,D> = eig(A)

      D     =

          3.0000    0.0000    0.0000
          0.0000    1.0000    0.0000
          0.0000    0.0000    2.0000

      X     =

          -.0891    3.4903   41.8091
           .1782   -9.1284  -62.7136
          -.9800   46.4473  376.2818

   Since A is similar to B, its eigenvalues are also 1, 2 and 3.
   They happen to be computed in another order by the EISPACK
   subroutines. The fact that the columns of X, which are the
   eigenvectors, are so far from being orthonormal is our first
   indication that the eigenvalues are sensitive. To see this
   sensitivity, we display more figures of the computed eigenvalues.

      long, diag(D)

      ANS   =

         2.999999999973599
         1.000000000015625
         2.000000000011505

   We see that, on this computer, the last five significant figures
   are contaminated by roundoff error. A somewhat superficial
   explanation of this is provided by

      short,  cond(X)

      ANS   =

         3.2216e+05

   The condition number of X gives an upper bound for the relative
   error in the computed eigenvalues. However, this condition
   number is affected by scaling.

      X = X/diag(X(3,:)),  cond(X)

      X     =

           .0909     .0751     .1111
          -.1818    -.1965    -.1667
          1.0000    1.0000    1.0000

      ANS   =

         1.7692e+03


   Rescaling the eigenvectors so that their last components are
   all equal to one has two consequences. The condition of X is
   decreased by over two orders of magnitude. (This is about the
   minimum condition that can be obtained by such diagonal scaling.)
   Moreover, it is now apparent that the three eigenvectors are
   nearly parallel.

   More detailed information on the sensitivity of the
   individual eigenvalues involves the left eigenvectors.

      Y = inv(X'),  Y'*A*X

      Y     =

       -511.5000  259.5000  252.0000
        616.0000 -346.0000 -270.0000
        159.5000  -86.5000  -72.0000

      ANS   =

          3.0000     .0000     .0000
           .0000    1.0000     .0000
           .0000     .0000    2.0000

   We are now in a position to compute the sensitivities of the
   individual eigenvalues.

      for j = 1:3, c(j) = norm(Y(:,j))*norm(X(:,j)); end,  C

      C     =

        833.1092
        450.7228
        383.7564

   These three numbers are the reciprocals of the cosines of the
   angles between the left and right eigenvectors. It can be shown
   that perturbation of the elements of A can result in a
   perturbation of the j-th eigenvalue which is c(j) times as large.
   In this example, the first eigenvalue has the largest
   sensitivity.

   We now proceed to show that A is close to a matrix with a
   double eigenvalue. The direction of the required perturbation is
   given by

      E = -1.e-6*Y(:,1)*X(:,1)'

      E     =

         1.0e-03 *

           .0465    -.0930     .5115
          -.0560     .1120    -.6160
          -.0145     .0290    -.1595

   With some trial and error which we do not show, we bracket the
   point where two eigenvalues of a perturbed A coalesce and then
   become complex.

      eig(A + .4*E),  eig(A + .5*E)

      ANS   =

          1.1500
          2.5996
          2.2504

      ANS   =

         2.4067 +  .1753*i
         2.4067 -  .1753*i
         1.1866 + 0.0000*i

   Now, a bisecting search, driven by the imaginary part of one of
   the eigenvalues, finds the point where two eigenvalues are nearly
   equal.

      r = .4;  s = .5;

      while s-r > 1.e-14, t = (r+s)/2; d = eig(A+t*E); ...
        if imag(d(1))=0, r = t; else, s = t;

      long,  T

      T     =

           .450380734134507


   Finally, we display the perturbed matrix, which is obviously
   close to the original, and its pair of nearly equal eigenvalues.
   (We have dropped a few digits from the long output.)

      A+t*E,  eig(A+t*E)

      A

       -63.999979057   81.999958114   21.000230369
       143.999974778 -177.999949557  -46.000277434
      -771.000006530  962.000013061  247.999928164

      ANS   =

         2.415741150
         2.415740621
         1.168517777

   The first two eigenvectors of A + t*E are almost
   indistinguishable indicating that the perturbed matrix is almost
   defective.

      <X,D> = eig(A+t*E);  X = X/diag(X(3,:))

      X     =

          .096019578     .096019586    .071608466
         -.178329614    -.178329608   -.199190520
         1.000000000    1.000000000   1.000000000

      short,  cond(X)

      ANS   =

         3.3997e+09


9.  SYNTAX DIAGRAMS

   A formal description of the language acceptable to MAT88,
   as well as a flow chart of the mat88 program, is provided by the
   syntax diagrams or syntax graphs of wirth [6]. There are eleven
   non-terminal symbols in the language:

      LINE, STATEMENT, CLAUSE, EXPRESSION, TERM,
      FACTOR, NUMBER, INTEGER, NAME, COMMAND, TEXT .

   The diagrams define each of the non-terminal symbols using the
   others and the terminal symbols:

      LETTER -- A THROUGH Z,
      DIGIT  -- 0 THROUGH 9,
      CHAR   -- ( ) ; : + - * / \ = . , < >
      QUOTE  -- '


   LINE

          |-----> STATEMENT >----|
          |                      |
          |-----> CLAUSE >-------|
          |                      |
   -------|-----> EXPR >---------|------>
        | |                      | |
        | |-----> COMMAND >------| |
        | |                      | |
        | |-> > >-> EXPR >-> < >-| |
        | |                      | |
        | |----------------------| |
        |                          |
        |        |-< ; <-|         |
        |--------|       |---------|
                 |-< , <-|


   STATEMENT

        |-> NAME >--------------------------------|
        |          |                              |
        |          |         |--> : >---|         |
        |          |         |          |         |
        |          |-> ( >---|-> EXPR >-|---> ) >-|
        |                  |              |       |
   -----|                  |-----< , <----|       |--> = >--> EXPR >--->
        |                                         |
        |       |--< , <---|                      |
        |       |          |                      |
        |-> < >---> NAME >---> > >----------------|

   CLAUSE

        |---> FOR   >---> NAME >---> = >---> EXPR >--------------|
        |                                                        |
        | |-> WHILE >-|                                          |
        |-|           |-> EXPR >----------------------           |
        | |-> IF    >-|          |   |   |   |   |   |           |
   -----|                        <   <=  =   <>  >=  >           |---->
        |                        |   |   |   |   |   |           |
        |                        ----------------------> EXPR >--|
        |                                                        |
        |---> ELSE  >--------------------------------------------|
        |                                                        |
        |---> END   >--------------------------------------------|

   EXPR

          |-> + >-|
          |       |
   -------|-------|-------> TERM >---------->
          |       |    |             |
          |-> - >-|    |  |-< + <-|  |
                       |  |       |  |
                       |--|-< - <-|--|
                          |       |
                          |-< : <-|


   TERM

   ---------------------> FACTOR >---------------------->
           |                                   |
           |             |-< * <-|             |
           |  |-------|  |       |  |-------|  |
           |--|       |--|-< / <-|--|       |--|
              |-< . <-|  |       |  |-< . <-|
                         |-< \ <-|

   FACTOR

        |----------------> NUMBER >---------------|
        |                                         |
        |-> NAME >--------------------------------|
        |          |                              |
        |          |         |--> : >---|         |
        |          |         |          |         |
        |          |-> ( >---|-> EXPR >-|---> ) >-|
        |                  |              |       |
        |                  |-----< , <----|       |
        |                                         |
   -----|------------> ( >-----> EXPR >-----> ) >-|-|-------|----->
        |                                         | |       | |
        |                  |--------------|       | |-> ' >-| |
        |                  |              |       |           |
        |------------> < >-|---> EXPR >---|-> > >-|           |
        |                    |          |         |           |
        |                    |--<   <---|         |           |
        |                    |          |         |           |
        |                    |--< ; <---|         |           |
        |                    |          |         |           |
        |                    |--< , <---|         |           |
        |                                         |           |
        |------------> > >-----> EXPR >-----> < >-|           |
        |                                         |           |
        |-----> FACTOR >---> ** >---> FACTOR >----|           |
        |                                                     |
        |------------> ' >-----> TEXT >-----> ' >-------------|


   NUMBER

       |----------|                          |-> + >-|
       |          |                          |       |
   -----> INT >-----> . >---> INT >-----> E >---------> INT >---->
                |                   | |      |       |        |
                |                   | |      |-> - >-|        |
                |                   | |                       |
                |---------------------------------------------|


   INT

   ------------> DIGIT >----------->
             |           |
             |-----------|


   NAME

                     |--< LETTER <--|
                     |              |
   ------> LETTER >--|--------------|----->
                     |              |
                     |--< DIGIT  <--|



   COMMAND

                           |--> NAME >--|
                           |            |
   --------> NAME >--------|------------|---->
                           |            |
                           |--> CHAR >--|
                           |            |
                           |---> ' >----|

   TEXT

                   |-> LETTER >--|
                   |             |
                   |-> DIGIT >---|
   ----------------|             |-------------->
               |   |-> CHAR >----|   |
               |   |             |   |
               |   |-> ' >-> ' >-|   |
               |                     |
               |---------------------|


10.  THE PARSER-INTERPRETER


   The structure of the parser-interpreter is similar to that
   of Wirth's compiler [6] for his simple language, PL/0 , except
   that MAT88 is programmed in Fortran, which does not have
   explicit recursion. The interrelation of the primary subroutines
   is shown in the following diagram.

         MAIN
           |
         MAT88     |--CLAUSE
           |       |    |
         PARSE-----|--EXPR----TERM----FACTOR
                   |    |       |       |
                   |    |-------|-------|
                   |    |       |       |
                   |  STACK1  STACK2  STACKG
                   |
                   |--STACKP--PRINT
                   |
                   |--COMAND
                   |
                   |
                   |          |--CGECO
                   |          |
                   |          |--CGEFA
                   |          |
                   |--MATFN1--|--CGESL
                   |          |
                   |          |--CGEDI
                   |          |
                   |          |--CPOFA
                   |
                   |
                   |          |--IMTQL2
                   |          |
                   |          |--HTRIDI
                   |          |
                   |--MATFN2--|--HTRIBK
                   |          |
                   |          |--CORTH
                   |          |
                   |          |--COMQR3
                   |
                   |
                   |--MATFN3-----CSVDC
                   |
                   |
                   |          |--CQRDC
                   |--MATFN4--|
                   |          |--CQRSL
                   |
                   |
                   |          |--FILES
                   |--MATFN5--|
                              |--SAVLOD

   Subroutine PARSE controls the interpretation of each
   statement. It calls subroutines that process the various
   syntactic quantities such as command, expression, term and
   factor. A fairly simple program stack mechanism allows these
   subroutines to recursively "call" each other along the lines
   allowed by the syntax diagrams. The four STACK subroutines
   manage the variable memory and perform elementary operations,
   such as matrix addition and transposition.

   The four subroutines MATFN1 though MATFN4 are called
   whenever "serious" matrix computations are required. They are
   interface routines which call the various LINPACK and EISPACK
   subroutines. MATFN5 primarily handles the file access tasks.

   Two large real arrays, STKR and STKI, are used to store all
   the matrices. Four integer arrays are used to store the names,
   the row and column dimensions, and the pointers into the real
   stacks. The following diagram illustrates this storage scheme.

    TOP         IDSTK     MSTK NSTK LSTK               STKR       STKI
     --      -- -- -- --   --   --   --              --------   --------
    |  |--->|  |  |  |  | |  | |  | |  |----------->|        | |        |
     --      -- -- -- --   --   --   --              --------   --------
            |  |  |  |  | |  | |  | |  |            |        | |        |
             -- -- -- --   --   --   --              --------   --------
                  .         .    .    .                  .          .
                  .         .    .    .                  .          .
                  .         .    .    .                  .          .
             -- -- -- --   --   --   --              --------   --------
    BOT     |  |  |  |  | |  | |  | |  |            |        | |        |
     --      -- -- -- --   --   --   --              --------   --------
    |  |--->| X|  |  |  | | 2| | 1| |  |----------->|  3.14  | |  0.00  |
     --      -- -- -- --   --   --   --              --------   --------
            | A|  |  |  | | 2| | 2| |  |---------   |  0.00  | |  1.00  |
             -- -- -- --   --   --   --          \   --------   --------
            | E| P| S|  | | 1| | 1| |  |-------   ->| 11.00  | |  0.00  |
             -- -- -- --   --   --   --        \     --------   --------
            | F| L| O| P| | 1| | 2| |  |------  \   | 21.00  | |  0.00  |
             -- -- -- --   --   --   --       \  \   --------   --------
            | E| Y| E|  | |-1| |-1| |  |---    \ |  | 12.00  | |  0.00  |
             -- -- -- --   --   --   --    \   | |   --------   --------
            | R| A| N| D| | 1| | 1| |  |-   \  | |  | 22.00  | |  0.00  |
             -- -- -- --   --   --   --  \  |  \ \   --------   --------
                                         |  \   \ ->| 1.E-15 | |  0.00  |
                                         \   \   \   --------   --------
                                          \   \   ->|  0.00  | |  0.00  |
                                           \   \     --------   --------
                                            \   \   |  0.00  | |  0.00  |
                                             \   \   --------   --------
                                              \   ->|  1.00  | |  0.00  |
                                               \     --------   --------
                                                --->| URAND  | |  0.00  |
                                                     --------   --------

   The top portion of the stack is used for temporary variables
   and the bottom portion for saved variables. The figure shows the
   situation after the line

      A = <11,12; 21,22>,  x = <3.14, sqrt(-1)>'

   has been processed. The four permanent names, EPS, FLOP, RAND
   and EYE, occupy the last four positions of the variable stacks.
   RAND has dimensions 1 by 1, but whenever its value is requested,
   a random number generator is used instead. EYE has dimensions -1
   by -1 to indicate that the actual dimensions must be determined
   later by context. The two saved variables have dimensions 2 by 2
   and 2 by 1 and so take up a total of 6 locations.

   Subsequent statements involving A and x will result in
   temporary copies being made in the top of the stack for use in
   the actual calculations. Whenever the top of the stack reaches
   the bottom, a message indicating memory has been exceeded is
   printed, but the current variables are not affected.

   This modular structure makes it possible to implement MAT88
   on a system with a limited amount of memory. The object code for
   the MATFN's and the LINPACK-EISPACK subroutines is rarely needed.
   Although it is not standard, many Fortran operating systems
   provide some overlay mechanism so that this code is brought into
   the main memory only when required. The variables, which occupy
   a relatively small portion of the memory, remain in place, while
   the subroutines which process them are loaded a few at a time.


11. THE NUMERICAL ALGORITHMS

   The algorithms underlying the basic MAT88 functions are
   described in the LINPACK and EISPACK guides [1-3]. The following
   list gives the subroutines used by these functions.

      INV(A)          - CGECO,CGEDI
      DET(A)          - CGECO,CGEDI
      LU(A)           - CGEFA
      RCOND(A)        - CGECO
      CHOL(A)         - CPOFA
      SVD(A)          - CSVDC
      COND(A)         - CSVDC
      NORM(A,2)       - CSVDC
      PINV(A,eps)     - CSVDC
      RANK(A,eps)     - CSVDC
      QR(A)           - CQRDC,CQRSL
      ORTH(A)         - CQRDC,CSQSL
      A\B and B/A     - CGECO,CGESL if A is square.
                      - CQRDC,CQRSL if A is not square.
      EIG(A)          - HTRIDI,IMTQL2,HTRIBK if A is Hermitian.
                      - CORTH,COMQR2         if A is not Hermitian.
      SCHUR(A)        - same as EIG.
      HESS(A)         - same as EIG.

   Minor modifications were made to all these subroutines. The
   LINPACK routines were changed to replace the Fortran complex
   arithmetic with explicit references to real and imaginary parts.
   Since most of the floating point arithmetic is concentrated in a
   few low-level subroutines which perform vector operations (the
   Basic Linear Algebra Subprograms), this was not an extensive
   change. It also facilitated implementation of the FLOP and CHOP
   features which count and optionally truncate each floating point
   operation.

   The EISPACK subroutine COMQR2 was modified to allow access
   to the Schur triangular form, ordinarily just an intermediate
   result. IMTQL2 was modified to make computation of the
   eigenvectors optional. Both subroutines were modified to
   eliminate the machine-dependent accuracy parameter and all the
   EISPACK subroutines were changed to include FLOP and CHOP.

   The algorithms employed for the POLY and ROOTS functions
   illustrate an interesting aspect of the modern approach to
   eigenvalue computation. POLY(A) generates the characteristic
   polynomial of A and ROOTS(POLY(A)) finds the roots of that
   polynomial, which are, of course, the eigenvalues of A . But both
   POLY and ROOTS use EISPACK eigenvalues subroutines, which are
   based on similarity transformations. So the classical approach
   which characterizes eigenvalues as roots of the characteristic
   polynomial is actually reversed.

   If A is an n by n matrix, POLY(A) produces the coefficients
   C(1) through C(n+1), with C(1) = 1, in

         DET(z*EYE-A) = C(1)*z**n + ... + C(n)*z + C(n+1) .

   The algorithm can be expressed compactly using MAT88:

         Z = EIG(A);
         C = 0*ONES(n+1,1);  C(1) = 1;
         for j = 1:n, C(2:j+1) = C(2:j+1) - Z(j)*C(1:j);
         C

   This recursion is easily derived by expanding the product

         (z - z(1))*(z - z(2))* ... * (z-z(n)) .

   It is possible to prove that POLY(A) produces the coefficients in
   the characteristic polynomial of a matrix within roundoff error
   of A. This is true even if the eigenvalues of A are badly
   conditioned. The traditional algorithms for obtaining the
   characteristic polynomial which do not use the eigenvalues do not
   have such satisfactory numerical properties.

   If C is a vector with n+1 components, ROOTS(C) finds the
   roots of the polynomial of degree n ,

          p(z) = C(1)*z**n + ... + C(n)*z + C(n+1) .

   The algorithm simply involves computing the eigenvalues of the
   companion matrix:

         A = 0*ONES(n,n)
         for j = 1:n, A(1,j) = -C(j+1)/C(1);
         for i = 2:n, A(i,i-1) = 1;
         EIG(A)

   It is possible to prove that the results produced are the exact
   eigenvalues of a matrix within roundoff error of the companion
   matrix A, but this does not mean that they are the exact roots of
   a polynomial with coefficients within roundoff error of those in
   C . There are more accurate, more efficient methods for finding
   polynomial roots, but this approach has the crucial advantage
   that it does not require very much additional code.

   The elementary functions EXP, LOG, SQRT, SIN, COS and ATAN
   are applied to square matrices by diagonalizing the matrix,
   applying the functions to the individual eigenvalues and then
   transforming back. For example, EXP(A) is computed by

         <X,D> = EIG(A);
         for j = 1:n, D(j,j) = EXP(D(j,j));
         X*D/X

   This is essentially method number 14 out of the 19 'dubious'
   possibilities described in [8]. It is dubious because it doesn't
   always work. The matrix of eigenvectors X can be arbitrarily
   badly conditioned and all accuracy lost in the computation of
   X*D/X. A warning message is printed if RCOND(X) is very small,
   but this only catches the extreme cases. An example of a case
   not detected is when A has a double eigenvalue, but theoretically
   only one linearly independent eigenvector associated with it.
   The computed eigenvalues will be separated by something on the
   order of the square root of the roundoff level. This separation
   will be reflected in RCOND(X) which will probably not be small
   enough to trigger the error message. The computed EXP(A) will be
   accurate to only half precision. Better methods are known for
   computing EXP(A), but they do not easily extend to the other five
   functions and would require a considerable amount of additional
   code.

   The expression A**p is evaluated by repeated multiplication
   if p is an integer greater than 1. Otherwise it is evaluated by

         <X,D> = EIG(A);
         for j = 1:n, D(j,j) = EXP(p*LOG(D(j,j)))
         X*D/X

   This suffers from the same potential loss of accuracy if X is
   badly conditioned. It was partly for this reason that the case
   p = 1 is included in the general case. Comparison of A**1 with A
   gives some idea of the loss of accuracy for other values of p and
   for the elementary functions.

   RREF, the reduced row echelon form, is of some interest in
   theoretical linear algebra, although it has little computational
   value. It is included in MAT88 for pedagogical reasons. The
   algorithm is essentially Gauss-Jordan elimination with detection
   of negligible columns applied to rectangular matrices.

   There are three separate places in MAT88 where the rank of
   a matrix is implicitly computed: in RREF(A), in A\B for non-
   square A, and in the pseudoinverse PINV(A). Three different
   algorithms with three different criteria for negligibility are
   used and so it is possible that three different values could be
   produced for the same matrix. With RREF(A), the rank of A is the
   number of nonzero rows. The elimination algorithm used for RREF
   is the fastest of the three rank-determining algorithms, but it
   is the least sophisticated numerically and the least reliable.
   With A\B, the algorithm is essentially that used by example
   subroutine SQRST in chapter 9 of the LINPACK guide. With
   PINV(A), the algorithm is based on the singular value
   decomposition and is described in chapter 11 of the LINPACK
   guide. The SVD algorithm is the most time-consuming, but the
   most reliable and is therefore also used for RANK(A).

   The uniformly distributed random numbers in RAND are
   obtained from the machine-independent random number generator
   URAND described in [9]. It is possible to switch to normally
   distributed random numbers, which are obtained using a
   transformation also described in [9].

        The computation of

                   2    2
             sqrt(a  + b )

   is required in many matrix algorithms, particularly those
   involving complex arithmetic. A new approach to carrying out
   this operation is described by Moler and Morrison [10]. It is a
   cubically convergent algorithm which starts with a and b ,
   rather than with their squares, and thereby avoids destructive
   arithmetic underflows and overflows. In MAT88, the algorithm is
   used for complex modulus, Euclidean vector norm, plane rotations,
   and the shift calculation in the eigenvalue and singular value
   iterations.


12. FLOP AND CHOP

   Detailed information about the amount of work involved in
   matrix calculations and the resulting accuracy is provided by
   FLOP and CHOP. The basic unit of work is the "flop", or floating
   point operation. Roughly, one flop is one execution of a Fortran
   statement like

         S = S + X(I)*Y(I)

   or

         Y(I) = Y(I) + T*X(I)

   In other words, it consists of one floating point multiplication,
   together with one floating point addition and the associated
   indexing and storage reference operations.

   MAT88 will print the number of flops required for a
   particular statement when the statement is terminated by an extra
   comma. For example, the line

         n = 20;  RAND(n)*RAND(n);,

   ends with an extra comma. Two 20 by 20 random matrices are
   generated and multiplied together. The result is assigned to
   ANS, but the semicolon suppresses its printing. The only output
   is

           8800 flops

   This is n**3 + 2*n**2 flops, n**2 for each random matrix and
   n**3 for the product.

   FLOP is a predefined vector with two components. FLOP(1) is
   the number of flops used by the most recently executed statement,
   except that statements with zero flops are ignored. For example,
   after executing the previous statement,

         flop(1)/n**3

   results in

         ANS   =

             1.1000


   FLOP(2) is the cumulative total of all the flops used since
   the beginning of the MAT88 session. The statement

         FLOP = <0 0>

   resets the total.

   There are several difficulties associated with keeping a
   precise count of floating point operations. An addition or
   subtraction that is not paired with a multiplication is usually
   counted as a flop. The same is true of an isolated multiplication
   that is not paired with an addition. Each floating point
   division counts as a flop. But the number of operations required
   by system dependent library functions such as square root cannot
   be counted, so most elementary functions are arbitrarily counted
   as using only one flop.

   The biggest difficulty occurs with complex arithmetic.
   Almost all operations on the real parts of matrices are counted.
   However, the operations on the complex parts of matrices are
   counted only when they involve nonzero elements. This means that
   simple operations on nonreal matrices require only about twice as
   many flops as the same operations on real matrices. This factor
   of two is not necessarily an accurate measure of the relative
   costs of real and complex arithmetic.

   The result of each floating point operation may also be
   "chopped" to simulate a computer with a shorter word length. The
   details of this chopping operation depend upon the format of the
   floating point word. Usually, the fraction in the floating point
   word can be regarded as consisting of several octal or
   hexadecimal digits. The least significant of these digits can be
   set to zero by a logical masking operation. Thus the statement

         CHOP(p)

   causes the p least significant octal or hexadecimal digits in
   the result of each floating point operation to be set to zero.
   For example, if the computer being used has an IBM 360 long
   floating point word with 14 hexadecimal digits in the fraction,
   then CHOP(8) results in simulation of a computer with only 6
   hexadecimal digits in the fraction, i.e. a short floating point
   word. On a computer such as the CDC 6600 with 16 octal digits,
   CHOP(8) results in about the same accuracy because the remaining
   8 octal digits represent the same number of bits as 6 hexadecimal
   digits.

   Some idea of the effect of CHOP on any particular system can
   be obtained by executing the following statements.

         long,   t = 1/10
         long z, t = 1/10
         chop(8)
         long,   t = 1/10
         long z, t = 1/10


   The following Fortran subprograms illustrate more details of
   FLOP and CHOP. The first subprogram is a simplified example of a
   system-dependent function used within MAT88 itself. The common
   variable FLP is essentially the first component of the variable
   FLOP. The common variable CHP is initially zero, but it is set
   to p by the statement CHOP(p). To shorten the DATA statement,
   we assume there are only 6 hexadecimal digits. We also assume an
   extension of Fortran that allows .AND. to be used as a binary
   operation between two real variables.

         REAL FUNCTION FLOP(X)
         REAL X
         INTEGER FLP,CHP
         COMMON FLP,CHP
         REAL MASK(5)
         DATA MASK/ZFFFFFFF0,ZFFFFFF00,ZFFFFF000,ZFFFF0000,ZFFF00000/
         FLP = FLP + 1
         IF (CHP .EQ. 0) FLOP = X
         IF (CHP .GE. 1 .AND. CHP .LE. 5) FLOP = X .AND. MASK(CHP)
         IF (CHP .GE. 6) FLOP = 0.0
         END REAL FUNCTION FLOP


   The following subroutine illustrates a typical use of the
   previous function within MAT88. It is a simplified version of
   the Basic Linear Algebra Subprogram that adds a scalar multiple
   of one vector to another. We assume here that the vectors are
   stored with a memory increment of one.

         SUBROUTINE SAXPY(N,TR,TI,XR,XI,YR,YI)
         REAL TR,TI,XR(N),XI(N),YR(N),YI(N),FLOP
         IF (N .LE. 0) RETURN
         IF (TR .EQ. 0.0 .AND. TI .EQ. 0.0) RETURN
         DO I = 1, N
            YR(I) = FLOP(YR(I) + TR*XR(I) - TI*XI(I))
            YI(I) = YI(I) + TR*XI(I) + TI*XR(I)
            IF (YI(I) .NE. 0.0D0) YI(I) = FLOP(YI(I))
         enddo
         END SUBROUTINE SAXPY


   The saxpy operation is perhaps the most fundamental
   operation within LINPACK. It is used in the computation of the
   LU, the QR and the SVD factorizations, and in several other
   places. We see that adding a multiple of one vector with n
   components to another uses n flops if the vectors are real and
   between n and 2*n flops if the vectors have nonzero imaginary
   components.

   The permanent MAT88 variable EPS is reset by the statement
   CHOP(p). Its new value is usually the smallest inverse power of
   two that satisfies the Fortran logical test

               FLOP(1.0+EPS) .GT. 1.0

   However, if EPS had been directly reset to a larger value, the
   old value is retained.

13. COMMUNICATING WITH OTHER PROGRAMS

   There are four different ways MAT88 can be used in
   conjunction with other programs:

         -- USER,
         -- EXEC,
         -- SAVE and LOAD,
         -- MATZ, CALL and QUIT .

   Let us illustrate each of these by the following simple
   example.

         n = 6
         for i = 1:n, for j = 1:n, a(i,j) = abs(i-j);
         A
         X = inv(A)


   The example A could be introduced into MAT88 by writing
   the following Fortran subroutine.

            SUBROUTINE mat88_user(A,M,N,S,T)
            DOUBLEPRECISION A(*),S,T
            N = IDINT(A(1))
            M = N
            DO J = 1, N
               DO I = 1, N
                  K = I + (J-1)*M
                  A(K) = IABS(I-J)
               enddo
            enddo
            END SUBROUTINE USER

   This subroutine should be compiled and linked into MAT88 in
   place of the original version of USER. Then the MAT88
   statements

         n = 6
         A = user(n)
         X = inv(A)

   do the job.

   The example A could be generated by storing the following
   text in a file named, say, EXAMPLE .

         for i = 1:n, for j = 1:n, a(i,j) = abs(i-j);

   Then the MAT88 statements

         n = 6
         exec('EXAMPLE',0)
         X = inv(A)

   have the desired effect. The 0 as the optional second parameter
   of exec indicates that the text in the file should not be printed
   on the terminal.

   The matrices A and X could also be stored in files. Two
   separate main programs would be involved. The first is:

            PROGRAM MAINA
            DOUBLEPRECISION A(10,10)
            N = 6
            DO J = 1, N
               DO I = 1, N
                  A(I,J) = IABS(I-J)
               enddo
            enddo
            OPEN(UNIT=1,FILE='A')
            WRITE(1,101) N,N
        101 FORMAT('A   ',2I4)
            DO J = 1, N
               WRITE(1,102) (A(I,J),I=1,N)
            enddo
        102 FORMAT(4Z18)
            END PROGRAM MAINA

   The OPEN statement may take different forms on different systems.
   It attaches Fortran logical unit number 1 to the file named A.
   The FORMAT number 102 may also be system dependent. This
   particular one is appropriate for hexadecimal computers with an 8
   byte double precision floating point word. Check, or modify,
   MAT88 subroutine SAVLOD.

   After this program is executed, enter MAT88 and give the
   following statements:

         load('A')
         X = inv(A)
         save('X',X)

   If all goes according to plan, this will read the matrix A from
   the file A, invert it, store the inverse in X and then write the
   matrix X on the file X. The following program can then access X.

            PROGRAM MAINX
            DOUBLEPRECISION X(10,10)
            OPEN(UNIT=1,FILE='X')
            REWIND 1
            READ (1,101) ID,M,N
        101 FORMAT(A4,2I4)
            DO J = 1, N
               READ(1,102) (X(I,J),I=1,M)
            ENDDO
        102 FORMAT(4Z18)
            ...
            ...


   The most elaborate mechanism involves using MAT88 as a subroutine
   within another program. Communication with the MAT88 stack is
   accomplished using subroutine MATZ which is distributed with MAT88,
   but which is not used by MAT88 itself. The preample of MATZ is:

         SUBROUTINE MATZ(A,LDA,M,N,IDA,JOB,IERR)
         INTEGER LDA,M,N,IDA(1),JOB,IERR
         DOUBLEPRECISION A(LDA,N)

         ! ACCESS MAT88 VARIABLE STACK
         ! A IS AN M BY N MATRIX, STORED IN AN ARRAY WITH
         !     LEADING DIMENSION LDA.
         ! IDA IS THE NAME OF A.
         !     IF IDA IS AN INTEGER K LESS THAN 10, THEN THE NAME IS 'A'K
         !     OTHERWISE, IDA(1:4) IS FOUR CHARACTERS, FORMAT 4A1.
         ! JOB =  0  GET REAL A FROM MAT88,
         !     =  1  PUT REAL A INTO MAT88,
         !     = 10  GET IMAG PART OF A FROM MAT88,
         !     = 11  PUT IMAG PART OF A INTO MAT88.
         ! RETURN WITH NONZERO IERR AFTER MAT88 ERROR MESSAGE.
         !
         ! USES MAT88 ROUTINES STACKG, STACKP AND ERROR


        The preample of subroutine MAT88 is:


         SUBROUTINE MAT88(INIT)
         ! INIT = 0 FOR FIRST ENTRY, NONZERO FOR SUBSEQUENT ENTRIES


        To do our example, write the following program:

            DOUBLEPRECISION A(10,10),X(10,10)
            INTEGER IDA(4),IDX(4)
            DATA LDA/10/
            DATA IDA/'A',' ',' ',' '/, IDX/'X',' ',' ',' '/
            CALL M_88(0,'')
            N = 6
            DO J = 1, N
               DO I = 1, N
                  A(I,J) = IABS(I-J)
               enddo
            enddo
            CALL MATZ(A,LDA,N,N,IDA,1,IERR)
            IF (IERR .NE. 0) GO TO ...
            CALL MAT88(1,'')
            CALL MATZ(X,LDA,N,N,IDX,0,IERR)
            IF (IERR .NE. 0) GO TO ...
            ...
            ...

   When this program is executed, the call to MAT88(0) produces the
   MAT88 greeting, then waits for input. The command

            quit

   sends control back to our example program. The matrix A is
   generated by the program and sent to the stack by the first call
   to MATZ. The call to MAT88(1) produces the MAT88(1) prompt. Then
   the statements

            X = inv(A)
            quit

   will invert our matrix, put the result on the stack and go back
   to our program. The second call to MATZ will retrieve X .

   By the way, this matrix X is interesting. Take a look at
   round(2*(n-1)*X).

ACKNOWLEDGEMENT

   Most of the work on MAT88 has been carried out at the University
   of New Mexico, where it is being supported by the National Science
   Foundation. Additional work has been done during visits to Stanford
   Linear Accelerator Center, Argonne National Laboratory and Los Alamos
   Scientific Laboratory, where support has been provided by NSF and the
   Department of Energy.

REFERENCES

 [1]  J. J. Dongarra, J. R. Bunch, C. B. Moler and G. W. Stewart,
      LINPACK Users' Guide, Society for Industrial and Applied
      Mathematics, Philadelphia, 1979.

 [2]  B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, Y.
      Ikebe, V. C. Klema, C. B. Moler, Matrix Eigensystem Routines
      -- EISPACK Guide, Lecture Notes in Computer Science, volume
      6, second edition, Springer-Verlag, 1976.

 [3]  B. S. Garbow, J. M. Boyle, J. J. Dongarra, C. B. Moler,
      Matrix Eigensystem Routines -- EISPACK Guide Extension,
      Lecture Notes in Computer Science, volume 51, Springer-
      Verlag, 1977.

 [4]  S. Cohen and S. Piper, SPEAKEASY III Reference Manual,
      Speakeasy Computing Corp., Chicago, Ill., 1979.

 [5]  J. H. Wilkinson and C. Reinsch, Handbook for Automatic
      Computation, volume II, Linear Algebra, Springer-Verlag,
     1971.

 [6]  Niklaus Wirth, Algorithms + Data Structures = Programs,
      Prentice-Hall, 1976.

 [7]  H. B. Keller and D. Sachs, "Calculations of the Conductivity
      of a Medium Containing Cylindrical Inclusions", J. Applied
      Physics 35, 537-538, 1964.

 [8]  C. B. Moler and C. F. Van Loan, Nineteen Dubious Ways to
      Compute the Exponential of a Matrix, SIAM Review 20, 801-
      836, 1979.

 [9]  G. E. Forsythe, M. A. Malcolm and C. B. Moler, Computer
      Methods for Mathematical Computations, Prentice-Hall, 1977.

 [10] C. B. Moler and D. R. Morrison, "Replacing square roots by
      Pythagorean sums", University of New Mexico, Computer
      Science Department, technical report, submitted for
     publication, 1980.

APPENDIX
$BLOCK
end subroutine mat_make_manual
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
end module M_matrix
